function GN(i, e) { for (var t = 0; t < e.length; t++) { const n = e[t]; if (typeof n != "string" && !Array.isArray(n)) { for (const r in n) if (r !== "default" && !(r in i)) { const s = Object.getOwnPropertyDescriptor(n, r); s && Object.defineProperty(i, r, s.get ? s : { enumerable: !0, get: () => n[r] }) } } } return Object.freeze(Object.defineProperty(i, Symbol.toStringTag, { value: "Module" })) } (function () { const e = document.createElement("link").relList; if (e && e.supports && e.supports("modulepreload")) return; for (const r of document.querySelectorAll('link[rel="modulepreload"]')) n(r); new MutationObserver(r => { for (const s of r) if (s.type === "childList") for (const o of s.addedNodes) o.tagName === "LINK" && o.rel === "modulepreload" && n(o) }).observe(document, { childList: !0, subtree: !0 }); function t(r) { const s = {}; return r.integrity && (s.integrity = r.integrity), r.referrerPolicy && (s.referrerPolicy = r.referrerPolicy), r.crossOrigin === "use-credentials" ? s.credentials = "include" : r.crossOrigin === "anonymous" ? s.credentials = "omit" : s.credentials = "same-origin", s } function n(r) { if (r.ep) return; r.ep = !0; const s = t(r); fetch(r.href, s) } })(); function LS(i) { return i && i.__esModule && Object.prototype.hasOwnProperty.call(i, "default") ? i.default : i } var WI = { exports: {} }, lv = {}, XI = { exports: {} }, Vt = {};/**
 * @license React
 * react.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */var Kp = Symbol.for("react.element"), VN = Symbol.for("react.portal"), WN = Symbol.for("react.fragment"), XN = Symbol.for("react.strict_mode"), JN = Symbol.for("react.profiler"), YN = Symbol.for("react.provider"), jN = Symbol.for("react.context"), KN = Symbol.for("react.forward_ref"), qN = Symbol.for("react.suspense"), QN = Symbol.for("react.memo"), ZN = Symbol.for("react.lazy"), DT = Symbol.iterator; function $N(i) { return i === null || typeof i != "object" ? null : (i = DT && i[DT] || i["@@iterator"], typeof i == "function" ? i : null) } var JI = { isMounted: function () { return !1 }, enqueueForceUpdate: function () { }, enqueueReplaceState: function () { }, enqueueSetState: function () { } }, YI = Object.assign, jI = {}; function Eh(i, e, t) { this.props = i, this.context = e, this.refs = jI, this.updater = t || JI } Eh.prototype.isReactComponent = {}; Eh.prototype.setState = function (i, e) { if (typeof i != "object" && typeof i != "function" && i != null) throw Error("setState(...): takes an object of state variables to update or a function which returns an object of state variables."); this.updater.enqueueSetState(this, i, e, "setState") }; Eh.prototype.forceUpdate = function (i) { this.updater.enqueueForceUpdate(this, i, "forceUpdate") }; function KI() { } KI.prototype = Eh.prototype; function DS(i, e, t) { this.props = i, this.context = e, this.refs = jI, this.updater = t || JI } var OS = DS.prototype = new KI; OS.constructor = DS; YI(OS, Eh.prototype); OS.isPureReactComponent = !0; var OT = Array.isArray, qI = Object.prototype.hasOwnProperty, FS = { current: null }, QI = { key: !0, ref: !0, __self: !0, __source: !0 }; function ZI(i, e, t) { var n, r = {}, s = null, o = null; if (e != null) for (n in e.ref !== void 0 && (o = e.ref), e.key !== void 0 && (s = "" + e.key), e) qI.call(e, n) && !QI.hasOwnProperty(n) && (r[n] = e[n]); var a = arguments.length - 2; if (a === 1) r.children = t; else if (1 < a) { for (var l = Array(a), c = 0; c < a; c++)l[c] = arguments[c + 2]; r.children = l } if (i && i.defaultProps) for (n in a = i.defaultProps, a) r[n] === void 0 && (r[n] = a[n]); return { $$typeof: Kp, type: i, key: s, ref: o, props: r, _owner: FS.current } } function eU(i, e) { return { $$typeof: Kp, type: i.type, key: e, ref: i.ref, props: i.props, _owner: i._owner } } function kS(i) { return typeof i == "object" && i !== null && i.$$typeof === Kp } function tU(i) { var e = { "=": "=0", ":": "=2" }; return "$" + i.replace(/[=:]/g, function (t) { return e[t] }) } var FT = /\/+/g; function mx(i, e) { return typeof i == "object" && i !== null && i.key != null ? tU("" + i.key) : e.toString(36) } function L0(i, e, t, n, r) { var s = typeof i; (s === "undefined" || s === "boolean") && (i = null); var o = !1; if (i === null) o = !0; else switch (s) { case "string": case "number": o = !0; break; case "object": switch (i.$$typeof) { case Kp: case VN: o = !0 } }if (o) return o = i, r = r(o), i = n === "" ? "." + mx(o, 0) : n, OT(r) ? (t = "", i != null && (t = i.replace(FT, "$&/") + "/"), L0(r, e, t, "", function (c) { return c })) : r != null && (kS(r) && (r = eU(r, t + (!r.key || o && o.key === r.key ? "" : ("" + r.key).replace(FT, "$&/") + "/") + i)), e.push(r)), 1; if (o = 0, n = n === "" ? "." : n + ":", OT(i)) for (var a = 0; a < i.length; a++) { s = i[a]; var l = n + mx(s, a); o += L0(s, e, t, l, r) } else if (l = $N(i), typeof l == "function") for (i = l.call(i), a = 0; !(s = i.next()).done;)s = s.value, l = n + mx(s, a++), o += L0(s, e, t, l, r); else if (s === "object") throw e = String(i), Error("Objects are not valid as a React child (found: " + (e === "[object Object]" ? "object with keys {" + Object.keys(i).join(", ") + "}" : e) + "). If you meant to render a collection of children, use an array instead."); return o } function ug(i, e, t) { if (i == null) return i; var n = [], r = 0; return L0(i, n, "", "", function (s) { return e.call(t, s, r++) }), n } function nU(i) { if (i._status === -1) { var e = i._result; e = e(), e.then(function (t) { (i._status === 0 || i._status === -1) && (i._status = 1, i._result = t) }, function (t) { (i._status === 0 || i._status === -1) && (i._status = 2, i._result = t) }), i._status === -1 && (i._status = 0, i._result = e) } if (i._status === 1) return i._result.default; throw i._result } var xr = { current: null }, D0 = { transition: null }, iU = { ReactCurrentDispatcher: xr, ReactCurrentBatchConfig: D0, ReactCurrentOwner: FS }; Vt.Children = { map: ug, forEach: function (i, e, t) { ug(i, function () { e.apply(this, arguments) }, t) }, count: function (i) { var e = 0; return ug(i, function () { e++ }), e }, toArray: function (i) { return ug(i, function (e) { return e }) || [] }, only: function (i) { if (!kS(i)) throw Error("React.Children.only expected to receive a single React element child."); return i } }; Vt.Component = Eh; Vt.Fragment = WN; Vt.Profiler = JN; Vt.PureComponent = DS; Vt.StrictMode = XN; Vt.Suspense = qN; Vt.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = iU; Vt.cloneElement = function (i, e, t) { if (i == null) throw Error("React.cloneElement(...): The argument must be a React element, but you passed " + i + "."); var n = YI({}, i.props), r = i.key, s = i.ref, o = i._owner; if (e != null) { if (e.ref !== void 0 && (s = e.ref, o = FS.current), e.key !== void 0 && (r = "" + e.key), i.type && i.type.defaultProps) var a = i.type.defaultProps; for (l in e) qI.call(e, l) && !QI.hasOwnProperty(l) && (n[l] = e[l] === void 0 && a !== void 0 ? a[l] : e[l]) } var l = arguments.length - 2; if (l === 1) n.children = t; else if (1 < l) { a = Array(l); for (var c = 0; c < l; c++)a[c] = arguments[c + 2]; n.children = a } return { $$typeof: Kp, type: i.type, key: r, ref: s, props: n, _owner: o } }; Vt.createContext = function (i) { return i = { $$typeof: jN, _currentValue: i, _currentValue2: i, _threadCount: 0, Provider: null, Consumer: null, _defaultValue: null, _globalName: null }, i.Provider = { $$typeof: YN, _context: i }, i.Consumer = i }; Vt.createElement = ZI; Vt.createFactory = function (i) { var e = ZI.bind(null, i); return e.type = i, e }; Vt.createRef = function () { return { current: null } }; Vt.forwardRef = function (i) { return { $$typeof: KN, render: i } }; Vt.isValidElement = kS; Vt.lazy = function (i) { return { $$typeof: ZN, _payload: { _status: -1, _result: i }, _init: nU } }; Vt.memo = function (i, e) { return { $$typeof: QN, type: i, compare: e === void 0 ? null : e } }; Vt.startTransition = function (i) { var e = D0.transition; D0.transition = {}; try { i() } finally { D0.transition = e } }; Vt.unstable_act = function () { throw Error("act(...) is not supported in production builds of React.") }; Vt.useCallback = function (i, e) { return xr.current.useCallback(i, e) }; Vt.useContext = function (i) { return xr.current.useContext(i) }; Vt.useDebugValue = function () { }; Vt.useDeferredValue = function (i) { return xr.current.useDeferredValue(i) }; Vt.useEffect = function (i, e) { return xr.current.useEffect(i, e) }; Vt.useId = function () { return xr.current.useId() }; Vt.useImperativeHandle = function (i, e, t) { return xr.current.useImperativeHandle(i, e, t) }; Vt.useInsertionEffect = function (i, e) { return xr.current.useInsertionEffect(i, e) }; Vt.useLayoutEffect = function (i, e) { return xr.current.useLayoutEffect(i, e) }; Vt.useMemo = function (i, e) { return xr.current.useMemo(i, e) }; Vt.useReducer = function (i, e, t) { return xr.current.useReducer(i, e, t) }; Vt.useRef = function (i) { return xr.current.useRef(i) }; Vt.useState = function (i) { return xr.current.useState(i) }; Vt.useSyncExternalStore = function (i, e, t) { return xr.current.useSyncExternalStore(i, e, t) }; Vt.useTransition = function () { return xr.current.useTransition() }; Vt.version = "18.2.0"; XI.exports = Vt; var ce = XI.exports; const Qf = LS(ce), rU = GN({ __proto__: null, default: Qf }, [ce]);/**
 * @license React
 * react-jsx-runtime.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */var sU = ce, oU = Symbol.for("react.element"), aU = Symbol.for("react.fragment"), lU = Object.prototype.hasOwnProperty, cU = sU.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner, uU = { key: !0, ref: !0, __self: !0, __source: !0 }; function $I(i, e, t) { var n, r = {}, s = null, o = null; t !== void 0 && (s = "" + t), e.key !== void 0 && (s = "" + e.key), e.ref !== void 0 && (o = e.ref); for (n in e) lU.call(e, n) && !uU.hasOwnProperty(n) && (r[n] = e[n]); if (i && i.defaultProps) for (n in e = i.defaultProps, e) r[n] === void 0 && (r[n] = e[n]); return { $$typeof: oU, type: i, key: s, ref: o, props: r, _owner: cU.current } } lv.Fragment = aU; lv.jsx = $I; lv.jsxs = $I; WI.exports = lv; var Re = WI.exports, yM = {}, eB = { exports: {} }, cs = {}, tB = { exports: {} }, nB = {};/**
 * @license React
 * scheduler.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */(function (i) { function e(F, Y) { var L = F.length; F.push(Y); e: for (; 0 < L;) { var G = L - 1 >>> 1, K = F[G]; if (0 < r(K, Y)) F[G] = Y, F[L] = K, L = G; else break e } } function t(F) { return F.length === 0 ? null : F[0] } function n(F) { if (F.length === 0) return null; var Y = F[0], L = F.pop(); if (L !== Y) { F[0] = L; e: for (var G = 0, K = F.length, ye = K >>> 1; G < ye;) { var ge = 2 * (G + 1) - 1, xe = F[ge], Be = ge + 1, Ie = F[Be]; if (0 > r(xe, L)) Be < K && 0 > r(Ie, xe) ? (F[G] = Ie, F[Be] = L, G = Be) : (F[G] = xe, F[ge] = L, G = ge); else if (Be < K && 0 > r(Ie, L)) F[G] = Ie, F[Be] = L, G = Be; else break e } } return Y } function r(F, Y) { var L = F.sortIndex - Y.sortIndex; return L !== 0 ? L : F.id - Y.id } if (typeof performance == "object" && typeof performance.now == "function") { var s = performance; i.unstable_now = function () { return s.now() } } else { var o = Date, a = o.now(); i.unstable_now = function () { return o.now() - a } } var l = [], c = [], f = 1, d = null, p = 3, m = !1, y = !1, _ = !1, x = typeof setTimeout == "function" ? setTimeout : null, g = typeof clearTimeout == "function" ? clearTimeout : null, A = typeof setImmediate < "u" ? setImmediate : null; typeof navigator < "u" && navigator.scheduling !== void 0 && navigator.scheduling.isInputPending !== void 0 && navigator.scheduling.isInputPending.bind(navigator.scheduling); function M(F) { for (var Y = t(c); Y !== null;) { if (Y.callback === null) n(c); else if (Y.startTime <= F) n(c), Y.sortIndex = Y.expirationTime, e(l, Y); else break; Y = t(c) } } function S(F) { if (_ = !1, M(F), !y) if (t(l) !== null) y = !0, ne(C); else { var Y = t(c); Y !== null && Q(S, Y.startTime - F) } } function C(F, Y) { y = !1, _ && (_ = !1, g(B), B = -1), m = !0; var L = p; try { for (M(Y), d = t(l); d !== null && (!(d.expirationTime > Y) || F && !N());) { var G = d.callback; if (typeof G == "function") { d.callback = null, p = d.priorityLevel; var K = G(d.expirationTime <= Y); Y = i.unstable_now(), typeof K == "function" ? d.callback = K : d === t(l) && n(l), M(Y) } else n(l); d = t(l) } if (d !== null) var ye = !0; else { var ge = t(c); ge !== null && Q(S, ge.startTime - Y), ye = !1 } return ye } finally { d = null, p = L, m = !1 } } var T = !1, R = null, B = -1, b = 5, I = -1; function N() { return !(i.unstable_now() - I < b) } function V() { if (R !== null) { var F = i.unstable_now(); I = F; var Y = !0; try { Y = R(!0, F) } finally { Y ? J() : (T = !1, R = null) } } else T = !1 } var J; if (typeof A == "function") J = function () { A(V) }; else if (typeof MessageChannel < "u") { var j = new MessageChannel, q = j.port2; j.port1.onmessage = V, J = function () { q.postMessage(null) } } else J = function () { x(V, 0) }; function ne(F) { R = F, T || (T = !0, J()) } function Q(F, Y) { B = x(function () { F(i.unstable_now()) }, Y) } i.unstable_IdlePriority = 5, i.unstable_ImmediatePriority = 1, i.unstable_LowPriority = 4, i.unstable_NormalPriority = 3, i.unstable_Profiling = null, i.unstable_UserBlockingPriority = 2, i.unstable_cancelCallback = function (F) { F.callback = null }, i.unstable_continueExecution = function () { y || m || (y = !0, ne(C)) }, i.unstable_forceFrameRate = function (F) { 0 > F || 125 < F ? console.error("forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported") : b = 0 < F ? Math.floor(1e3 / F) : 5 }, i.unstable_getCurrentPriorityLevel = function () { return p }, i.unstable_getFirstCallbackNode = function () { return t(l) }, i.unstable_next = function (F) { switch (p) { case 1: case 2: case 3: var Y = 3; break; default: Y = p }var L = p; p = Y; try { return F() } finally { p = L } }, i.unstable_pauseExecution = function () { }, i.unstable_requestPaint = function () { }, i.unstable_runWithPriority = function (F, Y) { switch (F) { case 1: case 2: case 3: case 4: case 5: break; default: F = 3 }var L = p; p = F; try { return Y() } finally { p = L } }, i.unstable_scheduleCallback = function (F, Y, L) { var G = i.unstable_now(); switch (typeof L == "object" && L !== null ? (L = L.delay, L = typeof L == "number" && 0 < L ? G + L : G) : L = G, F) { case 1: var K = -1; break; case 2: K = 250; break; case 5: K = 1073741823; break; case 4: K = 1e4; break; default: K = 5e3 }return K = L + K, F = { id: f++, callback: Y, priorityLevel: F, startTime: L, expirationTime: K, sortIndex: -1 }, L > G ? (F.sortIndex = L, e(c, F), t(l) === null && F === t(c) && (_ ? (g(B), B = -1) : _ = !0, Q(S, L - G))) : (F.sortIndex = K, e(l, F), y || m || (y = !0, ne(C))), F }, i.unstable_shouldYield = N, i.unstable_wrapCallback = function (F) { var Y = p; return function () { var L = p; p = Y; try { return F.apply(this, arguments) } finally { p = L } } } })(nB); tB.exports = nB; var fU = tB.exports;/**
 * @license React
 * react-dom.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */var iB = ce, os = fU; function Pe(i) { for (var e = "https://reactjs.org/docs/error-decoder.html?invariant=" + i, t = 1; t < arguments.length; t++)e += "&args[]=" + encodeURIComponent(arguments[t]); return "Minified React error #" + i + "; visit " + e + " for the full message or use the non-minified dev environment for full errors and additional helpful warnings." } var rB = new Set, cp = {}; function fu(i, e) { Zf(i, e), Zf(i + "Capture", e) } function Zf(i, e) { for (cp[i] = e, i = 0; i < e.length; i++)rB.add(e[i]) } var Ta = !(typeof window > "u" || typeof window.document > "u" || typeof window.document.createElement > "u"), vM = Object.prototype.hasOwnProperty, hU = /^[:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD][:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\-.0-9\u00B7\u0300-\u036F\u203F-\u2040]*$/, kT = {}, NT = {}; function dU(i) { return vM.call(NT, i) ? !0 : vM.call(kT, i) ? !1 : hU.test(i) ? NT[i] = !0 : (kT[i] = !0, !1) } function pU(i, e, t, n) { if (t !== null && t.type === 0) return !1; switch (typeof e) { case "function": case "symbol": return !0; case "boolean": return n ? !1 : t !== null ? !t.acceptsBooleans : (i = i.toLowerCase().slice(0, 5), i !== "data-" && i !== "aria-"); default: return !1 } } function mU(i, e, t, n) { if (e === null || typeof e > "u" || pU(i, e, t, n)) return !0; if (n) return !1; if (t !== null) switch (t.type) { case 3: return !e; case 4: return e === !1; case 5: return isNaN(e); case 6: return isNaN(e) || 1 > e }return !1 } function Ar(i, e, t, n, r, s, o) { this.acceptsBooleans = e === 2 || e === 3 || e === 4, this.attributeName = n, this.attributeNamespace = r, this.mustUseProperty = t, this.propertyName = i, this.type = e, this.sanitizeURL = s, this.removeEmptyString = o } var ki = {}; "children dangerouslySetInnerHTML defaultValue defaultChecked innerHTML suppressContentEditableWarning suppressHydrationWarning style".split(" ").forEach(function (i) { ki[i] = new Ar(i, 0, !1, i, null, !1, !1) });[["acceptCharset", "accept-charset"], ["className", "class"], ["htmlFor", "for"], ["httpEquiv", "http-equiv"]].forEach(function (i) { var e = i[0]; ki[e] = new Ar(e, 1, !1, i[1], null, !1, !1) });["contentEditable", "draggable", "spellCheck", "value"].forEach(function (i) { ki[i] = new Ar(i, 2, !1, i.toLowerCase(), null, !1, !1) });["autoReverse", "externalResourcesRequired", "focusable", "preserveAlpha"].forEach(function (i) { ki[i] = new Ar(i, 2, !1, i, null, !1, !1) }); "allowFullScreen async autoFocus autoPlay controls default defer disabled disablePictureInPicture disableRemotePlayback formNoValidate hidden loop noModule noValidate open playsInline readOnly required reversed scoped seamless itemScope".split(" ").forEach(function (i) { ki[i] = new Ar(i, 3, !1, i.toLowerCase(), null, !1, !1) });["checked", "multiple", "muted", "selected"].forEach(function (i) { ki[i] = new Ar(i, 3, !0, i, null, !1, !1) });["capture", "download"].forEach(function (i) { ki[i] = new Ar(i, 4, !1, i, null, !1, !1) });["cols", "rows", "size", "span"].forEach(function (i) { ki[i] = new Ar(i, 6, !1, i, null, !1, !1) });["rowSpan", "start"].forEach(function (i) { ki[i] = new Ar(i, 5, !1, i.toLowerCase(), null, !1, !1) }); var NS = /[\-:]([a-z])/g; function US(i) { return i[1].toUpperCase() } "accent-height alignment-baseline arabic-form baseline-shift cap-height clip-path clip-rule color-interpolation color-interpolation-filters color-profile color-rendering dominant-baseline enable-background fill-opacity fill-rule flood-color flood-opacity font-family font-size font-size-adjust font-stretch font-style font-variant font-weight glyph-name glyph-orientation-horizontal glyph-orientation-vertical horiz-adv-x horiz-origin-x image-rendering letter-spacing lighting-color marker-end marker-mid marker-start overline-position overline-thickness paint-order panose-1 pointer-events rendering-intent shape-rendering stop-color stop-opacity strikethrough-position strikethrough-thickness stroke-dasharray stroke-dashoffset stroke-linecap stroke-linejoin stroke-miterlimit stroke-opacity stroke-width text-anchor text-decoration text-rendering underline-position underline-thickness unicode-bidi unicode-range units-per-em v-alphabetic v-hanging v-ideographic v-mathematical vector-effect vert-adv-y vert-origin-x vert-origin-y word-spacing writing-mode xmlns:xlink x-height".split(" ").forEach(function (i) { var e = i.replace(NS, US); ki[e] = new Ar(e, 1, !1, i, null, !1, !1) }); "xlink:actuate xlink:arcrole xlink:role xlink:show xlink:title xlink:type".split(" ").forEach(function (i) { var e = i.replace(NS, US); ki[e] = new Ar(e, 1, !1, i, "http://www.w3.org/1999/xlink", !1, !1) });["xml:base", "xml:lang", "xml:space"].forEach(function (i) { var e = i.replace(NS, US); ki[e] = new Ar(e, 1, !1, i, "http://www.w3.org/XML/1998/namespace", !1, !1) });["tabIndex", "crossOrigin"].forEach(function (i) { ki[i] = new Ar(i, 1, !1, i.toLowerCase(), null, !1, !1) }); ki.xlinkHref = new Ar("xlinkHref", 1, !1, "xlink:href", "http://www.w3.org/1999/xlink", !0, !1);["src", "href", "action", "formAction"].forEach(function (i) { ki[i] = new Ar(i, 1, !1, i.toLowerCase(), null, !0, !0) }); function zS(i, e, t, n) { var r = ki.hasOwnProperty(e) ? ki[e] : null; (r !== null ? r.type !== 0 : n || !(2 < e.length) || e[0] !== "o" && e[0] !== "O" || e[1] !== "n" && e[1] !== "N") && (mU(e, t, r, n) && (t = null), n || r === null ? dU(e) && (t === null ? i.removeAttribute(e) : i.setAttribute(e, "" + t)) : r.mustUseProperty ? i[r.propertyName] = t === null ? r.type === 3 ? !1 : "" : t : (e = r.attributeName, n = r.attributeNamespace, t === null ? i.removeAttribute(e) : (r = r.type, t = r === 3 || r === 4 && t === !0 ? "" : "" + t, n ? i.setAttributeNS(n, e, t) : i.setAttribute(e, t)))) } var Fa = iB.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED, fg = Symbol.for("react.element"), hf = Symbol.for("react.portal"), df = Symbol.for("react.fragment"), HS = Symbol.for("react.strict_mode"), _M = Symbol.for("react.profiler"), sB = Symbol.for("react.provider"), oB = Symbol.for("react.context"), GS = Symbol.for("react.forward_ref"), xM = Symbol.for("react.suspense"), AM = Symbol.for("react.suspense_list"), VS = Symbol.for("react.memo"), tl = Symbol.for("react.lazy"), aB = Symbol.for("react.offscreen"), UT = Symbol.iterator; function ed(i) { return i === null || typeof i != "object" ? null : (i = UT && i[UT] || i["@@iterator"], typeof i == "function" ? i : null) } var Dn = Object.assign, gx; function Sd(i) {
	if (gx === void 0) try { throw Error() } catch (t) { var e = t.stack.trim().match(/\n( *(at )?)/); gx = e && e[1] || "" } return `
`+ gx + i
} var yx = !1; function vx(i, e) {
	if (!i || yx) return ""; yx = !0; var t = Error.prepareStackTrace; Error.prepareStackTrace = void 0; try { if (e) if (e = function () { throw Error() }, Object.defineProperty(e.prototype, "props", { set: function () { throw Error() } }), typeof Reflect == "object" && Reflect.construct) { try { Reflect.construct(e, []) } catch (c) { var n = c } Reflect.construct(i, [], e) } else { try { e.call() } catch (c) { n = c } i.call(e.prototype) } else { try { throw Error() } catch (c) { n = c } i() } } catch (c) {
		if (c && n && typeof c.stack == "string") {
			for (var r = c.stack.split(`
`), s = n.stack.split(`
`), o = r.length - 1, a = s.length - 1; 1 <= o && 0 <= a && r[o] !== s[a];)a--; for (; 1 <= o && 0 <= a; o--, a--)if (r[o] !== s[a]) {
				if (o !== 1 || a !== 1) do if (o--, a--, 0 > a || r[o] !== s[a]) {
					var l = `
`+ r[o].replace(" at new ", " at "); return i.displayName && l.includes("<anonymous>") && (l = l.replace("<anonymous>", i.displayName)), l
				} while (1 <= o && 0 <= a); break
			}
		}
	} finally { yx = !1, Error.prepareStackTrace = t } return (i = i ? i.displayName || i.name : "") ? Sd(i) : ""
} function gU(i) { switch (i.tag) { case 5: return Sd(i.type); case 16: return Sd("Lazy"); case 13: return Sd("Suspense"); case 19: return Sd("SuspenseList"); case 0: case 2: case 15: return i = vx(i.type, !1), i; case 11: return i = vx(i.type.render, !1), i; case 1: return i = vx(i.type, !0), i; default: return "" } } function MM(i) { if (i == null) return null; if (typeof i == "function") return i.displayName || i.name || null; if (typeof i == "string") return i; switch (i) { case df: return "Fragment"; case hf: return "Portal"; case _M: return "Profiler"; case HS: return "StrictMode"; case xM: return "Suspense"; case AM: return "SuspenseList" }if (typeof i == "object") switch (i.$$typeof) { case oB: return (i.displayName || "Context") + ".Consumer"; case sB: return (i._context.displayName || "Context") + ".Provider"; case GS: var e = i.render; return i = i.displayName, i || (i = e.displayName || e.name || "", i = i !== "" ? "ForwardRef(" + i + ")" : "ForwardRef"), i; case VS: return e = i.displayName || null, e !== null ? e : MM(i.type) || "Memo"; case tl: e = i._payload, i = i._init; try { return MM(i(e)) } catch { } }return null } function yU(i) { var e = i.type; switch (i.tag) { case 24: return "Cache"; case 9: return (e.displayName || "Context") + ".Consumer"; case 10: return (e._context.displayName || "Context") + ".Provider"; case 18: return "DehydratedFragment"; case 11: return i = e.render, i = i.displayName || i.name || "", e.displayName || (i !== "" ? "ForwardRef(" + i + ")" : "ForwardRef"); case 7: return "Fragment"; case 5: return e; case 4: return "Portal"; case 3: return "Root"; case 6: return "Text"; case 16: return MM(e); case 8: return e === HS ? "StrictMode" : "Mode"; case 22: return "Offscreen"; case 12: return "Profiler"; case 21: return "Scope"; case 13: return "Suspense"; case 19: return "SuspenseList"; case 25: return "TracingMarker"; case 1: case 0: case 17: case 2: case 14: case 15: if (typeof e == "function") return e.displayName || e.name || null; if (typeof e == "string") return e }return null } function Bl(i) { switch (typeof i) { case "boolean": case "number": case "string": case "undefined": return i; case "object": return i; default: return "" } } function lB(i) { var e = i.type; return (i = i.nodeName) && i.toLowerCase() === "input" && (e === "checkbox" || e === "radio") } function vU(i) { var e = lB(i) ? "checked" : "value", t = Object.getOwnPropertyDescriptor(i.constructor.prototype, e), n = "" + i[e]; if (!i.hasOwnProperty(e) && typeof t < "u" && typeof t.get == "function" && typeof t.set == "function") { var r = t.get, s = t.set; return Object.defineProperty(i, e, { configurable: !0, get: function () { return r.call(this) }, set: function (o) { n = "" + o, s.call(this, o) } }), Object.defineProperty(i, e, { enumerable: t.enumerable }), { getValue: function () { return n }, setValue: function (o) { n = "" + o }, stopTracking: function () { i._valueTracker = null, delete i[e] } } } } function hg(i) { i._valueTracker || (i._valueTracker = vU(i)) } function cB(i) { if (!i) return !1; var e = i._valueTracker; if (!e) return !0; var t = e.getValue(), n = ""; return i && (n = lB(i) ? i.checked ? "true" : "false" : i.value), i = n, i !== t ? (e.setValue(i), !0) : !1 } function hy(i) { if (i = i || (typeof document < "u" ? document : void 0), typeof i > "u") return null; try { return i.activeElement || i.body } catch { return i.body } } function wM(i, e) { var t = e.checked; return Dn({}, e, { defaultChecked: void 0, defaultValue: void 0, value: void 0, checked: t ?? i._wrapperState.initialChecked }) } function zT(i, e) { var t = e.defaultValue == null ? "" : e.defaultValue, n = e.checked != null ? e.checked : e.defaultChecked; t = Bl(e.value != null ? e.value : t), i._wrapperState = { initialChecked: n, initialValue: t, controlled: e.type === "checkbox" || e.type === "radio" ? e.checked != null : e.value != null } } function uB(i, e) { e = e.checked, e != null && zS(i, "checked", e, !1) } function SM(i, e) { uB(i, e); var t = Bl(e.value), n = e.type; if (t != null) n === "number" ? (t === 0 && i.value === "" || i.value != t) && (i.value = "" + t) : i.value !== "" + t && (i.value = "" + t); else if (n === "submit" || n === "reset") { i.removeAttribute("value"); return } e.hasOwnProperty("value") ? EM(i, e.type, t) : e.hasOwnProperty("defaultValue") && EM(i, e.type, Bl(e.defaultValue)), e.checked == null && e.defaultChecked != null && (i.defaultChecked = !!e.defaultChecked) } function HT(i, e, t) { if (e.hasOwnProperty("value") || e.hasOwnProperty("defaultValue")) { var n = e.type; if (!(n !== "submit" && n !== "reset" || e.value !== void 0 && e.value !== null)) return; e = "" + i._wrapperState.initialValue, t || e === i.value || (i.value = e), i.defaultValue = e } t = i.name, t !== "" && (i.name = ""), i.defaultChecked = !!i._wrapperState.initialChecked, t !== "" && (i.name = t) } function EM(i, e, t) { (e !== "number" || hy(i.ownerDocument) !== i) && (t == null ? i.defaultValue = "" + i._wrapperState.initialValue : i.defaultValue !== "" + t && (i.defaultValue = "" + t)) } var Ed = Array.isArray; function Df(i, e, t, n) { if (i = i.options, e) { e = {}; for (var r = 0; r < t.length; r++)e["$" + t[r]] = !0; for (t = 0; t < i.length; t++)r = e.hasOwnProperty("$" + i[t].value), i[t].selected !== r && (i[t].selected = r), r && n && (i[t].defaultSelected = !0) } else { for (t = "" + Bl(t), e = null, r = 0; r < i.length; r++) { if (i[r].value === t) { i[r].selected = !0, n && (i[r].defaultSelected = !0); return } e !== null || i[r].disabled || (e = i[r]) } e !== null && (e.selected = !0) } } function CM(i, e) { if (e.dangerouslySetInnerHTML != null) throw Error(Pe(91)); return Dn({}, e, { value: void 0, defaultValue: void 0, children: "" + i._wrapperState.initialValue }) } function GT(i, e) { var t = e.value; if (t == null) { if (t = e.children, e = e.defaultValue, t != null) { if (e != null) throw Error(Pe(92)); if (Ed(t)) { if (1 < t.length) throw Error(Pe(93)); t = t[0] } e = t } e == null && (e = ""), t = e } i._wrapperState = { initialValue: Bl(t) } } function fB(i, e) { var t = Bl(e.value), n = Bl(e.defaultValue); t != null && (t = "" + t, t !== i.value && (i.value = t), e.defaultValue == null && i.defaultValue !== t && (i.defaultValue = t)), n != null && (i.defaultValue = "" + n) } function VT(i) { var e = i.textContent; e === i._wrapperState.initialValue && e !== "" && e !== null && (i.value = e) } function hB(i) { switch (i) { case "svg": return "http://www.w3.org/2000/svg"; case "math": return "http://www.w3.org/1998/Math/MathML"; default: return "http://www.w3.org/1999/xhtml" } } function TM(i, e) { return i == null || i === "http://www.w3.org/1999/xhtml" ? hB(e) : i === "http://www.w3.org/2000/svg" && e === "foreignObject" ? "http://www.w3.org/1999/xhtml" : i } var dg, dB = function (i) { return typeof MSApp < "u" && MSApp.execUnsafeLocalFunction ? function (e, t, n, r) { MSApp.execUnsafeLocalFunction(function () { return i(e, t, n, r) }) } : i }(function (i, e) { if (i.namespaceURI !== "http://www.w3.org/2000/svg" || "innerHTML" in i) i.innerHTML = e; else { for (dg = dg || document.createElement("div"), dg.innerHTML = "<svg>" + e.valueOf().toString() + "</svg>", e = dg.firstChild; i.firstChild;)i.removeChild(i.firstChild); for (; e.firstChild;)i.appendChild(e.firstChild) } }); function up(i, e) { if (e) { var t = i.firstChild; if (t && t === i.lastChild && t.nodeType === 3) { t.nodeValue = e; return } } i.textContent = e } var Od = { animationIterationCount: !0, aspectRatio: !0, borderImageOutset: !0, borderImageSlice: !0, borderImageWidth: !0, boxFlex: !0, boxFlexGroup: !0, boxOrdinalGroup: !0, columnCount: !0, columns: !0, flex: !0, flexGrow: !0, flexPositive: !0, flexShrink: !0, flexNegative: !0, flexOrder: !0, gridArea: !0, gridRow: !0, gridRowEnd: !0, gridRowSpan: !0, gridRowStart: !0, gridColumn: !0, gridColumnEnd: !0, gridColumnSpan: !0, gridColumnStart: !0, fontWeight: !0, lineClamp: !0, lineHeight: !0, opacity: !0, order: !0, orphans: !0, tabSize: !0, widows: !0, zIndex: !0, zoom: !0, fillOpacity: !0, floodOpacity: !0, stopOpacity: !0, strokeDasharray: !0, strokeDashoffset: !0, strokeMiterlimit: !0, strokeOpacity: !0, strokeWidth: !0 }, _U = ["Webkit", "ms", "Moz", "O"]; Object.keys(Od).forEach(function (i) { _U.forEach(function (e) { e = e + i.charAt(0).toUpperCase() + i.substring(1), Od[e] = Od[i] }) }); function pB(i, e, t) { return e == null || typeof e == "boolean" || e === "" ? "" : t || typeof e != "number" || e === 0 || Od.hasOwnProperty(i) && Od[i] ? ("" + e).trim() : e + "px" } function mB(i, e) { i = i.style; for (var t in e) if (e.hasOwnProperty(t)) { var n = t.indexOf("--") === 0, r = pB(t, e[t], n); t === "float" && (t = "cssFloat"), n ? i.setProperty(t, r) : i[t] = r } } var xU = Dn({ menuitem: !0 }, { area: !0, base: !0, br: !0, col: !0, embed: !0, hr: !0, img: !0, input: !0, keygen: !0, link: !0, meta: !0, param: !0, source: !0, track: !0, wbr: !0 }); function bM(i, e) { if (e) { if (xU[i] && (e.children != null || e.dangerouslySetInnerHTML != null)) throw Error(Pe(137, i)); if (e.dangerouslySetInnerHTML != null) { if (e.children != null) throw Error(Pe(60)); if (typeof e.dangerouslySetInnerHTML != "object" || !("__html" in e.dangerouslySetInnerHTML)) throw Error(Pe(61)) } if (e.style != null && typeof e.style != "object") throw Error(Pe(62)) } } function RM(i, e) { if (i.indexOf("-") === -1) return typeof e.is == "string"; switch (i) { case "annotation-xml": case "color-profile": case "font-face": case "font-face-src": case "font-face-uri": case "font-face-format": case "font-face-name": case "missing-glyph": return !1; default: return !0 } } var PM = null; function WS(i) { return i = i.target || i.srcElement || window, i.correspondingUseElement && (i = i.correspondingUseElement), i.nodeType === 3 ? i.parentNode : i } var IM = null, Of = null, Ff = null; function WT(i) { if (i = Zp(i)) { if (typeof IM != "function") throw Error(Pe(280)); var e = i.stateNode; e && (e = dv(e), IM(i.stateNode, i.type, e)) } } function gB(i) { Of ? Ff ? Ff.push(i) : Ff = [i] : Of = i } function yB() { if (Of) { var i = Of, e = Ff; if (Ff = Of = null, WT(i), e) for (i = 0; i < e.length; i++)WT(e[i]) } } function vB(i, e) { return i(e) } function _B() { } var _x = !1; function xB(i, e, t) { if (_x) return i(e, t); _x = !0; try { return vB(i, e, t) } finally { _x = !1, (Of !== null || Ff !== null) && (_B(), yB()) } } function fp(i, e) { var t = i.stateNode; if (t === null) return null; var n = dv(t); if (n === null) return null; t = n[e]; e: switch (e) { case "onClick": case "onClickCapture": case "onDoubleClick": case "onDoubleClickCapture": case "onMouseDown": case "onMouseDownCapture": case "onMouseMove": case "onMouseMoveCapture": case "onMouseUp": case "onMouseUpCapture": case "onMouseEnter": (n = !n.disabled) || (i = i.type, n = !(i === "button" || i === "input" || i === "select" || i === "textarea")), i = !n; break e; default: i = !1 }if (i) return null; if (t && typeof t != "function") throw Error(Pe(231, e, typeof t)); return t } var BM = !1; if (Ta) try { var td = {}; Object.defineProperty(td, "passive", { get: function () { BM = !0 } }), window.addEventListener("test", td, td), window.removeEventListener("test", td, td) } catch { BM = !1 } function AU(i, e, t, n, r, s, o, a, l) { var c = Array.prototype.slice.call(arguments, 3); try { e.apply(t, c) } catch (f) { this.onError(f) } } var Fd = !1, dy = null, py = !1, LM = null, MU = { onError: function (i) { Fd = !0, dy = i } }; function wU(i, e, t, n, r, s, o, a, l) { Fd = !1, dy = null, AU.apply(MU, arguments) } function SU(i, e, t, n, r, s, o, a, l) { if (wU.apply(this, arguments), Fd) { if (Fd) { var c = dy; Fd = !1, dy = null } else throw Error(Pe(198)); py || (py = !0, LM = c) } } function hu(i) { var e = i, t = i; if (i.alternate) for (; e.return;)e = e.return; else { i = e; do e = i, e.flags & 4098 && (t = e.return), i = e.return; while (i) } return e.tag === 3 ? t : null } function AB(i) { if (i.tag === 13) { var e = i.memoizedState; if (e === null && (i = i.alternate, i !== null && (e = i.memoizedState)), e !== null) return e.dehydrated } return null } function XT(i) { if (hu(i) !== i) throw Error(Pe(188)) } function EU(i) { var e = i.alternate; if (!e) { if (e = hu(i), e === null) throw Error(Pe(188)); return e !== i ? null : i } for (var t = i, n = e; ;) { var r = t.return; if (r === null) break; var s = r.alternate; if (s === null) { if (n = r.return, n !== null) { t = n; continue } break } if (r.child === s.child) { for (s = r.child; s;) { if (s === t) return XT(r), i; if (s === n) return XT(r), e; s = s.sibling } throw Error(Pe(188)) } if (t.return !== n.return) t = r, n = s; else { for (var o = !1, a = r.child; a;) { if (a === t) { o = !0, t = r, n = s; break } if (a === n) { o = !0, n = r, t = s; break } a = a.sibling } if (!o) { for (a = s.child; a;) { if (a === t) { o = !0, t = s, n = r; break } if (a === n) { o = !0, n = s, t = r; break } a = a.sibling } if (!o) throw Error(Pe(189)) } } if (t.alternate !== n) throw Error(Pe(190)) } if (t.tag !== 3) throw Error(Pe(188)); return t.stateNode.current === t ? i : e } function MB(i) { return i = EU(i), i !== null ? wB(i) : null } function wB(i) { if (i.tag === 5 || i.tag === 6) return i; for (i = i.child; i !== null;) { var e = wB(i); if (e !== null) return e; i = i.sibling } return null } var SB = os.unstable_scheduleCallback, JT = os.unstable_cancelCallback, CU = os.unstable_shouldYield, TU = os.unstable_requestPaint, qn = os.unstable_now, bU = os.unstable_getCurrentPriorityLevel, XS = os.unstable_ImmediatePriority, EB = os.unstable_UserBlockingPriority, my = os.unstable_NormalPriority, RU = os.unstable_LowPriority, CB = os.unstable_IdlePriority, cv = null, Fo = null; function PU(i) { if (Fo && typeof Fo.onCommitFiberRoot == "function") try { Fo.onCommitFiberRoot(cv, i, void 0, (i.current.flags & 128) === 128) } catch { } } var so = Math.clz32 ? Math.clz32 : LU, IU = Math.log, BU = Math.LN2; function LU(i) { return i >>>= 0, i === 0 ? 32 : 31 - (IU(i) / BU | 0) | 0 } var pg = 64, mg = 4194304; function Cd(i) { switch (i & -i) { case 1: return 1; case 2: return 2; case 4: return 4; case 8: return 8; case 16: return 16; case 32: return 32; case 64: case 128: case 256: case 512: case 1024: case 2048: case 4096: case 8192: case 16384: case 32768: case 65536: case 131072: case 262144: case 524288: case 1048576: case 2097152: return i & 4194240; case 4194304: case 8388608: case 16777216: case 33554432: case 67108864: return i & 130023424; case 134217728: return 134217728; case 268435456: return 268435456; case 536870912: return 536870912; case 1073741824: return 1073741824; default: return i } } function gy(i, e) { var t = i.pendingLanes; if (t === 0) return 0; var n = 0, r = i.suspendedLanes, s = i.pingedLanes, o = t & 268435455; if (o !== 0) { var a = o & ~r; a !== 0 ? n = Cd(a) : (s &= o, s !== 0 && (n = Cd(s))) } else o = t & ~r, o !== 0 ? n = Cd(o) : s !== 0 && (n = Cd(s)); if (n === 0) return 0; if (e !== 0 && e !== n && !(e & r) && (r = n & -n, s = e & -e, r >= s || r === 16 && (s & 4194240) !== 0)) return e; if (n & 4 && (n |= t & 16), e = i.entangledLanes, e !== 0) for (i = i.entanglements, e &= n; 0 < e;)t = 31 - so(e), r = 1 << t, n |= i[t], e &= ~r; return n } function DU(i, e) { switch (i) { case 1: case 2: case 4: return e + 250; case 8: case 16: case 32: case 64: case 128: case 256: case 512: case 1024: case 2048: case 4096: case 8192: case 16384: case 32768: case 65536: case 131072: case 262144: case 524288: case 1048576: case 2097152: return e + 5e3; case 4194304: case 8388608: case 16777216: case 33554432: case 67108864: return -1; case 134217728: case 268435456: case 536870912: case 1073741824: return -1; default: return -1 } } function OU(i, e) { for (var t = i.suspendedLanes, n = i.pingedLanes, r = i.expirationTimes, s = i.pendingLanes; 0 < s;) { var o = 31 - so(s), a = 1 << o, l = r[o]; l === -1 ? (!(a & t) || a & n) && (r[o] = DU(a, e)) : l <= e && (i.expiredLanes |= a), s &= ~a } } function DM(i) { return i = i.pendingLanes & -1073741825, i !== 0 ? i : i & 1073741824 ? 1073741824 : 0 } function TB() { var i = pg; return pg <<= 1, !(pg & 4194240) && (pg = 64), i } function xx(i) { for (var e = [], t = 0; 31 > t; t++)e.push(i); return e } function qp(i, e, t) { i.pendingLanes |= e, e !== 536870912 && (i.suspendedLanes = 0, i.pingedLanes = 0), i = i.eventTimes, e = 31 - so(e), i[e] = t } function FU(i, e) { var t = i.pendingLanes & ~e; i.pendingLanes = e, i.suspendedLanes = 0, i.pingedLanes = 0, i.expiredLanes &= e, i.mutableReadLanes &= e, i.entangledLanes &= e, e = i.entanglements; var n = i.eventTimes; for (i = i.expirationTimes; 0 < t;) { var r = 31 - so(t), s = 1 << r; e[r] = 0, n[r] = -1, i[r] = -1, t &= ~s } } function JS(i, e) { var t = i.entangledLanes |= e; for (i = i.entanglements; t;) { var n = 31 - so(t), r = 1 << n; r & e | i[n] & e && (i[n] |= e), t &= ~r } } var an = 0; function bB(i) { return i &= -i, 1 < i ? 4 < i ? i & 268435455 ? 16 : 536870912 : 4 : 1 } var RB, YS, PB, IB, BB, OM = !1, gg = [], gl = null, yl = null, vl = null, hp = new Map, dp = new Map, sl = [], kU = "mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput copy cut paste click change contextmenu reset submit".split(" "); function YT(i, e) { switch (i) { case "focusin": case "focusout": gl = null; break; case "dragenter": case "dragleave": yl = null; break; case "mouseover": case "mouseout": vl = null; break; case "pointerover": case "pointerout": hp.delete(e.pointerId); break; case "gotpointercapture": case "lostpointercapture": dp.delete(e.pointerId) } } function nd(i, e, t, n, r, s) { return i === null || i.nativeEvent !== s ? (i = { blockedOn: e, domEventName: t, eventSystemFlags: n, nativeEvent: s, targetContainers: [r] }, e !== null && (e = Zp(e), e !== null && YS(e)), i) : (i.eventSystemFlags |= n, e = i.targetContainers, r !== null && e.indexOf(r) === -1 && e.push(r), i) } function NU(i, e, t, n, r) { switch (e) { case "focusin": return gl = nd(gl, i, e, t, n, r), !0; case "dragenter": return yl = nd(yl, i, e, t, n, r), !0; case "mouseover": return vl = nd(vl, i, e, t, n, r), !0; case "pointerover": var s = r.pointerId; return hp.set(s, nd(hp.get(s) || null, i, e, t, n, r)), !0; case "gotpointercapture": return s = r.pointerId, dp.set(s, nd(dp.get(s) || null, i, e, t, n, r)), !0 }return !1 } function LB(i) { var e = Cc(i.target); if (e !== null) { var t = hu(e); if (t !== null) { if (e = t.tag, e === 13) { if (e = AB(t), e !== null) { i.blockedOn = e, BB(i.priority, function () { PB(t) }); return } } else if (e === 3 && t.stateNode.current.memoizedState.isDehydrated) { i.blockedOn = t.tag === 3 ? t.stateNode.containerInfo : null; return } } } i.blockedOn = null } function O0(i) { if (i.blockedOn !== null) return !1; for (var e = i.targetContainers; 0 < e.length;) { var t = FM(i.domEventName, i.eventSystemFlags, e[0], i.nativeEvent); if (t === null) { t = i.nativeEvent; var n = new t.constructor(t.type, t); PM = n, t.target.dispatchEvent(n), PM = null } else return e = Zp(t), e !== null && YS(e), i.blockedOn = t, !1; e.shift() } return !0 } function jT(i, e, t) { O0(i) && t.delete(e) } function UU() { OM = !1, gl !== null && O0(gl) && (gl = null), yl !== null && O0(yl) && (yl = null), vl !== null && O0(vl) && (vl = null), hp.forEach(jT), dp.forEach(jT) } function id(i, e) { i.blockedOn === e && (i.blockedOn = null, OM || (OM = !0, os.unstable_scheduleCallback(os.unstable_NormalPriority, UU))) } function pp(i) { function e(r) { return id(r, i) } if (0 < gg.length) { id(gg[0], i); for (var t = 1; t < gg.length; t++) { var n = gg[t]; n.blockedOn === i && (n.blockedOn = null) } } for (gl !== null && id(gl, i), yl !== null && id(yl, i), vl !== null && id(vl, i), hp.forEach(e), dp.forEach(e), t = 0; t < sl.length; t++)n = sl[t], n.blockedOn === i && (n.blockedOn = null); for (; 0 < sl.length && (t = sl[0], t.blockedOn === null);)LB(t), t.blockedOn === null && sl.shift() } var kf = Fa.ReactCurrentBatchConfig, yy = !0; function zU(i, e, t, n) { var r = an, s = kf.transition; kf.transition = null; try { an = 1, jS(i, e, t, n) } finally { an = r, kf.transition = s } } function HU(i, e, t, n) { var r = an, s = kf.transition; kf.transition = null; try { an = 4, jS(i, e, t, n) } finally { an = r, kf.transition = s } } function jS(i, e, t, n) { if (yy) { var r = FM(i, e, t, n); if (r === null) Px(i, e, n, vy, t), YT(i, n); else if (NU(r, i, e, t, n)) n.stopPropagation(); else if (YT(i, n), e & 4 && -1 < kU.indexOf(i)) { for (; r !== null;) { var s = Zp(r); if (s !== null && RB(s), s = FM(i, e, t, n), s === null && Px(i, e, n, vy, t), s === r) break; r = s } r !== null && n.stopPropagation() } else Px(i, e, n, null, t) } } var vy = null; function FM(i, e, t, n) { if (vy = null, i = WS(n), i = Cc(i), i !== null) if (e = hu(i), e === null) i = null; else if (t = e.tag, t === 13) { if (i = AB(e), i !== null) return i; i = null } else if (t === 3) { if (e.stateNode.current.memoizedState.isDehydrated) return e.tag === 3 ? e.stateNode.containerInfo : null; i = null } else e !== i && (i = null); return vy = i, null } function DB(i) { switch (i) { case "cancel": case "click": case "close": case "contextmenu": case "copy": case "cut": case "auxclick": case "dblclick": case "dragend": case "dragstart": case "drop": case "focusin": case "focusout": case "input": case "invalid": case "keydown": case "keypress": case "keyup": case "mousedown": case "mouseup": case "paste": case "pause": case "play": case "pointercancel": case "pointerdown": case "pointerup": case "ratechange": case "reset": case "resize": case "seeked": case "submit": case "touchcancel": case "touchend": case "touchstart": case "volumechange": case "change": case "selectionchange": case "textInput": case "compositionstart": case "compositionend": case "compositionupdate": case "beforeblur": case "afterblur": case "beforeinput": case "blur": case "fullscreenchange": case "focus": case "hashchange": case "popstate": case "select": case "selectstart": return 1; case "drag": case "dragenter": case "dragexit": case "dragleave": case "dragover": case "mousemove": case "mouseout": case "mouseover": case "pointermove": case "pointerout": case "pointerover": case "scroll": case "toggle": case "touchmove": case "wheel": case "mouseenter": case "mouseleave": case "pointerenter": case "pointerleave": return 4; case "message": switch (bU()) { case XS: return 1; case EB: return 4; case my: case RU: return 16; case CB: return 536870912; default: return 16 }default: return 16 } } var ll = null, KS = null, F0 = null; function OB() { if (F0) return F0; var i, e = KS, t = e.length, n, r = "value" in ll ? ll.value : ll.textContent, s = r.length; for (i = 0; i < t && e[i] === r[i]; i++); var o = t - i; for (n = 1; n <= o && e[t - n] === r[s - n]; n++); return F0 = r.slice(i, 1 < n ? 1 - n : void 0) } function k0(i) { var e = i.keyCode; return "charCode" in i ? (i = i.charCode, i === 0 && e === 13 && (i = 13)) : i = e, i === 10 && (i = 13), 32 <= i || i === 13 ? i : 0 } function yg() { return !0 } function KT() { return !1 } function us(i) { function e(t, n, r, s, o) { this._reactName = t, this._targetInst = r, this.type = n, this.nativeEvent = s, this.target = o, this.currentTarget = null; for (var a in i) i.hasOwnProperty(a) && (t = i[a], this[a] = t ? t(s) : s[a]); return this.isDefaultPrevented = (s.defaultPrevented != null ? s.defaultPrevented : s.returnValue === !1) ? yg : KT, this.isPropagationStopped = KT, this } return Dn(e.prototype, { preventDefault: function () { this.defaultPrevented = !0; var t = this.nativeEvent; t && (t.preventDefault ? t.preventDefault() : typeof t.returnValue != "unknown" && (t.returnValue = !1), this.isDefaultPrevented = yg) }, stopPropagation: function () { var t = this.nativeEvent; t && (t.stopPropagation ? t.stopPropagation() : typeof t.cancelBubble != "unknown" && (t.cancelBubble = !0), this.isPropagationStopped = yg) }, persist: function () { }, isPersistent: yg }), e } var Ch = { eventPhase: 0, bubbles: 0, cancelable: 0, timeStamp: function (i) { return i.timeStamp || Date.now() }, defaultPrevented: 0, isTrusted: 0 }, qS = us(Ch), Qp = Dn({}, Ch, { view: 0, detail: 0 }), GU = us(Qp), Ax, Mx, rd, uv = Dn({}, Qp, { screenX: 0, screenY: 0, clientX: 0, clientY: 0, pageX: 0, pageY: 0, ctrlKey: 0, shiftKey: 0, altKey: 0, metaKey: 0, getModifierState: QS, button: 0, buttons: 0, relatedTarget: function (i) { return i.relatedTarget === void 0 ? i.fromElement === i.srcElement ? i.toElement : i.fromElement : i.relatedTarget }, movementX: function (i) { return "movementX" in i ? i.movementX : (i !== rd && (rd && i.type === "mousemove" ? (Ax = i.screenX - rd.screenX, Mx = i.screenY - rd.screenY) : Mx = Ax = 0, rd = i), Ax) }, movementY: function (i) { return "movementY" in i ? i.movementY : Mx } }), qT = us(uv), VU = Dn({}, uv, { dataTransfer: 0 }), WU = us(VU), XU = Dn({}, Qp, { relatedTarget: 0 }), wx = us(XU), JU = Dn({}, Ch, { animationName: 0, elapsedTime: 0, pseudoElement: 0 }), YU = us(JU), jU = Dn({}, Ch, { clipboardData: function (i) { return "clipboardData" in i ? i.clipboardData : window.clipboardData } }), KU = us(jU), qU = Dn({}, Ch, { data: 0 }), QT = us(qU), QU = { Esc: "Escape", Spacebar: " ", Left: "ArrowLeft", Up: "ArrowUp", Right: "ArrowRight", Down: "ArrowDown", Del: "Delete", Win: "OS", Menu: "ContextMenu", Apps: "ContextMenu", Scroll: "ScrollLock", MozPrintableKey: "Unidentified" }, ZU = { 8: "Backspace", 9: "Tab", 12: "Clear", 13: "Enter", 16: "Shift", 17: "Control", 18: "Alt", 19: "Pause", 20: "CapsLock", 27: "Escape", 32: " ", 33: "PageUp", 34: "PageDown", 35: "End", 36: "Home", 37: "ArrowLeft", 38: "ArrowUp", 39: "ArrowRight", 40: "ArrowDown", 45: "Insert", 46: "Delete", 112: "F1", 113: "F2", 114: "F3", 115: "F4", 116: "F5", 117: "F6", 118: "F7", 119: "F8", 120: "F9", 121: "F10", 122: "F11", 123: "F12", 144: "NumLock", 145: "ScrollLock", 224: "Meta" }, $U = { Alt: "altKey", Control: "ctrlKey", Meta: "metaKey", Shift: "shiftKey" }; function e3(i) { var e = this.nativeEvent; return e.getModifierState ? e.getModifierState(i) : (i = $U[i]) ? !!e[i] : !1 } function QS() { return e3 } var t3 = Dn({}, Qp, { key: function (i) { if (i.key) { var e = QU[i.key] || i.key; if (e !== "Unidentified") return e } return i.type === "keypress" ? (i = k0(i), i === 13 ? "Enter" : String.fromCharCode(i)) : i.type === "keydown" || i.type === "keyup" ? ZU[i.keyCode] || "Unidentified" : "" }, code: 0, location: 0, ctrlKey: 0, shiftKey: 0, altKey: 0, metaKey: 0, repeat: 0, locale: 0, getModifierState: QS, charCode: function (i) { return i.type === "keypress" ? k0(i) : 0 }, keyCode: function (i) { return i.type === "keydown" || i.type === "keyup" ? i.keyCode : 0 }, which: function (i) { return i.type === "keypress" ? k0(i) : i.type === "keydown" || i.type === "keyup" ? i.keyCode : 0 } }), n3 = us(t3), i3 = Dn({}, uv, { pointerId: 0, width: 0, height: 0, pressure: 0, tangentialPressure: 0, tiltX: 0, tiltY: 0, twist: 0, pointerType: 0, isPrimary: 0 }), ZT = us(i3), r3 = Dn({}, Qp, { touches: 0, targetTouches: 0, changedTouches: 0, altKey: 0, metaKey: 0, ctrlKey: 0, shiftKey: 0, getModifierState: QS }), s3 = us(r3), o3 = Dn({}, Ch, { propertyName: 0, elapsedTime: 0, pseudoElement: 0 }), a3 = us(o3), l3 = Dn({}, uv, { deltaX: function (i) { return "deltaX" in i ? i.deltaX : "wheelDeltaX" in i ? -i.wheelDeltaX : 0 }, deltaY: function (i) { return "deltaY" in i ? i.deltaY : "wheelDeltaY" in i ? -i.wheelDeltaY : "wheelDelta" in i ? -i.wheelDelta : 0 }, deltaZ: 0, deltaMode: 0 }), c3 = us(l3), u3 = [9, 13, 27, 32], ZS = Ta && "CompositionEvent" in window, kd = null; Ta && "documentMode" in document && (kd = document.documentMode); var f3 = Ta && "TextEvent" in window && !kd, FB = Ta && (!ZS || kd && 8 < kd && 11 >= kd), $T = String.fromCharCode(32), eb = !1; function kB(i, e) { switch (i) { case "keyup": return u3.indexOf(e.keyCode) !== -1; case "keydown": return e.keyCode !== 229; case "keypress": case "mousedown": case "focusout": return !0; default: return !1 } } function NB(i) { return i = i.detail, typeof i == "object" && "data" in i ? i.data : null } var pf = !1; function h3(i, e) { switch (i) { case "compositionend": return NB(e); case "keypress": return e.which !== 32 ? null : (eb = !0, $T); case "textInput": return i = e.data, i === $T && eb ? null : i; default: return null } } function d3(i, e) { if (pf) return i === "compositionend" || !ZS && kB(i, e) ? (i = OB(), F0 = KS = ll = null, pf = !1, i) : null; switch (i) { case "paste": return null; case "keypress": if (!(e.ctrlKey || e.altKey || e.metaKey) || e.ctrlKey && e.altKey) { if (e.char && 1 < e.char.length) return e.char; if (e.which) return String.fromCharCode(e.which) } return null; case "compositionend": return FB && e.locale !== "ko" ? null : e.data; default: return null } } var p3 = { color: !0, date: !0, datetime: !0, "datetime-local": !0, email: !0, month: !0, number: !0, password: !0, range: !0, search: !0, tel: !0, text: !0, time: !0, url: !0, week: !0 }; function tb(i) { var e = i && i.nodeName && i.nodeName.toLowerCase(); return e === "input" ? !!p3[i.type] : e === "textarea" } function UB(i, e, t, n) { gB(n), e = _y(e, "onChange"), 0 < e.length && (t = new qS("onChange", "change", null, t, n), i.push({ event: t, listeners: e })) } var Nd = null, mp = null; function m3(i) { qB(i, 0) } function fv(i) { var e = yf(i); if (cB(e)) return i } function g3(i, e) { if (i === "change") return e } var zB = !1; if (Ta) { var Sx; if (Ta) { var Ex = "oninput" in document; if (!Ex) { var nb = document.createElement("div"); nb.setAttribute("oninput", "return;"), Ex = typeof nb.oninput == "function" } Sx = Ex } else Sx = !1; zB = Sx && (!document.documentMode || 9 < document.documentMode) } function ib() { Nd && (Nd.detachEvent("onpropertychange", HB), mp = Nd = null) } function HB(i) { if (i.propertyName === "value" && fv(mp)) { var e = []; UB(e, mp, i, WS(i)), xB(m3, e) } } function y3(i, e, t) { i === "focusin" ? (ib(), Nd = e, mp = t, Nd.attachEvent("onpropertychange", HB)) : i === "focusout" && ib() } function v3(i) { if (i === "selectionchange" || i === "keyup" || i === "keydown") return fv(mp) } function _3(i, e) { if (i === "click") return fv(e) } function x3(i, e) { if (i === "input" || i === "change") return fv(e) } function A3(i, e) { return i === e && (i !== 0 || 1 / i === 1 / e) || i !== i && e !== e } var uo = typeof Object.is == "function" ? Object.is : A3; function gp(i, e) { if (uo(i, e)) return !0; if (typeof i != "object" || i === null || typeof e != "object" || e === null) return !1; var t = Object.keys(i), n = Object.keys(e); if (t.length !== n.length) return !1; for (n = 0; n < t.length; n++) { var r = t[n]; if (!vM.call(e, r) || !uo(i[r], e[r])) return !1 } return !0 } function rb(i) { for (; i && i.firstChild;)i = i.firstChild; return i } function sb(i, e) { var t = rb(i); i = 0; for (var n; t;) { if (t.nodeType === 3) { if (n = i + t.textContent.length, i <= e && n >= e) return { node: t, offset: e - i }; i = n } e: { for (; t;) { if (t.nextSibling) { t = t.nextSibling; break e } t = t.parentNode } t = void 0 } t = rb(t) } } function GB(i, e) { return i && e ? i === e ? !0 : i && i.nodeType === 3 ? !1 : e && e.nodeType === 3 ? GB(i, e.parentNode) : "contains" in i ? i.contains(e) : i.compareDocumentPosition ? !!(i.compareDocumentPosition(e) & 16) : !1 : !1 } function VB() { for (var i = window, e = hy(); e instanceof i.HTMLIFrameElement;) { try { var t = typeof e.contentWindow.location.href == "string" } catch { t = !1 } if (t) i = e.contentWindow; else break; e = hy(i.document) } return e } function $S(i) { var e = i && i.nodeName && i.nodeName.toLowerCase(); return e && (e === "input" && (i.type === "text" || i.type === "search" || i.type === "tel" || i.type === "url" || i.type === "password") || e === "textarea" || i.contentEditable === "true") } function M3(i) { var e = VB(), t = i.focusedElem, n = i.selectionRange; if (e !== t && t && t.ownerDocument && GB(t.ownerDocument.documentElement, t)) { if (n !== null && $S(t)) { if (e = n.start, i = n.end, i === void 0 && (i = e), "selectionStart" in t) t.selectionStart = e, t.selectionEnd = Math.min(i, t.value.length); else if (i = (e = t.ownerDocument || document) && e.defaultView || window, i.getSelection) { i = i.getSelection(); var r = t.textContent.length, s = Math.min(n.start, r); n = n.end === void 0 ? s : Math.min(n.end, r), !i.extend && s > n && (r = n, n = s, s = r), r = sb(t, s); var o = sb(t, n); r && o && (i.rangeCount !== 1 || i.anchorNode !== r.node || i.anchorOffset !== r.offset || i.focusNode !== o.node || i.focusOffset !== o.offset) && (e = e.createRange(), e.setStart(r.node, r.offset), i.removeAllRanges(), s > n ? (i.addRange(e), i.extend(o.node, o.offset)) : (e.setEnd(o.node, o.offset), i.addRange(e))) } } for (e = [], i = t; i = i.parentNode;)i.nodeType === 1 && e.push({ element: i, left: i.scrollLeft, top: i.scrollTop }); for (typeof t.focus == "function" && t.focus(), t = 0; t < e.length; t++)i = e[t], i.element.scrollLeft = i.left, i.element.scrollTop = i.top } } var w3 = Ta && "documentMode" in document && 11 >= document.documentMode, mf = null, kM = null, Ud = null, NM = !1; function ob(i, e, t) { var n = t.window === t ? t.document : t.nodeType === 9 ? t : t.ownerDocument; NM || mf == null || mf !== hy(n) || (n = mf, "selectionStart" in n && $S(n) ? n = { start: n.selectionStart, end: n.selectionEnd } : (n = (n.ownerDocument && n.ownerDocument.defaultView || window).getSelection(), n = { anchorNode: n.anchorNode, anchorOffset: n.anchorOffset, focusNode: n.focusNode, focusOffset: n.focusOffset }), Ud && gp(Ud, n) || (Ud = n, n = _y(kM, "onSelect"), 0 < n.length && (e = new qS("onSelect", "select", null, e, t), i.push({ event: e, listeners: n }), e.target = mf))) } function vg(i, e) { var t = {}; return t[i.toLowerCase()] = e.toLowerCase(), t["Webkit" + i] = "webkit" + e, t["Moz" + i] = "moz" + e, t } var gf = { animationend: vg("Animation", "AnimationEnd"), animationiteration: vg("Animation", "AnimationIteration"), animationstart: vg("Animation", "AnimationStart"), transitionend: vg("Transition", "TransitionEnd") }, Cx = {}, WB = {}; Ta && (WB = document.createElement("div").style, "AnimationEvent" in window || (delete gf.animationend.animation, delete gf.animationiteration.animation, delete gf.animationstart.animation), "TransitionEvent" in window || delete gf.transitionend.transition); function hv(i) { if (Cx[i]) return Cx[i]; if (!gf[i]) return i; var e = gf[i], t; for (t in e) if (e.hasOwnProperty(t) && t in WB) return Cx[i] = e[t]; return i } var XB = hv("animationend"), JB = hv("animationiteration"), YB = hv("animationstart"), jB = hv("transitionend"), KB = new Map, ab = "abort auxClick cancel canPlay canPlayThrough click close contextMenu copy cut drag dragEnd dragEnter dragExit dragLeave dragOver dragStart drop durationChange emptied encrypted ended error gotPointerCapture input invalid keyDown keyPress keyUp load loadedData loadedMetadata loadStart lostPointerCapture mouseDown mouseMove mouseOut mouseOver mouseUp paste pause play playing pointerCancel pointerDown pointerMove pointerOut pointerOver pointerUp progress rateChange reset resize seeked seeking stalled submit suspend timeUpdate touchCancel touchEnd touchStart volumeChange scroll toggle touchMove waiting wheel".split(" "); function Gl(i, e) { KB.set(i, e), fu(e, [i]) } for (var Tx = 0; Tx < ab.length; Tx++) { var bx = ab[Tx], S3 = bx.toLowerCase(), E3 = bx[0].toUpperCase() + bx.slice(1); Gl(S3, "on" + E3) } Gl(XB, "onAnimationEnd"); Gl(JB, "onAnimationIteration"); Gl(YB, "onAnimationStart"); Gl("dblclick", "onDoubleClick"); Gl("focusin", "onFocus"); Gl("focusout", "onBlur"); Gl(jB, "onTransitionEnd"); Zf("onMouseEnter", ["mouseout", "mouseover"]); Zf("onMouseLeave", ["mouseout", "mouseover"]); Zf("onPointerEnter", ["pointerout", "pointerover"]); Zf("onPointerLeave", ["pointerout", "pointerover"]); fu("onChange", "change click focusin focusout input keydown keyup selectionchange".split(" ")); fu("onSelect", "focusout contextmenu dragend focusin keydown keyup mousedown mouseup selectionchange".split(" ")); fu("onBeforeInput", ["compositionend", "keypress", "textInput", "paste"]); fu("onCompositionEnd", "compositionend focusout keydown keypress keyup mousedown".split(" ")); fu("onCompositionStart", "compositionstart focusout keydown keypress keyup mousedown".split(" ")); fu("onCompositionUpdate", "compositionupdate focusout keydown keypress keyup mousedown".split(" ")); var Td = "abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange resize seeked seeking stalled suspend timeupdate volumechange waiting".split(" "), C3 = new Set("cancel close invalid load scroll toggle".split(" ").concat(Td)); function lb(i, e, t) { var n = i.type || "unknown-event"; i.currentTarget = t, SU(n, e, void 0, i), i.currentTarget = null } function qB(i, e) { e = (e & 4) !== 0; for (var t = 0; t < i.length; t++) { var n = i[t], r = n.event; n = n.listeners; e: { var s = void 0; if (e) for (var o = n.length - 1; 0 <= o; o--) { var a = n[o], l = a.instance, c = a.currentTarget; if (a = a.listener, l !== s && r.isPropagationStopped()) break e; lb(r, a, c), s = l } else for (o = 0; o < n.length; o++) { if (a = n[o], l = a.instance, c = a.currentTarget, a = a.listener, l !== s && r.isPropagationStopped()) break e; lb(r, a, c), s = l } } } if (py) throw i = LM, py = !1, LM = null, i } function mn(i, e) { var t = e[VM]; t === void 0 && (t = e[VM] = new Set); var n = i + "__bubble"; t.has(n) || (QB(e, i, 2, !1), t.add(n)) } function Rx(i, e, t) { var n = 0; e && (n |= 4), QB(t, i, n, e) } var _g = "_reactListening" + Math.random().toString(36).slice(2); function yp(i) { if (!i[_g]) { i[_g] = !0, rB.forEach(function (t) { t !== "selectionchange" && (C3.has(t) || Rx(t, !1, i), Rx(t, !0, i)) }); var e = i.nodeType === 9 ? i : i.ownerDocument; e === null || e[_g] || (e[_g] = !0, Rx("selectionchange", !1, e)) } } function QB(i, e, t, n) { switch (DB(e)) { case 1: var r = zU; break; case 4: r = HU; break; default: r = jS }t = r.bind(null, e, t, i), r = void 0, !BM || e !== "touchstart" && e !== "touchmove" && e !== "wheel" || (r = !0), n ? r !== void 0 ? i.addEventListener(e, t, { capture: !0, passive: r }) : i.addEventListener(e, t, !0) : r !== void 0 ? i.addEventListener(e, t, { passive: r }) : i.addEventListener(e, t, !1) } function Px(i, e, t, n, r) { var s = n; if (!(e & 1) && !(e & 2) && n !== null) e: for (; ;) { if (n === null) return; var o = n.tag; if (o === 3 || o === 4) { var a = n.stateNode.containerInfo; if (a === r || a.nodeType === 8 && a.parentNode === r) break; if (o === 4) for (o = n.return; o !== null;) { var l = o.tag; if ((l === 3 || l === 4) && (l = o.stateNode.containerInfo, l === r || l.nodeType === 8 && l.parentNode === r)) return; o = o.return } for (; a !== null;) { if (o = Cc(a), o === null) return; if (l = o.tag, l === 5 || l === 6) { n = s = o; continue e } a = a.parentNode } } n = n.return } xB(function () { var c = s, f = WS(t), d = []; e: { var p = KB.get(i); if (p !== void 0) { var m = qS, y = i; switch (i) { case "keypress": if (k0(t) === 0) break e; case "keydown": case "keyup": m = n3; break; case "focusin": y = "focus", m = wx; break; case "focusout": y = "blur", m = wx; break; case "beforeblur": case "afterblur": m = wx; break; case "click": if (t.button === 2) break e; case "auxclick": case "dblclick": case "mousedown": case "mousemove": case "mouseup": case "mouseout": case "mouseover": case "contextmenu": m = qT; break; case "drag": case "dragend": case "dragenter": case "dragexit": case "dragleave": case "dragover": case "dragstart": case "drop": m = WU; break; case "touchcancel": case "touchend": case "touchmove": case "touchstart": m = s3; break; case XB: case JB: case YB: m = YU; break; case jB: m = a3; break; case "scroll": m = GU; break; case "wheel": m = c3; break; case "copy": case "cut": case "paste": m = KU; break; case "gotpointercapture": case "lostpointercapture": case "pointercancel": case "pointerdown": case "pointermove": case "pointerout": case "pointerover": case "pointerup": m = ZT }var _ = (e & 4) !== 0, x = !_ && i === "scroll", g = _ ? p !== null ? p + "Capture" : null : p; _ = []; for (var A = c, M; A !== null;) { M = A; var S = M.stateNode; if (M.tag === 5 && S !== null && (M = S, g !== null && (S = fp(A, g), S != null && _.push(vp(A, S, M)))), x) break; A = A.return } 0 < _.length && (p = new m(p, y, null, t, f), d.push({ event: p, listeners: _ })) } } if (!(e & 7)) { e: { if (p = i === "mouseover" || i === "pointerover", m = i === "mouseout" || i === "pointerout", p && t !== PM && (y = t.relatedTarget || t.fromElement) && (Cc(y) || y[ba])) break e; if ((m || p) && (p = f.window === f ? f : (p = f.ownerDocument) ? p.defaultView || p.parentWindow : window, m ? (y = t.relatedTarget || t.toElement, m = c, y = y ? Cc(y) : null, y !== null && (x = hu(y), y !== x || y.tag !== 5 && y.tag !== 6) && (y = null)) : (m = null, y = c), m !== y)) { if (_ = qT, S = "onMouseLeave", g = "onMouseEnter", A = "mouse", (i === "pointerout" || i === "pointerover") && (_ = ZT, S = "onPointerLeave", g = "onPointerEnter", A = "pointer"), x = m == null ? p : yf(m), M = y == null ? p : yf(y), p = new _(S, A + "leave", m, t, f), p.target = x, p.relatedTarget = M, S = null, Cc(f) === c && (_ = new _(g, A + "enter", y, t, f), _.target = M, _.relatedTarget = x, S = _), x = S, m && y) t: { for (_ = m, g = y, A = 0, M = _; M; M = Bu(M))A++; for (M = 0, S = g; S; S = Bu(S))M++; for (; 0 < A - M;)_ = Bu(_), A--; for (; 0 < M - A;)g = Bu(g), M--; for (; A--;) { if (_ === g || g !== null && _ === g.alternate) break t; _ = Bu(_), g = Bu(g) } _ = null } else _ = null; m !== null && cb(d, p, m, _, !1), y !== null && x !== null && cb(d, x, y, _, !0) } } e: { if (p = c ? yf(c) : window, m = p.nodeName && p.nodeName.toLowerCase(), m === "select" || m === "input" && p.type === "file") var C = g3; else if (tb(p)) if (zB) C = x3; else { C = v3; var T = y3 } else (m = p.nodeName) && m.toLowerCase() === "input" && (p.type === "checkbox" || p.type === "radio") && (C = _3); if (C && (C = C(i, c))) { UB(d, C, t, f); break e } T && T(i, p, c), i === "focusout" && (T = p._wrapperState) && T.controlled && p.type === "number" && EM(p, "number", p.value) } switch (T = c ? yf(c) : window, i) { case "focusin": (tb(T) || T.contentEditable === "true") && (mf = T, kM = c, Ud = null); break; case "focusout": Ud = kM = mf = null; break; case "mousedown": NM = !0; break; case "contextmenu": case "mouseup": case "dragend": NM = !1, ob(d, t, f); break; case "selectionchange": if (w3) break; case "keydown": case "keyup": ob(d, t, f) }var R; if (ZS) e: { switch (i) { case "compositionstart": var B = "onCompositionStart"; break e; case "compositionend": B = "onCompositionEnd"; break e; case "compositionupdate": B = "onCompositionUpdate"; break e }B = void 0 } else pf ? kB(i, t) && (B = "onCompositionEnd") : i === "keydown" && t.keyCode === 229 && (B = "onCompositionStart"); B && (FB && t.locale !== "ko" && (pf || B !== "onCompositionStart" ? B === "onCompositionEnd" && pf && (R = OB()) : (ll = f, KS = "value" in ll ? ll.value : ll.textContent, pf = !0)), T = _y(c, B), 0 < T.length && (B = new QT(B, i, null, t, f), d.push({ event: B, listeners: T }), R ? B.data = R : (R = NB(t), R !== null && (B.data = R)))), (R = f3 ? h3(i, t) : d3(i, t)) && (c = _y(c, "onBeforeInput"), 0 < c.length && (f = new QT("onBeforeInput", "beforeinput", null, t, f), d.push({ event: f, listeners: c }), f.data = R)) } qB(d, e) }) } function vp(i, e, t) { return { instance: i, listener: e, currentTarget: t } } function _y(i, e) { for (var t = e + "Capture", n = []; i !== null;) { var r = i, s = r.stateNode; r.tag === 5 && s !== null && (r = s, s = fp(i, t), s != null && n.unshift(vp(i, s, r)), s = fp(i, e), s != null && n.push(vp(i, s, r))), i = i.return } return n } function Bu(i) { if (i === null) return null; do i = i.return; while (i && i.tag !== 5); return i || null } function cb(i, e, t, n, r) { for (var s = e._reactName, o = []; t !== null && t !== n;) { var a = t, l = a.alternate, c = a.stateNode; if (l !== null && l === n) break; a.tag === 5 && c !== null && (a = c, r ? (l = fp(t, s), l != null && o.unshift(vp(t, l, a))) : r || (l = fp(t, s), l != null && o.push(vp(t, l, a)))), t = t.return } o.length !== 0 && i.push({ event: e, listeners: o }) } var T3 = /\r\n?/g, b3 = /\u0000|\uFFFD/g; function ub(i) {
	return (typeof i == "string" ? i : "" + i).replace(T3, `
`).replace(b3, "")
} function xg(i, e, t) { if (e = ub(e), ub(i) !== e && t) throw Error(Pe(425)) } function xy() { } var UM = null, zM = null; function HM(i, e) { return i === "textarea" || i === "noscript" || typeof e.children == "string" || typeof e.children == "number" || typeof e.dangerouslySetInnerHTML == "object" && e.dangerouslySetInnerHTML !== null && e.dangerouslySetInnerHTML.__html != null } var GM = typeof setTimeout == "function" ? setTimeout : void 0, R3 = typeof clearTimeout == "function" ? clearTimeout : void 0, fb = typeof Promise == "function" ? Promise : void 0, P3 = typeof queueMicrotask == "function" ? queueMicrotask : typeof fb < "u" ? function (i) { return fb.resolve(null).then(i).catch(I3) } : GM; function I3(i) { setTimeout(function () { throw i }) } function Ix(i, e) { var t = e, n = 0; do { var r = t.nextSibling; if (i.removeChild(t), r && r.nodeType === 8) if (t = r.data, t === "/$") { if (n === 0) { i.removeChild(r), pp(e); return } n-- } else t !== "$" && t !== "$?" && t !== "$!" || n++; t = r } while (t); pp(e) } function _l(i) { for (; i != null; i = i.nextSibling) { var e = i.nodeType; if (e === 1 || e === 3) break; if (e === 8) { if (e = i.data, e === "$" || e === "$!" || e === "$?") break; if (e === "/$") return null } } return i } function hb(i) { i = i.previousSibling; for (var e = 0; i;) { if (i.nodeType === 8) { var t = i.data; if (t === "$" || t === "$!" || t === "$?") { if (e === 0) return i; e-- } else t === "/$" && e++ } i = i.previousSibling } return null } var Th = Math.random().toString(36).slice(2), Io = "__reactFiber$" + Th, _p = "__reactProps$" + Th, ba = "__reactContainer$" + Th, VM = "__reactEvents$" + Th, B3 = "__reactListeners$" + Th, L3 = "__reactHandles$" + Th; function Cc(i) { var e = i[Io]; if (e) return e; for (var t = i.parentNode; t;) { if (e = t[ba] || t[Io]) { if (t = e.alternate, e.child !== null || t !== null && t.child !== null) for (i = hb(i); i !== null;) { if (t = i[Io]) return t; i = hb(i) } return e } i = t, t = i.parentNode } return null } function Zp(i) { return i = i[Io] || i[ba], !i || i.tag !== 5 && i.tag !== 6 && i.tag !== 13 && i.tag !== 3 ? null : i } function yf(i) { if (i.tag === 5 || i.tag === 6) return i.stateNode; throw Error(Pe(33)) } function dv(i) { return i[_p] || null } var WM = [], vf = -1; function Vl(i) { return { current: i } } function vn(i) { 0 > vf || (i.current = WM[vf], WM[vf] = null, vf--) } function pn(i, e) { vf++, WM[vf] = i.current, i.current = e } var Ll = {}, nr = Vl(Ll), Lr = Vl(!1), qc = Ll; function $f(i, e) { var t = i.type.contextTypes; if (!t) return Ll; var n = i.stateNode; if (n && n.__reactInternalMemoizedUnmaskedChildContext === e) return n.__reactInternalMemoizedMaskedChildContext; var r = {}, s; for (s in t) r[s] = e[s]; return n && (i = i.stateNode, i.__reactInternalMemoizedUnmaskedChildContext = e, i.__reactInternalMemoizedMaskedChildContext = r), r } function Dr(i) { return i = i.childContextTypes, i != null } function Ay() { vn(Lr), vn(nr) } function db(i, e, t) { if (nr.current !== Ll) throw Error(Pe(168)); pn(nr, e), pn(Lr, t) } function ZB(i, e, t) { var n = i.stateNode; if (e = e.childContextTypes, typeof n.getChildContext != "function") return t; n = n.getChildContext(); for (var r in n) if (!(r in e)) throw Error(Pe(108, yU(i) || "Unknown", r)); return Dn({}, t, n) } function My(i) { return i = (i = i.stateNode) && i.__reactInternalMemoizedMergedChildContext || Ll, qc = nr.current, pn(nr, i), pn(Lr, Lr.current), !0 } function pb(i, e, t) { var n = i.stateNode; if (!n) throw Error(Pe(169)); t ? (i = ZB(i, e, qc), n.__reactInternalMemoizedMergedChildContext = i, vn(Lr), vn(nr), pn(nr, i)) : vn(Lr), pn(Lr, t) } var ha = null, pv = !1, Bx = !1; function $B(i) { ha === null ? ha = [i] : ha.push(i) } function D3(i) { pv = !0, $B(i) } function Wl() { if (!Bx && ha !== null) { Bx = !0; var i = 0, e = an; try { var t = ha; for (an = 1; i < t.length; i++) { var n = t[i]; do n = n(!0); while (n !== null) } ha = null, pv = !1 } catch (r) { throw ha !== null && (ha = ha.slice(i + 1)), SB(XS, Wl), r } finally { an = e, Bx = !1 } } return null } var _f = [], xf = 0, wy = null, Sy = 0, Cs = [], Ts = 0, Qc = null, ga = 1, ya = ""; function gc(i, e) { _f[xf++] = Sy, _f[xf++] = wy, wy = i, Sy = e } function eL(i, e, t) { Cs[Ts++] = ga, Cs[Ts++] = ya, Cs[Ts++] = Qc, Qc = i; var n = ga; i = ya; var r = 32 - so(n) - 1; n &= ~(1 << r), t += 1; var s = 32 - so(e) + r; if (30 < s) { var o = r - r % 5; s = (n & (1 << o) - 1).toString(32), n >>= o, r -= o, ga = 1 << 32 - so(e) + r | t << r | n, ya = s + i } else ga = 1 << s | t << r | n, ya = i } function e1(i) { i.return !== null && (gc(i, 1), eL(i, 1, 0)) } function t1(i) { for (; i === wy;)wy = _f[--xf], _f[xf] = null, Sy = _f[--xf], _f[xf] = null; for (; i === Qc;)Qc = Cs[--Ts], Cs[Ts] = null, ya = Cs[--Ts], Cs[Ts] = null, ga = Cs[--Ts], Cs[Ts] = null } var ns = null, es = null, Mn = !1, to = null; function tL(i, e) { var t = Ps(5, null, null, 0); t.elementType = "DELETED", t.stateNode = e, t.return = i, e = i.deletions, e === null ? (i.deletions = [t], i.flags |= 16) : e.push(t) } function mb(i, e) { switch (i.tag) { case 5: var t = i.type; return e = e.nodeType !== 1 || t.toLowerCase() !== e.nodeName.toLowerCase() ? null : e, e !== null ? (i.stateNode = e, ns = i, es = _l(e.firstChild), !0) : !1; case 6: return e = i.pendingProps === "" || e.nodeType !== 3 ? null : e, e !== null ? (i.stateNode = e, ns = i, es = null, !0) : !1; case 13: return e = e.nodeType !== 8 ? null : e, e !== null ? (t = Qc !== null ? { id: ga, overflow: ya } : null, i.memoizedState = { dehydrated: e, treeContext: t, retryLane: 1073741824 }, t = Ps(18, null, null, 0), t.stateNode = e, t.return = i, i.child = t, ns = i, es = null, !0) : !1; default: return !1 } } function XM(i) { return (i.mode & 1) !== 0 && (i.flags & 128) === 0 } function JM(i) { if (Mn) { var e = es; if (e) { var t = e; if (!mb(i, e)) { if (XM(i)) throw Error(Pe(418)); e = _l(t.nextSibling); var n = ns; e && mb(i, e) ? tL(n, t) : (i.flags = i.flags & -4097 | 2, Mn = !1, ns = i) } } else { if (XM(i)) throw Error(Pe(418)); i.flags = i.flags & -4097 | 2, Mn = !1, ns = i } } } function gb(i) { for (i = i.return; i !== null && i.tag !== 5 && i.tag !== 3 && i.tag !== 13;)i = i.return; ns = i } function Ag(i) { if (i !== ns) return !1; if (!Mn) return gb(i), Mn = !0, !1; var e; if ((e = i.tag !== 3) && !(e = i.tag !== 5) && (e = i.type, e = e !== "head" && e !== "body" && !HM(i.type, i.memoizedProps)), e && (e = es)) { if (XM(i)) throw nL(), Error(Pe(418)); for (; e;)tL(i, e), e = _l(e.nextSibling) } if (gb(i), i.tag === 13) { if (i = i.memoizedState, i = i !== null ? i.dehydrated : null, !i) throw Error(Pe(317)); e: { for (i = i.nextSibling, e = 0; i;) { if (i.nodeType === 8) { var t = i.data; if (t === "/$") { if (e === 0) { es = _l(i.nextSibling); break e } e-- } else t !== "$" && t !== "$!" && t !== "$?" || e++ } i = i.nextSibling } es = null } } else es = ns ? _l(i.stateNode.nextSibling) : null; return !0 } function nL() { for (var i = es; i;)i = _l(i.nextSibling) } function eh() { es = ns = null, Mn = !1 } function n1(i) { to === null ? to = [i] : to.push(i) } var O3 = Fa.ReactCurrentBatchConfig; function Zs(i, e) { if (i && i.defaultProps) { e = Dn({}, e), i = i.defaultProps; for (var t in i) e[t] === void 0 && (e[t] = i[t]); return e } return e } var Ey = Vl(null), Cy = null, Af = null, i1 = null; function r1() { i1 = Af = Cy = null } function s1(i) { var e = Ey.current; vn(Ey), i._currentValue = e } function YM(i, e, t) { for (; i !== null;) { var n = i.alternate; if ((i.childLanes & e) !== e ? (i.childLanes |= e, n !== null && (n.childLanes |= e)) : n !== null && (n.childLanes & e) !== e && (n.childLanes |= e), i === t) break; i = i.return } } function Nf(i, e) { Cy = i, i1 = Af = null, i = i.dependencies, i !== null && i.firstContext !== null && (i.lanes & e && (Br = !0), i.firstContext = null) } function ks(i) { var e = i._currentValue; if (i1 !== i) if (i = { context: i, memoizedValue: e, next: null }, Af === null) { if (Cy === null) throw Error(Pe(308)); Af = i, Cy.dependencies = { lanes: 0, firstContext: i } } else Af = Af.next = i; return e } var Tc = null; function o1(i) { Tc === null ? Tc = [i] : Tc.push(i) } function iL(i, e, t, n) { var r = e.interleaved; return r === null ? (t.next = t, o1(e)) : (t.next = r.next, r.next = t), e.interleaved = t, Ra(i, n) } function Ra(i, e) { i.lanes |= e; var t = i.alternate; for (t !== null && (t.lanes |= e), t = i, i = i.return; i !== null;)i.childLanes |= e, t = i.alternate, t !== null && (t.childLanes |= e), t = i, i = i.return; return t.tag === 3 ? t.stateNode : null } var nl = !1; function a1(i) { i.updateQueue = { baseState: i.memoizedState, firstBaseUpdate: null, lastBaseUpdate: null, shared: { pending: null, interleaved: null, lanes: 0 }, effects: null } } function rL(i, e) { i = i.updateQueue, e.updateQueue === i && (e.updateQueue = { baseState: i.baseState, firstBaseUpdate: i.firstBaseUpdate, lastBaseUpdate: i.lastBaseUpdate, shared: i.shared, effects: i.effects }) } function wa(i, e) { return { eventTime: i, lane: e, tag: 0, payload: null, callback: null, next: null } } function xl(i, e, t) { var n = i.updateQueue; if (n === null) return null; if (n = n.shared, Zt & 2) { var r = n.pending; return r === null ? e.next = e : (e.next = r.next, r.next = e), n.pending = e, Ra(i, t) } return r = n.interleaved, r === null ? (e.next = e, o1(n)) : (e.next = r.next, r.next = e), n.interleaved = e, Ra(i, t) } function N0(i, e, t) { if (e = e.updateQueue, e !== null && (e = e.shared, (t & 4194240) !== 0)) { var n = e.lanes; n &= i.pendingLanes, t |= n, e.lanes = t, JS(i, t) } } function yb(i, e) { var t = i.updateQueue, n = i.alternate; if (n !== null && (n = n.updateQueue, t === n)) { var r = null, s = null; if (t = t.firstBaseUpdate, t !== null) { do { var o = { eventTime: t.eventTime, lane: t.lane, tag: t.tag, payload: t.payload, callback: t.callback, next: null }; s === null ? r = s = o : s = s.next = o, t = t.next } while (t !== null); s === null ? r = s = e : s = s.next = e } else r = s = e; t = { baseState: n.baseState, firstBaseUpdate: r, lastBaseUpdate: s, shared: n.shared, effects: n.effects }, i.updateQueue = t; return } i = t.lastBaseUpdate, i === null ? t.firstBaseUpdate = e : i.next = e, t.lastBaseUpdate = e } function Ty(i, e, t, n) { var r = i.updateQueue; nl = !1; var s = r.firstBaseUpdate, o = r.lastBaseUpdate, a = r.shared.pending; if (a !== null) { r.shared.pending = null; var l = a, c = l.next; l.next = null, o === null ? s = c : o.next = c, o = l; var f = i.alternate; f !== null && (f = f.updateQueue, a = f.lastBaseUpdate, a !== o && (a === null ? f.firstBaseUpdate = c : a.next = c, f.lastBaseUpdate = l)) } if (s !== null) { var d = r.baseState; o = 0, f = c = l = null, a = s; do { var p = a.lane, m = a.eventTime; if ((n & p) === p) { f !== null && (f = f.next = { eventTime: m, lane: 0, tag: a.tag, payload: a.payload, callback: a.callback, next: null }); e: { var y = i, _ = a; switch (p = e, m = t, _.tag) { case 1: if (y = _.payload, typeof y == "function") { d = y.call(m, d, p); break e } d = y; break e; case 3: y.flags = y.flags & -65537 | 128; case 0: if (y = _.payload, p = typeof y == "function" ? y.call(m, d, p) : y, p == null) break e; d = Dn({}, d, p); break e; case 2: nl = !0 } } a.callback !== null && a.lane !== 0 && (i.flags |= 64, p = r.effects, p === null ? r.effects = [a] : p.push(a)) } else m = { eventTime: m, lane: p, tag: a.tag, payload: a.payload, callback: a.callback, next: null }, f === null ? (c = f = m, l = d) : f = f.next = m, o |= p; if (a = a.next, a === null) { if (a = r.shared.pending, a === null) break; p = a, a = p.next, p.next = null, r.lastBaseUpdate = p, r.shared.pending = null } } while (1); if (f === null && (l = d), r.baseState = l, r.firstBaseUpdate = c, r.lastBaseUpdate = f, e = r.shared.interleaved, e !== null) { r = e; do o |= r.lane, r = r.next; while (r !== e) } else s === null && (r.shared.lanes = 0); $c |= o, i.lanes = o, i.memoizedState = d } } function vb(i, e, t) { if (i = e.effects, e.effects = null, i !== null) for (e = 0; e < i.length; e++) { var n = i[e], r = n.callback; if (r !== null) { if (n.callback = null, n = t, typeof r != "function") throw Error(Pe(191, r)); r.call(n) } } } var sL = new iB.Component().refs; function jM(i, e, t, n) { e = i.memoizedState, t = t(n, e), t = t == null ? e : Dn({}, e, t), i.memoizedState = t, i.lanes === 0 && (i.updateQueue.baseState = t) } var mv = { isMounted: function (i) { return (i = i._reactInternals) ? hu(i) === i : !1 }, enqueueSetState: function (i, e, t) { i = i._reactInternals; var n = yr(), r = Ml(i), s = wa(n, r); s.payload = e, t != null && (s.callback = t), e = xl(i, s, r), e !== null && (oo(e, i, r, n), N0(e, i, r)) }, enqueueReplaceState: function (i, e, t) { i = i._reactInternals; var n = yr(), r = Ml(i), s = wa(n, r); s.tag = 1, s.payload = e, t != null && (s.callback = t), e = xl(i, s, r), e !== null && (oo(e, i, r, n), N0(e, i, r)) }, enqueueForceUpdate: function (i, e) { i = i._reactInternals; var t = yr(), n = Ml(i), r = wa(t, n); r.tag = 2, e != null && (r.callback = e), e = xl(i, r, n), e !== null && (oo(e, i, n, t), N0(e, i, n)) } }; function _b(i, e, t, n, r, s, o) { return i = i.stateNode, typeof i.shouldComponentUpdate == "function" ? i.shouldComponentUpdate(n, s, o) : e.prototype && e.prototype.isPureReactComponent ? !gp(t, n) || !gp(r, s) : !0 } function oL(i, e, t) { var n = !1, r = Ll, s = e.contextType; return typeof s == "object" && s !== null ? s = ks(s) : (r = Dr(e) ? qc : nr.current, n = e.contextTypes, s = (n = n != null) ? $f(i, r) : Ll), e = new e(t, s), i.memoizedState = e.state !== null && e.state !== void 0 ? e.state : null, e.updater = mv, i.stateNode = e, e._reactInternals = i, n && (i = i.stateNode, i.__reactInternalMemoizedUnmaskedChildContext = r, i.__reactInternalMemoizedMaskedChildContext = s), e } function xb(i, e, t, n) { i = e.state, typeof e.componentWillReceiveProps == "function" && e.componentWillReceiveProps(t, n), typeof e.UNSAFE_componentWillReceiveProps == "function" && e.UNSAFE_componentWillReceiveProps(t, n), e.state !== i && mv.enqueueReplaceState(e, e.state, null) } function KM(i, e, t, n) { var r = i.stateNode; r.props = t, r.state = i.memoizedState, r.refs = sL, a1(i); var s = e.contextType; typeof s == "object" && s !== null ? r.context = ks(s) : (s = Dr(e) ? qc : nr.current, r.context = $f(i, s)), r.state = i.memoizedState, s = e.getDerivedStateFromProps, typeof s == "function" && (jM(i, e, s, t), r.state = i.memoizedState), typeof e.getDerivedStateFromProps == "function" || typeof r.getSnapshotBeforeUpdate == "function" || typeof r.UNSAFE_componentWillMount != "function" && typeof r.componentWillMount != "function" || (e = r.state, typeof r.componentWillMount == "function" && r.componentWillMount(), typeof r.UNSAFE_componentWillMount == "function" && r.UNSAFE_componentWillMount(), e !== r.state && mv.enqueueReplaceState(r, r.state, null), Ty(i, t, r, n), r.state = i.memoizedState), typeof r.componentDidMount == "function" && (i.flags |= 4194308) } function sd(i, e, t) { if (i = t.ref, i !== null && typeof i != "function" && typeof i != "object") { if (t._owner) { if (t = t._owner, t) { if (t.tag !== 1) throw Error(Pe(309)); var n = t.stateNode } if (!n) throw Error(Pe(147, i)); var r = n, s = "" + i; return e !== null && e.ref !== null && typeof e.ref == "function" && e.ref._stringRef === s ? e.ref : (e = function (o) { var a = r.refs; a === sL && (a = r.refs = {}), o === null ? delete a[s] : a[s] = o }, e._stringRef = s, e) } if (typeof i != "string") throw Error(Pe(284)); if (!t._owner) throw Error(Pe(290, i)) } return i } function Mg(i, e) { throw i = Object.prototype.toString.call(e), Error(Pe(31, i === "[object Object]" ? "object with keys {" + Object.keys(e).join(", ") + "}" : i)) } function Ab(i) { var e = i._init; return e(i._payload) } function aL(i) { function e(g, A) { if (i) { var M = g.deletions; M === null ? (g.deletions = [A], g.flags |= 16) : M.push(A) } } function t(g, A) { if (!i) return null; for (; A !== null;)e(g, A), A = A.sibling; return null } function n(g, A) { for (g = new Map; A !== null;)A.key !== null ? g.set(A.key, A) : g.set(A.index, A), A = A.sibling; return g } function r(g, A) { return g = wl(g, A), g.index = 0, g.sibling = null, g } function s(g, A, M) { return g.index = M, i ? (M = g.alternate, M !== null ? (M = M.index, M < A ? (g.flags |= 2, A) : M) : (g.flags |= 2, A)) : (g.flags |= 1048576, A) } function o(g) { return i && g.alternate === null && (g.flags |= 2), g } function a(g, A, M, S) { return A === null || A.tag !== 6 ? (A = Ux(M, g.mode, S), A.return = g, A) : (A = r(A, M), A.return = g, A) } function l(g, A, M, S) { var C = M.type; return C === df ? f(g, A, M.props.children, S, M.key) : A !== null && (A.elementType === C || typeof C == "object" && C !== null && C.$$typeof === tl && Ab(C) === A.type) ? (S = r(A, M.props), S.ref = sd(g, A, M), S.return = g, S) : (S = W0(M.type, M.key, M.props, null, g.mode, S), S.ref = sd(g, A, M), S.return = g, S) } function c(g, A, M, S) { return A === null || A.tag !== 4 || A.stateNode.containerInfo !== M.containerInfo || A.stateNode.implementation !== M.implementation ? (A = zx(M, g.mode, S), A.return = g, A) : (A = r(A, M.children || []), A.return = g, A) } function f(g, A, M, S, C) { return A === null || A.tag !== 7 ? (A = Nc(M, g.mode, S, C), A.return = g, A) : (A = r(A, M), A.return = g, A) } function d(g, A, M) { if (typeof A == "string" && A !== "" || typeof A == "number") return A = Ux("" + A, g.mode, M), A.return = g, A; if (typeof A == "object" && A !== null) { switch (A.$$typeof) { case fg: return M = W0(A.type, A.key, A.props, null, g.mode, M), M.ref = sd(g, null, A), M.return = g, M; case hf: return A = zx(A, g.mode, M), A.return = g, A; case tl: var S = A._init; return d(g, S(A._payload), M) }if (Ed(A) || ed(A)) return A = Nc(A, g.mode, M, null), A.return = g, A; Mg(g, A) } return null } function p(g, A, M, S) { var C = A !== null ? A.key : null; if (typeof M == "string" && M !== "" || typeof M == "number") return C !== null ? null : a(g, A, "" + M, S); if (typeof M == "object" && M !== null) { switch (M.$$typeof) { case fg: return M.key === C ? l(g, A, M, S) : null; case hf: return M.key === C ? c(g, A, M, S) : null; case tl: return C = M._init, p(g, A, C(M._payload), S) }if (Ed(M) || ed(M)) return C !== null ? null : f(g, A, M, S, null); Mg(g, M) } return null } function m(g, A, M, S, C) { if (typeof S == "string" && S !== "" || typeof S == "number") return g = g.get(M) || null, a(A, g, "" + S, C); if (typeof S == "object" && S !== null) { switch (S.$$typeof) { case fg: return g = g.get(S.key === null ? M : S.key) || null, l(A, g, S, C); case hf: return g = g.get(S.key === null ? M : S.key) || null, c(A, g, S, C); case tl: var T = S._init; return m(g, A, M, T(S._payload), C) }if (Ed(S) || ed(S)) return g = g.get(M) || null, f(A, g, S, C, null); Mg(A, S) } return null } function y(g, A, M, S) { for (var C = null, T = null, R = A, B = A = 0, b = null; R !== null && B < M.length; B++) { R.index > B ? (b = R, R = null) : b = R.sibling; var I = p(g, R, M[B], S); if (I === null) { R === null && (R = b); break } i && R && I.alternate === null && e(g, R), A = s(I, A, B), T === null ? C = I : T.sibling = I, T = I, R = b } if (B === M.length) return t(g, R), Mn && gc(g, B), C; if (R === null) { for (; B < M.length; B++)R = d(g, M[B], S), R !== null && (A = s(R, A, B), T === null ? C = R : T.sibling = R, T = R); return Mn && gc(g, B), C } for (R = n(g, R); B < M.length; B++)b = m(R, g, B, M[B], S), b !== null && (i && b.alternate !== null && R.delete(b.key === null ? B : b.key), A = s(b, A, B), T === null ? C = b : T.sibling = b, T = b); return i && R.forEach(function (N) { return e(g, N) }), Mn && gc(g, B), C } function _(g, A, M, S) { var C = ed(M); if (typeof C != "function") throw Error(Pe(150)); if (M = C.call(M), M == null) throw Error(Pe(151)); for (var T = C = null, R = A, B = A = 0, b = null, I = M.next(); R !== null && !I.done; B++, I = M.next()) { R.index > B ? (b = R, R = null) : b = R.sibling; var N = p(g, R, I.value, S); if (N === null) { R === null && (R = b); break } i && R && N.alternate === null && e(g, R), A = s(N, A, B), T === null ? C = N : T.sibling = N, T = N, R = b } if (I.done) return t(g, R), Mn && gc(g, B), C; if (R === null) { for (; !I.done; B++, I = M.next())I = d(g, I.value, S), I !== null && (A = s(I, A, B), T === null ? C = I : T.sibling = I, T = I); return Mn && gc(g, B), C } for (R = n(g, R); !I.done; B++, I = M.next())I = m(R, g, B, I.value, S), I !== null && (i && I.alternate !== null && R.delete(I.key === null ? B : I.key), A = s(I, A, B), T === null ? C = I : T.sibling = I, T = I); return i && R.forEach(function (V) { return e(g, V) }), Mn && gc(g, B), C } function x(g, A, M, S) { if (typeof M == "object" && M !== null && M.type === df && M.key === null && (M = M.props.children), typeof M == "object" && M !== null) { switch (M.$$typeof) { case fg: e: { for (var C = M.key, T = A; T !== null;) { if (T.key === C) { if (C = M.type, C === df) { if (T.tag === 7) { t(g, T.sibling), A = r(T, M.props.children), A.return = g, g = A; break e } } else if (T.elementType === C || typeof C == "object" && C !== null && C.$$typeof === tl && Ab(C) === T.type) { t(g, T.sibling), A = r(T, M.props), A.ref = sd(g, T, M), A.return = g, g = A; break e } t(g, T); break } else e(g, T); T = T.sibling } M.type === df ? (A = Nc(M.props.children, g.mode, S, M.key), A.return = g, g = A) : (S = W0(M.type, M.key, M.props, null, g.mode, S), S.ref = sd(g, A, M), S.return = g, g = S) } return o(g); case hf: e: { for (T = M.key; A !== null;) { if (A.key === T) if (A.tag === 4 && A.stateNode.containerInfo === M.containerInfo && A.stateNode.implementation === M.implementation) { t(g, A.sibling), A = r(A, M.children || []), A.return = g, g = A; break e } else { t(g, A); break } else e(g, A); A = A.sibling } A = zx(M, g.mode, S), A.return = g, g = A } return o(g); case tl: return T = M._init, x(g, A, T(M._payload), S) }if (Ed(M)) return y(g, A, M, S); if (ed(M)) return _(g, A, M, S); Mg(g, M) } return typeof M == "string" && M !== "" || typeof M == "number" ? (M = "" + M, A !== null && A.tag === 6 ? (t(g, A.sibling), A = r(A, M), A.return = g, g = A) : (t(g, A), A = Ux(M, g.mode, S), A.return = g, g = A), o(g)) : t(g, A) } return x } var th = aL(!0), lL = aL(!1), $p = {}, ko = Vl($p), xp = Vl($p), Ap = Vl($p); function bc(i) { if (i === $p) throw Error(Pe(174)); return i } function l1(i, e) { switch (pn(Ap, e), pn(xp, i), pn(ko, $p), i = e.nodeType, i) { case 9: case 11: e = (e = e.documentElement) ? e.namespaceURI : TM(null, ""); break; default: i = i === 8 ? e.parentNode : e, e = i.namespaceURI || null, i = i.tagName, e = TM(e, i) }vn(ko), pn(ko, e) } function nh() { vn(ko), vn(xp), vn(Ap) } function cL(i) { bc(Ap.current); var e = bc(ko.current), t = TM(e, i.type); e !== t && (pn(xp, i), pn(ko, t)) } function c1(i) { xp.current === i && (vn(ko), vn(xp)) } var bn = Vl(0); function by(i) { for (var e = i; e !== null;) { if (e.tag === 13) { var t = e.memoizedState; if (t !== null && (t = t.dehydrated, t === null || t.data === "$?" || t.data === "$!")) return e } else if (e.tag === 19 && e.memoizedProps.revealOrder !== void 0) { if (e.flags & 128) return e } else if (e.child !== null) { e.child.return = e, e = e.child; continue } if (e === i) break; for (; e.sibling === null;) { if (e.return === null || e.return === i) return null; e = e.return } e.sibling.return = e.return, e = e.sibling } return null } var Lx = []; function u1() { for (var i = 0; i < Lx.length; i++)Lx[i]._workInProgressVersionPrimary = null; Lx.length = 0 } var U0 = Fa.ReactCurrentDispatcher, Dx = Fa.ReactCurrentBatchConfig, Zc = 0, Ln = null, fi = null, wi = null, Ry = !1, zd = !1, Mp = 0, F3 = 0; function Wi() { throw Error(Pe(321)) } function f1(i, e) { if (e === null) return !1; for (var t = 0; t < e.length && t < i.length; t++)if (!uo(i[t], e[t])) return !1; return !0 } function h1(i, e, t, n, r, s) { if (Zc = s, Ln = e, e.memoizedState = null, e.updateQueue = null, e.lanes = 0, U0.current = i === null || i.memoizedState === null ? z3 : H3, i = t(n, r), zd) { s = 0; do { if (zd = !1, Mp = 0, 25 <= s) throw Error(Pe(301)); s += 1, wi = fi = null, e.updateQueue = null, U0.current = G3, i = t(n, r) } while (zd) } if (U0.current = Py, e = fi !== null && fi.next !== null, Zc = 0, wi = fi = Ln = null, Ry = !1, e) throw Error(Pe(300)); return i } function d1() { var i = Mp !== 0; return Mp = 0, i } function Ro() { var i = { memoizedState: null, baseState: null, baseQueue: null, queue: null, next: null }; return wi === null ? Ln.memoizedState = wi = i : wi = wi.next = i, wi } function Ns() { if (fi === null) { var i = Ln.alternate; i = i !== null ? i.memoizedState : null } else i = fi.next; var e = wi === null ? Ln.memoizedState : wi.next; if (e !== null) wi = e, fi = i; else { if (i === null) throw Error(Pe(310)); fi = i, i = { memoizedState: fi.memoizedState, baseState: fi.baseState, baseQueue: fi.baseQueue, queue: fi.queue, next: null }, wi === null ? Ln.memoizedState = wi = i : wi = wi.next = i } return wi } function wp(i, e) { return typeof e == "function" ? e(i) : e } function Ox(i) { var e = Ns(), t = e.queue; if (t === null) throw Error(Pe(311)); t.lastRenderedReducer = i; var n = fi, r = n.baseQueue, s = t.pending; if (s !== null) { if (r !== null) { var o = r.next; r.next = s.next, s.next = o } n.baseQueue = r = s, t.pending = null } if (r !== null) { s = r.next, n = n.baseState; var a = o = null, l = null, c = s; do { var f = c.lane; if ((Zc & f) === f) l !== null && (l = l.next = { lane: 0, action: c.action, hasEagerState: c.hasEagerState, eagerState: c.eagerState, next: null }), n = c.hasEagerState ? c.eagerState : i(n, c.action); else { var d = { lane: f, action: c.action, hasEagerState: c.hasEagerState, eagerState: c.eagerState, next: null }; l === null ? (a = l = d, o = n) : l = l.next = d, Ln.lanes |= f, $c |= f } c = c.next } while (c !== null && c !== s); l === null ? o = n : l.next = a, uo(n, e.memoizedState) || (Br = !0), e.memoizedState = n, e.baseState = o, e.baseQueue = l, t.lastRenderedState = n } if (i = t.interleaved, i !== null) { r = i; do s = r.lane, Ln.lanes |= s, $c |= s, r = r.next; while (r !== i) } else r === null && (t.lanes = 0); return [e.memoizedState, t.dispatch] } function Fx(i) { var e = Ns(), t = e.queue; if (t === null) throw Error(Pe(311)); t.lastRenderedReducer = i; var n = t.dispatch, r = t.pending, s = e.memoizedState; if (r !== null) { t.pending = null; var o = r = r.next; do s = i(s, o.action), o = o.next; while (o !== r); uo(s, e.memoizedState) || (Br = !0), e.memoizedState = s, e.baseQueue === null && (e.baseState = s), t.lastRenderedState = s } return [s, n] } function uL() { } function fL(i, e) { var t = Ln, n = Ns(), r = e(), s = !uo(n.memoizedState, r); if (s && (n.memoizedState = r, Br = !0), n = n.queue, p1(pL.bind(null, t, n, i), [i]), n.getSnapshot !== e || s || wi !== null && wi.memoizedState.tag & 1) { if (t.flags |= 2048, Sp(9, dL.bind(null, t, n, r, e), void 0, null), Ci === null) throw Error(Pe(349)); Zc & 30 || hL(t, e, r) } return r } function hL(i, e, t) { i.flags |= 16384, i = { getSnapshot: e, value: t }, e = Ln.updateQueue, e === null ? (e = { lastEffect: null, stores: null }, Ln.updateQueue = e, e.stores = [i]) : (t = e.stores, t === null ? e.stores = [i] : t.push(i)) } function dL(i, e, t, n) { e.value = t, e.getSnapshot = n, mL(e) && gL(i) } function pL(i, e, t) { return t(function () { mL(e) && gL(i) }) } function mL(i) { var e = i.getSnapshot; i = i.value; try { var t = e(); return !uo(i, t) } catch { return !0 } } function gL(i) { var e = Ra(i, 1); e !== null && oo(e, i, 1, -1) } function Mb(i) { var e = Ro(); return typeof i == "function" && (i = i()), e.memoizedState = e.baseState = i, i = { pending: null, interleaved: null, lanes: 0, dispatch: null, lastRenderedReducer: wp, lastRenderedState: i }, e.queue = i, i = i.dispatch = U3.bind(null, Ln, i), [e.memoizedState, i] } function Sp(i, e, t, n) { return i = { tag: i, create: e, destroy: t, deps: n, next: null }, e = Ln.updateQueue, e === null ? (e = { lastEffect: null, stores: null }, Ln.updateQueue = e, e.lastEffect = i.next = i) : (t = e.lastEffect, t === null ? e.lastEffect = i.next = i : (n = t.next, t.next = i, i.next = n, e.lastEffect = i)), i } function yL() { return Ns().memoizedState } function z0(i, e, t, n) { var r = Ro(); Ln.flags |= i, r.memoizedState = Sp(1 | e, t, void 0, n === void 0 ? null : n) } function gv(i, e, t, n) { var r = Ns(); n = n === void 0 ? null : n; var s = void 0; if (fi !== null) { var o = fi.memoizedState; if (s = o.destroy, n !== null && f1(n, o.deps)) { r.memoizedState = Sp(e, t, s, n); return } } Ln.flags |= i, r.memoizedState = Sp(1 | e, t, s, n) } function wb(i, e) { return z0(8390656, 8, i, e) } function p1(i, e) { return gv(2048, 8, i, e) } function vL(i, e) { return gv(4, 2, i, e) } function _L(i, e) { return gv(4, 4, i, e) } function xL(i, e) { if (typeof e == "function") return i = i(), e(i), function () { e(null) }; if (e != null) return i = i(), e.current = i, function () { e.current = null } } function AL(i, e, t) { return t = t != null ? t.concat([i]) : null, gv(4, 4, xL.bind(null, e, i), t) } function m1() { } function ML(i, e) { var t = Ns(); e = e === void 0 ? null : e; var n = t.memoizedState; return n !== null && e !== null && f1(e, n[1]) ? n[0] : (t.memoizedState = [i, e], i) } function wL(i, e) { var t = Ns(); e = e === void 0 ? null : e; var n = t.memoizedState; return n !== null && e !== null && f1(e, n[1]) ? n[0] : (i = i(), t.memoizedState = [i, e], i) } function SL(i, e, t) { return Zc & 21 ? (uo(t, e) || (t = TB(), Ln.lanes |= t, $c |= t, i.baseState = !0), e) : (i.baseState && (i.baseState = !1, Br = !0), i.memoizedState = t) } function k3(i, e) { var t = an; an = t !== 0 && 4 > t ? t : 4, i(!0); var n = Dx.transition; Dx.transition = {}; try { i(!1), e() } finally { an = t, Dx.transition = n } } function EL() { return Ns().memoizedState } function N3(i, e, t) { var n = Ml(i); if (t = { lane: n, action: t, hasEagerState: !1, eagerState: null, next: null }, CL(i)) TL(e, t); else if (t = iL(i, e, t, n), t !== null) { var r = yr(); oo(t, i, n, r), bL(t, e, n) } } function U3(i, e, t) { var n = Ml(i), r = { lane: n, action: t, hasEagerState: !1, eagerState: null, next: null }; if (CL(i)) TL(e, r); else { var s = i.alternate; if (i.lanes === 0 && (s === null || s.lanes === 0) && (s = e.lastRenderedReducer, s !== null)) try { var o = e.lastRenderedState, a = s(o, t); if (r.hasEagerState = !0, r.eagerState = a, uo(a, o)) { var l = e.interleaved; l === null ? (r.next = r, o1(e)) : (r.next = l.next, l.next = r), e.interleaved = r; return } } catch { } finally { } t = iL(i, e, r, n), t !== null && (r = yr(), oo(t, i, n, r), bL(t, e, n)) } } function CL(i) { var e = i.alternate; return i === Ln || e !== null && e === Ln } function TL(i, e) { zd = Ry = !0; var t = i.pending; t === null ? e.next = e : (e.next = t.next, t.next = e), i.pending = e } function bL(i, e, t) { if (t & 4194240) { var n = e.lanes; n &= i.pendingLanes, t |= n, e.lanes = t, JS(i, t) } } var Py = { readContext: ks, useCallback: Wi, useContext: Wi, useEffect: Wi, useImperativeHandle: Wi, useInsertionEffect: Wi, useLayoutEffect: Wi, useMemo: Wi, useReducer: Wi, useRef: Wi, useState: Wi, useDebugValue: Wi, useDeferredValue: Wi, useTransition: Wi, useMutableSource: Wi, useSyncExternalStore: Wi, useId: Wi, unstable_isNewReconciler: !1 }, z3 = { readContext: ks, useCallback: function (i, e) { return Ro().memoizedState = [i, e === void 0 ? null : e], i }, useContext: ks, useEffect: wb, useImperativeHandle: function (i, e, t) { return t = t != null ? t.concat([i]) : null, z0(4194308, 4, xL.bind(null, e, i), t) }, useLayoutEffect: function (i, e) { return z0(4194308, 4, i, e) }, useInsertionEffect: function (i, e) { return z0(4, 2, i, e) }, useMemo: function (i, e) { var t = Ro(); return e = e === void 0 ? null : e, i = i(), t.memoizedState = [i, e], i }, useReducer: function (i, e, t) { var n = Ro(); return e = t !== void 0 ? t(e) : e, n.memoizedState = n.baseState = e, i = { pending: null, interleaved: null, lanes: 0, dispatch: null, lastRenderedReducer: i, lastRenderedState: e }, n.queue = i, i = i.dispatch = N3.bind(null, Ln, i), [n.memoizedState, i] }, useRef: function (i) { var e = Ro(); return i = { current: i }, e.memoizedState = i }, useState: Mb, useDebugValue: m1, useDeferredValue: function (i) { return Ro().memoizedState = i }, useTransition: function () { var i = Mb(!1), e = i[0]; return i = k3.bind(null, i[1]), Ro().memoizedState = i, [e, i] }, useMutableSource: function () { }, useSyncExternalStore: function (i, e, t) { var n = Ln, r = Ro(); if (Mn) { if (t === void 0) throw Error(Pe(407)); t = t() } else { if (t = e(), Ci === null) throw Error(Pe(349)); Zc & 30 || hL(n, e, t) } r.memoizedState = t; var s = { value: t, getSnapshot: e }; return r.queue = s, wb(pL.bind(null, n, s, i), [i]), n.flags |= 2048, Sp(9, dL.bind(null, n, s, t, e), void 0, null), t }, useId: function () { var i = Ro(), e = Ci.identifierPrefix; if (Mn) { var t = ya, n = ga; t = (n & ~(1 << 32 - so(n) - 1)).toString(32) + t, e = ":" + e + "R" + t, t = Mp++, 0 < t && (e += "H" + t.toString(32)), e += ":" } else t = F3++, e = ":" + e + "r" + t.toString(32) + ":"; return i.memoizedState = e }, unstable_isNewReconciler: !1 }, H3 = { readContext: ks, useCallback: ML, useContext: ks, useEffect: p1, useImperativeHandle: AL, useInsertionEffect: vL, useLayoutEffect: _L, useMemo: wL, useReducer: Ox, useRef: yL, useState: function () { return Ox(wp) }, useDebugValue: m1, useDeferredValue: function (i) { var e = Ns(); return SL(e, fi.memoizedState, i) }, useTransition: function () { var i = Ox(wp)[0], e = Ns().memoizedState; return [i, e] }, useMutableSource: uL, useSyncExternalStore: fL, useId: EL, unstable_isNewReconciler: !1 }, G3 = { readContext: ks, useCallback: ML, useContext: ks, useEffect: p1, useImperativeHandle: AL, useInsertionEffect: vL, useLayoutEffect: _L, useMemo: wL, useReducer: Fx, useRef: yL, useState: function () { return Fx(wp) }, useDebugValue: m1, useDeferredValue: function (i) { var e = Ns(); return fi === null ? e.memoizedState = i : SL(e, fi.memoizedState, i) }, useTransition: function () { var i = Fx(wp)[0], e = Ns().memoizedState; return [i, e] }, useMutableSource: uL, useSyncExternalStore: fL, useId: EL, unstable_isNewReconciler: !1 }; function ih(i, e) {
	try { var t = "", n = e; do t += gU(n), n = n.return; while (n); var r = t } catch (s) {
		r = `
Error generating stack: `+ s.message + `
`+ s.stack
	} return { value: i, source: e, stack: r, digest: null }
} function kx(i, e, t) { return { value: i, source: null, stack: t ?? null, digest: e ?? null } } function qM(i, e) { try { console.error(e.value) } catch (t) { setTimeout(function () { throw t }) } } var V3 = typeof WeakMap == "function" ? WeakMap : Map; function RL(i, e, t) { t = wa(-1, t), t.tag = 3, t.payload = { element: null }; var n = e.value; return t.callback = function () { By || (By = !0, ow = n), qM(i, e) }, t } function PL(i, e, t) { t = wa(-1, t), t.tag = 3; var n = i.type.getDerivedStateFromError; if (typeof n == "function") { var r = e.value; t.payload = function () { return n(r) }, t.callback = function () { qM(i, e) } } var s = i.stateNode; return s !== null && typeof s.componentDidCatch == "function" && (t.callback = function () { qM(i, e), typeof n != "function" && (Al === null ? Al = new Set([this]) : Al.add(this)); var o = e.stack; this.componentDidCatch(e.value, { componentStack: o !== null ? o : "" }) }), t } function Sb(i, e, t) { var n = i.pingCache; if (n === null) { n = i.pingCache = new V3; var r = new Set; n.set(e, r) } else r = n.get(e), r === void 0 && (r = new Set, n.set(e, r)); r.has(t) || (r.add(t), i = iz.bind(null, i, e, t), e.then(i, i)) } function Eb(i) { do { var e; if ((e = i.tag === 13) && (e = i.memoizedState, e = e !== null ? e.dehydrated !== null : !0), e) return i; i = i.return } while (i !== null); return null } function Cb(i, e, t, n, r) { return i.mode & 1 ? (i.flags |= 65536, i.lanes = r, i) : (i === e ? i.flags |= 65536 : (i.flags |= 128, t.flags |= 131072, t.flags &= -52805, t.tag === 1 && (t.alternate === null ? t.tag = 17 : (e = wa(-1, 1), e.tag = 2, xl(t, e, 1))), t.lanes |= 1), i) } var W3 = Fa.ReactCurrentOwner, Br = !1; function fr(i, e, t, n) { e.child = i === null ? lL(e, null, t, n) : th(e, i.child, t, n) } function Tb(i, e, t, n, r) { t = t.render; var s = e.ref; return Nf(e, r), n = h1(i, e, t, n, s, r), t = d1(), i !== null && !Br ? (e.updateQueue = i.updateQueue, e.flags &= -2053, i.lanes &= ~r, Pa(i, e, r)) : (Mn && t && e1(e), e.flags |= 1, fr(i, e, n, r), e.child) } function bb(i, e, t, n, r) { if (i === null) { var s = t.type; return typeof s == "function" && !w1(s) && s.defaultProps === void 0 && t.compare === null && t.defaultProps === void 0 ? (e.tag = 15, e.type = s, IL(i, e, s, n, r)) : (i = W0(t.type, null, n, e, e.mode, r), i.ref = e.ref, i.return = e, e.child = i) } if (s = i.child, !(i.lanes & r)) { var o = s.memoizedProps; if (t = t.compare, t = t !== null ? t : gp, t(o, n) && i.ref === e.ref) return Pa(i, e, r) } return e.flags |= 1, i = wl(s, n), i.ref = e.ref, i.return = e, e.child = i } function IL(i, e, t, n, r) { if (i !== null) { var s = i.memoizedProps; if (gp(s, n) && i.ref === e.ref) if (Br = !1, e.pendingProps = n = s, (i.lanes & r) !== 0) i.flags & 131072 && (Br = !0); else return e.lanes = i.lanes, Pa(i, e, r) } return QM(i, e, t, n, r) } function BL(i, e, t) { var n = e.pendingProps, r = n.children, s = i !== null ? i.memoizedState : null; if (n.mode === "hidden") if (!(e.mode & 1)) e.memoizedState = { baseLanes: 0, cachePool: null, transitions: null }, pn(wf, Kr), Kr |= t; else { if (!(t & 1073741824)) return i = s !== null ? s.baseLanes | t : t, e.lanes = e.childLanes = 1073741824, e.memoizedState = { baseLanes: i, cachePool: null, transitions: null }, e.updateQueue = null, pn(wf, Kr), Kr |= i, null; e.memoizedState = { baseLanes: 0, cachePool: null, transitions: null }, n = s !== null ? s.baseLanes : t, pn(wf, Kr), Kr |= n } else s !== null ? (n = s.baseLanes | t, e.memoizedState = null) : n = t, pn(wf, Kr), Kr |= n; return fr(i, e, r, t), e.child } function LL(i, e) { var t = e.ref; (i === null && t !== null || i !== null && i.ref !== t) && (e.flags |= 512, e.flags |= 2097152) } function QM(i, e, t, n, r) { var s = Dr(t) ? qc : nr.current; return s = $f(e, s), Nf(e, r), t = h1(i, e, t, n, s, r), n = d1(), i !== null && !Br ? (e.updateQueue = i.updateQueue, e.flags &= -2053, i.lanes &= ~r, Pa(i, e, r)) : (Mn && n && e1(e), e.flags |= 1, fr(i, e, t, r), e.child) } function Rb(i, e, t, n, r) { if (Dr(t)) { var s = !0; My(e) } else s = !1; if (Nf(e, r), e.stateNode === null) H0(i, e), oL(e, t, n), KM(e, t, n, r), n = !0; else if (i === null) { var o = e.stateNode, a = e.memoizedProps; o.props = a; var l = o.context, c = t.contextType; typeof c == "object" && c !== null ? c = ks(c) : (c = Dr(t) ? qc : nr.current, c = $f(e, c)); var f = t.getDerivedStateFromProps, d = typeof f == "function" || typeof o.getSnapshotBeforeUpdate == "function"; d || typeof o.UNSAFE_componentWillReceiveProps != "function" && typeof o.componentWillReceiveProps != "function" || (a !== n || l !== c) && xb(e, o, n, c), nl = !1; var p = e.memoizedState; o.state = p, Ty(e, n, o, r), l = e.memoizedState, a !== n || p !== l || Lr.current || nl ? (typeof f == "function" && (jM(e, t, f, n), l = e.memoizedState), (a = nl || _b(e, t, a, n, p, l, c)) ? (d || typeof o.UNSAFE_componentWillMount != "function" && typeof o.componentWillMount != "function" || (typeof o.componentWillMount == "function" && o.componentWillMount(), typeof o.UNSAFE_componentWillMount == "function" && o.UNSAFE_componentWillMount()), typeof o.componentDidMount == "function" && (e.flags |= 4194308)) : (typeof o.componentDidMount == "function" && (e.flags |= 4194308), e.memoizedProps = n, e.memoizedState = l), o.props = n, o.state = l, o.context = c, n = a) : (typeof o.componentDidMount == "function" && (e.flags |= 4194308), n = !1) } else { o = e.stateNode, rL(i, e), a = e.memoizedProps, c = e.type === e.elementType ? a : Zs(e.type, a), o.props = c, d = e.pendingProps, p = o.context, l = t.contextType, typeof l == "object" && l !== null ? l = ks(l) : (l = Dr(t) ? qc : nr.current, l = $f(e, l)); var m = t.getDerivedStateFromProps; (f = typeof m == "function" || typeof o.getSnapshotBeforeUpdate == "function") || typeof o.UNSAFE_componentWillReceiveProps != "function" && typeof o.componentWillReceiveProps != "function" || (a !== d || p !== l) && xb(e, o, n, l), nl = !1, p = e.memoizedState, o.state = p, Ty(e, n, o, r); var y = e.memoizedState; a !== d || p !== y || Lr.current || nl ? (typeof m == "function" && (jM(e, t, m, n), y = e.memoizedState), (c = nl || _b(e, t, c, n, p, y, l) || !1) ? (f || typeof o.UNSAFE_componentWillUpdate != "function" && typeof o.componentWillUpdate != "function" || (typeof o.componentWillUpdate == "function" && o.componentWillUpdate(n, y, l), typeof o.UNSAFE_componentWillUpdate == "function" && o.UNSAFE_componentWillUpdate(n, y, l)), typeof o.componentDidUpdate == "function" && (e.flags |= 4), typeof o.getSnapshotBeforeUpdate == "function" && (e.flags |= 1024)) : (typeof o.componentDidUpdate != "function" || a === i.memoizedProps && p === i.memoizedState || (e.flags |= 4), typeof o.getSnapshotBeforeUpdate != "function" || a === i.memoizedProps && p === i.memoizedState || (e.flags |= 1024), e.memoizedProps = n, e.memoizedState = y), o.props = n, o.state = y, o.context = l, n = c) : (typeof o.componentDidUpdate != "function" || a === i.memoizedProps && p === i.memoizedState || (e.flags |= 4), typeof o.getSnapshotBeforeUpdate != "function" || a === i.memoizedProps && p === i.memoizedState || (e.flags |= 1024), n = !1) } return ZM(i, e, t, n, s, r) } function ZM(i, e, t, n, r, s) { LL(i, e); var o = (e.flags & 128) !== 0; if (!n && !o) return r && pb(e, t, !1), Pa(i, e, s); n = e.stateNode, W3.current = e; var a = o && typeof t.getDerivedStateFromError != "function" ? null : n.render(); return e.flags |= 1, i !== null && o ? (e.child = th(e, i.child, null, s), e.child = th(e, null, a, s)) : fr(i, e, a, s), e.memoizedState = n.state, r && pb(e, t, !0), e.child } function DL(i) { var e = i.stateNode; e.pendingContext ? db(i, e.pendingContext, e.pendingContext !== e.context) : e.context && db(i, e.context, !1), l1(i, e.containerInfo) } function Pb(i, e, t, n, r) { return eh(), n1(r), e.flags |= 256, fr(i, e, t, n), e.child } var $M = { dehydrated: null, treeContext: null, retryLane: 0 }; function ew(i) { return { baseLanes: i, cachePool: null, transitions: null } } function OL(i, e, t) { var n = e.pendingProps, r = bn.current, s = !1, o = (e.flags & 128) !== 0, a; if ((a = o) || (a = i !== null && i.memoizedState === null ? !1 : (r & 2) !== 0), a ? (s = !0, e.flags &= -129) : (i === null || i.memoizedState !== null) && (r |= 1), pn(bn, r & 1), i === null) return JM(e), i = e.memoizedState, i !== null && (i = i.dehydrated, i !== null) ? (e.mode & 1 ? i.data === "$!" ? e.lanes = 8 : e.lanes = 1073741824 : e.lanes = 1, null) : (o = n.children, i = n.fallback, s ? (n = e.mode, s = e.child, o = { mode: "hidden", children: o }, !(n & 1) && s !== null ? (s.childLanes = 0, s.pendingProps = o) : s = _v(o, n, 0, null), i = Nc(i, n, t, null), s.return = e, i.return = e, s.sibling = i, e.child = s, e.child.memoizedState = ew(t), e.memoizedState = $M, i) : g1(e, o)); if (r = i.memoizedState, r !== null && (a = r.dehydrated, a !== null)) return X3(i, e, o, n, a, r, t); if (s) { s = n.fallback, o = e.mode, r = i.child, a = r.sibling; var l = { mode: "hidden", children: n.children }; return !(o & 1) && e.child !== r ? (n = e.child, n.childLanes = 0, n.pendingProps = l, e.deletions = null) : (n = wl(r, l), n.subtreeFlags = r.subtreeFlags & 14680064), a !== null ? s = wl(a, s) : (s = Nc(s, o, t, null), s.flags |= 2), s.return = e, n.return = e, n.sibling = s, e.child = n, n = s, s = e.child, o = i.child.memoizedState, o = o === null ? ew(t) : { baseLanes: o.baseLanes | t, cachePool: null, transitions: o.transitions }, s.memoizedState = o, s.childLanes = i.childLanes & ~t, e.memoizedState = $M, n } return s = i.child, i = s.sibling, n = wl(s, { mode: "visible", children: n.children }), !(e.mode & 1) && (n.lanes = t), n.return = e, n.sibling = null, i !== null && (t = e.deletions, t === null ? (e.deletions = [i], e.flags |= 16) : t.push(i)), e.child = n, e.memoizedState = null, n } function g1(i, e) { return e = _v({ mode: "visible", children: e }, i.mode, 0, null), e.return = i, i.child = e } function wg(i, e, t, n) { return n !== null && n1(n), th(e, i.child, null, t), i = g1(e, e.pendingProps.children), i.flags |= 2, e.memoizedState = null, i } function X3(i, e, t, n, r, s, o) { if (t) return e.flags & 256 ? (e.flags &= -257, n = kx(Error(Pe(422))), wg(i, e, o, n)) : e.memoizedState !== null ? (e.child = i.child, e.flags |= 128, null) : (s = n.fallback, r = e.mode, n = _v({ mode: "visible", children: n.children }, r, 0, null), s = Nc(s, r, o, null), s.flags |= 2, n.return = e, s.return = e, n.sibling = s, e.child = n, e.mode & 1 && th(e, i.child, null, o), e.child.memoizedState = ew(o), e.memoizedState = $M, s); if (!(e.mode & 1)) return wg(i, e, o, null); if (r.data === "$!") { if (n = r.nextSibling && r.nextSibling.dataset, n) var a = n.dgst; return n = a, s = Error(Pe(419)), n = kx(s, n, void 0), wg(i, e, o, n) } if (a = (o & i.childLanes) !== 0, Br || a) { if (n = Ci, n !== null) { switch (o & -o) { case 4: r = 2; break; case 16: r = 8; break; case 64: case 128: case 256: case 512: case 1024: case 2048: case 4096: case 8192: case 16384: case 32768: case 65536: case 131072: case 262144: case 524288: case 1048576: case 2097152: case 4194304: case 8388608: case 16777216: case 33554432: case 67108864: r = 32; break; case 536870912: r = 268435456; break; default: r = 0 }r = r & (n.suspendedLanes | o) ? 0 : r, r !== 0 && r !== s.retryLane && (s.retryLane = r, Ra(i, r), oo(n, i, r, -1)) } return M1(), n = kx(Error(Pe(421))), wg(i, e, o, n) } return r.data === "$?" ? (e.flags |= 128, e.child = i.child, e = rz.bind(null, i), r._reactRetry = e, null) : (i = s.treeContext, es = _l(r.nextSibling), ns = e, Mn = !0, to = null, i !== null && (Cs[Ts++] = ga, Cs[Ts++] = ya, Cs[Ts++] = Qc, ga = i.id, ya = i.overflow, Qc = e), e = g1(e, n.children), e.flags |= 4096, e) } function Ib(i, e, t) { i.lanes |= e; var n = i.alternate; n !== null && (n.lanes |= e), YM(i.return, e, t) } function Nx(i, e, t, n, r) { var s = i.memoizedState; s === null ? i.memoizedState = { isBackwards: e, rendering: null, renderingStartTime: 0, last: n, tail: t, tailMode: r } : (s.isBackwards = e, s.rendering = null, s.renderingStartTime = 0, s.last = n, s.tail = t, s.tailMode = r) } function FL(i, e, t) { var n = e.pendingProps, r = n.revealOrder, s = n.tail; if (fr(i, e, n.children, t), n = bn.current, n & 2) n = n & 1 | 2, e.flags |= 128; else { if (i !== null && i.flags & 128) e: for (i = e.child; i !== null;) { if (i.tag === 13) i.memoizedState !== null && Ib(i, t, e); else if (i.tag === 19) Ib(i, t, e); else if (i.child !== null) { i.child.return = i, i = i.child; continue } if (i === e) break e; for (; i.sibling === null;) { if (i.return === null || i.return === e) break e; i = i.return } i.sibling.return = i.return, i = i.sibling } n &= 1 } if (pn(bn, n), !(e.mode & 1)) e.memoizedState = null; else switch (r) { case "forwards": for (t = e.child, r = null; t !== null;)i = t.alternate, i !== null && by(i) === null && (r = t), t = t.sibling; t = r, t === null ? (r = e.child, e.child = null) : (r = t.sibling, t.sibling = null), Nx(e, !1, r, t, s); break; case "backwards": for (t = null, r = e.child, e.child = null; r !== null;) { if (i = r.alternate, i !== null && by(i) === null) { e.child = r; break } i = r.sibling, r.sibling = t, t = r, r = i } Nx(e, !0, t, null, s); break; case "together": Nx(e, !1, null, null, void 0); break; default: e.memoizedState = null }return e.child } function H0(i, e) { !(e.mode & 1) && i !== null && (i.alternate = null, e.alternate = null, e.flags |= 2) } function Pa(i, e, t) { if (i !== null && (e.dependencies = i.dependencies), $c |= e.lanes, !(t & e.childLanes)) return null; if (i !== null && e.child !== i.child) throw Error(Pe(153)); if (e.child !== null) { for (i = e.child, t = wl(i, i.pendingProps), e.child = t, t.return = e; i.sibling !== null;)i = i.sibling, t = t.sibling = wl(i, i.pendingProps), t.return = e; t.sibling = null } return e.child } function J3(i, e, t) { switch (e.tag) { case 3: DL(e), eh(); break; case 5: cL(e); break; case 1: Dr(e.type) && My(e); break; case 4: l1(e, e.stateNode.containerInfo); break; case 10: var n = e.type._context, r = e.memoizedProps.value; pn(Ey, n._currentValue), n._currentValue = r; break; case 13: if (n = e.memoizedState, n !== null) return n.dehydrated !== null ? (pn(bn, bn.current & 1), e.flags |= 128, null) : t & e.child.childLanes ? OL(i, e, t) : (pn(bn, bn.current & 1), i = Pa(i, e, t), i !== null ? i.sibling : null); pn(bn, bn.current & 1); break; case 19: if (n = (t & e.childLanes) !== 0, i.flags & 128) { if (n) return FL(i, e, t); e.flags |= 128 } if (r = e.memoizedState, r !== null && (r.rendering = null, r.tail = null, r.lastEffect = null), pn(bn, bn.current), n) break; return null; case 22: case 23: return e.lanes = 0, BL(i, e, t) }return Pa(i, e, t) } var kL, tw, NL, UL; kL = function (i, e) { for (var t = e.child; t !== null;) { if (t.tag === 5 || t.tag === 6) i.appendChild(t.stateNode); else if (t.tag !== 4 && t.child !== null) { t.child.return = t, t = t.child; continue } if (t === e) break; for (; t.sibling === null;) { if (t.return === null || t.return === e) return; t = t.return } t.sibling.return = t.return, t = t.sibling } }; tw = function () { }; NL = function (i, e, t, n) { var r = i.memoizedProps; if (r !== n) { i = e.stateNode, bc(ko.current); var s = null; switch (t) { case "input": r = wM(i, r), n = wM(i, n), s = []; break; case "select": r = Dn({}, r, { value: void 0 }), n = Dn({}, n, { value: void 0 }), s = []; break; case "textarea": r = CM(i, r), n = CM(i, n), s = []; break; default: typeof r.onClick != "function" && typeof n.onClick == "function" && (i.onclick = xy) }bM(t, n); var o; t = null; for (c in r) if (!n.hasOwnProperty(c) && r.hasOwnProperty(c) && r[c] != null) if (c === "style") { var a = r[c]; for (o in a) a.hasOwnProperty(o) && (t || (t = {}), t[o] = "") } else c !== "dangerouslySetInnerHTML" && c !== "children" && c !== "suppressContentEditableWarning" && c !== "suppressHydrationWarning" && c !== "autoFocus" && (cp.hasOwnProperty(c) ? s || (s = []) : (s = s || []).push(c, null)); for (c in n) { var l = n[c]; if (a = r != null ? r[c] : void 0, n.hasOwnProperty(c) && l !== a && (l != null || a != null)) if (c === "style") if (a) { for (o in a) !a.hasOwnProperty(o) || l && l.hasOwnProperty(o) || (t || (t = {}), t[o] = ""); for (o in l) l.hasOwnProperty(o) && a[o] !== l[o] && (t || (t = {}), t[o] = l[o]) } else t || (s || (s = []), s.push(c, t)), t = l; else c === "dangerouslySetInnerHTML" ? (l = l ? l.__html : void 0, a = a ? a.__html : void 0, l != null && a !== l && (s = s || []).push(c, l)) : c === "children" ? typeof l != "string" && typeof l != "number" || (s = s || []).push(c, "" + l) : c !== "suppressContentEditableWarning" && c !== "suppressHydrationWarning" && (cp.hasOwnProperty(c) ? (l != null && c === "onScroll" && mn("scroll", i), s || a === l || (s = [])) : (s = s || []).push(c, l)) } t && (s = s || []).push("style", t); var c = s; (e.updateQueue = c) && (e.flags |= 4) } }; UL = function (i, e, t, n) { t !== n && (e.flags |= 4) }; function od(i, e) { if (!Mn) switch (i.tailMode) { case "hidden": e = i.tail; for (var t = null; e !== null;)e.alternate !== null && (t = e), e = e.sibling; t === null ? i.tail = null : t.sibling = null; break; case "collapsed": t = i.tail; for (var n = null; t !== null;)t.alternate !== null && (n = t), t = t.sibling; n === null ? e || i.tail === null ? i.tail = null : i.tail.sibling = null : n.sibling = null } } function Xi(i) { var e = i.alternate !== null && i.alternate.child === i.child, t = 0, n = 0; if (e) for (var r = i.child; r !== null;)t |= r.lanes | r.childLanes, n |= r.subtreeFlags & 14680064, n |= r.flags & 14680064, r.return = i, r = r.sibling; else for (r = i.child; r !== null;)t |= r.lanes | r.childLanes, n |= r.subtreeFlags, n |= r.flags, r.return = i, r = r.sibling; return i.subtreeFlags |= n, i.childLanes = t, e } function Y3(i, e, t) { var n = e.pendingProps; switch (t1(e), e.tag) { case 2: case 16: case 15: case 0: case 11: case 7: case 8: case 12: case 9: case 14: return Xi(e), null; case 1: return Dr(e.type) && Ay(), Xi(e), null; case 3: return n = e.stateNode, nh(), vn(Lr), vn(nr), u1(), n.pendingContext && (n.context = n.pendingContext, n.pendingContext = null), (i === null || i.child === null) && (Ag(e) ? e.flags |= 4 : i === null || i.memoizedState.isDehydrated && !(e.flags & 256) || (e.flags |= 1024, to !== null && (cw(to), to = null))), tw(i, e), Xi(e), null; case 5: c1(e); var r = bc(Ap.current); if (t = e.type, i !== null && e.stateNode != null) NL(i, e, t, n, r), i.ref !== e.ref && (e.flags |= 512, e.flags |= 2097152); else { if (!n) { if (e.stateNode === null) throw Error(Pe(166)); return Xi(e), null } if (i = bc(ko.current), Ag(e)) { n = e.stateNode, t = e.type; var s = e.memoizedProps; switch (n[Io] = e, n[_p] = s, i = (e.mode & 1) !== 0, t) { case "dialog": mn("cancel", n), mn("close", n); break; case "iframe": case "object": case "embed": mn("load", n); break; case "video": case "audio": for (r = 0; r < Td.length; r++)mn(Td[r], n); break; case "source": mn("error", n); break; case "img": case "image": case "link": mn("error", n), mn("load", n); break; case "details": mn("toggle", n); break; case "input": zT(n, s), mn("invalid", n); break; case "select": n._wrapperState = { wasMultiple: !!s.multiple }, mn("invalid", n); break; case "textarea": GT(n, s), mn("invalid", n) }bM(t, s), r = null; for (var o in s) if (s.hasOwnProperty(o)) { var a = s[o]; o === "children" ? typeof a == "string" ? n.textContent !== a && (s.suppressHydrationWarning !== !0 && xg(n.textContent, a, i), r = ["children", a]) : typeof a == "number" && n.textContent !== "" + a && (s.suppressHydrationWarning !== !0 && xg(n.textContent, a, i), r = ["children", "" + a]) : cp.hasOwnProperty(o) && a != null && o === "onScroll" && mn("scroll", n) } switch (t) { case "input": hg(n), HT(n, s, !0); break; case "textarea": hg(n), VT(n); break; case "select": case "option": break; default: typeof s.onClick == "function" && (n.onclick = xy) }n = r, e.updateQueue = n, n !== null && (e.flags |= 4) } else { o = r.nodeType === 9 ? r : r.ownerDocument, i === "http://www.w3.org/1999/xhtml" && (i = hB(t)), i === "http://www.w3.org/1999/xhtml" ? t === "script" ? (i = o.createElement("div"), i.innerHTML = "<script><\/script>", i = i.removeChild(i.firstChild)) : typeof n.is == "string" ? i = o.createElement(t, { is: n.is }) : (i = o.createElement(t), t === "select" && (o = i, n.multiple ? o.multiple = !0 : n.size && (o.size = n.size))) : i = o.createElementNS(i, t), i[Io] = e, i[_p] = n, kL(i, e, !1, !1), e.stateNode = i; e: { switch (o = RM(t, n), t) { case "dialog": mn("cancel", i), mn("close", i), r = n; break; case "iframe": case "object": case "embed": mn("load", i), r = n; break; case "video": case "audio": for (r = 0; r < Td.length; r++)mn(Td[r], i); r = n; break; case "source": mn("error", i), r = n; break; case "img": case "image": case "link": mn("error", i), mn("load", i), r = n; break; case "details": mn("toggle", i), r = n; break; case "input": zT(i, n), r = wM(i, n), mn("invalid", i); break; case "option": r = n; break; case "select": i._wrapperState = { wasMultiple: !!n.multiple }, r = Dn({}, n, { value: void 0 }), mn("invalid", i); break; case "textarea": GT(i, n), r = CM(i, n), mn("invalid", i); break; default: r = n }bM(t, r), a = r; for (s in a) if (a.hasOwnProperty(s)) { var l = a[s]; s === "style" ? mB(i, l) : s === "dangerouslySetInnerHTML" ? (l = l ? l.__html : void 0, l != null && dB(i, l)) : s === "children" ? typeof l == "string" ? (t !== "textarea" || l !== "") && up(i, l) : typeof l == "number" && up(i, "" + l) : s !== "suppressContentEditableWarning" && s !== "suppressHydrationWarning" && s !== "autoFocus" && (cp.hasOwnProperty(s) ? l != null && s === "onScroll" && mn("scroll", i) : l != null && zS(i, s, l, o)) } switch (t) { case "input": hg(i), HT(i, n, !1); break; case "textarea": hg(i), VT(i); break; case "option": n.value != null && i.setAttribute("value", "" + Bl(n.value)); break; case "select": i.multiple = !!n.multiple, s = n.value, s != null ? Df(i, !!n.multiple, s, !1) : n.defaultValue != null && Df(i, !!n.multiple, n.defaultValue, !0); break; default: typeof r.onClick == "function" && (i.onclick = xy) }switch (t) { case "button": case "input": case "select": case "textarea": n = !!n.autoFocus; break e; case "img": n = !0; break e; default: n = !1 } } n && (e.flags |= 4) } e.ref !== null && (e.flags |= 512, e.flags |= 2097152) } return Xi(e), null; case 6: if (i && e.stateNode != null) UL(i, e, i.memoizedProps, n); else { if (typeof n != "string" && e.stateNode === null) throw Error(Pe(166)); if (t = bc(Ap.current), bc(ko.current), Ag(e)) { if (n = e.stateNode, t = e.memoizedProps, n[Io] = e, (s = n.nodeValue !== t) && (i = ns, i !== null)) switch (i.tag) { case 3: xg(n.nodeValue, t, (i.mode & 1) !== 0); break; case 5: i.memoizedProps.suppressHydrationWarning !== !0 && xg(n.nodeValue, t, (i.mode & 1) !== 0) }s && (e.flags |= 4) } else n = (t.nodeType === 9 ? t : t.ownerDocument).createTextNode(n), n[Io] = e, e.stateNode = n } return Xi(e), null; case 13: if (vn(bn), n = e.memoizedState, i === null || i.memoizedState !== null && i.memoizedState.dehydrated !== null) { if (Mn && es !== null && e.mode & 1 && !(e.flags & 128)) nL(), eh(), e.flags |= 98560, s = !1; else if (s = Ag(e), n !== null && n.dehydrated !== null) { if (i === null) { if (!s) throw Error(Pe(318)); if (s = e.memoizedState, s = s !== null ? s.dehydrated : null, !s) throw Error(Pe(317)); s[Io] = e } else eh(), !(e.flags & 128) && (e.memoizedState = null), e.flags |= 4; Xi(e), s = !1 } else to !== null && (cw(to), to = null), s = !0; if (!s) return e.flags & 65536 ? e : null } return e.flags & 128 ? (e.lanes = t, e) : (n = n !== null, n !== (i !== null && i.memoizedState !== null) && n && (e.child.flags |= 8192, e.mode & 1 && (i === null || bn.current & 1 ? di === 0 && (di = 3) : M1())), e.updateQueue !== null && (e.flags |= 4), Xi(e), null); case 4: return nh(), tw(i, e), i === null && yp(e.stateNode.containerInfo), Xi(e), null; case 10: return s1(e.type._context), Xi(e), null; case 17: return Dr(e.type) && Ay(), Xi(e), null; case 19: if (vn(bn), s = e.memoizedState, s === null) return Xi(e), null; if (n = (e.flags & 128) !== 0, o = s.rendering, o === null) if (n) od(s, !1); else { if (di !== 0 || i !== null && i.flags & 128) for (i = e.child; i !== null;) { if (o = by(i), o !== null) { for (e.flags |= 128, od(s, !1), n = o.updateQueue, n !== null && (e.updateQueue = n, e.flags |= 4), e.subtreeFlags = 0, n = t, t = e.child; t !== null;)s = t, i = n, s.flags &= 14680066, o = s.alternate, o === null ? (s.childLanes = 0, s.lanes = i, s.child = null, s.subtreeFlags = 0, s.memoizedProps = null, s.memoizedState = null, s.updateQueue = null, s.dependencies = null, s.stateNode = null) : (s.childLanes = o.childLanes, s.lanes = o.lanes, s.child = o.child, s.subtreeFlags = 0, s.deletions = null, s.memoizedProps = o.memoizedProps, s.memoizedState = o.memoizedState, s.updateQueue = o.updateQueue, s.type = o.type, i = o.dependencies, s.dependencies = i === null ? null : { lanes: i.lanes, firstContext: i.firstContext }), t = t.sibling; return pn(bn, bn.current & 1 | 2), e.child } i = i.sibling } s.tail !== null && qn() > rh && (e.flags |= 128, n = !0, od(s, !1), e.lanes = 4194304) } else { if (!n) if (i = by(o), i !== null) { if (e.flags |= 128, n = !0, t = i.updateQueue, t !== null && (e.updateQueue = t, e.flags |= 4), od(s, !0), s.tail === null && s.tailMode === "hidden" && !o.alternate && !Mn) return Xi(e), null } else 2 * qn() - s.renderingStartTime > rh && t !== 1073741824 && (e.flags |= 128, n = !0, od(s, !1), e.lanes = 4194304); s.isBackwards ? (o.sibling = e.child, e.child = o) : (t = s.last, t !== null ? t.sibling = o : e.child = o, s.last = o) } return s.tail !== null ? (e = s.tail, s.rendering = e, s.tail = e.sibling, s.renderingStartTime = qn(), e.sibling = null, t = bn.current, pn(bn, n ? t & 1 | 2 : t & 1), e) : (Xi(e), null); case 22: case 23: return A1(), n = e.memoizedState !== null, i !== null && i.memoizedState !== null !== n && (e.flags |= 8192), n && e.mode & 1 ? Kr & 1073741824 && (Xi(e), e.subtreeFlags & 6 && (e.flags |= 8192)) : Xi(e), null; case 24: return null; case 25: return null }throw Error(Pe(156, e.tag)) } function j3(i, e) { switch (t1(e), e.tag) { case 1: return Dr(e.type) && Ay(), i = e.flags, i & 65536 ? (e.flags = i & -65537 | 128, e) : null; case 3: return nh(), vn(Lr), vn(nr), u1(), i = e.flags, i & 65536 && !(i & 128) ? (e.flags = i & -65537 | 128, e) : null; case 5: return c1(e), null; case 13: if (vn(bn), i = e.memoizedState, i !== null && i.dehydrated !== null) { if (e.alternate === null) throw Error(Pe(340)); eh() } return i = e.flags, i & 65536 ? (e.flags = i & -65537 | 128, e) : null; case 19: return vn(bn), null; case 4: return nh(), null; case 10: return s1(e.type._context), null; case 22: case 23: return A1(), null; case 24: return null; default: return null } } var Sg = !1, Ki = !1, K3 = typeof WeakSet == "function" ? WeakSet : Set, $e = null; function Mf(i, e) { var t = i.ref; if (t !== null) if (typeof t == "function") try { t(null) } catch (n) { Un(i, e, n) } else t.current = null } function nw(i, e, t) { try { t() } catch (n) { Un(i, e, n) } } var Bb = !1; function q3(i, e) { if (UM = yy, i = VB(), $S(i)) { if ("selectionStart" in i) var t = { start: i.selectionStart, end: i.selectionEnd }; else e: { t = (t = i.ownerDocument) && t.defaultView || window; var n = t.getSelection && t.getSelection(); if (n && n.rangeCount !== 0) { t = n.anchorNode; var r = n.anchorOffset, s = n.focusNode; n = n.focusOffset; try { t.nodeType, s.nodeType } catch { t = null; break e } var o = 0, a = -1, l = -1, c = 0, f = 0, d = i, p = null; t: for (; ;) { for (var m; d !== t || r !== 0 && d.nodeType !== 3 || (a = o + r), d !== s || n !== 0 && d.nodeType !== 3 || (l = o + n), d.nodeType === 3 && (o += d.nodeValue.length), (m = d.firstChild) !== null;)p = d, d = m; for (; ;) { if (d === i) break t; if (p === t && ++c === r && (a = o), p === s && ++f === n && (l = o), (m = d.nextSibling) !== null) break; d = p, p = d.parentNode } d = m } t = a === -1 || l === -1 ? null : { start: a, end: l } } else t = null } t = t || { start: 0, end: 0 } } else t = null; for (zM = { focusedElem: i, selectionRange: t }, yy = !1, $e = e; $e !== null;)if (e = $e, i = e.child, (e.subtreeFlags & 1028) !== 0 && i !== null) i.return = e, $e = i; else for (; $e !== null;) { e = $e; try { var y = e.alternate; if (e.flags & 1024) switch (e.tag) { case 0: case 11: case 15: break; case 1: if (y !== null) { var _ = y.memoizedProps, x = y.memoizedState, g = e.stateNode, A = g.getSnapshotBeforeUpdate(e.elementType === e.type ? _ : Zs(e.type, _), x); g.__reactInternalSnapshotBeforeUpdate = A } break; case 3: var M = e.stateNode.containerInfo; M.nodeType === 1 ? M.textContent = "" : M.nodeType === 9 && M.documentElement && M.removeChild(M.documentElement); break; case 5: case 6: case 4: case 17: break; default: throw Error(Pe(163)) } } catch (S) { Un(e, e.return, S) } if (i = e.sibling, i !== null) { i.return = e.return, $e = i; break } $e = e.return } return y = Bb, Bb = !1, y } function Hd(i, e, t) { var n = e.updateQueue; if (n = n !== null ? n.lastEffect : null, n !== null) { var r = n = n.next; do { if ((r.tag & i) === i) { var s = r.destroy; r.destroy = void 0, s !== void 0 && nw(e, t, s) } r = r.next } while (r !== n) } } function yv(i, e) { if (e = e.updateQueue, e = e !== null ? e.lastEffect : null, e !== null) { var t = e = e.next; do { if ((t.tag & i) === i) { var n = t.create; t.destroy = n() } t = t.next } while (t !== e) } } function iw(i) { var e = i.ref; if (e !== null) { var t = i.stateNode; switch (i.tag) { case 5: i = t; break; default: i = t }typeof e == "function" ? e(i) : e.current = i } } function zL(i) { var e = i.alternate; e !== null && (i.alternate = null, zL(e)), i.child = null, i.deletions = null, i.sibling = null, i.tag === 5 && (e = i.stateNode, e !== null && (delete e[Io], delete e[_p], delete e[VM], delete e[B3], delete e[L3])), i.stateNode = null, i.return = null, i.dependencies = null, i.memoizedProps = null, i.memoizedState = null, i.pendingProps = null, i.stateNode = null, i.updateQueue = null } function HL(i) { return i.tag === 5 || i.tag === 3 || i.tag === 4 } function Lb(i) { e: for (; ;) { for (; i.sibling === null;) { if (i.return === null || HL(i.return)) return null; i = i.return } for (i.sibling.return = i.return, i = i.sibling; i.tag !== 5 && i.tag !== 6 && i.tag !== 18;) { if (i.flags & 2 || i.child === null || i.tag === 4) continue e; i.child.return = i, i = i.child } if (!(i.flags & 2)) return i.stateNode } } function rw(i, e, t) { var n = i.tag; if (n === 5 || n === 6) i = i.stateNode, e ? t.nodeType === 8 ? t.parentNode.insertBefore(i, e) : t.insertBefore(i, e) : (t.nodeType === 8 ? (e = t.parentNode, e.insertBefore(i, t)) : (e = t, e.appendChild(i)), t = t._reactRootContainer, t != null || e.onclick !== null || (e.onclick = xy)); else if (n !== 4 && (i = i.child, i !== null)) for (rw(i, e, t), i = i.sibling; i !== null;)rw(i, e, t), i = i.sibling } function sw(i, e, t) { var n = i.tag; if (n === 5 || n === 6) i = i.stateNode, e ? t.insertBefore(i, e) : t.appendChild(i); else if (n !== 4 && (i = i.child, i !== null)) for (sw(i, e, t), i = i.sibling; i !== null;)sw(i, e, t), i = i.sibling } var Bi = null, eo = !1; function Ja(i, e, t) { for (t = t.child; t !== null;)GL(i, e, t), t = t.sibling } function GL(i, e, t) { if (Fo && typeof Fo.onCommitFiberUnmount == "function") try { Fo.onCommitFiberUnmount(cv, t) } catch { } switch (t.tag) { case 5: Ki || Mf(t, e); case 6: var n = Bi, r = eo; Bi = null, Ja(i, e, t), Bi = n, eo = r, Bi !== null && (eo ? (i = Bi, t = t.stateNode, i.nodeType === 8 ? i.parentNode.removeChild(t) : i.removeChild(t)) : Bi.removeChild(t.stateNode)); break; case 18: Bi !== null && (eo ? (i = Bi, t = t.stateNode, i.nodeType === 8 ? Ix(i.parentNode, t) : i.nodeType === 1 && Ix(i, t), pp(i)) : Ix(Bi, t.stateNode)); break; case 4: n = Bi, r = eo, Bi = t.stateNode.containerInfo, eo = !0, Ja(i, e, t), Bi = n, eo = r; break; case 0: case 11: case 14: case 15: if (!Ki && (n = t.updateQueue, n !== null && (n = n.lastEffect, n !== null))) { r = n = n.next; do { var s = r, o = s.destroy; s = s.tag, o !== void 0 && (s & 2 || s & 4) && nw(t, e, o), r = r.next } while (r !== n) } Ja(i, e, t); break; case 1: if (!Ki && (Mf(t, e), n = t.stateNode, typeof n.componentWillUnmount == "function")) try { n.props = t.memoizedProps, n.state = t.memoizedState, n.componentWillUnmount() } catch (a) { Un(t, e, a) } Ja(i, e, t); break; case 21: Ja(i, e, t); break; case 22: t.mode & 1 ? (Ki = (n = Ki) || t.memoizedState !== null, Ja(i, e, t), Ki = n) : Ja(i, e, t); break; default: Ja(i, e, t) } } function Db(i) { var e = i.updateQueue; if (e !== null) { i.updateQueue = null; var t = i.stateNode; t === null && (t = i.stateNode = new K3), e.forEach(function (n) { var r = sz.bind(null, i, n); t.has(n) || (t.add(n), n.then(r, r)) }) } } function Ys(i, e) { var t = e.deletions; if (t !== null) for (var n = 0; n < t.length; n++) { var r = t[n]; try { var s = i, o = e, a = o; e: for (; a !== null;) { switch (a.tag) { case 5: Bi = a.stateNode, eo = !1; break e; case 3: Bi = a.stateNode.containerInfo, eo = !0; break e; case 4: Bi = a.stateNode.containerInfo, eo = !0; break e }a = a.return } if (Bi === null) throw Error(Pe(160)); GL(s, o, r), Bi = null, eo = !1; var l = r.alternate; l !== null && (l.return = null), r.return = null } catch (c) { Un(r, e, c) } } if (e.subtreeFlags & 12854) for (e = e.child; e !== null;)VL(e, i), e = e.sibling } function VL(i, e) { var t = i.alternate, n = i.flags; switch (i.tag) { case 0: case 11: case 14: case 15: if (Ys(e, i), bo(i), n & 4) { try { Hd(3, i, i.return), yv(3, i) } catch (_) { Un(i, i.return, _) } try { Hd(5, i, i.return) } catch (_) { Un(i, i.return, _) } } break; case 1: Ys(e, i), bo(i), n & 512 && t !== null && Mf(t, t.return); break; case 5: if (Ys(e, i), bo(i), n & 512 && t !== null && Mf(t, t.return), i.flags & 32) { var r = i.stateNode; try { up(r, "") } catch (_) { Un(i, i.return, _) } } if (n & 4 && (r = i.stateNode, r != null)) { var s = i.memoizedProps, o = t !== null ? t.memoizedProps : s, a = i.type, l = i.updateQueue; if (i.updateQueue = null, l !== null) try { a === "input" && s.type === "radio" && s.name != null && uB(r, s), RM(a, o); var c = RM(a, s); for (o = 0; o < l.length; o += 2) { var f = l[o], d = l[o + 1]; f === "style" ? mB(r, d) : f === "dangerouslySetInnerHTML" ? dB(r, d) : f === "children" ? up(r, d) : zS(r, f, d, c) } switch (a) { case "input": SM(r, s); break; case "textarea": fB(r, s); break; case "select": var p = r._wrapperState.wasMultiple; r._wrapperState.wasMultiple = !!s.multiple; var m = s.value; m != null ? Df(r, !!s.multiple, m, !1) : p !== !!s.multiple && (s.defaultValue != null ? Df(r, !!s.multiple, s.defaultValue, !0) : Df(r, !!s.multiple, s.multiple ? [] : "", !1)) }r[_p] = s } catch (_) { Un(i, i.return, _) } } break; case 6: if (Ys(e, i), bo(i), n & 4) { if (i.stateNode === null) throw Error(Pe(162)); r = i.stateNode, s = i.memoizedProps; try { r.nodeValue = s } catch (_) { Un(i, i.return, _) } } break; case 3: if (Ys(e, i), bo(i), n & 4 && t !== null && t.memoizedState.isDehydrated) try { pp(e.containerInfo) } catch (_) { Un(i, i.return, _) } break; case 4: Ys(e, i), bo(i); break; case 13: Ys(e, i), bo(i), r = i.child, r.flags & 8192 && (s = r.memoizedState !== null, r.stateNode.isHidden = s, !s || r.alternate !== null && r.alternate.memoizedState !== null || (_1 = qn())), n & 4 && Db(i); break; case 22: if (f = t !== null && t.memoizedState !== null, i.mode & 1 ? (Ki = (c = Ki) || f, Ys(e, i), Ki = c) : Ys(e, i), bo(i), n & 8192) { if (c = i.memoizedState !== null, (i.stateNode.isHidden = c) && !f && i.mode & 1) for ($e = i, f = i.child; f !== null;) { for (d = $e = f; $e !== null;) { switch (p = $e, m = p.child, p.tag) { case 0: case 11: case 14: case 15: Hd(4, p, p.return); break; case 1: Mf(p, p.return); var y = p.stateNode; if (typeof y.componentWillUnmount == "function") { n = p, t = p.return; try { e = n, y.props = e.memoizedProps, y.state = e.memoizedState, y.componentWillUnmount() } catch (_) { Un(n, t, _) } } break; case 5: Mf(p, p.return); break; case 22: if (p.memoizedState !== null) { Fb(d); continue } }m !== null ? (m.return = p, $e = m) : Fb(d) } f = f.sibling } e: for (f = null, d = i; ;) { if (d.tag === 5) { if (f === null) { f = d; try { r = d.stateNode, c ? (s = r.style, typeof s.setProperty == "function" ? s.setProperty("display", "none", "important") : s.display = "none") : (a = d.stateNode, l = d.memoizedProps.style, o = l != null && l.hasOwnProperty("display") ? l.display : null, a.style.display = pB("display", o)) } catch (_) { Un(i, i.return, _) } } } else if (d.tag === 6) { if (f === null) try { d.stateNode.nodeValue = c ? "" : d.memoizedProps } catch (_) { Un(i, i.return, _) } } else if ((d.tag !== 22 && d.tag !== 23 || d.memoizedState === null || d === i) && d.child !== null) { d.child.return = d, d = d.child; continue } if (d === i) break e; for (; d.sibling === null;) { if (d.return === null || d.return === i) break e; f === d && (f = null), d = d.return } f === d && (f = null), d.sibling.return = d.return, d = d.sibling } } break; case 19: Ys(e, i), bo(i), n & 4 && Db(i); break; case 21: break; default: Ys(e, i), bo(i) } } function bo(i) { var e = i.flags; if (e & 2) { try { e: { for (var t = i.return; t !== null;) { if (HL(t)) { var n = t; break e } t = t.return } throw Error(Pe(160)) } switch (n.tag) { case 5: var r = n.stateNode; n.flags & 32 && (up(r, ""), n.flags &= -33); var s = Lb(i); sw(i, s, r); break; case 3: case 4: var o = n.stateNode.containerInfo, a = Lb(i); rw(i, a, o); break; default: throw Error(Pe(161)) } } catch (l) { Un(i, i.return, l) } i.flags &= -3 } e & 4096 && (i.flags &= -4097) } function Q3(i, e, t) { $e = i, WL(i) } function WL(i, e, t) { for (var n = (i.mode & 1) !== 0; $e !== null;) { var r = $e, s = r.child; if (r.tag === 22 && n) { var o = r.memoizedState !== null || Sg; if (!o) { var a = r.alternate, l = a !== null && a.memoizedState !== null || Ki; a = Sg; var c = Ki; if (Sg = o, (Ki = l) && !c) for ($e = r; $e !== null;)o = $e, l = o.child, o.tag === 22 && o.memoizedState !== null ? kb(r) : l !== null ? (l.return = o, $e = l) : kb(r); for (; s !== null;)$e = s, WL(s), s = s.sibling; $e = r, Sg = a, Ki = c } Ob(i) } else r.subtreeFlags & 8772 && s !== null ? (s.return = r, $e = s) : Ob(i) } } function Ob(i) { for (; $e !== null;) { var e = $e; if (e.flags & 8772) { var t = e.alternate; try { if (e.flags & 8772) switch (e.tag) { case 0: case 11: case 15: Ki || yv(5, e); break; case 1: var n = e.stateNode; if (e.flags & 4 && !Ki) if (t === null) n.componentDidMount(); else { var r = e.elementType === e.type ? t.memoizedProps : Zs(e.type, t.memoizedProps); n.componentDidUpdate(r, t.memoizedState, n.__reactInternalSnapshotBeforeUpdate) } var s = e.updateQueue; s !== null && vb(e, s, n); break; case 3: var o = e.updateQueue; if (o !== null) { if (t = null, e.child !== null) switch (e.child.tag) { case 5: t = e.child.stateNode; break; case 1: t = e.child.stateNode }vb(e, o, t) } break; case 5: var a = e.stateNode; if (t === null && e.flags & 4) { t = a; var l = e.memoizedProps; switch (e.type) { case "button": case "input": case "select": case "textarea": l.autoFocus && t.focus(); break; case "img": l.src && (t.src = l.src) } } break; case 6: break; case 4: break; case 12: break; case 13: if (e.memoizedState === null) { var c = e.alternate; if (c !== null) { var f = c.memoizedState; if (f !== null) { var d = f.dehydrated; d !== null && pp(d) } } } break; case 19: case 17: case 21: case 22: case 23: case 25: break; default: throw Error(Pe(163)) }Ki || e.flags & 512 && iw(e) } catch (p) { Un(e, e.return, p) } } if (e === i) { $e = null; break } if (t = e.sibling, t !== null) { t.return = e.return, $e = t; break } $e = e.return } } function Fb(i) { for (; $e !== null;) { var e = $e; if (e === i) { $e = null; break } var t = e.sibling; if (t !== null) { t.return = e.return, $e = t; break } $e = e.return } } function kb(i) { for (; $e !== null;) { var e = $e; try { switch (e.tag) { case 0: case 11: case 15: var t = e.return; try { yv(4, e) } catch (l) { Un(e, t, l) } break; case 1: var n = e.stateNode; if (typeof n.componentDidMount == "function") { var r = e.return; try { n.componentDidMount() } catch (l) { Un(e, r, l) } } var s = e.return; try { iw(e) } catch (l) { Un(e, s, l) } break; case 5: var o = e.return; try { iw(e) } catch (l) { Un(e, o, l) } } } catch (l) { Un(e, e.return, l) } if (e === i) { $e = null; break } var a = e.sibling; if (a !== null) { a.return = e.return, $e = a; break } $e = e.return } } var Z3 = Math.ceil, Iy = Fa.ReactCurrentDispatcher, y1 = Fa.ReactCurrentOwner, Ds = Fa.ReactCurrentBatchConfig, Zt = 0, Ci = null, ri = null, Fi = 0, Kr = 0, wf = Vl(0), di = 0, Ep = null, $c = 0, vv = 0, v1 = 0, Gd = null, Tr = null, _1 = 0, rh = 1 / 0, ua = null, By = !1, ow = null, Al = null, Eg = !1, cl = null, Ly = 0, Vd = 0, aw = null, G0 = -1, V0 = 0; function yr() { return Zt & 6 ? qn() : G0 !== -1 ? G0 : G0 = qn() } function Ml(i) { return i.mode & 1 ? Zt & 2 && Fi !== 0 ? Fi & -Fi : O3.transition !== null ? (V0 === 0 && (V0 = TB()), V0) : (i = an, i !== 0 || (i = window.event, i = i === void 0 ? 16 : DB(i.type)), i) : 1 } function oo(i, e, t, n) { if (50 < Vd) throw Vd = 0, aw = null, Error(Pe(185)); qp(i, t, n), (!(Zt & 2) || i !== Ci) && (i === Ci && (!(Zt & 2) && (vv |= t), di === 4 && ol(i, Fi)), Or(i, n), t === 1 && Zt === 0 && !(e.mode & 1) && (rh = qn() + 500, pv && Wl())) } function Or(i, e) { var t = i.callbackNode; OU(i, e); var n = gy(i, i === Ci ? Fi : 0); if (n === 0) t !== null && JT(t), i.callbackNode = null, i.callbackPriority = 0; else if (e = n & -n, i.callbackPriority !== e) { if (t != null && JT(t), e === 1) i.tag === 0 ? D3(Nb.bind(null, i)) : $B(Nb.bind(null, i)), P3(function () { !(Zt & 6) && Wl() }), t = null; else { switch (bB(n)) { case 1: t = XS; break; case 4: t = EB; break; case 16: t = my; break; case 536870912: t = CB; break; default: t = my }t = ZL(t, XL.bind(null, i)) } i.callbackPriority = e, i.callbackNode = t } } function XL(i, e) { if (G0 = -1, V0 = 0, Zt & 6) throw Error(Pe(327)); var t = i.callbackNode; if (Uf() && i.callbackNode !== t) return null; var n = gy(i, i === Ci ? Fi : 0); if (n === 0) return null; if (n & 30 || n & i.expiredLanes || e) e = Dy(i, n); else { e = n; var r = Zt; Zt |= 2; var s = YL(); (Ci !== i || Fi !== e) && (ua = null, rh = qn() + 500, kc(i, e)); do try { tz(); break } catch (a) { JL(i, a) } while (1); r1(), Iy.current = s, Zt = r, ri !== null ? e = 0 : (Ci = null, Fi = 0, e = di) } if (e !== 0) { if (e === 2 && (r = DM(i), r !== 0 && (n = r, e = lw(i, r))), e === 1) throw t = Ep, kc(i, 0), ol(i, n), Or(i, qn()), t; if (e === 6) ol(i, n); else { if (r = i.current.alternate, !(n & 30) && !$3(r) && (e = Dy(i, n), e === 2 && (s = DM(i), s !== 0 && (n = s, e = lw(i, s))), e === 1)) throw t = Ep, kc(i, 0), ol(i, n), Or(i, qn()), t; switch (i.finishedWork = r, i.finishedLanes = n, e) { case 0: case 1: throw Error(Pe(345)); case 2: yc(i, Tr, ua); break; case 3: if (ol(i, n), (n & 130023424) === n && (e = _1 + 500 - qn(), 10 < e)) { if (gy(i, 0) !== 0) break; if (r = i.suspendedLanes, (r & n) !== n) { yr(), i.pingedLanes |= i.suspendedLanes & r; break } i.timeoutHandle = GM(yc.bind(null, i, Tr, ua), e); break } yc(i, Tr, ua); break; case 4: if (ol(i, n), (n & 4194240) === n) break; for (e = i.eventTimes, r = -1; 0 < n;) { var o = 31 - so(n); s = 1 << o, o = e[o], o > r && (r = o), n &= ~s } if (n = r, n = qn() - n, n = (120 > n ? 120 : 480 > n ? 480 : 1080 > n ? 1080 : 1920 > n ? 1920 : 3e3 > n ? 3e3 : 4320 > n ? 4320 : 1960 * Z3(n / 1960)) - n, 10 < n) { i.timeoutHandle = GM(yc.bind(null, i, Tr, ua), n); break } yc(i, Tr, ua); break; case 5: yc(i, Tr, ua); break; default: throw Error(Pe(329)) } } } return Or(i, qn()), i.callbackNode === t ? XL.bind(null, i) : null } function lw(i, e) { var t = Gd; return i.current.memoizedState.isDehydrated && (kc(i, e).flags |= 256), i = Dy(i, e), i !== 2 && (e = Tr, Tr = t, e !== null && cw(e)), i } function cw(i) { Tr === null ? Tr = i : Tr.push.apply(Tr, i) } function $3(i) { for (var e = i; ;) { if (e.flags & 16384) { var t = e.updateQueue; if (t !== null && (t = t.stores, t !== null)) for (var n = 0; n < t.length; n++) { var r = t[n], s = r.getSnapshot; r = r.value; try { if (!uo(s(), r)) return !1 } catch { return !1 } } } if (t = e.child, e.subtreeFlags & 16384 && t !== null) t.return = e, e = t; else { if (e === i) break; for (; e.sibling === null;) { if (e.return === null || e.return === i) return !0; e = e.return } e.sibling.return = e.return, e = e.sibling } } return !0 } function ol(i, e) { for (e &= ~v1, e &= ~vv, i.suspendedLanes |= e, i.pingedLanes &= ~e, i = i.expirationTimes; 0 < e;) { var t = 31 - so(e), n = 1 << t; i[t] = -1, e &= ~n } } function Nb(i) { if (Zt & 6) throw Error(Pe(327)); Uf(); var e = gy(i, 0); if (!(e & 1)) return Or(i, qn()), null; var t = Dy(i, e); if (i.tag !== 0 && t === 2) { var n = DM(i); n !== 0 && (e = n, t = lw(i, n)) } if (t === 1) throw t = Ep, kc(i, 0), ol(i, e), Or(i, qn()), t; if (t === 6) throw Error(Pe(345)); return i.finishedWork = i.current.alternate, i.finishedLanes = e, yc(i, Tr, ua), Or(i, qn()), null } function x1(i, e) { var t = Zt; Zt |= 1; try { return i(e) } finally { Zt = t, Zt === 0 && (rh = qn() + 500, pv && Wl()) } } function eu(i) { cl !== null && cl.tag === 0 && !(Zt & 6) && Uf(); var e = Zt; Zt |= 1; var t = Ds.transition, n = an; try { if (Ds.transition = null, an = 1, i) return i() } finally { an = n, Ds.transition = t, Zt = e, !(Zt & 6) && Wl() } } function A1() { Kr = wf.current, vn(wf) } function kc(i, e) { i.finishedWork = null, i.finishedLanes = 0; var t = i.timeoutHandle; if (t !== -1 && (i.timeoutHandle = -1, R3(t)), ri !== null) for (t = ri.return; t !== null;) { var n = t; switch (t1(n), n.tag) { case 1: n = n.type.childContextTypes, n != null && Ay(); break; case 3: nh(), vn(Lr), vn(nr), u1(); break; case 5: c1(n); break; case 4: nh(); break; case 13: vn(bn); break; case 19: vn(bn); break; case 10: s1(n.type._context); break; case 22: case 23: A1() }t = t.return } if (Ci = i, ri = i = wl(i.current, null), Fi = Kr = e, di = 0, Ep = null, v1 = vv = $c = 0, Tr = Gd = null, Tc !== null) { for (e = 0; e < Tc.length; e++)if (t = Tc[e], n = t.interleaved, n !== null) { t.interleaved = null; var r = n.next, s = t.pending; if (s !== null) { var o = s.next; s.next = r, n.next = o } t.pending = n } Tc = null } return i } function JL(i, e) { do { var t = ri; try { if (r1(), U0.current = Py, Ry) { for (var n = Ln.memoizedState; n !== null;) { var r = n.queue; r !== null && (r.pending = null), n = n.next } Ry = !1 } if (Zc = 0, wi = fi = Ln = null, zd = !1, Mp = 0, y1.current = null, t === null || t.return === null) { di = 1, Ep = e, ri = null; break } e: { var s = i, o = t.return, a = t, l = e; if (e = Fi, a.flags |= 32768, l !== null && typeof l == "object" && typeof l.then == "function") { var c = l, f = a, d = f.tag; if (!(f.mode & 1) && (d === 0 || d === 11 || d === 15)) { var p = f.alternate; p ? (f.updateQueue = p.updateQueue, f.memoizedState = p.memoizedState, f.lanes = p.lanes) : (f.updateQueue = null, f.memoizedState = null) } var m = Eb(o); if (m !== null) { m.flags &= -257, Cb(m, o, a, s, e), m.mode & 1 && Sb(s, c, e), e = m, l = c; var y = e.updateQueue; if (y === null) { var _ = new Set; _.add(l), e.updateQueue = _ } else y.add(l); break e } else { if (!(e & 1)) { Sb(s, c, e), M1(); break e } l = Error(Pe(426)) } } else if (Mn && a.mode & 1) { var x = Eb(o); if (x !== null) { !(x.flags & 65536) && (x.flags |= 256), Cb(x, o, a, s, e), n1(ih(l, a)); break e } } s = l = ih(l, a), di !== 4 && (di = 2), Gd === null ? Gd = [s] : Gd.push(s), s = o; do { switch (s.tag) { case 3: s.flags |= 65536, e &= -e, s.lanes |= e; var g = RL(s, l, e); yb(s, g); break e; case 1: a = l; var A = s.type, M = s.stateNode; if (!(s.flags & 128) && (typeof A.getDerivedStateFromError == "function" || M !== null && typeof M.componentDidCatch == "function" && (Al === null || !Al.has(M)))) { s.flags |= 65536, e &= -e, s.lanes |= e; var S = PL(s, a, e); yb(s, S); break e } }s = s.return } while (s !== null) } KL(t) } catch (C) { e = C, ri === t && t !== null && (ri = t = t.return); continue } break } while (1) } function YL() { var i = Iy.current; return Iy.current = Py, i === null ? Py : i } function M1() { (di === 0 || di === 3 || di === 2) && (di = 4), Ci === null || !($c & 268435455) && !(vv & 268435455) || ol(Ci, Fi) } function Dy(i, e) { var t = Zt; Zt |= 2; var n = YL(); (Ci !== i || Fi !== e) && (ua = null, kc(i, e)); do try { ez(); break } catch (r) { JL(i, r) } while (1); if (r1(), Zt = t, Iy.current = n, ri !== null) throw Error(Pe(261)); return Ci = null, Fi = 0, di } function ez() { for (; ri !== null;)jL(ri) } function tz() { for (; ri !== null && !CU();)jL(ri) } function jL(i) { var e = QL(i.alternate, i, Kr); i.memoizedProps = i.pendingProps, e === null ? KL(i) : ri = e, y1.current = null } function KL(i) { var e = i; do { var t = e.alternate; if (i = e.return, e.flags & 32768) { if (t = j3(t, e), t !== null) { t.flags &= 32767, ri = t; return } if (i !== null) i.flags |= 32768, i.subtreeFlags = 0, i.deletions = null; else { di = 6, ri = null; return } } else if (t = Y3(t, e, Kr), t !== null) { ri = t; return } if (e = e.sibling, e !== null) { ri = e; return } ri = e = i } while (e !== null); di === 0 && (di = 5) } function yc(i, e, t) { var n = an, r = Ds.transition; try { Ds.transition = null, an = 1, nz(i, e, t, n) } finally { Ds.transition = r, an = n } return null } function nz(i, e, t, n) { do Uf(); while (cl !== null); if (Zt & 6) throw Error(Pe(327)); t = i.finishedWork; var r = i.finishedLanes; if (t === null) return null; if (i.finishedWork = null, i.finishedLanes = 0, t === i.current) throw Error(Pe(177)); i.callbackNode = null, i.callbackPriority = 0; var s = t.lanes | t.childLanes; if (FU(i, s), i === Ci && (ri = Ci = null, Fi = 0), !(t.subtreeFlags & 2064) && !(t.flags & 2064) || Eg || (Eg = !0, ZL(my, function () { return Uf(), null })), s = (t.flags & 15990) !== 0, t.subtreeFlags & 15990 || s) { s = Ds.transition, Ds.transition = null; var o = an; an = 1; var a = Zt; Zt |= 4, y1.current = null, q3(i, t), VL(t, i), M3(zM), yy = !!UM, zM = UM = null, i.current = t, Q3(t), TU(), Zt = a, an = o, Ds.transition = s } else i.current = t; if (Eg && (Eg = !1, cl = i, Ly = r), s = i.pendingLanes, s === 0 && (Al = null), PU(t.stateNode), Or(i, qn()), e !== null) for (n = i.onRecoverableError, t = 0; t < e.length; t++)r = e[t], n(r.value, { componentStack: r.stack, digest: r.digest }); if (By) throw By = !1, i = ow, ow = null, i; return Ly & 1 && i.tag !== 0 && Uf(), s = i.pendingLanes, s & 1 ? i === aw ? Vd++ : (Vd = 0, aw = i) : Vd = 0, Wl(), null } function Uf() { if (cl !== null) { var i = bB(Ly), e = Ds.transition, t = an; try { if (Ds.transition = null, an = 16 > i ? 16 : i, cl === null) var n = !1; else { if (i = cl, cl = null, Ly = 0, Zt & 6) throw Error(Pe(331)); var r = Zt; for (Zt |= 4, $e = i.current; $e !== null;) { var s = $e, o = s.child; if ($e.flags & 16) { var a = s.deletions; if (a !== null) { for (var l = 0; l < a.length; l++) { var c = a[l]; for ($e = c; $e !== null;) { var f = $e; switch (f.tag) { case 0: case 11: case 15: Hd(8, f, s) }var d = f.child; if (d !== null) d.return = f, $e = d; else for (; $e !== null;) { f = $e; var p = f.sibling, m = f.return; if (zL(f), f === c) { $e = null; break } if (p !== null) { p.return = m, $e = p; break } $e = m } } } var y = s.alternate; if (y !== null) { var _ = y.child; if (_ !== null) { y.child = null; do { var x = _.sibling; _.sibling = null, _ = x } while (_ !== null) } } $e = s } } if (s.subtreeFlags & 2064 && o !== null) o.return = s, $e = o; else e: for (; $e !== null;) { if (s = $e, s.flags & 2048) switch (s.tag) { case 0: case 11: case 15: Hd(9, s, s.return) }var g = s.sibling; if (g !== null) { g.return = s.return, $e = g; break e } $e = s.return } } var A = i.current; for ($e = A; $e !== null;) { o = $e; var M = o.child; if (o.subtreeFlags & 2064 && M !== null) M.return = o, $e = M; else e: for (o = A; $e !== null;) { if (a = $e, a.flags & 2048) try { switch (a.tag) { case 0: case 11: case 15: yv(9, a) } } catch (C) { Un(a, a.return, C) } if (a === o) { $e = null; break e } var S = a.sibling; if (S !== null) { S.return = a.return, $e = S; break e } $e = a.return } } if (Zt = r, Wl(), Fo && typeof Fo.onPostCommitFiberRoot == "function") try { Fo.onPostCommitFiberRoot(cv, i) } catch { } n = !0 } return n } finally { an = t, Ds.transition = e } } return !1 } function Ub(i, e, t) { e = ih(t, e), e = RL(i, e, 1), i = xl(i, e, 1), e = yr(), i !== null && (qp(i, 1, e), Or(i, e)) } function Un(i, e, t) { if (i.tag === 3) Ub(i, i, t); else for (; e !== null;) { if (e.tag === 3) { Ub(e, i, t); break } else if (e.tag === 1) { var n = e.stateNode; if (typeof e.type.getDerivedStateFromError == "function" || typeof n.componentDidCatch == "function" && (Al === null || !Al.has(n))) { i = ih(t, i), i = PL(e, i, 1), e = xl(e, i, 1), i = yr(), e !== null && (qp(e, 1, i), Or(e, i)); break } } e = e.return } } function iz(i, e, t) { var n = i.pingCache; n !== null && n.delete(e), e = yr(), i.pingedLanes |= i.suspendedLanes & t, Ci === i && (Fi & t) === t && (di === 4 || di === 3 && (Fi & 130023424) === Fi && 500 > qn() - _1 ? kc(i, 0) : v1 |= t), Or(i, e) } function qL(i, e) { e === 0 && (i.mode & 1 ? (e = mg, mg <<= 1, !(mg & 130023424) && (mg = 4194304)) : e = 1); var t = yr(); i = Ra(i, e), i !== null && (qp(i, e, t), Or(i, t)) } function rz(i) { var e = i.memoizedState, t = 0; e !== null && (t = e.retryLane), qL(i, t) } function sz(i, e) { var t = 0; switch (i.tag) { case 13: var n = i.stateNode, r = i.memoizedState; r !== null && (t = r.retryLane); break; case 19: n = i.stateNode; break; default: throw Error(Pe(314)) }n !== null && n.delete(e), qL(i, t) } var QL; QL = function (i, e, t) { if (i !== null) if (i.memoizedProps !== e.pendingProps || Lr.current) Br = !0; else { if (!(i.lanes & t) && !(e.flags & 128)) return Br = !1, J3(i, e, t); Br = !!(i.flags & 131072) } else Br = !1, Mn && e.flags & 1048576 && eL(e, Sy, e.index); switch (e.lanes = 0, e.tag) { case 2: var n = e.type; H0(i, e), i = e.pendingProps; var r = $f(e, nr.current); Nf(e, t), r = h1(null, e, n, i, r, t); var s = d1(); return e.flags |= 1, typeof r == "object" && r !== null && typeof r.render == "function" && r.$$typeof === void 0 ? (e.tag = 1, e.memoizedState = null, e.updateQueue = null, Dr(n) ? (s = !0, My(e)) : s = !1, e.memoizedState = r.state !== null && r.state !== void 0 ? r.state : null, a1(e), r.updater = mv, e.stateNode = r, r._reactInternals = e, KM(e, n, i, t), e = ZM(null, e, n, !0, s, t)) : (e.tag = 0, Mn && s && e1(e), fr(null, e, r, t), e = e.child), e; case 16: n = e.elementType; e: { switch (H0(i, e), i = e.pendingProps, r = n._init, n = r(n._payload), e.type = n, r = e.tag = az(n), i = Zs(n, i), r) { case 0: e = QM(null, e, n, i, t); break e; case 1: e = Rb(null, e, n, i, t); break e; case 11: e = Tb(null, e, n, i, t); break e; case 14: e = bb(null, e, n, Zs(n.type, i), t); break e }throw Error(Pe(306, n, "")) } return e; case 0: return n = e.type, r = e.pendingProps, r = e.elementType === n ? r : Zs(n, r), QM(i, e, n, r, t); case 1: return n = e.type, r = e.pendingProps, r = e.elementType === n ? r : Zs(n, r), Rb(i, e, n, r, t); case 3: e: { if (DL(e), i === null) throw Error(Pe(387)); n = e.pendingProps, s = e.memoizedState, r = s.element, rL(i, e), Ty(e, n, null, t); var o = e.memoizedState; if (n = o.element, s.isDehydrated) if (s = { element: n, isDehydrated: !1, cache: o.cache, pendingSuspenseBoundaries: o.pendingSuspenseBoundaries, transitions: o.transitions }, e.updateQueue.baseState = s, e.memoizedState = s, e.flags & 256) { r = ih(Error(Pe(423)), e), e = Pb(i, e, n, t, r); break e } else if (n !== r) { r = ih(Error(Pe(424)), e), e = Pb(i, e, n, t, r); break e } else for (es = _l(e.stateNode.containerInfo.firstChild), ns = e, Mn = !0, to = null, t = lL(e, null, n, t), e.child = t; t;)t.flags = t.flags & -3 | 4096, t = t.sibling; else { if (eh(), n === r) { e = Pa(i, e, t); break e } fr(i, e, n, t) } e = e.child } return e; case 5: return cL(e), i === null && JM(e), n = e.type, r = e.pendingProps, s = i !== null ? i.memoizedProps : null, o = r.children, HM(n, r) ? o = null : s !== null && HM(n, s) && (e.flags |= 32), LL(i, e), fr(i, e, o, t), e.child; case 6: return i === null && JM(e), null; case 13: return OL(i, e, t); case 4: return l1(e, e.stateNode.containerInfo), n = e.pendingProps, i === null ? e.child = th(e, null, n, t) : fr(i, e, n, t), e.child; case 11: return n = e.type, r = e.pendingProps, r = e.elementType === n ? r : Zs(n, r), Tb(i, e, n, r, t); case 7: return fr(i, e, e.pendingProps, t), e.child; case 8: return fr(i, e, e.pendingProps.children, t), e.child; case 12: return fr(i, e, e.pendingProps.children, t), e.child; case 10: e: { if (n = e.type._context, r = e.pendingProps, s = e.memoizedProps, o = r.value, pn(Ey, n._currentValue), n._currentValue = o, s !== null) if (uo(s.value, o)) { if (s.children === r.children && !Lr.current) { e = Pa(i, e, t); break e } } else for (s = e.child, s !== null && (s.return = e); s !== null;) { var a = s.dependencies; if (a !== null) { o = s.child; for (var l = a.firstContext; l !== null;) { if (l.context === n) { if (s.tag === 1) { l = wa(-1, t & -t), l.tag = 2; var c = s.updateQueue; if (c !== null) { c = c.shared; var f = c.pending; f === null ? l.next = l : (l.next = f.next, f.next = l), c.pending = l } } s.lanes |= t, l = s.alternate, l !== null && (l.lanes |= t), YM(s.return, t, e), a.lanes |= t; break } l = l.next } } else if (s.tag === 10) o = s.type === e.type ? null : s.child; else if (s.tag === 18) { if (o = s.return, o === null) throw Error(Pe(341)); o.lanes |= t, a = o.alternate, a !== null && (a.lanes |= t), YM(o, t, e), o = s.sibling } else o = s.child; if (o !== null) o.return = s; else for (o = s; o !== null;) { if (o === e) { o = null; break } if (s = o.sibling, s !== null) { s.return = o.return, o = s; break } o = o.return } s = o } fr(i, e, r.children, t), e = e.child } return e; case 9: return r = e.type, n = e.pendingProps.children, Nf(e, t), r = ks(r), n = n(r), e.flags |= 1, fr(i, e, n, t), e.child; case 14: return n = e.type, r = Zs(n, e.pendingProps), r = Zs(n.type, r), bb(i, e, n, r, t); case 15: return IL(i, e, e.type, e.pendingProps, t); case 17: return n = e.type, r = e.pendingProps, r = e.elementType === n ? r : Zs(n, r), H0(i, e), e.tag = 1, Dr(n) ? (i = !0, My(e)) : i = !1, Nf(e, t), oL(e, n, r), KM(e, n, r, t), ZM(null, e, n, !0, i, t); case 19: return FL(i, e, t); case 22: return BL(i, e, t) }throw Error(Pe(156, e.tag)) }; function ZL(i, e) { return SB(i, e) } function oz(i, e, t, n) { this.tag = i, this.key = t, this.sibling = this.child = this.return = this.stateNode = this.type = this.elementType = null, this.index = 0, this.ref = null, this.pendingProps = e, this.dependencies = this.memoizedState = this.updateQueue = this.memoizedProps = null, this.mode = n, this.subtreeFlags = this.flags = 0, this.deletions = null, this.childLanes = this.lanes = 0, this.alternate = null } function Ps(i, e, t, n) { return new oz(i, e, t, n) } function w1(i) { return i = i.prototype, !(!i || !i.isReactComponent) } function az(i) { if (typeof i == "function") return w1(i) ? 1 : 0; if (i != null) { if (i = i.$$typeof, i === GS) return 11; if (i === VS) return 14 } return 2 } function wl(i, e) { var t = i.alternate; return t === null ? (t = Ps(i.tag, e, i.key, i.mode), t.elementType = i.elementType, t.type = i.type, t.stateNode = i.stateNode, t.alternate = i, i.alternate = t) : (t.pendingProps = e, t.type = i.type, t.flags = 0, t.subtreeFlags = 0, t.deletions = null), t.flags = i.flags & 14680064, t.childLanes = i.childLanes, t.lanes = i.lanes, t.child = i.child, t.memoizedProps = i.memoizedProps, t.memoizedState = i.memoizedState, t.updateQueue = i.updateQueue, e = i.dependencies, t.dependencies = e === null ? null : { lanes: e.lanes, firstContext: e.firstContext }, t.sibling = i.sibling, t.index = i.index, t.ref = i.ref, t } function W0(i, e, t, n, r, s) { var o = 2; if (n = i, typeof i == "function") w1(i) && (o = 1); else if (typeof i == "string") o = 5; else e: switch (i) { case df: return Nc(t.children, r, s, e); case HS: o = 8, r |= 8; break; case _M: return i = Ps(12, t, e, r | 2), i.elementType = _M, i.lanes = s, i; case xM: return i = Ps(13, t, e, r), i.elementType = xM, i.lanes = s, i; case AM: return i = Ps(19, t, e, r), i.elementType = AM, i.lanes = s, i; case aB: return _v(t, r, s, e); default: if (typeof i == "object" && i !== null) switch (i.$$typeof) { case sB: o = 10; break e; case oB: o = 9; break e; case GS: o = 11; break e; case VS: o = 14; break e; case tl: o = 16, n = null; break e }throw Error(Pe(130, i == null ? i : typeof i, "")) }return e = Ps(o, t, e, r), e.elementType = i, e.type = n, e.lanes = s, e } function Nc(i, e, t, n) { return i = Ps(7, i, n, e), i.lanes = t, i } function _v(i, e, t, n) { return i = Ps(22, i, n, e), i.elementType = aB, i.lanes = t, i.stateNode = { isHidden: !1 }, i } function Ux(i, e, t) { return i = Ps(6, i, null, e), i.lanes = t, i } function zx(i, e, t) { return e = Ps(4, i.children !== null ? i.children : [], i.key, e), e.lanes = t, e.stateNode = { containerInfo: i.containerInfo, pendingChildren: null, implementation: i.implementation }, e } function lz(i, e, t, n, r) { this.tag = e, this.containerInfo = i, this.finishedWork = this.pingCache = this.current = this.pendingChildren = null, this.timeoutHandle = -1, this.callbackNode = this.pendingContext = this.context = null, this.callbackPriority = 0, this.eventTimes = xx(0), this.expirationTimes = xx(-1), this.entangledLanes = this.finishedLanes = this.mutableReadLanes = this.expiredLanes = this.pingedLanes = this.suspendedLanes = this.pendingLanes = 0, this.entanglements = xx(0), this.identifierPrefix = n, this.onRecoverableError = r, this.mutableSourceEagerHydrationData = null } function S1(i, e, t, n, r, s, o, a, l) { return i = new lz(i, e, t, a, l), e === 1 ? (e = 1, s === !0 && (e |= 8)) : e = 0, s = Ps(3, null, null, e), i.current = s, s.stateNode = i, s.memoizedState = { element: n, isDehydrated: t, cache: null, transitions: null, pendingSuspenseBoundaries: null }, a1(s), i } function cz(i, e, t) { var n = 3 < arguments.length && arguments[3] !== void 0 ? arguments[3] : null; return { $$typeof: hf, key: n == null ? null : "" + n, children: i, containerInfo: e, implementation: t } } function $L(i) { if (!i) return Ll; i = i._reactInternals; e: { if (hu(i) !== i || i.tag !== 1) throw Error(Pe(170)); var e = i; do { switch (e.tag) { case 3: e = e.stateNode.context; break e; case 1: if (Dr(e.type)) { e = e.stateNode.__reactInternalMemoizedMergedChildContext; break e } }e = e.return } while (e !== null); throw Error(Pe(171)) } if (i.tag === 1) { var t = i.type; if (Dr(t)) return ZB(i, t, e) } return e } function e2(i, e, t, n, r, s, o, a, l) { return i = S1(t, n, !0, i, r, s, o, a, l), i.context = $L(null), t = i.current, n = yr(), r = Ml(t), s = wa(n, r), s.callback = e ?? null, xl(t, s, r), i.current.lanes = r, qp(i, r, n), Or(i, n), i } function xv(i, e, t, n) { var r = e.current, s = yr(), o = Ml(r); return t = $L(t), e.context === null ? e.context = t : e.pendingContext = t, e = wa(s, o), e.payload = { element: i }, n = n === void 0 ? null : n, n !== null && (e.callback = n), i = xl(r, e, o), i !== null && (oo(i, r, o, s), N0(i, r, o)), o } function Oy(i) { if (i = i.current, !i.child) return null; switch (i.child.tag) { case 5: return i.child.stateNode; default: return i.child.stateNode } } function zb(i, e) { if (i = i.memoizedState, i !== null && i.dehydrated !== null) { var t = i.retryLane; i.retryLane = t !== 0 && t < e ? t : e } } function E1(i, e) { zb(i, e), (i = i.alternate) && zb(i, e) } function uz() { return null } var t2 = typeof reportError == "function" ? reportError : function (i) { console.error(i) }; function C1(i) { this._internalRoot = i } Av.prototype.render = C1.prototype.render = function (i) { var e = this._internalRoot; if (e === null) throw Error(Pe(409)); xv(i, e, null, null) }; Av.prototype.unmount = C1.prototype.unmount = function () { var i = this._internalRoot; if (i !== null) { this._internalRoot = null; var e = i.containerInfo; eu(function () { xv(null, i, null, null) }), e[ba] = null } }; function Av(i) { this._internalRoot = i } Av.prototype.unstable_scheduleHydration = function (i) { if (i) { var e = IB(); i = { blockedOn: null, target: i, priority: e }; for (var t = 0; t < sl.length && e !== 0 && e < sl[t].priority; t++); sl.splice(t, 0, i), t === 0 && LB(i) } }; function T1(i) { return !(!i || i.nodeType !== 1 && i.nodeType !== 9 && i.nodeType !== 11) } function Mv(i) { return !(!i || i.nodeType !== 1 && i.nodeType !== 9 && i.nodeType !== 11 && (i.nodeType !== 8 || i.nodeValue !== " react-mount-point-unstable ")) } function Hb() { } function fz(i, e, t, n, r) { if (r) { if (typeof n == "function") { var s = n; n = function () { var c = Oy(o); s.call(c) } } var o = e2(e, n, i, 0, null, !1, !1, "", Hb); return i._reactRootContainer = o, i[ba] = o.current, yp(i.nodeType === 8 ? i.parentNode : i), eu(), o } for (; r = i.lastChild;)i.removeChild(r); if (typeof n == "function") { var a = n; n = function () { var c = Oy(l); a.call(c) } } var l = S1(i, 0, !1, null, null, !1, !1, "", Hb); return i._reactRootContainer = l, i[ba] = l.current, yp(i.nodeType === 8 ? i.parentNode : i), eu(function () { xv(e, l, t, n) }), l } function wv(i, e, t, n, r) { var s = t._reactRootContainer; if (s) { var o = s; if (typeof r == "function") { var a = r; r = function () { var l = Oy(o); a.call(l) } } xv(e, o, i, r) } else o = fz(t, e, i, r, n); return Oy(o) } RB = function (i) { switch (i.tag) { case 3: var e = i.stateNode; if (e.current.memoizedState.isDehydrated) { var t = Cd(e.pendingLanes); t !== 0 && (JS(e, t | 1), Or(e, qn()), !(Zt & 6) && (rh = qn() + 500, Wl())) } break; case 13: eu(function () { var n = Ra(i, 1); if (n !== null) { var r = yr(); oo(n, i, 1, r) } }), E1(i, 1) } }; YS = function (i) { if (i.tag === 13) { var e = Ra(i, 134217728); if (e !== null) { var t = yr(); oo(e, i, 134217728, t) } E1(i, 134217728) } }; PB = function (i) { if (i.tag === 13) { var e = Ml(i), t = Ra(i, e); if (t !== null) { var n = yr(); oo(t, i, e, n) } E1(i, e) } }; IB = function () { return an }; BB = function (i, e) { var t = an; try { return an = i, e() } finally { an = t } }; IM = function (i, e, t) { switch (e) { case "input": if (SM(i, t), e = t.name, t.type === "radio" && e != null) { for (t = i; t.parentNode;)t = t.parentNode; for (t = t.querySelectorAll("input[name=" + JSON.stringify("" + e) + '][type="radio"]'), e = 0; e < t.length; e++) { var n = t[e]; if (n !== i && n.form === i.form) { var r = dv(n); if (!r) throw Error(Pe(90)); cB(n), SM(n, r) } } } break; case "textarea": fB(i, t); break; case "select": e = t.value, e != null && Df(i, !!t.multiple, e, !1) } }; vB = x1; _B = eu; var hz = { usingClientEntryPoint: !1, Events: [Zp, yf, dv, gB, yB, x1] }, ad = { findFiberByHostInstance: Cc, bundleType: 0, version: "18.2.0", rendererPackageName: "react-dom" }, dz = { bundleType: ad.bundleType, version: ad.version, rendererPackageName: ad.rendererPackageName, rendererConfig: ad.rendererConfig, overrideHookState: null, overrideHookStateDeletePath: null, overrideHookStateRenamePath: null, overrideProps: null, overridePropsDeletePath: null, overridePropsRenamePath: null, setErrorHandler: null, setSuspenseHandler: null, scheduleUpdate: null, currentDispatcherRef: Fa.ReactCurrentDispatcher, findHostInstanceByFiber: function (i) { return i = MB(i), i === null ? null : i.stateNode }, findFiberByHostInstance: ad.findFiberByHostInstance || uz, findHostInstancesForRefresh: null, scheduleRefresh: null, scheduleRoot: null, setRefreshHandler: null, getCurrentFiber: null, reconcilerVersion: "18.2.0-next-9e3b772b8-20220608" }; if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u") { var Cg = __REACT_DEVTOOLS_GLOBAL_HOOK__; if (!Cg.isDisabled && Cg.supportsFiber) try { cv = Cg.inject(dz), Fo = Cg } catch { } } cs.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = hz; cs.createPortal = function (i, e) { var t = 2 < arguments.length && arguments[2] !== void 0 ? arguments[2] : null; if (!T1(e)) throw Error(Pe(200)); return cz(i, e, null, t) }; cs.createRoot = function (i, e) { if (!T1(i)) throw Error(Pe(299)); var t = !1, n = "", r = t2; return e != null && (e.unstable_strictMode === !0 && (t = !0), e.identifierPrefix !== void 0 && (n = e.identifierPrefix), e.onRecoverableError !== void 0 && (r = e.onRecoverableError)), e = S1(i, 1, !1, null, null, t, !1, n, r), i[ba] = e.current, yp(i.nodeType === 8 ? i.parentNode : i), new C1(e) }; cs.findDOMNode = function (i) { if (i == null) return null; if (i.nodeType === 1) return i; var e = i._reactInternals; if (e === void 0) throw typeof i.render == "function" ? Error(Pe(188)) : (i = Object.keys(i).join(","), Error(Pe(268, i))); return i = MB(e), i = i === null ? null : i.stateNode, i }; cs.flushSync = function (i) { return eu(i) }; cs.hydrate = function (i, e, t) { if (!Mv(e)) throw Error(Pe(200)); return wv(null, i, e, !0, t) }; cs.hydrateRoot = function (i, e, t) { if (!T1(i)) throw Error(Pe(405)); var n = t != null && t.hydratedSources || null, r = !1, s = "", o = t2; if (t != null && (t.unstable_strictMode === !0 && (r = !0), t.identifierPrefix !== void 0 && (s = t.identifierPrefix), t.onRecoverableError !== void 0 && (o = t.onRecoverableError)), e = e2(e, null, i, 1, t ?? null, r, !1, s, o), i[ba] = e.current, yp(i), n) for (i = 0; i < n.length; i++)t = n[i], r = t._getVersion, r = r(t._source), e.mutableSourceEagerHydrationData == null ? e.mutableSourceEagerHydrationData = [t, r] : e.mutableSourceEagerHydrationData.push(t, r); return new Av(e) }; cs.render = function (i, e, t) { if (!Mv(e)) throw Error(Pe(200)); return wv(null, i, e, !1, t) }; cs.unmountComponentAtNode = function (i) { if (!Mv(i)) throw Error(Pe(40)); return i._reactRootContainer ? (eu(function () { wv(null, null, i, !1, function () { i._reactRootContainer = null, i[ba] = null }) }), !0) : !1 }; cs.unstable_batchedUpdates = x1; cs.unstable_renderSubtreeIntoContainer = function (i, e, t, n) { if (!Mv(t)) throw Error(Pe(200)); if (i == null || i._reactInternals === void 0) throw Error(Pe(38)); return wv(i, e, t, !1, n) }; cs.version = "18.2.0-next-9e3b772b8-20220608"; function n2() { if (!(typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ > "u" || typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE != "function")) try { __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(n2) } catch (i) { console.error(i) } } n2(), eB.exports = cs; var pz = eB.exports, Gb = pz; yM.createRoot = Gb.createRoot, yM.hydrateRoot = Gb.hydrateRoot;/**
 * @remix-run/router v1.8.0
 *
 * Copyright (c) Remix Software Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE.md file in the root directory of this source tree.
 *
 * @license MIT
 */function Cp() { return Cp = Object.assign ? Object.assign.bind() : function (i) { for (var e = 1; e < arguments.length; e++) { var t = arguments[e]; for (var n in t) Object.prototype.hasOwnProperty.call(t, n) && (i[n] = t[n]) } return i }, Cp.apply(this, arguments) } var Rc; (function (i) { i.Pop = "POP", i.Push = "PUSH", i.Replace = "REPLACE" })(Rc || (Rc = {})); const Vb = "popstate"; function mz(i) { i === void 0 && (i = {}); function e(n, r) { let { pathname: s, search: o, hash: a } = n.location; return uw("", { pathname: s, search: o, hash: a }, r.state && r.state.usr || null, r.state && r.state.key || "default") } function t(n, r) { return typeof r == "string" ? r : Fy(r) } return yz(e, t, null, i) } function ao(i, e) { if (i === !1 || i === null || typeof i > "u") throw new Error(e) } function gz() { return Math.random().toString(36).substr(2, 8) } function Wb(i, e) { return { usr: i.state, key: i.key, idx: e } } function uw(i, e, t, n) { return t === void 0 && (t = null), Cp({ pathname: typeof i == "string" ? i : i.pathname, search: "", hash: "" }, typeof e == "string" ? Sv(e) : e, { state: t, key: e && e.key || n || gz() }) } function Fy(i) { let { pathname: e = "/", search: t = "", hash: n = "" } = i; return t && t !== "?" && (e += t.charAt(0) === "?" ? t : "?" + t), n && n !== "#" && (e += n.charAt(0) === "#" ? n : "#" + n), e } function Sv(i) { let e = {}; if (i) { let t = i.indexOf("#"); t >= 0 && (e.hash = i.substr(t), i = i.substr(0, t)); let n = i.indexOf("?"); n >= 0 && (e.search = i.substr(n), i = i.substr(0, n)), i && (e.pathname = i) } return e } function yz(i, e, t, n) { n === void 0 && (n = {}); let { window: r = document.defaultView, v5Compat: s = !1 } = n, o = r.history, a = Rc.Pop, l = null, c = f(); c == null && (c = 0, o.replaceState(Cp({}, o.state, { idx: c }), "")); function f() { return (o.state || { idx: null }).idx } function d() { a = Rc.Pop; let x = f(), g = x == null ? null : x - c; c = x, l && l({ action: a, location: _.location, delta: g }) } function p(x, g) { a = Rc.Push; let A = uw(_.location, x, g); t && t(A, x), c = f() + 1; let M = Wb(A, c), S = _.createHref(A); try { o.pushState(M, "", S) } catch (C) { if (C instanceof DOMException && C.name === "DataCloneError") throw C; r.location.assign(S) } s && l && l({ action: a, location: _.location, delta: 1 }) } function m(x, g) { a = Rc.Replace; let A = uw(_.location, x, g); t && t(A, x), c = f(); let M = Wb(A, c), S = _.createHref(A); o.replaceState(M, "", S), s && l && l({ action: a, location: _.location, delta: 0 }) } function y(x) { let g = r.location.origin !== "null" ? r.location.origin : r.location.href, A = typeof x == "string" ? x : Fy(x); return ao(g, "No window.location.(origin|href) available to create URL for href: " + A), new URL(A, g) } let _ = { get action() { return a }, get location() { return i(r, o) }, listen(x) { if (l) throw new Error("A history only accepts one active listener"); return r.addEventListener(Vb, d), l = x, () => { r.removeEventListener(Vb, d), l = null } }, createHref(x) { return e(r, x) }, createURL: y, encodeLocation(x) { let g = y(x); return { pathname: g.pathname, search: g.search, hash: g.hash } }, push: p, replace: m, go(x) { return o.go(x) } }; return _ } var Xb; (function (i) { i.data = "data", i.deferred = "deferred", i.redirect = "redirect", i.error = "error" })(Xb || (Xb = {})); function i2(i, e) { if (e === "/") return i; if (!i.toLowerCase().startsWith(e.toLowerCase())) return null; let t = e.endsWith("/") ? e.length - 1 : e.length, n = i.charAt(t); return n && n !== "/" ? null : i.slice(t) || "/" } function vz(i, e) { e === void 0 && (e = "/"); let { pathname: t, search: n = "", hash: r = "" } = typeof i == "string" ? Sv(i) : i; return { pathname: t ? t.startsWith("/") ? t : _z(t, e) : e, search: xz(n), hash: Az(r) } } function _z(i, e) { let t = e.replace(/\/+$/, "").split("/"); return i.split("/").forEach(r => { r === ".." ? t.length > 1 && t.pop() : r !== "." && t.push(r) }), t.length > 1 ? t.join("/") : "/" } function Hx(i, e, t, n) { return "Cannot include a '" + i + "' character in a manually specified " + ("`to." + e + "` field [" + JSON.stringify(n) + "].  Please separate it out to the ") + ("`to." + t + "` field. Alternatively you may provide the full path as ") + 'a string in <Link to="..."> and the router will parse it for you.' } function r2(i) { return i.filter((e, t) => t === 0 || e.route.path && e.route.path.length > 0) } function s2(i, e, t, n) { n === void 0 && (n = !1); let r; typeof i == "string" ? r = Sv(i) : (r = Cp({}, i), ao(!r.pathname || !r.pathname.includes("?"), Hx("?", "pathname", "search", r)), ao(!r.pathname || !r.pathname.includes("#"), Hx("#", "pathname", "hash", r)), ao(!r.search || !r.search.includes("#"), Hx("#", "search", "hash", r))); let s = i === "" || r.pathname === "", o = s ? "/" : r.pathname, a; if (n || o == null) a = t; else { let d = e.length - 1; if (o.startsWith("..")) { let p = o.split("/"); for (; p[0] === "..";)p.shift(), d -= 1; r.pathname = p.join("/") } a = d >= 0 ? e[d] : "/" } let l = vz(r, a), c = o && o !== "/" && o.endsWith("/"), f = (s || o === ".") && t.endsWith("/"); return !l.pathname.endsWith("/") && (c || f) && (l.pathname += "/"), l } const o2 = i => i.join("/").replace(/\/\/+/g, "/"), xz = i => !i || i === "?" ? "" : i.startsWith("?") ? i : "?" + i, Az = i => !i || i === "#" ? "" : i.startsWith("#") ? i : "#" + i, a2 = ["post", "put", "patch", "delete"]; new Set(a2); const Mz = ["get", ...a2]; new Set(Mz);/**
 * React Router v6.15.0
 *
 * Copyright (c) Remix Software Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE.md file in the root directory of this source tree.
 *
 * @license MIT
 */function fw() { return fw = Object.assign ? Object.assign.bind() : function (i) { for (var e = 1; e < arguments.length; e++) { var t = arguments[e]; for (var n in t) Object.prototype.hasOwnProperty.call(t, n) && (i[n] = t[n]) } return i }, fw.apply(this, arguments) } const l2 = ce.createContext(null), wz = ce.createContext(null), bh = ce.createContext(null), b1 = ce.createContext(null), Ev = ce.createContext({ outlet: null, matches: [], isDataRoute: !1 }); function Sz(i, e) { let { relative: t } = e === void 0 ? {} : e; Cv() || ao(!1); let { basename: n, navigator: r } = ce.useContext(bh), { hash: s, pathname: o, search: a } = R1(i, { relative: t }), l = o; return n !== "/" && (l = o === "/" ? n : o2([n, o])), r.createHref({ pathname: l, search: a, hash: s }) } function Cv() { return ce.useContext(b1) != null } function Tv() { return Cv() || ao(!1), ce.useContext(b1).location } function c2(i) { ce.useContext(bh).static || ce.useLayoutEffect(i) } function Ez() { let { isDataRoute: i } = ce.useContext(Ev); return i ? Pz() : Cz() } function Cz() { Cv() || ao(!1); let i = ce.useContext(l2), { basename: e, navigator: t } = ce.useContext(bh), { matches: n } = ce.useContext(Ev), { pathname: r } = Tv(), s = JSON.stringify(r2(n).map(l => l.pathnameBase)), o = ce.useRef(!1); return c2(() => { o.current = !0 }), ce.useCallback(function (l, c) { if (c === void 0 && (c = {}), !o.current) return; if (typeof l == "number") { t.go(l); return } let f = s2(l, JSON.parse(s), r, c.relative === "path"); i == null && e !== "/" && (f.pathname = f.pathname === "/" ? e : o2([e, f.pathname])), (c.replace ? t.replace : t.push)(f, c.state, c) }, [e, t, s, r, i]) } function R1(i, e) { let { relative: t } = e === void 0 ? {} : e, { matches: n } = ce.useContext(Ev), { pathname: r } = Tv(), s = JSON.stringify(r2(n).map(o => o.pathnameBase)); return ce.useMemo(() => s2(i, JSON.parse(s), r, t === "path"), [i, s, r, t]) } var u2 = function (i) { return i.UseBlocker = "useBlocker", i.UseRevalidator = "useRevalidator", i.UseNavigateStable = "useNavigate", i }(u2 || {}), f2 = function (i) { return i.UseBlocker = "useBlocker", i.UseLoaderData = "useLoaderData", i.UseActionData = "useActionData", i.UseRouteError = "useRouteError", i.UseNavigation = "useNavigation", i.UseRouteLoaderData = "useRouteLoaderData", i.UseMatches = "useMatches", i.UseRevalidator = "useRevalidator", i.UseNavigateStable = "useNavigate", i.UseRouteId = "useRouteId", i }(f2 || {}); function Tz(i) { let e = ce.useContext(l2); return e || ao(!1), e } function bz(i) { let e = ce.useContext(Ev); return e || ao(!1), e } function Rz(i) { let e = bz(), t = e.matches[e.matches.length - 1]; return t.route.id || ao(!1), t.route.id } function Pz() { let { router: i } = Tz(u2.UseNavigateStable), e = Rz(f2.UseNavigateStable), t = ce.useRef(!1); return c2(() => { t.current = !0 }), ce.useCallback(function (r, s) { s === void 0 && (s = {}), t.current && (typeof r == "number" ? i.navigate(r) : i.navigate(r, fw({ fromRouteId: e }, s))) }, [i, e]) } function Iz(i) { let { basename: e = "/", children: t = null, location: n, navigationType: r = Rc.Pop, navigator: s, static: o = !1 } = i; Cv() && ao(!1); let a = e.replace(/^\/*/, "/"), l = ce.useMemo(() => ({ basename: a, navigator: s, static: o }), [a, s, o]); typeof n == "string" && (n = Sv(n)); let { pathname: c = "/", search: f = "", hash: d = "", state: p = null, key: m = "default" } = n, y = ce.useMemo(() => { let _ = i2(c, a); return _ == null ? null : { location: { pathname: _, search: f, hash: d, state: p, key: m }, navigationType: r } }, [a, c, f, d, p, m, r]); return y == null ? null : ce.createElement(bh.Provider, { value: l }, ce.createElement(b1.Provider, { children: t, value: y })) } new Promise(() => { });/**
 * React Router DOM v6.15.0
 *
 * Copyright (c) Remix Software Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE.md file in the root directory of this source tree.
 *
 * @license MIT
 */function ky() { return ky = Object.assign ? Object.assign.bind() : function (i) { for (var e = 1; e < arguments.length; e++) { var t = arguments[e]; for (var n in t) Object.prototype.hasOwnProperty.call(t, n) && (i[n] = t[n]) } return i }, ky.apply(this, arguments) } function h2(i, e) { if (i == null) return {}; var t = {}, n = Object.keys(i), r, s; for (s = 0; s < n.length; s++)r = n[s], !(e.indexOf(r) >= 0) && (t[r] = i[r]); return t } function Bz(i) { return !!(i.metaKey || i.altKey || i.ctrlKey || i.shiftKey) } function Lz(i, e) { return i.button === 0 && (!e || e === "_self") && !Bz(i) } const Dz = ["onClick", "relative", "reloadDocument", "replace", "state", "target", "to", "preventScrollReset"], Oz = ["aria-current", "caseSensitive", "className", "end", "style", "to", "children"], Fz = "startTransition", Jb = rU[Fz]; function kz(i) { let { basename: e, children: t, future: n, window: r } = i, s = ce.useRef(); s.current == null && (s.current = mz({ window: r, v5Compat: !0 })); let o = s.current, [a, l] = ce.useState({ action: o.action, location: o.location }), { v7_startTransition: c } = n || {}, f = ce.useCallback(d => { c && Jb ? Jb(() => l(d)) : l(d) }, [l, c]); return ce.useLayoutEffect(() => o.listen(f), [o, f]), ce.createElement(Iz, { basename: e, children: t, location: a.location, navigationType: a.action, navigator: o }) } const Nz = typeof window < "u" && typeof window.document < "u" && typeof window.document.createElement < "u", Uz = /^(?:[a-z][a-z0-9+.-]*:|\/\/)/i, d2 = ce.forwardRef(function (e, t) { let { onClick: n, relative: r, reloadDocument: s, replace: o, state: a, target: l, to: c, preventScrollReset: f } = e, d = h2(e, Dz), { basename: p } = ce.useContext(bh), m, y = !1; if (typeof c == "string" && Uz.test(c) && (m = c, Nz)) try { let A = new URL(window.location.href), M = c.startsWith("//") ? new URL(A.protocol + c) : new URL(c), S = i2(M.pathname, p); M.origin === A.origin && S != null ? c = S + M.search + M.hash : y = !0 } catch { } let _ = Sz(c, { relative: r }), x = zz(c, { replace: o, state: a, target: l, preventScrollReset: f, relative: r }); function g(A) { n && n(A), A.defaultPrevented || x(A) } return ce.createElement("a", ky({}, d, { href: m || _, onClick: y || s ? n : g, ref: t, target: l })) }), p2 = ce.forwardRef(function (e, t) { let { "aria-current": n = "page", caseSensitive: r = !1, className: s = "", end: o = !1, style: a, to: l, children: c } = e, f = h2(e, Oz), d = R1(l, { relative: f.relative }), p = Tv(), m = ce.useContext(wz), { navigator: y } = ce.useContext(bh), _ = y.encodeLocation ? y.encodeLocation(d).pathname : d.pathname, x = p.pathname, g = m && m.navigation && m.navigation.location ? m.navigation.location.pathname : null; r || (x = x.toLowerCase(), g = g ? g.toLowerCase() : null, _ = _.toLowerCase()); let A = x === _ || !o && x.startsWith(_) && x.charAt(_.length) === "/", M = g != null && (g === _ || !o && g.startsWith(_) && g.charAt(_.length) === "/"), S = A ? n : void 0, C; typeof s == "function" ? C = s({ isActive: A, isPending: M }) : C = [s, A ? "active" : null, M ? "pending" : null].filter(Boolean).join(" "); let T = typeof a == "function" ? a({ isActive: A, isPending: M }) : a; return ce.createElement(d2, ky({}, f, { "aria-current": S, className: C, ref: t, style: T, to: l }), typeof c == "function" ? c({ isActive: A, isPending: M }) : c) }); var Yb; (function (i) { i.UseScrollRestoration = "useScrollRestoration", i.UseSubmit = "useSubmit", i.UseSubmitFetcher = "useSubmitFetcher", i.UseFetcher = "useFetcher" })(Yb || (Yb = {})); var jb; (function (i) { i.UseFetchers = "useFetchers", i.UseScrollRestoration = "useScrollRestoration" })(jb || (jb = {})); function zz(i, e) { let { target: t, replace: n, state: r, preventScrollReset: s, relative: o } = e === void 0 ? {} : e, a = Ez(), l = Tv(), c = R1(i, { relative: o }); return ce.useCallback(f => { if (Lz(f, t)) { f.preventDefault(); let d = n !== void 0 ? n : Fy(l) === Fy(c); a(i, { replace: d, state: r, preventScrollReset: s, relative: o }) } }, [l, a, c, n, r, t, i, s, o]) }/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */var hw = function () { return hw = Object.assign || function (e) { for (var t, n = 1, r = arguments.length; n < r; n++) { t = arguments[n]; for (var s in t) Object.prototype.hasOwnProperty.call(t, s) && (e[s] = t[s]) } return e }, hw.apply(this, arguments) }; function Hz(i, e) { var t = {}; for (var n in i) Object.prototype.hasOwnProperty.call(i, n) && e.indexOf(n) < 0 && (t[n] = i[n]); if (i != null && typeof Object.getOwnPropertySymbols == "function") for (var r = 0, n = Object.getOwnPropertySymbols(i); r < n.length; r++)e.indexOf(n[r]) < 0 && Object.prototype.propertyIsEnumerable.call(i, n[r]) && (t[n[r]] = i[n[r]]); return t } var zf = "", Wd = null, X0 = null, m2 = null; function P1() { zf = "", Wd !== null && Wd.disconnect(), X0 !== null && (window.clearTimeout(X0), X0 = null) } function Kb(i) { var e = ["BUTTON", "INPUT", "SELECT", "TEXTAREA"], t = ["A", "AREA"]; return e.includes(i.tagName) && !i.hasAttribute("disabled") || t.includes(i.tagName) && i.hasAttribute("href") } function qb() { var i = null; if (zf === "#") i = document.body; else { var e = zf.replace("#", ""); i = document.getElementById(e), i === null && zf === "#top" && (i = document.body) } if (i !== null) { m2(i); var t = i.getAttribute("tabindex"); return t === null && !Kb(i) && i.setAttribute("tabindex", -1), i.focus({ preventScroll: !0 }), t === null && !Kb(i) && (i.blur(), i.removeAttribute("tabindex")), P1(), !0 } return !1 } function Gz(i) { window.setTimeout(function () { qb() === !1 && (Wd === null && (Wd = new MutationObserver(qb)), Wd.observe(document, { attributes: !0, childList: !0, subtree: !0 }), X0 = window.setTimeout(function () { P1() }, i || 1e4)) }, 0) } function g2(i) { return Qf.forwardRef(function (e, t) { var n = ""; typeof e.to == "string" && e.to.includes("#") ? n = "#" + e.to.split("#").slice(1).join("#") : typeof e.to == "object" && typeof e.to.hash == "string" && (n = e.to.hash); var r = {}; i === p2 && (r.isActive = function (a, l) { return a && a.isExact && l.hash === n }); function s(a) { P1(), zf = e.elementId ? "#" + e.elementId : n, e.onClick && e.onClick(a), zf !== "" && !a.defaultPrevented && a.button === 0 && (!e.target || e.target === "_self") && !(a.metaKey || a.altKey || a.ctrlKey || a.shiftKey) && (m2 = e.scroll || function (l) { return e.smooth ? l.scrollIntoView({ behavior: "smooth" }) : l.scrollIntoView() }, Gz(e.timeout)) } var o = Hz(e, ["scroll", "smooth", "timeout", "elementId"]); return Qf.createElement(i, hw({}, r, o, { onClick: s, ref: t }), e.children) }) } var Tg = g2(d2); g2(p2); const Vz = () => { const [i, e] = ce.useState(!0), t = () => { window.scrollY > 80 && e(window.scrollY < n), n = window.scrollY }; let n = 0; return ce.useEffect(() => (window.addEventListener("scroll", t), () => { window.removeEventListener("scroll", t) }), []), Re.jsxs("ul", { className: `navbar ${i ? "show" : "hide"}`, children: [Re.jsxs("div", { className: "navList", children: [Re.jsx("li", { className: "navLi", children: Re.jsx(Tg, { to: "#front", smooth: !0, children: "Home" }) }), Re.jsx("li", { className: "navLi", children: Re.jsx(Tg, { to: "#projects", smooth: !0, children: "Projects" }) }), Re.jsx("li", { className: "navLi", children: Re.jsx(Tg, { to: "#interests", smooth: !0, children: "Interests" }) }), Re.jsx("li", { className: "navLi", children: Re.jsx(Tg, { to: "#contact", smooth: !0, children: "Contact" }) })] }), Re.jsx("div", { className: "navTitle", children: "Welcome to my Portfolio" })] }) }; const Wz = () => Re.jsxs("div", { className: "frontContainer ", id: "front", children: [Re.jsxs("div", { className: "frontSection", children: [Re.jsx("div", { className: "frontTitle", children: "Hi, I'm Kamil" }), Re.jsx("div", { className: "frontDesc", children: '"Practice Makes Perfect"' })] }), Re.jsx("div", { className: "polygon1" })] }); function fa(i) { if (i === void 0) throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); return i } function y2(i, e) { i.prototype = Object.create(e.prototype), i.prototype.constructor = i, i.__proto__ = e }/*!
 * GSAP 3.12.2
 * https://greensock.com
 *
 * @license Copyright 2008-2023, GreenSock. All rights reserved.
 * Subject to the terms at https://greensock.com/standard-license or for
 * Club GreenSock members, the agreement issued with that membership.
 * @author: Jack Doyle, jack@greensock.com
*/var is = { autoSleep: 120, force3D: "auto", nullTargetWarn: 1, units: { lineHeight: "" } }, sh = { duration: .5, overwrite: !1, delay: 0 }, I1, Qi, Hn, Is = 1e8, fn = 1 / Is, dw = Math.PI * 2, Xz = dw / 4, Jz = 0, v2 = Math.sqrt, Yz = Math.cos, jz = Math.sin, bi = function (e) { return typeof e == "string" }, Wn = function (e) { return typeof e == "function" }, Ia = function (e) { return typeof e == "number" }, B1 = function (e) { return typeof e > "u" }, Xo = function (e) { return typeof e == "object" }, Fr = function (e) { return e !== !1 }, L1 = function () { return typeof window < "u" }, bg = function (e) { return Wn(e) || bi(e) }, _2 = typeof ArrayBuffer == "function" && ArrayBuffer.isView || function () { }, Zi = Array.isArray, pw = /(?:-?\.?\d|\.)+/gi, x2 = /[-+=.]*\d+[.e\-+]*\d*[e\-+]*\d*/g, Sf = /[-+=.]*\d+[.e-]*\d*[a-z%]*/g, Gx = /[-+=.]*\d+\.?\d*(?:e-|e\+)?\d*/gi, A2 = /[+-]=-?[.\d]+/, M2 = /[^,'"\[\]\s]+/gi, Kz = /^[+\-=e\s\d]*\d+[.\d]*([a-z]*|%)\s*$/i, Rn, ws, mw, D1, as = {}, Ny = {}, w2, S2 = function (e) { return (Ny = tu(e, as)) && Ur }, O1 = function (e, t) { return console.warn("Invalid property", e, "set to", t, "Missing plugin? gsap.registerPlugin()") }, Uy = function (e, t) { return !t && console.warn(e) }, E2 = function (e, t) { return e && (as[e] = t) && Ny && (Ny[e] = t) || as }, Tp = function () { return 0 }, qz = { suppressEvents: !0, isStart: !0, kill: !1 }, J0 = { suppressEvents: !0, kill: !1 }, Qz = { suppressEvents: !0 }, F1 = {}, Sl = [], gw = {}, C2, Qr = {}, Vx = {}, Qb = 30, Y0 = [], k1 = "", N1 = function (e) { var t = e[0], n, r; if (Xo(t) || Wn(t) || (e = [e]), !(n = (t._gsap || {}).harness)) { for (r = Y0.length; r-- && !Y0[r].targetTest(t);); n = Y0[r] } for (r = e.length; r--;)e[r] && (e[r]._gsap || (e[r]._gsap = new q2(e[r], n))) || e.splice(r, 1); return e }, Uc = function (e) { return e._gsap || N1(Bs(e))[0]._gsap }, T2 = function (e, t, n) { return (n = e[t]) && Wn(n) ? e[t]() : B1(n) && e.getAttribute && e.getAttribute(t) || n }, kr = function (e, t) { return (e = e.split(",")).forEach(t) || e }, Kn = function (e) { return Math.round(e * 1e5) / 1e5 || 0 }, Li = function (e) { return Math.round(e * 1e7) / 1e7 || 0 }, Hf = function (e, t) { var n = t.charAt(0), r = parseFloat(t.substr(2)); return e = parseFloat(e), n === "+" ? e + r : n === "-" ? e - r : n === "*" ? e * r : e / r }, Zz = function (e, t) { for (var n = t.length, r = 0; e.indexOf(t[r]) < 0 && ++r < n;); return r < n }, zy = function () { var e = Sl.length, t = Sl.slice(0), n, r; for (gw = {}, Sl.length = 0, n = 0; n < e; n++)r = t[n], r && r._lazy && (r.render(r._lazy[0], r._lazy[1], !0)._lazy = 0) }, b2 = function (e, t, n, r) { Sl.length && !Qi && zy(), e.render(t, n, r || Qi && t < 0 && (e._initted || e._startAt)), Sl.length && !Qi && zy() }, R2 = function (e) { var t = parseFloat(e); return (t || t === 0) && (e + "").match(M2).length < 2 ? t : bi(e) ? e.trim() : e }, P2 = function (e) { return e }, Us = function (e, t) { for (var n in t) n in e || (e[n] = t[n]); return e }, $z = function (e) { return function (t, n) { for (var r in n) r in t || r === "duration" && e || r === "ease" || (t[r] = n[r]) } }, tu = function (e, t) { for (var n in t) e[n] = t[n]; return e }, Zb = function i(e, t) { for (var n in t) n !== "__proto__" && n !== "constructor" && n !== "prototype" && (e[n] = Xo(t[n]) ? i(e[n] || (e[n] = {}), t[n]) : t[n]); return e }, Hy = function (e, t) { var n = {}, r; for (r in e) r in t || (n[r] = e[r]); return n }, Xd = function (e) { var t = e.parent || Rn, n = e.keyframes ? $z(Zi(e.keyframes)) : Us; if (Fr(e.inherit)) for (; t;)n(e, t.vars.defaults), t = t.parent || t._dp; return e }, eH = function (e, t) { for (var n = e.length, r = n === t.length; r && n-- && e[n] === t[n];); return n < 0 }, I2 = function (e, t, n, r, s) { n === void 0 && (n = "_first"), r === void 0 && (r = "_last"); var o = e[r], a; if (s) for (a = t[s]; o && o[s] > a;)o = o._prev; return o ? (t._next = o._next, o._next = t) : (t._next = e[n], e[n] = t), t._next ? t._next._prev = t : e[r] = t, t._prev = o, t.parent = t._dp = e, t }, bv = function (e, t, n, r) { n === void 0 && (n = "_first"), r === void 0 && (r = "_last"); var s = t._prev, o = t._next; s ? s._next = o : e[n] === t && (e[n] = o), o ? o._prev = s : e[r] === t && (e[r] = s), t._next = t._prev = t.parent = null }, Dl = function (e, t) { e.parent && (!t || e.parent.autoRemoveChildren) && e.parent.remove && e.parent.remove(e), e._act = 0 }, zc = function (e, t) { if (e && (!t || t._end > e._dur || t._start < 0)) for (var n = e; n;)n._dirty = 1, n = n.parent; return e }, tH = function (e) { for (var t = e.parent; t && t.parent;)t._dirty = 1, t.totalDuration(), t = t.parent; return e }, yw = function (e, t, n, r) { return e._startAt && (Qi ? e._startAt.revert(J0) : e.vars.immediateRender && !e.vars.autoRevert || e._startAt.render(t, !0, r)) }, nH = function i(e) { return !e || e._ts && i(e.parent) }, $b = function (e) { return e._repeat ? oh(e._tTime, e = e.duration() + e._rDelay) * e : 0 }, oh = function (e, t) { var n = Math.floor(e /= t); return e && n === e ? n - 1 : n }, Gy = function (e, t) { return (e - t._start) * t._ts + (t._ts >= 0 ? 0 : t._dirty ? t.totalDuration() : t._tDur) }, Rv = function (e) { return e._end = Li(e._start + (e._tDur / Math.abs(e._ts || e._rts || fn) || 0)) }, Pv = function (e, t) { var n = e._dp; return n && n.smoothChildTiming && e._ts && (e._start = Li(n._time - (e._ts > 0 ? t / e._ts : ((e._dirty ? e.totalDuration() : e._tDur) - t) / -e._ts)), Rv(e), n._dirty || zc(n, e)), e }, B2 = function (e, t) { var n; if ((t._time || !t._dur && t._initted || t._start < e._time && (t._dur || !t.add)) && (n = Gy(e.rawTime(), t), (!t._dur || em(0, t.totalDuration(), n) - t._tTime > fn) && t.render(n, !0)), zc(e, t)._dp && e._initted && e._time >= e._dur && e._ts) { if (e._dur < e.duration()) for (n = e; n._dp;)n.rawTime() >= 0 && n.totalTime(n._tTime), n = n._dp; e._zTime = -fn } }, Bo = function (e, t, n, r) { return t.parent && Dl(t), t._start = Li((Ia(n) ? n : n || e !== Rn ? Ms(e, n, t) : e._time) + t._delay), t._end = Li(t._start + (t.totalDuration() / Math.abs(t.timeScale()) || 0)), I2(e, t, "_first", "_last", e._sort ? "_start" : 0), vw(t) || (e._recent = t), r || B2(e, t), e._ts < 0 && Pv(e, e._tTime), e }, L2 = function (e, t) { return (as.ScrollTrigger || O1("scrollTrigger", t)) && as.ScrollTrigger.create(t, e) }, D2 = function (e, t, n, r, s) { if (z1(e, t, s), !e._initted) return 1; if (!n && e._pt && !Qi && (e._dur && e.vars.lazy !== !1 || !e._dur && e.vars.lazy) && C2 !== Zr.frame) return Sl.push(e), e._lazy = [s, r], 1 }, iH = function i(e) { var t = e.parent; return t && t._ts && t._initted && !t._lock && (t.rawTime() < 0 || i(t)) }, vw = function (e) { var t = e.data; return t === "isFromStart" || t === "isStart" }, rH = function (e, t, n, r) { var s = e.ratio, o = t < 0 || !t && (!e._start && iH(e) && !(!e._initted && vw(e)) || (e._ts < 0 || e._dp._ts < 0) && !vw(e)) ? 0 : 1, a = e._rDelay, l = 0, c, f, d; if (a && e._repeat && (l = em(0, e._tDur, t), f = oh(l, a), e._yoyo && f & 1 && (o = 1 - o), f !== oh(e._tTime, a) && (s = 1 - o, e.vars.repeatRefresh && e._initted && e.invalidate())), o !== s || Qi || r || e._zTime === fn || !t && e._zTime) { if (!e._initted && D2(e, t, r, n, l)) return; for (d = e._zTime, e._zTime = t || (n ? fn : 0), n || (n = t && !d), e.ratio = o, e._from && (o = 1 - o), e._time = 0, e._tTime = l, c = e._pt; c;)c.r(o, c.d), c = c._next; t < 0 && yw(e, t, n, !0), e._onUpdate && !n && Ls(e, "onUpdate"), l && e._repeat && !n && e.parent && Ls(e, "onRepeat"), (t >= e._tDur || t < 0) && e.ratio === o && (o && Dl(e, 1), !n && !Qi && (Ls(e, o ? "onComplete" : "onReverseComplete", !0), e._prom && e._prom())) } else e._zTime || (e._zTime = t) }, sH = function (e, t, n) { var r; if (n > t) for (r = e._first; r && r._start <= n;) { if (r.data === "isPause" && r._start > t) return r; r = r._next } else for (r = e._last; r && r._start >= n;) { if (r.data === "isPause" && r._start < t) return r; r = r._prev } }, ah = function (e, t, n, r) { var s = e._repeat, o = Li(t) || 0, a = e._tTime / e._tDur; return a && !r && (e._time *= o / e._dur), e._dur = o, e._tDur = s ? s < 0 ? 1e10 : Li(o * (s + 1) + e._rDelay * s) : o, a > 0 && !r && Pv(e, e._tTime = e._tDur * a), e.parent && Rv(e), n || zc(e.parent, e), e }, eR = function (e) { return e instanceof Rr ? zc(e) : ah(e, e._dur) }, oH = { _start: 0, endTime: Tp, totalDuration: Tp }, Ms = function i(e, t, n) { var r = e.labels, s = e._recent || oH, o = e.duration() >= Is ? s.endTime(!1) : e._dur, a, l, c; return bi(t) && (isNaN(t) || t in r) ? (l = t.charAt(0), c = t.substr(-1) === "%", a = t.indexOf("="), l === "<" || l === ">" ? (a >= 0 && (t = t.replace(/=/, "")), (l === "<" ? s._start : s.endTime(s._repeat >= 0)) + (parseFloat(t.substr(1)) || 0) * (c ? (a < 0 ? s : n).totalDuration() / 100 : 1)) : a < 0 ? (t in r || (r[t] = o), r[t]) : (l = parseFloat(t.charAt(a - 1) + t.substr(a + 1)), c && n && (l = l / 100 * (Zi(n) ? n[0] : n).totalDuration()), a > 1 ? i(e, t.substr(0, a - 1), n) + l : o + l)) : t == null ? o : +t }, Jd = function (e, t, n) { var r = Ia(t[1]), s = (r ? 2 : 1) + (e < 2 ? 0 : 1), o = t[s], a, l; if (r && (o.duration = t[1]), o.parent = n, e) { for (a = o, l = n; l && !("immediateRender" in a);)a = l.vars.defaults || {}, l = Fr(l.vars.inherit) && l.parent; o.immediateRender = Fr(a.immediateRender), e < 2 ? o.runBackwards = 1 : o.startAt = t[s - 1] } return new ii(t[0], o, t[s + 1]) }, Xl = function (e, t) { return e || e === 0 ? t(e) : t }, em = function (e, t, n) { return n < e ? e : n > t ? t : n }, qi = function (e, t) { return !bi(e) || !(t = Kz.exec(e)) ? "" : t[1] }, aH = function (e, t, n) { return Xl(n, function (r) { return em(e, t, r) }) }, _w = [].slice, O2 = function (e, t) { return e && Xo(e) && "length" in e && (!t && !e.length || e.length - 1 in e && Xo(e[0])) && !e.nodeType && e !== ws }, lH = function (e, t, n) { return n === void 0 && (n = []), e.forEach(function (r) { var s; return bi(r) && !t || O2(r, 1) ? (s = n).push.apply(s, Bs(r)) : n.push(r) }) || n }, Bs = function (e, t, n) { return Hn && !t && Hn.selector ? Hn.selector(e) : bi(e) && !n && (mw || !lh()) ? _w.call((t || D1).querySelectorAll(e), 0) : Zi(e) ? lH(e, n) : O2(e) ? _w.call(e, 0) : e ? [e] : [] }, xw = function (e) { return e = Bs(e)[0] || Uy("Invalid scope") || {}, function (t) { var n = e.current || e.nativeElement || e; return Bs(t, n.querySelectorAll ? n : n === e ? Uy("Invalid scope") || D1.createElement("div") : e) } }, F2 = function (e) { return e.sort(function () { return .5 - Math.random() }) }, k2 = function (e) { if (Wn(e)) return e; var t = Xo(e) ? e : { each: e }, n = Hc(t.ease), r = t.from || 0, s = parseFloat(t.base) || 0, o = {}, a = r > 0 && r < 1, l = isNaN(r) || a, c = t.axis, f = r, d = r; return bi(r) ? f = d = { center: .5, edges: .5, end: 1 }[r] || 0 : !a && l && (f = r[0], d = r[1]), function (p, m, y) { var _ = (y || t).length, x = o[_], g, A, M, S, C, T, R, B, b; if (!x) { if (b = t.grid === "auto" ? 0 : (t.grid || [1, Is])[1], !b) { for (R = -Is; R < (R = y[b++].getBoundingClientRect().left) && b < _;); b-- } for (x = o[_] = [], g = l ? Math.min(b, _) * f - .5 : r % b, A = b === Is ? 0 : l ? _ * d / b - .5 : r / b | 0, R = 0, B = Is, T = 0; T < _; T++)M = T % b - g, S = A - (T / b | 0), x[T] = C = c ? Math.abs(c === "y" ? S : M) : v2(M * M + S * S), C > R && (R = C), C < B && (B = C); r === "random" && F2(x), x.max = R - B, x.min = B, x.v = _ = (parseFloat(t.amount) || parseFloat(t.each) * (b > _ ? _ - 1 : c ? c === "y" ? _ / b : b : Math.max(b, _ / b)) || 0) * (r === "edges" ? -1 : 1), x.b = _ < 0 ? s - _ : s, x.u = qi(t.amount || t.each) || 0, n = n && _ < 0 ? Y2(n) : n } return _ = (x[p] - x.min) / x.max || 0, Li(x.b + (n ? n(_) : _) * x.v) + x.u } }, Aw = function (e) { var t = Math.pow(10, ((e + "").split(".")[1] || "").length); return function (n) { var r = Li(Math.round(parseFloat(n) / e) * e * t); return (r - r % 1) / t + (Ia(n) ? 0 : qi(n)) } }, N2 = function (e, t) { var n = Zi(e), r, s; return !n && Xo(e) && (r = n = e.radius || Is, e.values ? (e = Bs(e.values), (s = !Ia(e[0])) && (r *= r)) : e = Aw(e.increment)), Xl(t, n ? Wn(e) ? function (o) { return s = e(o), Math.abs(s - o) <= r ? s : o } : function (o) { for (var a = parseFloat(s ? o.x : o), l = parseFloat(s ? o.y : 0), c = Is, f = 0, d = e.length, p, m; d--;)s ? (p = e[d].x - a, m = e[d].y - l, p = p * p + m * m) : p = Math.abs(e[d] - a), p < c && (c = p, f = d); return f = !r || c <= r ? e[f] : o, s || f === o || Ia(o) ? f : f + qi(o) } : Aw(e)) }, U2 = function (e, t, n, r) { return Xl(Zi(e) ? !t : n === !0 ? !!(n = 0) : !r, function () { return Zi(e) ? e[~~(Math.random() * e.length)] : (n = n || 1e-5) && (r = n < 1 ? Math.pow(10, (n + "").length - 2) : 1) && Math.floor(Math.round((e - n / 2 + Math.random() * (t - e + n * .99)) / n) * n * r) / r }) }, cH = function () { for (var e = arguments.length, t = new Array(e), n = 0; n < e; n++)t[n] = arguments[n]; return function (r) { return t.reduce(function (s, o) { return o(s) }, r) } }, uH = function (e, t) { return function (n) { return e(parseFloat(n)) + (t || qi(n)) } }, fH = function (e, t, n) { return H2(e, t, 0, 1, n) }, z2 = function (e, t, n) { return Xl(n, function (r) { return e[~~t(r)] }) }, hH = function i(e, t, n) { var r = t - e; return Zi(e) ? z2(e, i(0, e.length), t) : Xl(n, function (s) { return (r + (s - e) % r) % r + e }) }, dH = function i(e, t, n) { var r = t - e, s = r * 2; return Zi(e) ? z2(e, i(0, e.length - 1), t) : Xl(n, function (o) { return o = (s + (o - e) % s) % s || 0, e + (o > r ? s - o : o) }) }, bp = function (e) { for (var t = 0, n = "", r, s, o, a; ~(r = e.indexOf("random(", t));)o = e.indexOf(")", r), a = e.charAt(r + 7) === "[", s = e.substr(r + 7, o - r - 7).match(a ? M2 : pw), n += e.substr(t, r - t) + U2(a ? s : +s[0], a ? 0 : +s[1], +s[2] || 1e-5), t = o + 1; return n + e.substr(t, e.length - t) }, H2 = function (e, t, n, r, s) { var o = t - e, a = r - n; return Xl(s, function (l) { return n + ((l - e) / o * a || 0) }) }, pH = function i(e, t, n, r) { var s = isNaN(e + t) ? 0 : function (m) { return (1 - m) * e + m * t }; if (!s) { var o = bi(e), a = {}, l, c, f, d, p; if (n === !0 && (r = 1) && (n = null), o) e = { p: e }, t = { p: t }; else if (Zi(e) && !Zi(t)) { for (f = [], d = e.length, p = d - 2, c = 1; c < d; c++)f.push(i(e[c - 1], e[c])); d--, s = function (y) { y *= d; var _ = Math.min(p, ~~y); return f[_](y - _) }, n = t } else r || (e = tu(Zi(e) ? [] : {}, e)); if (!f) { for (l in t) U1.call(a, e, l, "get", t[l]); s = function (y) { return V1(y, a) || (o ? e.p : e) } } } return Xl(n, s) }, tR = function (e, t, n) { var r = e.labels, s = Is, o, a, l; for (o in r) a = r[o] - t, a < 0 == !!n && a && s > (a = Math.abs(a)) && (l = o, s = a); return l }, Ls = function (e, t, n) { var r = e.vars, s = r[t], o = Hn, a = e._ctx, l, c, f; if (s) return l = r[t + "Params"], c = r.callbackScope || e, n && Sl.length && zy(), a && (Hn = a), f = l ? s.apply(c, l) : s.call(c), Hn = o, f }, bd = function (e) { return Dl(e), e.scrollTrigger && e.scrollTrigger.kill(!!Qi), e.progress() < 1 && Ls(e, "onInterrupt"), e }, Ef, G2 = [], V2 = function (e) { if (L1() && e) { e = !e.name && e.default || e; var t = e.name, n = Wn(e), r = t && !n && e.init ? function () { this._props = [] } : e, s = { init: Tp, render: V1, add: U1, kill: PH, modifier: RH, rawVars: 0 }, o = { targetTest: 0, get: 0, getSetter: G1, aliases: {}, register: 0 }; if (lh(), e !== r) { if (Qr[t]) return; Us(r, Us(Hy(e, s), o)), tu(r.prototype, tu(s, Hy(e, o))), Qr[r.prop = t] = r, e.targetTest && (Y0.push(r), F1[t] = 1), t = (t === "css" ? "CSS" : t.charAt(0).toUpperCase() + t.substr(1)) + "Plugin" } E2(t, r), e.register && e.register(Ur, r, Nr) } else e && G2.push(e) }, un = 255, Rd = { aqua: [0, un, un], lime: [0, un, 0], silver: [192, 192, 192], black: [0, 0, 0], maroon: [128, 0, 0], teal: [0, 128, 128], blue: [0, 0, un], navy: [0, 0, 128], white: [un, un, un], olive: [128, 128, 0], yellow: [un, un, 0], orange: [un, 165, 0], gray: [128, 128, 128], purple: [128, 0, 128], green: [0, 128, 0], red: [un, 0, 0], pink: [un, 192, 203], cyan: [0, un, un], transparent: [un, un, un, 0] }, Wx = function (e, t, n) { return e += e < 0 ? 1 : e > 1 ? -1 : 0, (e * 6 < 1 ? t + (n - t) * e * 6 : e < .5 ? n : e * 3 < 2 ? t + (n - t) * (2 / 3 - e) * 6 : t) * un + .5 | 0 }, W2 = function (e, t, n) { var r = e ? Ia(e) ? [e >> 16, e >> 8 & un, e & un] : 0 : Rd.black, s, o, a, l, c, f, d, p, m, y; if (!r) { if (e.substr(-1) === "," && (e = e.substr(0, e.length - 1)), Rd[e]) r = Rd[e]; else if (e.charAt(0) === "#") { if (e.length < 6 && (s = e.charAt(1), o = e.charAt(2), a = e.charAt(3), e = "#" + s + s + o + o + a + a + (e.length === 5 ? e.charAt(4) + e.charAt(4) : "")), e.length === 9) return r = parseInt(e.substr(1, 6), 16), [r >> 16, r >> 8 & un, r & un, parseInt(e.substr(7), 16) / 255]; e = parseInt(e.substr(1), 16), r = [e >> 16, e >> 8 & un, e & un] } else if (e.substr(0, 3) === "hsl") { if (r = y = e.match(pw), !t) l = +r[0] % 360 / 360, c = +r[1] / 100, f = +r[2] / 100, o = f <= .5 ? f * (c + 1) : f + c - f * c, s = f * 2 - o, r.length > 3 && (r[3] *= 1), r[0] = Wx(l + 1 / 3, s, o), r[1] = Wx(l, s, o), r[2] = Wx(l - 1 / 3, s, o); else if (~e.indexOf("=")) return r = e.match(x2), n && r.length < 4 && (r[3] = 1), r } else r = e.match(pw) || Rd.transparent; r = r.map(Number) } return t && !y && (s = r[0] / un, o = r[1] / un, a = r[2] / un, d = Math.max(s, o, a), p = Math.min(s, o, a), f = (d + p) / 2, d === p ? l = c = 0 : (m = d - p, c = f > .5 ? m / (2 - d - p) : m / (d + p), l = d === s ? (o - a) / m + (o < a ? 6 : 0) : d === o ? (a - s) / m + 2 : (s - o) / m + 4, l *= 60), r[0] = ~~(l + .5), r[1] = ~~(c * 100 + .5), r[2] = ~~(f * 100 + .5)), n && r.length < 4 && (r[3] = 1), r }, X2 = function (e) { var t = [], n = [], r = -1; return e.split(El).forEach(function (s) { var o = s.match(Sf) || []; t.push.apply(t, o), n.push(r += o.length + 1) }), t.c = n, t }, nR = function (e, t, n) { var r = "", s = (e + r).match(El), o = t ? "hsla(" : "rgba(", a = 0, l, c, f, d; if (!s) return e; if (s = s.map(function (p) { return (p = W2(p, t, 1)) && o + (t ? p[0] + "," + p[1] + "%," + p[2] + "%," + p[3] : p.join(",")) + ")" }), n && (f = X2(e), l = n.c, l.join(r) !== f.c.join(r))) for (c = e.replace(El, "1").split(Sf), d = c.length - 1; a < d; a++)r += c[a] + (~l.indexOf(a) ? s.shift() || o + "0,0,0,0)" : (f.length ? f : s.length ? s : n).shift()); if (!c) for (c = e.split(El), d = c.length - 1; a < d; a++)r += c[a] + s[a]; return r + c[d] }, El = function () { var i = "(?:\\b(?:(?:rgb|rgba|hsl|hsla)\\(.+?\\))|\\B#(?:[0-9a-f]{3,4}){1,2}\\b", e; for (e in Rd) i += "|" + e + "\\b"; return new RegExp(i + ")", "gi") }(), mH = /hsl[a]?\(/, J2 = function (e) { var t = e.join(" "), n; if (El.lastIndex = 0, El.test(t)) return n = mH.test(t), e[1] = nR(e[1], n), e[0] = nR(e[0], n, X2(e[1])), !0 }, Rp, Zr = function () { var i = Date.now, e = 500, t = 33, n = i(), r = n, s = 1e3 / 240, o = s, a = [], l, c, f, d, p, m, y = function _(x) { var g = i() - r, A = x === !0, M, S, C, T; if (g > e && (n += g - t), r += g, C = r - n, M = C - o, (M > 0 || A) && (T = ++d.frame, p = C - d.time * 1e3, d.time = C = C / 1e3, o += M + (M >= s ? 4 : s - M), S = 1), A || (l = c(_)), S) for (m = 0; m < a.length; m++)a[m](C, p, T, x) }; return d = { time: 0, frame: 0, tick: function () { y(!0) }, deltaRatio: function (x) { return p / (1e3 / (x || 60)) }, wake: function () { w2 && (!mw && L1() && (ws = mw = window, D1 = ws.document || {}, as.gsap = Ur, (ws.gsapVersions || (ws.gsapVersions = [])).push(Ur.version), S2(Ny || ws.GreenSockGlobals || !ws.gsap && ws || {}), f = ws.requestAnimationFrame, G2.forEach(V2)), l && d.sleep(), c = f || function (x) { return setTimeout(x, o - d.time * 1e3 + 1 | 0) }, Rp = 1, y(2)) }, sleep: function () { (f ? ws.cancelAnimationFrame : clearTimeout)(l), Rp = 0, c = Tp }, lagSmoothing: function (x, g) { e = x || 1 / 0, t = Math.min(g || 33, e) }, fps: function (x) { s = 1e3 / (x || 240), o = d.time * 1e3 + s }, add: function (x, g, A) { var M = g ? function (S, C, T, R) { x(S, C, T, R), d.remove(M) } : x; return d.remove(x), a[A ? "unshift" : "push"](M), lh(), M }, remove: function (x, g) { ~(g = a.indexOf(x)) && a.splice(g, 1) && m >= g && m-- }, _listeners: a }, d }(), lh = function () { return !Rp && Zr.wake() }, Jt = {}, gH = /^[\d.\-M][\d.\-,\s]/, yH = /["']/g, vH = function (e) { for (var t = {}, n = e.substr(1, e.length - 3).split(":"), r = n[0], s = 1, o = n.length, a, l, c; s < o; s++)l = n[s], a = s !== o - 1 ? l.lastIndexOf(",") : l.length, c = l.substr(0, a), t[r] = isNaN(c) ? c.replace(yH, "").trim() : +c, r = l.substr(a + 1).trim(); return t }, _H = function (e) { var t = e.indexOf("(") + 1, n = e.indexOf(")"), r = e.indexOf("(", t); return e.substring(t, ~r && r < n ? e.indexOf(")", n + 1) : n) }, xH = function (e) { var t = (e + "").split("("), n = Jt[t[0]]; return n && t.length > 1 && n.config ? n.config.apply(null, ~e.indexOf("{") ? [vH(t[1])] : _H(e).split(",").map(R2)) : Jt._CE && gH.test(e) ? Jt._CE("", e) : n }, Y2 = function (e) { return function (t) { return 1 - e(1 - t) } }, j2 = function i(e, t) { for (var n = e._first, r; n;)n instanceof Rr ? i(n, t) : n.vars.yoyoEase && (!n._yoyo || !n._repeat) && n._yoyo !== t && (n.timeline ? i(n.timeline, t) : (r = n._ease, n._ease = n._yEase, n._yEase = r, n._yoyo = t)), n = n._next }, Hc = function (e, t) { return e && (Wn(e) ? e : Jt[e] || xH(e)) || t }, du = function (e, t, n, r) { n === void 0 && (n = function (l) { return 1 - t(1 - l) }), r === void 0 && (r = function (l) { return l < .5 ? t(l * 2) / 2 : 1 - t((1 - l) * 2) / 2 }); var s = { easeIn: t, easeOut: n, easeInOut: r }, o; return kr(e, function (a) { Jt[a] = as[a] = s, Jt[o = a.toLowerCase()] = n; for (var l in s) Jt[o + (l === "easeIn" ? ".in" : l === "easeOut" ? ".out" : ".inOut")] = Jt[a + "." + l] = s[l] }), s }, K2 = function (e) { return function (t) { return t < .5 ? (1 - e(1 - t * 2)) / 2 : .5 + e((t - .5) * 2) / 2 } }, Xx = function i(e, t, n) { var r = t >= 1 ? t : 1, s = (n || (e ? .3 : .45)) / (t < 1 ? t : 1), o = s / dw * (Math.asin(1 / r) || 0), a = function (f) { return f === 1 ? 1 : r * Math.pow(2, -10 * f) * jz((f - o) * s) + 1 }, l = e === "out" ? a : e === "in" ? function (c) { return 1 - a(1 - c) } : K2(a); return s = dw / s, l.config = function (c, f) { return i(e, c, f) }, l }, Jx = function i(e, t) { t === void 0 && (t = 1.70158); var n = function (o) { return o ? --o * o * ((t + 1) * o + t) + 1 : 0 }, r = e === "out" ? n : e === "in" ? function (s) { return 1 - n(1 - s) } : K2(n); return r.config = function (s) { return i(e, s) }, r }; kr("Linear,Quad,Cubic,Quart,Quint,Strong", function (i, e) { var t = e < 5 ? e + 1 : e; du(i + ",Power" + (t - 1), e ? function (n) { return Math.pow(n, t) } : function (n) { return n }, function (n) { return 1 - Math.pow(1 - n, t) }, function (n) { return n < .5 ? Math.pow(n * 2, t) / 2 : 1 - Math.pow((1 - n) * 2, t) / 2 }) }); Jt.Linear.easeNone = Jt.none = Jt.Linear.easeIn; du("Elastic", Xx("in"), Xx("out"), Xx()); (function (i, e) { var t = 1 / e, n = 2 * t, r = 2.5 * t, s = function (a) { return a < t ? i * a * a : a < n ? i * Math.pow(a - 1.5 / e, 2) + .75 : a < r ? i * (a -= 2.25 / e) * a + .9375 : i * Math.pow(a - 2.625 / e, 2) + .984375 }; du("Bounce", function (o) { return 1 - s(1 - o) }, s) })(7.5625, 2.75); du("Expo", function (i) { return i ? Math.pow(2, 10 * (i - 1)) : 0 }); du("Circ", function (i) { return -(v2(1 - i * i) - 1) }); du("Sine", function (i) { return i === 1 ? 1 : -Yz(i * Xz) + 1 }); du("Back", Jx("in"), Jx("out"), Jx()); Jt.SteppedEase = Jt.steps = as.SteppedEase = { config: function (e, t) { e === void 0 && (e = 1); var n = 1 / e, r = e + (t ? 0 : 1), s = t ? 1 : 0, o = 1 - fn; return function (a) { return ((r * em(0, o, a) | 0) + s) * n } } }; sh.ease = Jt["quad.out"]; kr("onComplete,onUpdate,onStart,onRepeat,onReverseComplete,onInterrupt", function (i) { return k1 += i + "," + i + "Params," }); var q2 = function (e, t) { this.id = Jz++, e._gsap = this, this.target = e, this.harness = t, this.get = t ? t.get : T2, this.set = t ? t.getSetter : G1 }, Pp = function () { function i(t) { this.vars = t, this._delay = +t.delay || 0, (this._repeat = t.repeat === 1 / 0 ? -2 : t.repeat || 0) && (this._rDelay = t.repeatDelay || 0, this._yoyo = !!t.yoyo || !!t.yoyoEase), this._ts = 1, ah(this, +t.duration, 1, 1), this.data = t.data, Hn && (this._ctx = Hn, Hn.data.push(this)), Rp || Zr.wake() } var e = i.prototype; return e.delay = function (n) { return n || n === 0 ? (this.parent && this.parent.smoothChildTiming && this.startTime(this._start + n - this._delay), this._delay = n, this) : this._delay }, e.duration = function (n) { return arguments.length ? this.totalDuration(this._repeat > 0 ? n + (n + this._rDelay) * this._repeat : n) : this.totalDuration() && this._dur }, e.totalDuration = function (n) { return arguments.length ? (this._dirty = 0, ah(this, this._repeat < 0 ? n : (n - this._repeat * this._rDelay) / (this._repeat + 1))) : this._tDur }, e.totalTime = function (n, r) { if (lh(), !arguments.length) return this._tTime; var s = this._dp; if (s && s.smoothChildTiming && this._ts) { for (Pv(this, n), !s._dp || s.parent || B2(s, this); s && s.parent;)s.parent._time !== s._start + (s._ts >= 0 ? s._tTime / s._ts : (s.totalDuration() - s._tTime) / -s._ts) && s.totalTime(s._tTime, !0), s = s.parent; !this.parent && this._dp.autoRemoveChildren && (this._ts > 0 && n < this._tDur || this._ts < 0 && n > 0 || !this._tDur && !n) && Bo(this._dp, this, this._start - this._delay) } return (this._tTime !== n || !this._dur && !r || this._initted && Math.abs(this._zTime) === fn || !n && !this._initted && (this.add || this._ptLookup)) && (this._ts || (this._pTime = n), b2(this, n, r)), this }, e.time = function (n, r) { return arguments.length ? this.totalTime(Math.min(this.totalDuration(), n + $b(this)) % (this._dur + this._rDelay) || (n ? this._dur : 0), r) : this._time }, e.totalProgress = function (n, r) { return arguments.length ? this.totalTime(this.totalDuration() * n, r) : this.totalDuration() ? Math.min(1, this._tTime / this._tDur) : this.ratio }, e.progress = function (n, r) { return arguments.length ? this.totalTime(this.duration() * (this._yoyo && !(this.iteration() & 1) ? 1 - n : n) + $b(this), r) : this.duration() ? Math.min(1, this._time / this._dur) : this.ratio }, e.iteration = function (n, r) { var s = this.duration() + this._rDelay; return arguments.length ? this.totalTime(this._time + (n - 1) * s, r) : this._repeat ? oh(this._tTime, s) + 1 : 1 }, e.timeScale = function (n) { if (!arguments.length) return this._rts === -fn ? 0 : this._rts; if (this._rts === n) return this; var r = this.parent && this._ts ? Gy(this.parent._time, this) : this._tTime; return this._rts = +n || 0, this._ts = this._ps || n === -fn ? 0 : this._rts, this.totalTime(em(-Math.abs(this._delay), this._tDur, r), !0), Rv(this), tH(this) }, e.paused = function (n) { return arguments.length ? (this._ps !== n && (this._ps = n, n ? (this._pTime = this._tTime || Math.max(-this._delay, this.rawTime()), this._ts = this._act = 0) : (lh(), this._ts = this._rts, this.totalTime(this.parent && !this.parent.smoothChildTiming ? this.rawTime() : this._tTime || this._pTime, this.progress() === 1 && Math.abs(this._zTime) !== fn && (this._tTime -= fn)))), this) : this._ps }, e.startTime = function (n) { if (arguments.length) { this._start = n; var r = this.parent || this._dp; return r && (r._sort || !this.parent) && Bo(r, this, n - this._delay), this } return this._start }, e.endTime = function (n) { return this._start + (Fr(n) ? this.totalDuration() : this.duration()) / Math.abs(this._ts || 1) }, e.rawTime = function (n) { var r = this.parent || this._dp; return r ? n && (!this._ts || this._repeat && this._time && this.totalProgress() < 1) ? this._tTime % (this._dur + this._rDelay) : this._ts ? Gy(r.rawTime(n), this) : this._tTime : this._tTime }, e.revert = function (n) { n === void 0 && (n = Qz); var r = Qi; return Qi = n, (this._initted || this._startAt) && (this.timeline && this.timeline.revert(n), this.totalTime(-.01, n.suppressEvents)), this.data !== "nested" && n.kill !== !1 && this.kill(), Qi = r, this }, e.globalTime = function (n) { for (var r = this, s = arguments.length ? n : r.rawTime(); r;)s = r._start + s / (r._ts || 1), r = r._dp; return !this.parent && this._sat ? this._sat.vars.immediateRender ? -1 / 0 : this._sat.globalTime(n) : s }, e.repeat = function (n) { return arguments.length ? (this._repeat = n === 1 / 0 ? -2 : n, eR(this)) : this._repeat === -2 ? 1 / 0 : this._repeat }, e.repeatDelay = function (n) { if (arguments.length) { var r = this._time; return this._rDelay = n, eR(this), r ? this.time(r) : this } return this._rDelay }, e.yoyo = function (n) { return arguments.length ? (this._yoyo = n, this) : this._yoyo }, e.seek = function (n, r) { return this.totalTime(Ms(this, n), Fr(r)) }, e.restart = function (n, r) { return this.play().totalTime(n ? -this._delay : 0, Fr(r)) }, e.play = function (n, r) { return n != null && this.seek(n, r), this.reversed(!1).paused(!1) }, e.reverse = function (n, r) { return n != null && this.seek(n || this.totalDuration(), r), this.reversed(!0).paused(!1) }, e.pause = function (n, r) { return n != null && this.seek(n, r), this.paused(!0) }, e.resume = function () { return this.paused(!1) }, e.reversed = function (n) { return arguments.length ? (!!n !== this.reversed() && this.timeScale(-this._rts || (n ? -fn : 0)), this) : this._rts < 0 }, e.invalidate = function () { return this._initted = this._act = 0, this._zTime = -fn, this }, e.isActive = function () { var n = this.parent || this._dp, r = this._start, s; return !!(!n || this._ts && this._initted && n.isActive() && (s = n.rawTime(!0)) >= r && s < this.endTime(!0) - fn) }, e.eventCallback = function (n, r, s) { var o = this.vars; return arguments.length > 1 ? (r ? (o[n] = r, s && (o[n + "Params"] = s), n === "onUpdate" && (this._onUpdate = r)) : delete o[n], this) : o[n] }, e.then = function (n) { var r = this; return new Promise(function (s) { var o = Wn(n) ? n : P2, a = function () { var c = r.then; r.then = null, Wn(o) && (o = o(r)) && (o.then || o === r) && (r.then = c), s(o), r.then = c }; r._initted && r.totalProgress() === 1 && r._ts >= 0 || !r._tTime && r._ts < 0 ? a() : r._prom = a }) }, e.kill = function () { bd(this) }, i }(); Us(Pp.prototype, { _time: 0, _start: 0, _end: 0, _tTime: 0, _tDur: 0, _dirty: 0, _repeat: 0, _yoyo: !1, parent: null, _initted: !1, _rDelay: 0, _ts: 1, _dp: 0, ratio: 0, _zTime: -fn, _prom: 0, _ps: !1, _rts: 1 }); var Rr = function (i) { y2(e, i); function e(n, r) { var s; return n === void 0 && (n = {}), s = i.call(this, n) || this, s.labels = {}, s.smoothChildTiming = !!n.smoothChildTiming, s.autoRemoveChildren = !!n.autoRemoveChildren, s._sort = Fr(n.sortChildren), Rn && Bo(n.parent || Rn, fa(s), r), n.reversed && s.reverse(), n.paused && s.paused(!0), n.scrollTrigger && L2(fa(s), n.scrollTrigger), s } var t = e.prototype; return t.to = function (r, s, o) { return Jd(0, arguments, this), this }, t.from = function (r, s, o) { return Jd(1, arguments, this), this }, t.fromTo = function (r, s, o, a) { return Jd(2, arguments, this), this }, t.set = function (r, s, o) { return s.duration = 0, s.parent = this, Xd(s).repeatDelay || (s.repeat = 0), s.immediateRender = !!s.immediateRender, new ii(r, s, Ms(this, o), 1), this }, t.call = function (r, s, o) { return Bo(this, ii.delayedCall(0, r, s), o) }, t.staggerTo = function (r, s, o, a, l, c, f) { return o.duration = s, o.stagger = o.stagger || a, o.onComplete = c, o.onCompleteParams = f, o.parent = this, new ii(r, o, Ms(this, l)), this }, t.staggerFrom = function (r, s, o, a, l, c, f) { return o.runBackwards = 1, Xd(o).immediateRender = Fr(o.immediateRender), this.staggerTo(r, s, o, a, l, c, f) }, t.staggerFromTo = function (r, s, o, a, l, c, f, d) { return a.startAt = o, Xd(a).immediateRender = Fr(a.immediateRender), this.staggerTo(r, s, a, l, c, f, d) }, t.render = function (r, s, o) { var a = this._time, l = this._dirty ? this.totalDuration() : this._tDur, c = this._dur, f = r <= 0 ? 0 : Li(r), d = this._zTime < 0 != r < 0 && (this._initted || !c), p, m, y, _, x, g, A, M, S, C, T, R; if (this !== Rn && f > l && r >= 0 && (f = l), f !== this._tTime || o || d) { if (a !== this._time && c && (f += this._time - a, r += this._time - a), p = f, S = this._start, M = this._ts, g = !M, d && (c || (a = this._zTime), (r || !s) && (this._zTime = r)), this._repeat) { if (T = this._yoyo, x = c + this._rDelay, this._repeat < -1 && r < 0) return this.totalTime(x * 100 + r, s, o); if (p = Li(f % x), f === l ? (_ = this._repeat, p = c) : (_ = ~~(f / x), _ && _ === f / x && (p = c, _--), p > c && (p = c)), C = oh(this._tTime, x), !a && this._tTime && C !== _ && this._tTime - C * x - this._dur <= 0 && (C = _), T && _ & 1 && (p = c - p, R = 1), _ !== C && !this._lock) { var B = T && C & 1, b = B === (T && _ & 1); if (_ < C && (B = !B), a = B ? 0 : f % c ? c : f, this._lock = 1, this.render(a || (R ? 0 : Li(_ * x)), s, !c)._lock = 0, this._tTime = f, !s && this.parent && Ls(this, "onRepeat"), this.vars.repeatRefresh && !R && (this.invalidate()._lock = 1), a && a !== this._time || g !== !this._ts || this.vars.onRepeat && !this.parent && !this._act) return this; if (c = this._dur, l = this._tDur, b && (this._lock = 2, a = B ? c : -1e-4, this.render(a, !0), this.vars.repeatRefresh && !R && this.invalidate()), this._lock = 0, !this._ts && !g) return this; j2(this, R) } } if (this._hasPause && !this._forcing && this._lock < 2 && (A = sH(this, Li(a), Li(p)), A && (f -= p - (p = A._start))), this._tTime = f, this._time = p, this._act = !M, this._initted || (this._onUpdate = this.vars.onUpdate, this._initted = 1, this._zTime = r, a = 0), !a && p && !s && !_ && (Ls(this, "onStart"), this._tTime !== f)) return this; if (p >= a && r >= 0) for (m = this._first; m;) { if (y = m._next, (m._act || p >= m._start) && m._ts && A !== m) { if (m.parent !== this) return this.render(r, s, o); if (m.render(m._ts > 0 ? (p - m._start) * m._ts : (m._dirty ? m.totalDuration() : m._tDur) + (p - m._start) * m._ts, s, o), p !== this._time || !this._ts && !g) { A = 0, y && (f += this._zTime = -fn); break } } m = y } else { m = this._last; for (var I = r < 0 ? r : p; m;) { if (y = m._prev, (m._act || I <= m._end) && m._ts && A !== m) { if (m.parent !== this) return this.render(r, s, o); if (m.render(m._ts > 0 ? (I - m._start) * m._ts : (m._dirty ? m.totalDuration() : m._tDur) + (I - m._start) * m._ts, s, o || Qi && (m._initted || m._startAt)), p !== this._time || !this._ts && !g) { A = 0, y && (f += this._zTime = I ? -fn : fn); break } } m = y } } if (A && !s && (this.pause(), A.render(p >= a ? 0 : -fn)._zTime = p >= a ? 1 : -1, this._ts)) return this._start = S, Rv(this), this.render(r, s, o); this._onUpdate && !s && Ls(this, "onUpdate", !0), (f === l && this._tTime >= this.totalDuration() || !f && a) && (S === this._start || Math.abs(M) !== Math.abs(this._ts)) && (this._lock || ((r || !c) && (f === l && this._ts > 0 || !f && this._ts < 0) && Dl(this, 1), !s && !(r < 0 && !a) && (f || a || !l) && (Ls(this, f === l && r >= 0 ? "onComplete" : "onReverseComplete", !0), this._prom && !(f < l && this.timeScale() > 0) && this._prom()))) } return this }, t.add = function (r, s) { var o = this; if (Ia(s) || (s = Ms(this, s, r)), !(r instanceof Pp)) { if (Zi(r)) return r.forEach(function (a) { return o.add(a, s) }), this; if (bi(r)) return this.addLabel(r, s); if (Wn(r)) r = ii.delayedCall(0, r); else return this } return this !== r ? Bo(this, r, s) : this }, t.getChildren = function (r, s, o, a) { r === void 0 && (r = !0), s === void 0 && (s = !0), o === void 0 && (o = !0), a === void 0 && (a = -Is); for (var l = [], c = this._first; c;)c._start >= a && (c instanceof ii ? s && l.push(c) : (o && l.push(c), r && l.push.apply(l, c.getChildren(!0, s, o)))), c = c._next; return l }, t.getById = function (r) { for (var s = this.getChildren(1, 1, 1), o = s.length; o--;)if (s[o].vars.id === r) return s[o] }, t.remove = function (r) { return bi(r) ? this.removeLabel(r) : Wn(r) ? this.killTweensOf(r) : (bv(this, r), r === this._recent && (this._recent = this._last), zc(this)) }, t.totalTime = function (r, s) { return arguments.length ? (this._forcing = 1, !this._dp && this._ts && (this._start = Li(Zr.time - (this._ts > 0 ? r / this._ts : (this.totalDuration() - r) / -this._ts))), i.prototype.totalTime.call(this, r, s), this._forcing = 0, this) : this._tTime }, t.addLabel = function (r, s) { return this.labels[r] = Ms(this, s), this }, t.removeLabel = function (r) { return delete this.labels[r], this }, t.addPause = function (r, s, o) { var a = ii.delayedCall(0, s || Tp, o); return a.data = "isPause", this._hasPause = 1, Bo(this, a, Ms(this, r)) }, t.removePause = function (r) { var s = this._first; for (r = Ms(this, r); s;)s._start === r && s.data === "isPause" && Dl(s), s = s._next }, t.killTweensOf = function (r, s, o) { for (var a = this.getTweensOf(r, o), l = a.length; l--;)ul !== a[l] && a[l].kill(r, s); return this }, t.getTweensOf = function (r, s) { for (var o = [], a = Bs(r), l = this._first, c = Ia(s), f; l;)l instanceof ii ? Zz(l._targets, a) && (c ? (!ul || l._initted && l._ts) && l.globalTime(0) <= s && l.globalTime(l.totalDuration()) > s : !s || l.isActive()) && o.push(l) : (f = l.getTweensOf(a, s)).length && o.push.apply(o, f), l = l._next; return o }, t.tweenTo = function (r, s) { s = s || {}; var o = this, a = Ms(o, r), l = s, c = l.startAt, f = l.onStart, d = l.onStartParams, p = l.immediateRender, m, y = ii.to(o, Us({ ease: s.ease || "none", lazy: !1, immediateRender: !1, time: a, overwrite: "auto", duration: s.duration || Math.abs((a - (c && "time" in c ? c.time : o._time)) / o.timeScale()) || fn, onStart: function () { if (o.pause(), !m) { var x = s.duration || Math.abs((a - (c && "time" in c ? c.time : o._time)) / o.timeScale()); y._dur !== x && ah(y, x, 0, 1).render(y._time, !0, !0), m = 1 } f && f.apply(y, d || []) } }, s)); return p ? y.render(0) : y }, t.tweenFromTo = function (r, s, o) { return this.tweenTo(s, Us({ startAt: { time: Ms(this, r) } }, o)) }, t.recent = function () { return this._recent }, t.nextLabel = function (r) { return r === void 0 && (r = this._time), tR(this, Ms(this, r)) }, t.previousLabel = function (r) { return r === void 0 && (r = this._time), tR(this, Ms(this, r), 1) }, t.currentLabel = function (r) { return arguments.length ? this.seek(r, !0) : this.previousLabel(this._time + fn) }, t.shiftChildren = function (r, s, o) { o === void 0 && (o = 0); for (var a = this._first, l = this.labels, c; a;)a._start >= o && (a._start += r, a._end += r), a = a._next; if (s) for (c in l) l[c] >= o && (l[c] += r); return zc(this) }, t.invalidate = function (r) { var s = this._first; for (this._lock = 0; s;)s.invalidate(r), s = s._next; return i.prototype.invalidate.call(this, r) }, t.clear = function (r) { r === void 0 && (r = !0); for (var s = this._first, o; s;)o = s._next, this.remove(s), s = o; return this._dp && (this._time = this._tTime = this._pTime = 0), r && (this.labels = {}), zc(this) }, t.totalDuration = function (r) { var s = 0, o = this, a = o._last, l = Is, c, f, d; if (arguments.length) return o.timeScale((o._repeat < 0 ? o.duration() : o.totalDuration()) / (o.reversed() ? -r : r)); if (o._dirty) { for (d = o.parent; a;)c = a._prev, a._dirty && a.totalDuration(), f = a._start, f > l && o._sort && a._ts && !o._lock ? (o._lock = 1, Bo(o, a, f - a._delay, 1)._lock = 0) : l = f, f < 0 && a._ts && (s -= f, (!d && !o._dp || d && d.smoothChildTiming) && (o._start += f / o._ts, o._time -= f, o._tTime -= f), o.shiftChildren(-f, !1, -1 / 0), l = 0), a._end > s && a._ts && (s = a._end), a = c; ah(o, o === Rn && o._time > s ? o._time : s, 1, 1), o._dirty = 0 } return o._tDur }, e.updateRoot = function (r) { if (Rn._ts && (b2(Rn, Gy(r, Rn)), C2 = Zr.frame), Zr.frame >= Qb) { Qb += is.autoSleep || 120; var s = Rn._first; if ((!s || !s._ts) && is.autoSleep && Zr._listeners.length < 2) { for (; s && !s._ts;)s = s._next; s || Zr.sleep() } } }, e }(Pp); Us(Rr.prototype, { _lock: 0, _hasPause: 0, _forcing: 0 }); var AH = function (e, t, n, r, s, o, a) { var l = new Nr(this._pt, e, t, 0, 1, nD, null, s), c = 0, f = 0, d, p, m, y, _, x, g, A; for (l.b = n, l.e = r, n += "", r += "", (g = ~r.indexOf("random(")) && (r = bp(r)), o && (A = [n, r], o(A, e, t), n = A[0], r = A[1]), p = n.match(Gx) || []; d = Gx.exec(r);)y = d[0], _ = r.substring(c, d.index), m ? m = (m + 1) % 5 : _.substr(-5) === "rgba(" && (m = 1), y !== p[f++] && (x = parseFloat(p[f - 1]) || 0, l._pt = { _next: l._pt, p: _ || f === 1 ? _ : ",", s: x, c: y.charAt(1) === "=" ? Hf(x, y) - x : parseFloat(y) - x, m: m && m < 4 ? Math.round : 0 }, c = Gx.lastIndex); return l.c = c < r.length ? r.substring(c, r.length) : "", l.fp = a, (A2.test(r) || g) && (l.e = 0), this._pt = l, l }, U1 = function (e, t, n, r, s, o, a, l, c, f) { Wn(r) && (r = r(s || 0, e, o)); var d = e[t], p = n !== "get" ? n : Wn(d) ? c ? e[t.indexOf("set") || !Wn(e["get" + t.substr(3)]) ? t : "get" + t.substr(3)](c) : e[t]() : d, m = Wn(d) ? c ? CH : eD : H1, y; if (bi(r) && (~r.indexOf("random(") && (r = bp(r)), r.charAt(1) === "=" && (y = Hf(p, r) + (qi(p) || 0), (y || y === 0) && (r = y))), !f || p !== r || Mw) return !isNaN(p * r) && r !== "" ? (y = new Nr(this._pt, e, t, +p || 0, r - (p || 0), typeof d == "boolean" ? bH : tD, 0, m), c && (y.fp = c), a && y.modifier(a, this, e), this._pt = y) : (!d && !(t in e) && O1(t, r), AH.call(this, e, t, p, r, m, l || is.stringFilter, c)) }, MH = function (e, t, n, r, s) { if (Wn(e) && (e = Yd(e, s, t, n, r)), !Xo(e) || e.style && e.nodeType || Zi(e) || _2(e)) return bi(e) ? Yd(e, s, t, n, r) : e; var o = {}, a; for (a in e) o[a] = Yd(e[a], s, t, n, r); return o }, Q2 = function (e, t, n, r, s, o) { var a, l, c, f; if (Qr[e] && (a = new Qr[e]).init(s, a.rawVars ? t[e] : MH(t[e], r, s, o, n), n, r, o) !== !1 && (n._pt = l = new Nr(n._pt, s, e, 0, 1, a.render, a, 0, a.priority), n !== Ef)) for (c = n._ptLookup[n._targets.indexOf(s)], f = a._props.length; f--;)c[a._props[f]] = l; return a }, ul, Mw, z1 = function i(e, t, n) { var r = e.vars, s = r.ease, o = r.startAt, a = r.immediateRender, l = r.lazy, c = r.onUpdate, f = r.onUpdateParams, d = r.callbackScope, p = r.runBackwards, m = r.yoyoEase, y = r.keyframes, _ = r.autoRevert, x = e._dur, g = e._startAt, A = e._targets, M = e.parent, S = M && M.data === "nested" ? M.vars.targets : A, C = e._overwrite === "auto" && !I1, T = e.timeline, R, B, b, I, N, V, J, j, q, ne, Q, F, Y; if (T && (!y || !s) && (s = "none"), e._ease = Hc(s, sh.ease), e._yEase = m ? Y2(Hc(m === !0 ? s : m, sh.ease)) : 0, m && e._yoyo && !e._repeat && (m = e._yEase, e._yEase = e._ease, e._ease = m), e._from = !T && !!r.runBackwards, !T || y && !r.stagger) { if (j = A[0] ? Uc(A[0]).harness : 0, F = j && r[j.prop], R = Hy(r, F1), g && (g._zTime < 0 && g.progress(1), t < 0 && p && a && !_ ? g.render(-1, !0) : g.revert(p && x ? J0 : qz), g._lazy = 0), o) { if (Dl(e._startAt = ii.set(A, Us({ data: "isStart", overwrite: !1, parent: M, immediateRender: !0, lazy: !g && Fr(l), startAt: null, delay: 0, onUpdate: c, onUpdateParams: f, callbackScope: d, stagger: 0 }, o))), e._startAt._dp = 0, e._startAt._sat = e, t < 0 && (Qi || !a && !_) && e._startAt.revert(J0), a && x && t <= 0 && n <= 0) { t && (e._zTime = t); return } } else if (p && x && !g) { if (t && (a = !1), b = Us({ overwrite: !1, data: "isFromStart", lazy: a && !g && Fr(l), immediateRender: a, stagger: 0, parent: M }, R), F && (b[j.prop] = F), Dl(e._startAt = ii.set(A, b)), e._startAt._dp = 0, e._startAt._sat = e, t < 0 && (Qi ? e._startAt.revert(J0) : e._startAt.render(-1, !0)), e._zTime = t, !a) i(e._startAt, fn, fn); else if (!t) return } for (e._pt = e._ptCache = 0, l = x && Fr(l) || l && !x, B = 0; B < A.length; B++) { if (N = A[B], J = N._gsap || N1(A)[B]._gsap, e._ptLookup[B] = ne = {}, gw[J.id] && Sl.length && zy(), Q = S === A ? B : S.indexOf(N), j && (q = new j).init(N, F || R, e, Q, S) !== !1 && (e._pt = I = new Nr(e._pt, N, q.name, 0, 1, q.render, q, 0, q.priority), q._props.forEach(function (L) { ne[L] = I }), q.priority && (V = 1)), !j || F) for (b in R) Qr[b] && (q = Q2(b, R, e, Q, N, S)) ? q.priority && (V = 1) : ne[b] = I = U1.call(e, N, b, "get", R[b], Q, S, 0, r.stringFilter); e._op && e._op[B] && e.kill(N, e._op[B]), C && e._pt && (ul = e, Rn.killTweensOf(N, ne, e.globalTime(t)), Y = !e.parent, ul = 0), e._pt && l && (gw[J.id] = 1) } V && iD(e), e._onInit && e._onInit(e) } e._onUpdate = c, e._initted = (!e._op || e._pt) && !Y, y && t <= 0 && T.render(Is, !0, !0) }, wH = function (e, t, n, r, s, o, a) { var l = (e._pt && e._ptCache || (e._ptCache = {}))[t], c, f, d, p; if (!l) for (l = e._ptCache[t] = [], d = e._ptLookup, p = e._targets.length; p--;) { if (c = d[p][t], c && c.d && c.d._pt) for (c = c.d._pt; c && c.p !== t && c.fp !== t;)c = c._next; if (!c) return Mw = 1, e.vars[t] = "+=0", z1(e, a), Mw = 0, 1; l.push(c) } for (p = l.length; p--;)f = l[p], c = f._pt || f, c.s = (r || r === 0) && !s ? r : c.s + (r || 0) + o * c.c, c.c = n - c.s, f.e && (f.e = Kn(n) + qi(f.e)), f.b && (f.b = c.s + qi(f.b)) }, SH = function (e, t) { var n = e[0] ? Uc(e[0]).harness : 0, r = n && n.aliases, s, o, a, l; if (!r) return t; s = tu({}, t); for (o in r) if (o in s) for (l = r[o].split(","), a = l.length; a--;)s[l[a]] = s[o]; return s }, EH = function (e, t, n, r) { var s = t.ease || r || "power1.inOut", o, a; if (Zi(t)) a = n[e] || (n[e] = []), t.forEach(function (l, c) { return a.push({ t: c / (t.length - 1) * 100, v: l, e: s }) }); else for (o in t) a = n[o] || (n[o] = []), o === "ease" || a.push({ t: parseFloat(e), v: t[o], e: s }) }, Yd = function (e, t, n, r, s) { return Wn(e) ? e.call(t, n, r, s) : bi(e) && ~e.indexOf("random(") ? bp(e) : e }, Z2 = k1 + "repeat,repeatDelay,yoyo,repeatRefresh,yoyoEase,autoRevert", $2 = {}; kr(Z2 + ",id,stagger,delay,duration,paused,scrollTrigger", function (i) { return $2[i] = 1 }); var ii = function (i) { y2(e, i); function e(n, r, s, o) { var a; typeof r == "number" && (s.duration = r, r = s, s = null), a = i.call(this, o ? r : Xd(r)) || this; var l = a.vars, c = l.duration, f = l.delay, d = l.immediateRender, p = l.stagger, m = l.overwrite, y = l.keyframes, _ = l.defaults, x = l.scrollTrigger, g = l.yoyoEase, A = r.parent || Rn, M = (Zi(n) || _2(n) ? Ia(n[0]) : "length" in r) ? [n] : Bs(n), S, C, T, R, B, b, I, N; if (a._targets = M.length ? N1(M) : Uy("GSAP target " + n + " not found. https://greensock.com", !is.nullTargetWarn) || [], a._ptLookup = [], a._overwrite = m, y || p || bg(c) || bg(f)) { if (r = a.vars, S = a.timeline = new Rr({ data: "nested", defaults: _ || {}, targets: A && A.data === "nested" ? A.vars.targets : M }), S.kill(), S.parent = S._dp = fa(a), S._start = 0, p || bg(c) || bg(f)) { if (R = M.length, I = p && k2(p), Xo(p)) for (B in p) ~Z2.indexOf(B) && (N || (N = {}), N[B] = p[B]); for (C = 0; C < R; C++)T = Hy(r, $2), T.stagger = 0, g && (T.yoyoEase = g), N && tu(T, N), b = M[C], T.duration = +Yd(c, fa(a), C, b, M), T.delay = (+Yd(f, fa(a), C, b, M) || 0) - a._delay, !p && R === 1 && T.delay && (a._delay = f = T.delay, a._start += f, T.delay = 0), S.to(b, T, I ? I(C, b, M) : 0), S._ease = Jt.none; S.duration() ? c = f = 0 : a.timeline = 0 } else if (y) { Xd(Us(S.vars.defaults, { ease: "none" })), S._ease = Hc(y.ease || r.ease || "none"); var V = 0, J, j, q; if (Zi(y)) y.forEach(function (ne) { return S.to(M, ne, ">") }), S.duration(); else { T = {}; for (B in y) B === "ease" || B === "easeEach" || EH(B, y[B], T, y.easeEach); for (B in T) for (J = T[B].sort(function (ne, Q) { return ne.t - Q.t }), V = 0, C = 0; C < J.length; C++)j = J[C], q = { ease: j.e, duration: (j.t - (C ? J[C - 1].t : 0)) / 100 * c }, q[B] = j.v, S.to(M, q, V), V += q.duration; S.duration() < c && S.to({}, { duration: c - S.duration() }) } } c || a.duration(c = S.duration()) } else a.timeline = 0; return m === !0 && !I1 && (ul = fa(a), Rn.killTweensOf(M), ul = 0), Bo(A, fa(a), s), r.reversed && a.reverse(), r.paused && a.paused(!0), (d || !c && !y && a._start === Li(A._time) && Fr(d) && nH(fa(a)) && A.data !== "nested") && (a._tTime = -fn, a.render(Math.max(0, -f) || 0)), x && L2(fa(a), x), a } var t = e.prototype; return t.render = function (r, s, o) { var a = this._time, l = this._tDur, c = this._dur, f = r < 0, d = r > l - fn && !f ? l : r < fn ? 0 : r, p, m, y, _, x, g, A, M, S; if (!c) rH(this, r, s, o); else if (d !== this._tTime || !r || o || !this._initted && this._tTime || this._startAt && this._zTime < 0 !== f) { if (p = d, M = this.timeline, this._repeat) { if (_ = c + this._rDelay, this._repeat < -1 && f) return this.totalTime(_ * 100 + r, s, o); if (p = Li(d % _), d === l ? (y = this._repeat, p = c) : (y = ~~(d / _), y && y === d / _ && (p = c, y--), p > c && (p = c)), g = this._yoyo && y & 1, g && (S = this._yEase, p = c - p), x = oh(this._tTime, _), p === a && !o && this._initted) return this._tTime = d, this; y !== x && (M && this._yEase && j2(M, g), this.vars.repeatRefresh && !g && !this._lock && (this._lock = o = 1, this.render(Li(_ * y), !0).invalidate()._lock = 0)) } if (!this._initted) { if (D2(this, f ? r : p, o, s, d)) return this._tTime = 0, this; if (a !== this._time) return this; if (c !== this._dur) return this.render(r, s, o) } if (this._tTime = d, this._time = p, !this._act && this._ts && (this._act = 1, this._lazy = 0), this.ratio = A = (S || this._ease)(p / c), this._from && (this.ratio = A = 1 - A), p && !a && !s && !y && (Ls(this, "onStart"), this._tTime !== d)) return this; for (m = this._pt; m;)m.r(A, m.d), m = m._next; M && M.render(r < 0 ? r : !p && g ? -fn : M._dur * M._ease(p / this._dur), s, o) || this._startAt && (this._zTime = r), this._onUpdate && !s && (f && yw(this, r, s, o), Ls(this, "onUpdate")), this._repeat && y !== x && this.vars.onRepeat && !s && this.parent && Ls(this, "onRepeat"), (d === this._tDur || !d) && this._tTime === d && (f && !this._onUpdate && yw(this, r, !0, !0), (r || !c) && (d === this._tDur && this._ts > 0 || !d && this._ts < 0) && Dl(this, 1), !s && !(f && !a) && (d || a || g) && (Ls(this, d === l ? "onComplete" : "onReverseComplete", !0), this._prom && !(d < l && this.timeScale() > 0) && this._prom())) } return this }, t.targets = function () { return this._targets }, t.invalidate = function (r) { return (!r || !this.vars.runBackwards) && (this._startAt = 0), this._pt = this._op = this._onUpdate = this._lazy = this.ratio = 0, this._ptLookup = [], this.timeline && this.timeline.invalidate(r), i.prototype.invalidate.call(this, r) }, t.resetTo = function (r, s, o, a) { Rp || Zr.wake(), this._ts || this.play(); var l = Math.min(this._dur, (this._dp._time - this._start) * this._ts), c; return this._initted || z1(this, l), c = this._ease(l / this._dur), wH(this, r, s, o, a, c, l) ? this.resetTo(r, s, o, a) : (Pv(this, 0), this.parent || I2(this._dp, this, "_first", "_last", this._dp._sort ? "_start" : 0), this.render(0)) }, t.kill = function (r, s) { if (s === void 0 && (s = "all"), !r && (!s || s === "all")) return this._lazy = this._pt = 0, this.parent ? bd(this) : this; if (this.timeline) { var o = this.timeline.totalDuration(); return this.timeline.killTweensOf(r, s, ul && ul.vars.overwrite !== !0)._first || bd(this), this.parent && o !== this.timeline.totalDuration() && ah(this, this._dur * this.timeline._tDur / o, 0, 1), this } var a = this._targets, l = r ? Bs(r) : a, c = this._ptLookup, f = this._pt, d, p, m, y, _, x, g; if ((!s || s === "all") && eH(a, l)) return s === "all" && (this._pt = 0), bd(this); for (d = this._op = this._op || [], s !== "all" && (bi(s) && (_ = {}, kr(s, function (A) { return _[A] = 1 }), s = _), s = SH(a, s)), g = a.length; g--;)if (~l.indexOf(a[g])) { p = c[g], s === "all" ? (d[g] = s, y = p, m = {}) : (m = d[g] = d[g] || {}, y = s); for (_ in y) x = p && p[_], x && ((!("kill" in x.d) || x.d.kill(_) === !0) && bv(this, x, "_pt"), delete p[_]), m !== "all" && (m[_] = 1) } return this._initted && !this._pt && f && bd(this), this }, e.to = function (r, s) { return new e(r, s, arguments[2]) }, e.from = function (r, s) { return Jd(1, arguments) }, e.delayedCall = function (r, s, o, a) { return new e(s, 0, { immediateRender: !1, lazy: !1, overwrite: !1, delay: r, onComplete: s, onReverseComplete: s, onCompleteParams: o, onReverseCompleteParams: o, callbackScope: a }) }, e.fromTo = function (r, s, o) { return Jd(2, arguments) }, e.set = function (r, s) { return s.duration = 0, s.repeatDelay || (s.repeat = 0), new e(r, s) }, e.killTweensOf = function (r, s, o) { return Rn.killTweensOf(r, s, o) }, e }(Pp); Us(ii.prototype, { _targets: [], _lazy: 0, _startAt: 0, _op: 0, _onInit: 0 }); kr("staggerTo,staggerFrom,staggerFromTo", function (i) { ii[i] = function () { var e = new Rr, t = _w.call(arguments, 0); return t.splice(i === "staggerFromTo" ? 5 : 4, 0, 0), e[i].apply(e, t) } }); var H1 = function (e, t, n) { return e[t] = n }, eD = function (e, t, n) { return e[t](n) }, CH = function (e, t, n, r) { return e[t](r.fp, n) }, TH = function (e, t, n) { return e.setAttribute(t, n) }, G1 = function (e, t) { return Wn(e[t]) ? eD : B1(e[t]) && e.setAttribute ? TH : H1 }, tD = function (e, t) { return t.set(t.t, t.p, Math.round((t.s + t.c * e) * 1e6) / 1e6, t) }, bH = function (e, t) { return t.set(t.t, t.p, !!(t.s + t.c * e), t) }, nD = function (e, t) { var n = t._pt, r = ""; if (!e && t.b) r = t.b; else if (e === 1 && t.e) r = t.e; else { for (; n;)r = n.p + (n.m ? n.m(n.s + n.c * e) : Math.round((n.s + n.c * e) * 1e4) / 1e4) + r, n = n._next; r += t.c } t.set(t.t, t.p, r, t) }, V1 = function (e, t) { for (var n = t._pt; n;)n.r(e, n.d), n = n._next }, RH = function (e, t, n, r) { for (var s = this._pt, o; s;)o = s._next, s.p === r && s.modifier(e, t, n), s = o }, PH = function (e) { for (var t = this._pt, n, r; t;)r = t._next, t.p === e && !t.op || t.op === e ? bv(this, t, "_pt") : t.dep || (n = 1), t = r; return !n }, IH = function (e, t, n, r) { r.mSet(e, t, r.m.call(r.tween, n, r.mt), r) }, iD = function (e) { for (var t = e._pt, n, r, s, o; t;) { for (n = t._next, r = s; r && r.pr > t.pr;)r = r._next; (t._prev = r ? r._prev : o) ? t._prev._next = t : s = t, (t._next = r) ? r._prev = t : o = t, t = n } e._pt = s }, Nr = function () { function i(t, n, r, s, o, a, l, c, f) { this.t = n, this.s = s, this.c = o, this.p = r, this.r = a || tD, this.d = l || this, this.set = c || H1, this.pr = f || 0, this._next = t, t && (t._prev = this) } var e = i.prototype; return e.modifier = function (n, r, s) { this.mSet = this.mSet || this.set, this.set = IH, this.m = n, this.mt = s, this.tween = r }, i }(); kr(k1 + "parent,duration,ease,delay,overwrite,runBackwards,startAt,yoyo,immediateRender,repeat,repeatDelay,data,paused,reversed,lazy,callbackScope,stringFilter,id,yoyoEase,stagger,inherit,repeatRefresh,keyframes,autoRevert,scrollTrigger", function (i) { return F1[i] = 1 }); as.TweenMax = as.TweenLite = ii; as.TimelineLite = as.TimelineMax = Rr; Rn = new Rr({ sortChildren: !1, defaults: sh, autoRemoveChildren: !0, id: "root", smoothChildTiming: !0 }); is.stringFilter = J2; var Gc = [], j0 = {}, BH = [], iR = 0, LH = 0, Yx = function (e) { return (j0[e] || BH).map(function (t) { return t() }) }, ww = function () { var e = Date.now(), t = []; e - iR > 2 && (Yx("matchMediaInit"), Gc.forEach(function (n) { var r = n.queries, s = n.conditions, o, a, l, c; for (a in r) o = ws.matchMedia(r[a]).matches, o && (l = 1), o !== s[a] && (s[a] = o, c = 1); c && (n.revert(), l && t.push(n)) }), Yx("matchMediaRevert"), t.forEach(function (n) { return n.onMatch(n) }), iR = e, Yx("matchMedia")) }, rD = function () { function i(t, n) { this.selector = n && xw(n), this.data = [], this._r = [], this.isReverted = !1, this.id = LH++, t && this.add(t) } var e = i.prototype; return e.add = function (n, r, s) { Wn(n) && (s = r, r = n, n = Wn); var o = this, a = function () { var c = Hn, f = o.selector, d; return c && c !== o && c.data.push(o), s && (o.selector = xw(s)), Hn = o, d = r.apply(o, arguments), Wn(d) && o._r.push(d), Hn = c, o.selector = f, o.isReverted = !1, d }; return o.last = a, n === Wn ? a(o) : n ? o[n] = a : a }, e.ignore = function (n) { var r = Hn; Hn = null, n(this), Hn = r }, e.getTweens = function () { var n = []; return this.data.forEach(function (r) { return r instanceof i ? n.push.apply(n, r.getTweens()) : r instanceof ii && !(r.parent && r.parent.data === "nested") && n.push(r) }), n }, e.clear = function () { this._r.length = this.data.length = 0 }, e.kill = function (n, r) { var s = this; if (n) { var o = this.getTweens(); this.data.forEach(function (l) { l.data === "isFlip" && (l.revert(), l.getChildren(!0, !0, !1).forEach(function (c) { return o.splice(o.indexOf(c), 1) })) }), o.map(function (l) { return { g: l.globalTime(0), t: l } }).sort(function (l, c) { return c.g - l.g || -1 / 0 }).forEach(function (l) { return l.t.revert(n) }), this.data.forEach(function (l) { return !(l instanceof ii) && l.revert && l.revert(n) }), this._r.forEach(function (l) { return l(n, s) }), this.isReverted = !0 } else this.data.forEach(function (l) { return l.kill && l.kill() }); if (this.clear(), r) for (var a = Gc.length; a--;)Gc[a].id === this.id && Gc.splice(a, 1) }, e.revert = function (n) { this.kill(n || {}) }, i }(), DH = function () { function i(t) { this.contexts = [], this.scope = t } var e = i.prototype; return e.add = function (n, r, s) { Xo(n) || (n = { matches: n }); var o = new rD(0, s || this.scope), a = o.conditions = {}, l, c, f; Hn && !o.selector && (o.selector = Hn.selector), this.contexts.push(o), r = o.add("onMatch", r), o.queries = n; for (c in n) c === "all" ? f = 1 : (l = ws.matchMedia(n[c]), l && (Gc.indexOf(o) < 0 && Gc.push(o), (a[c] = l.matches) && (f = 1), l.addListener ? l.addListener(ww) : l.addEventListener("change", ww))); return f && r(o), this }, e.revert = function (n) { this.kill(n || {}) }, e.kill = function (n) { this.contexts.forEach(function (r) { return r.kill(n, !0) }) }, i }(), Vy = { registerPlugin: function () { for (var e = arguments.length, t = new Array(e), n = 0; n < e; n++)t[n] = arguments[n]; t.forEach(function (r) { return V2(r) }) }, timeline: function (e) { return new Rr(e) }, getTweensOf: function (e, t) { return Rn.getTweensOf(e, t) }, getProperty: function (e, t, n, r) { bi(e) && (e = Bs(e)[0]); var s = Uc(e || {}).get, o = n ? P2 : R2; return n === "native" && (n = ""), e && (t ? o((Qr[t] && Qr[t].get || s)(e, t, n, r)) : function (a, l, c) { return o((Qr[a] && Qr[a].get || s)(e, a, l, c)) }) }, quickSetter: function (e, t, n) { if (e = Bs(e), e.length > 1) { var r = e.map(function (f) { return Ur.quickSetter(f, t, n) }), s = r.length; return function (f) { for (var d = s; d--;)r[d](f) } } e = e[0] || {}; var o = Qr[t], a = Uc(e), l = a.harness && (a.harness.aliases || {})[t] || t, c = o ? function (f) { var d = new o; Ef._pt = 0, d.init(e, n ? f + n : f, Ef, 0, [e]), d.render(1, d), Ef._pt && V1(1, Ef) } : a.set(e, l); return o ? c : function (f) { return c(e, l, n ? f + n : f, a, 1) } }, quickTo: function (e, t, n) { var r, s = Ur.to(e, tu((r = {}, r[t] = "+=0.1", r.paused = !0, r), n || {})), o = function (l, c, f) { return s.resetTo(t, l, c, f) }; return o.tween = s, o }, isTweening: function (e) { return Rn.getTweensOf(e, !0).length > 0 }, defaults: function (e) { return e && e.ease && (e.ease = Hc(e.ease, sh.ease)), Zb(sh, e || {}) }, config: function (e) { return Zb(is, e || {}) }, registerEffect: function (e) { var t = e.name, n = e.effect, r = e.plugins, s = e.defaults, o = e.extendTimeline; (r || "").split(",").forEach(function (a) { return a && !Qr[a] && !as[a] && Uy(t + " effect requires " + a + " plugin.") }), Vx[t] = function (a, l, c) { return n(Bs(a), Us(l || {}, s), c) }, o && (Rr.prototype[t] = function (a, l, c) { return this.add(Vx[t](a, Xo(l) ? l : (c = l) && {}, this), c) }) }, registerEase: function (e, t) { Jt[e] = Hc(t) }, parseEase: function (e, t) { return arguments.length ? Hc(e, t) : Jt }, getById: function (e) { return Rn.getById(e) }, exportRoot: function (e, t) { e === void 0 && (e = {}); var n = new Rr(e), r, s; for (n.smoothChildTiming = Fr(e.smoothChildTiming), Rn.remove(n), n._dp = 0, n._time = n._tTime = Rn._time, r = Rn._first; r;)s = r._next, (t || !(!r._dur && r instanceof ii && r.vars.onComplete === r._targets[0])) && Bo(n, r, r._start - r._delay), r = s; return Bo(Rn, n, 0), n }, context: function (e, t) { return e ? new rD(e, t) : Hn }, matchMedia: function (e) { return new DH(e) }, matchMediaRefresh: function () { return Gc.forEach(function (e) { var t = e.conditions, n, r; for (r in t) t[r] && (t[r] = !1, n = 1); n && e.revert() }) || ww() }, addEventListener: function (e, t) { var n = j0[e] || (j0[e] = []); ~n.indexOf(t) || n.push(t) }, removeEventListener: function (e, t) { var n = j0[e], r = n && n.indexOf(t); r >= 0 && n.splice(r, 1) }, utils: { wrap: hH, wrapYoyo: dH, distribute: k2, random: U2, snap: N2, normalize: fH, getUnit: qi, clamp: aH, splitColor: W2, toArray: Bs, selector: xw, mapRange: H2, pipe: cH, unitize: uH, interpolate: pH, shuffle: F2 }, install: S2, effects: Vx, ticker: Zr, updateRoot: Rr.updateRoot, plugins: Qr, globalTimeline: Rn, core: { PropTween: Nr, globals: E2, Tween: ii, Timeline: Rr, Animation: Pp, getCache: Uc, _removeLinkedListItem: bv, reverting: function () { return Qi }, context: function (e) { return e && Hn && (Hn.data.push(e), e._ctx = Hn), Hn }, suppressOverwrites: function (e) { return I1 = e } } }; kr("to,from,fromTo,delayedCall,set,killTweensOf", function (i) { return Vy[i] = ii[i] }); Zr.add(Rr.updateRoot); Ef = Vy.to({}, { duration: 0 }); var OH = function (e, t) { for (var n = e._pt; n && n.p !== t && n.op !== t && n.fp !== t;)n = n._next; return n }, FH = function (e, t) { var n = e._targets, r, s, o; for (r in t) for (s = n.length; s--;)o = e._ptLookup[s][r], o && (o = o.d) && (o._pt && (o = OH(o, r)), o && o.modifier && o.modifier(t[r], e, n[s], r)) }, jx = function (e, t) { return { name: e, rawVars: 1, init: function (r, s, o) { o._onInit = function (a) { var l, c; if (bi(s) && (l = {}, kr(s, function (f) { return l[f] = 1 }), s = l), t) { l = {}; for (c in s) l[c] = t(s[c]); s = l } FH(a, s) } } } }, Ur = Vy.registerPlugin({ name: "attr", init: function (e, t, n, r, s) { var o, a, l; this.tween = n; for (o in t) l = e.getAttribute(o) || "", a = this.add(e, "setAttribute", (l || 0) + "", t[o], r, s, 0, 0, o), a.op = o, a.b = l, this._props.push(o) }, render: function (e, t) { for (var n = t._pt; n;)Qi ? n.set(n.t, n.p, n.b, n) : n.r(e, n.d), n = n._next } }, { name: "endArray", init: function (e, t) { for (var n = t.length; n--;)this.add(e, n, e[n] || 0, t[n], 0, 0, 0, 0, 0, 1) } }, jx("roundProps", Aw), jx("modifiers"), jx("snap", N2)) || Vy; ii.version = Rr.version = Ur.version = "3.12.2"; w2 = 1; L1() && lh(); Jt.Power0; Jt.Power1; Jt.Power2; Jt.Power3; Jt.Power4; Jt.Linear; Jt.Quad; Jt.Cubic; Jt.Quart; Jt.Quint; Jt.Strong; Jt.Elastic; Jt.Back; Jt.SteppedEase; Jt.Bounce; Jt.Sine; Jt.Expo; Jt.Circ;/*!
 * CSSPlugin 3.12.2
 * https://greensock.com
 *
 * Copyright 2008-2023, GreenSock. All rights reserved.
 * Subject to the terms at https://greensock.com/standard-license or for
 * Club GreenSock members, the agreement issued with that membership.
 * @author: Jack Doyle, jack@greensock.com
*/var rR, fl, Gf, W1, Pc, sR, X1, kH = function () { return typeof window < "u" }, Ba = {}, vc = 180 / Math.PI, Vf = Math.PI / 180, Lu = Math.atan2, oR = 1e8, J1 = /([A-Z])/g, NH = /(left|right|width|margin|padding|x)/i, UH = /[\s,\(]\S/, Lo = { autoAlpha: "opacity,visibility", scale: "scaleX,scaleY", alpha: "opacity" }, Sw = function (e, t) { return t.set(t.t, t.p, Math.round((t.s + t.c * e) * 1e4) / 1e4 + t.u, t) }, zH = function (e, t) { return t.set(t.t, t.p, e === 1 ? t.e : Math.round((t.s + t.c * e) * 1e4) / 1e4 + t.u, t) }, HH = function (e, t) { return t.set(t.t, t.p, e ? Math.round((t.s + t.c * e) * 1e4) / 1e4 + t.u : t.b, t) }, GH = function (e, t) { var n = t.s + t.c * e; t.set(t.t, t.p, ~~(n + (n < 0 ? -.5 : .5)) + t.u, t) }, sD = function (e, t) { return t.set(t.t, t.p, e ? t.e : t.b, t) }, oD = function (e, t) { return t.set(t.t, t.p, e !== 1 ? t.b : t.e, t) }, VH = function (e, t, n) { return e.style[t] = n }, WH = function (e, t, n) { return e.style.setProperty(t, n) }, XH = function (e, t, n) { return e._gsap[t] = n }, JH = function (e, t, n) { return e._gsap.scaleX = e._gsap.scaleY = n }, YH = function (e, t, n, r, s) { var o = e._gsap; o.scaleX = o.scaleY = n, o.renderTransform(s, o) }, jH = function (e, t, n, r, s) { var o = e._gsap; o[t] = n, o.renderTransform(s, o) }, In = "transform", lo = In + "Origin", KH = function i(e, t) { var n = this, r = this.target, s = r.style; if (e in Ba && s) { if (this.tfm = this.tfm || {}, e !== "transform") e = Lo[e] || e, ~e.indexOf(",") ? e.split(",").forEach(function (o) { return n.tfm[o] = da(r, o) }) : this.tfm[e] = r._gsap.x ? r._gsap[e] : da(r, e); else return Lo.transform.split(",").forEach(function (o) { return i.call(n, o, t) }); if (this.props.indexOf(In) >= 0) return; r._gsap.svg && (this.svgo = r.getAttribute("data-svg-origin"), this.props.push(lo, t, "")), e = In } (s || t) && this.props.push(e, t, s[e]) }, aD = function (e) { e.translate && (e.removeProperty("translate"), e.removeProperty("scale"), e.removeProperty("rotate")) }, qH = function () { var e = this.props, t = this.target, n = t.style, r = t._gsap, s, o; for (s = 0; s < e.length; s += 3)e[s + 1] ? t[e[s]] = e[s + 2] : e[s + 2] ? n[e[s]] = e[s + 2] : n.removeProperty(e[s].substr(0, 2) === "--" ? e[s] : e[s].replace(J1, "-$1").toLowerCase()); if (this.tfm) { for (o in this.tfm) r[o] = this.tfm[o]; r.svg && (r.renderTransform(), t.setAttribute("data-svg-origin", this.svgo || "")), s = X1(), (!s || !s.isStart) && !n[In] && (aD(n), r.uncache = 1) } }, lD = function (e, t) { var n = { target: e, props: [], revert: qH, save: KH }; return e._gsap || Ur.core.getCache(e), t && t.split(",").forEach(function (r) { return n.save(r) }), n }, cD, Ew = function (e, t) { var n = fl.createElementNS ? fl.createElementNS((t || "http://www.w3.org/1999/xhtml").replace(/^https/, "http"), e) : fl.createElement(e); return n.style ? n : fl.createElement(e) }, No = function i(e, t, n) { var r = getComputedStyle(e); return r[t] || r.getPropertyValue(t.replace(J1, "-$1").toLowerCase()) || r.getPropertyValue(t) || !n && i(e, ch(t) || t, 1) || "" }, aR = "O,Moz,ms,Ms,Webkit".split(","), ch = function (e, t, n) { var r = t || Pc, s = r.style, o = 5; if (e in s && !n) return e; for (e = e.charAt(0).toUpperCase() + e.substr(1); o-- && !(aR[o] + e in s);); return o < 0 ? null : (o === 3 ? "ms" : o >= 0 ? aR[o] : "") + e }, Cw = function () { kH() && window.document && (rR = window, fl = rR.document, Gf = fl.documentElement, Pc = Ew("div") || { style: {} }, Ew("div"), In = ch(In), lo = In + "Origin", Pc.style.cssText = "border-width:0;line-height:0;position:absolute;padding:0", cD = !!ch("perspective"), X1 = Ur.core.reverting, W1 = 1) }, Kx = function i(e) { var t = Ew("svg", this.ownerSVGElement && this.ownerSVGElement.getAttribute("xmlns") || "http://www.w3.org/2000/svg"), n = this.parentNode, r = this.nextSibling, s = this.style.cssText, o; if (Gf.appendChild(t), t.appendChild(this), this.style.display = "block", e) try { o = this.getBBox(), this._gsapBBox = this.getBBox, this.getBBox = i } catch { } else this._gsapBBox && (o = this._gsapBBox()); return n && (r ? n.insertBefore(this, r) : n.appendChild(this)), Gf.removeChild(t), this.style.cssText = s, o }, lR = function (e, t) { for (var n = t.length; n--;)if (e.hasAttribute(t[n])) return e.getAttribute(t[n]) }, uD = function (e) { var t; try { t = e.getBBox() } catch { t = Kx.call(e, !0) } return t && (t.width || t.height) || e.getBBox === Kx || (t = Kx.call(e, !0)), t && !t.width && !t.x && !t.y ? { x: +lR(e, ["x", "cx", "x1"]) || 0, y: +lR(e, ["y", "cy", "y1"]) || 0, width: 0, height: 0 } : t }, fD = function (e) { return !!(e.getCTM && (!e.parentNode || e.ownerSVGElement) && uD(e)) }, Ip = function (e, t) { if (t) { var n = e.style; t in Ba && t !== lo && (t = In), n.removeProperty ? ((t.substr(0, 2) === "ms" || t.substr(0, 6) === "webkit") && (t = "-" + t), n.removeProperty(t.replace(J1, "-$1").toLowerCase())) : n.removeAttribute(t) } }, hl = function (e, t, n, r, s, o) { var a = new Nr(e._pt, t, n, 0, 1, o ? oD : sD); return e._pt = a, a.b = r, a.e = s, e._props.push(n), a }, cR = { deg: 1, rad: 1, turn: 1 }, QH = { grid: 1, flex: 1 }, Ol = function i(e, t, n, r) { var s = parseFloat(n) || 0, o = (n + "").trim().substr((s + "").length) || "px", a = Pc.style, l = NH.test(t), c = e.tagName.toLowerCase() === "svg", f = (c ? "client" : "offset") + (l ? "Width" : "Height"), d = 100, p = r === "px", m = r === "%", y, _, x, g; return r === o || !s || cR[r] || cR[o] ? s : (o !== "px" && !p && (s = i(e, t, n, "px")), g = e.getCTM && fD(e), (m || o === "%") && (Ba[t] || ~t.indexOf("adius")) ? (y = g ? e.getBBox()[l ? "width" : "height"] : e[f], Kn(m ? s / y * d : s / 100 * y)) : (a[l ? "width" : "height"] = d + (p ? o : r), _ = ~t.indexOf("adius") || r === "em" && e.appendChild && !c ? e : e.parentNode, g && (_ = (e.ownerSVGElement || {}).parentNode), (!_ || _ === fl || !_.appendChild) && (_ = fl.body), x = _._gsap, x && m && x.width && l && x.time === Zr.time && !x.uncache ? Kn(s / x.width * d) : ((m || o === "%") && !QH[No(_, "display")] && (a.position = No(e, "position")), _ === e && (a.position = "static"), _.appendChild(Pc), y = Pc[f], _.removeChild(Pc), a.position = "absolute", l && m && (x = Uc(_), x.time = Zr.time, x.width = _[f]), Kn(p ? y * s / d : y && s ? d / y * s : 0)))) }, da = function (e, t, n, r) { var s; return W1 || Cw(), t in Lo && t !== "transform" && (t = Lo[t], ~t.indexOf(",") && (t = t.split(",")[0])), Ba[t] && t !== "transform" ? (s = Lp(e, r), s = t !== "transformOrigin" ? s[t] : s.svg ? s.origin : Xy(No(e, lo)) + " " + s.zOrigin + "px") : (s = e.style[t], (!s || s === "auto" || r || ~(s + "").indexOf("calc(")) && (s = Wy[t] && Wy[t](e, t, n) || No(e, t) || T2(e, t) || (t === "opacity" ? 1 : 0))), n && !~(s + "").trim().indexOf(" ") ? Ol(e, t, s, n) + n : s }, ZH = function (e, t, n, r) { if (!n || n === "none") { var s = ch(t, e, 1), o = s && No(e, s, 1); o && o !== n ? (t = s, n = o) : t === "borderColor" && (n = No(e, "borderTopColor")) } var a = new Nr(this._pt, e.style, t, 0, 1, nD), l = 0, c = 0, f, d, p, m, y, _, x, g, A, M, S, C; if (a.b = n, a.e = r, n += "", r += "", r === "auto" && (e.style[t] = r, r = No(e, t) || r, e.style[t] = n), f = [n, r], J2(f), n = f[0], r = f[1], p = n.match(Sf) || [], C = r.match(Sf) || [], C.length) { for (; d = Sf.exec(r);)x = d[0], A = r.substring(l, d.index), y ? y = (y + 1) % 5 : (A.substr(-5) === "rgba(" || A.substr(-5) === "hsla(") && (y = 1), x !== (_ = p[c++] || "") && (m = parseFloat(_) || 0, S = _.substr((m + "").length), x.charAt(1) === "=" && (x = Hf(m, x) + S), g = parseFloat(x), M = x.substr((g + "").length), l = Sf.lastIndex - M.length, M || (M = M || is.units[t] || S, l === r.length && (r += M, a.e += M)), S !== M && (m = Ol(e, t, _, M) || 0), a._pt = { _next: a._pt, p: A || c === 1 ? A : ",", s: m, c: g - m, m: y && y < 4 || t === "zIndex" ? Math.round : 0 }); a.c = l < r.length ? r.substring(l, r.length) : "" } else a.r = t === "display" && r === "none" ? oD : sD; return A2.test(r) && (a.e = 0), this._pt = a, a }, uR = { top: "0%", bottom: "100%", left: "0%", right: "100%", center: "50%" }, $H = function (e) { var t = e.split(" "), n = t[0], r = t[1] || "50%"; return (n === "top" || n === "bottom" || r === "left" || r === "right") && (e = n, n = r, r = e), t[0] = uR[n] || n, t[1] = uR[r] || r, t.join(" ") }, eG = function (e, t) { if (t.tween && t.tween._time === t.tween._dur) { var n = t.t, r = n.style, s = t.u, o = n._gsap, a, l, c; if (s === "all" || s === !0) r.cssText = "", l = 1; else for (s = s.split(","), c = s.length; --c > -1;)a = s[c], Ba[a] && (l = 1, a = a === "transformOrigin" ? lo : In), Ip(n, a); l && (Ip(n, In), o && (o.svg && n.removeAttribute("transform"), Lp(n, 1), o.uncache = 1, aD(r))) } }, Wy = { clearProps: function (e, t, n, r, s) { if (s.data !== "isFromStart") { var o = e._pt = new Nr(e._pt, t, n, 0, 0, eG); return o.u = r, o.pr = -10, o.tween = s, e._props.push(n), 1 } } }, Bp = [1, 0, 0, 1, 0, 0], hD = {}, dD = function (e) { return e === "matrix(1, 0, 0, 1, 0, 0)" || e === "none" || !e }, fR = function (e) { var t = No(e, In); return dD(t) ? Bp : t.substr(7).match(x2).map(Kn) }, Y1 = function (e, t) { var n = e._gsap || Uc(e), r = e.style, s = fR(e), o, a, l, c; return n.svg && e.getAttribute("transform") ? (l = e.transform.baseVal.consolidate().matrix, s = [l.a, l.b, l.c, l.d, l.e, l.f], s.join(",") === "1,0,0,1,0,0" ? Bp : s) : (s === Bp && !e.offsetParent && e !== Gf && !n.svg && (l = r.display, r.display = "block", o = e.parentNode, (!o || !e.offsetParent) && (c = 1, a = e.nextElementSibling, Gf.appendChild(e)), s = fR(e), l ? r.display = l : Ip(e, "display"), c && (a ? o.insertBefore(e, a) : o ? o.appendChild(e) : Gf.removeChild(e))), t && s.length > 6 ? [s[0], s[1], s[4], s[5], s[12], s[13]] : s) }, Tw = function (e, t, n, r, s, o) { var a = e._gsap, l = s || Y1(e, !0), c = a.xOrigin || 0, f = a.yOrigin || 0, d = a.xOffset || 0, p = a.yOffset || 0, m = l[0], y = l[1], _ = l[2], x = l[3], g = l[4], A = l[5], M = t.split(" "), S = parseFloat(M[0]) || 0, C = parseFloat(M[1]) || 0, T, R, B, b; n ? l !== Bp && (R = m * x - y * _) && (B = S * (x / R) + C * (-_ / R) + (_ * A - x * g) / R, b = S * (-y / R) + C * (m / R) - (m * A - y * g) / R, S = B, C = b) : (T = uD(e), S = T.x + (~M[0].indexOf("%") ? S / 100 * T.width : S), C = T.y + (~(M[1] || M[0]).indexOf("%") ? C / 100 * T.height : C)), r || r !== !1 && a.smooth ? (g = S - c, A = C - f, a.xOffset = d + (g * m + A * _) - g, a.yOffset = p + (g * y + A * x) - A) : a.xOffset = a.yOffset = 0, a.xOrigin = S, a.yOrigin = C, a.smooth = !!r, a.origin = t, a.originIsAbsolute = !!n, e.style[lo] = "0px 0px", o && (hl(o, a, "xOrigin", c, S), hl(o, a, "yOrigin", f, C), hl(o, a, "xOffset", d, a.xOffset), hl(o, a, "yOffset", p, a.yOffset)), e.setAttribute("data-svg-origin", S + " " + C) }, Lp = function (e, t) { var n = e._gsap || new q2(e); if ("x" in n && !t && !n.uncache) return n; var r = e.style, s = n.scaleX < 0, o = "px", a = "deg", l = getComputedStyle(e), c = No(e, lo) || "0", f, d, p, m, y, _, x, g, A, M, S, C, T, R, B, b, I, N, V, J, j, q, ne, Q, F, Y, L, G, K, ye, ge, xe; return f = d = p = _ = x = g = A = M = S = 0, m = y = 1, n.svg = !!(e.getCTM && fD(e)), l.translate && ((l.translate !== "none" || l.scale !== "none" || l.rotate !== "none") && (r[In] = (l.translate !== "none" ? "translate3d(" + (l.translate + " 0 0").split(" ").slice(0, 3).join(", ") + ") " : "") + (l.rotate !== "none" ? "rotate(" + l.rotate + ") " : "") + (l.scale !== "none" ? "scale(" + l.scale.split(" ").join(",") + ") " : "") + (l[In] !== "none" ? l[In] : "")), r.scale = r.rotate = r.translate = "none"), R = Y1(e, n.svg), n.svg && (n.uncache ? (F = e.getBBox(), c = n.xOrigin - F.x + "px " + (n.yOrigin - F.y) + "px", Q = "") : Q = !t && e.getAttribute("data-svg-origin"), Tw(e, Q || c, !!Q || n.originIsAbsolute, n.smooth !== !1, R)), C = n.xOrigin || 0, T = n.yOrigin || 0, R !== Bp && (N = R[0], V = R[1], J = R[2], j = R[3], f = q = R[4], d = ne = R[5], R.length === 6 ? (m = Math.sqrt(N * N + V * V), y = Math.sqrt(j * j + J * J), _ = N || V ? Lu(V, N) * vc : 0, A = J || j ? Lu(J, j) * vc + _ : 0, A && (y *= Math.abs(Math.cos(A * Vf))), n.svg && (f -= C - (C * N + T * J), d -= T - (C * V + T * j))) : (xe = R[6], ye = R[7], L = R[8], G = R[9], K = R[10], ge = R[11], f = R[12], d = R[13], p = R[14], B = Lu(xe, K), x = B * vc, B && (b = Math.cos(-B), I = Math.sin(-B), Q = q * b + L * I, F = ne * b + G * I, Y = xe * b + K * I, L = q * -I + L * b, G = ne * -I + G * b, K = xe * -I + K * b, ge = ye * -I + ge * b, q = Q, ne = F, xe = Y), B = Lu(-J, K), g = B * vc, B && (b = Math.cos(-B), I = Math.sin(-B), Q = N * b - L * I, F = V * b - G * I, Y = J * b - K * I, ge = j * I + ge * b, N = Q, V = F, J = Y), B = Lu(V, N), _ = B * vc, B && (b = Math.cos(B), I = Math.sin(B), Q = N * b + V * I, F = q * b + ne * I, V = V * b - N * I, ne = ne * b - q * I, N = Q, q = F), x && Math.abs(x) + Math.abs(_) > 359.9 && (x = _ = 0, g = 180 - g), m = Kn(Math.sqrt(N * N + V * V + J * J)), y = Kn(Math.sqrt(ne * ne + xe * xe)), B = Lu(q, ne), A = Math.abs(B) > 2e-4 ? B * vc : 0, S = ge ? 1 / (ge < 0 ? -ge : ge) : 0), n.svg && (Q = e.getAttribute("transform"), n.forceCSS = e.setAttribute("transform", "") || !dD(No(e, In)), Q && e.setAttribute("transform", Q))), Math.abs(A) > 90 && Math.abs(A) < 270 && (s ? (m *= -1, A += _ <= 0 ? 180 : -180, _ += _ <= 0 ? 180 : -180) : (y *= -1, A += A <= 0 ? 180 : -180)), t = t || n.uncache, n.x = f - ((n.xPercent = f && (!t && n.xPercent || (Math.round(e.offsetWidth / 2) === Math.round(-f) ? -50 : 0))) ? e.offsetWidth * n.xPercent / 100 : 0) + o, n.y = d - ((n.yPercent = d && (!t && n.yPercent || (Math.round(e.offsetHeight / 2) === Math.round(-d) ? -50 : 0))) ? e.offsetHeight * n.yPercent / 100 : 0) + o, n.z = p + o, n.scaleX = Kn(m), n.scaleY = Kn(y), n.rotation = Kn(_) + a, n.rotationX = Kn(x) + a, n.rotationY = Kn(g) + a, n.skewX = A + a, n.skewY = M + a, n.transformPerspective = S + o, (n.zOrigin = parseFloat(c.split(" ")[2]) || 0) && (r[lo] = Xy(c)), n.xOffset = n.yOffset = 0, n.force3D = is.force3D, n.renderTransform = n.svg ? nG : cD ? pD : tG, n.uncache = 0, n }, Xy = function (e) { return (e = e.split(" "))[0] + " " + e[1] }, qx = function (e, t, n) { var r = qi(t); return Kn(parseFloat(t) + parseFloat(Ol(e, "x", n + "px", r))) + r }, tG = function (e, t) { t.z = "0px", t.rotationY = t.rotationX = "0deg", t.force3D = 0, pD(e, t) }, rc = "0deg", ld = "0px", sc = ") ", pD = function (e, t) { var n = t || this, r = n.xPercent, s = n.yPercent, o = n.x, a = n.y, l = n.z, c = n.rotation, f = n.rotationY, d = n.rotationX, p = n.skewX, m = n.skewY, y = n.scaleX, _ = n.scaleY, x = n.transformPerspective, g = n.force3D, A = n.target, M = n.zOrigin, S = "", C = g === "auto" && e && e !== 1 || g === !0; if (M && (d !== rc || f !== rc)) { var T = parseFloat(f) * Vf, R = Math.sin(T), B = Math.cos(T), b; T = parseFloat(d) * Vf, b = Math.cos(T), o = qx(A, o, R * b * -M), a = qx(A, a, -Math.sin(T) * -M), l = qx(A, l, B * b * -M + M) } x !== ld && (S += "perspective(" + x + sc), (r || s) && (S += "translate(" + r + "%, " + s + "%) "), (C || o !== ld || a !== ld || l !== ld) && (S += l !== ld || C ? "translate3d(" + o + ", " + a + ", " + l + ") " : "translate(" + o + ", " + a + sc), c !== rc && (S += "rotate(" + c + sc), f !== rc && (S += "rotateY(" + f + sc), d !== rc && (S += "rotateX(" + d + sc), (p !== rc || m !== rc) && (S += "skew(" + p + ", " + m + sc), (y !== 1 || _ !== 1) && (S += "scale(" + y + ", " + _ + sc), A.style[In] = S || "translate(0, 0)" }, nG = function (e, t) { var n = t || this, r = n.xPercent, s = n.yPercent, o = n.x, a = n.y, l = n.rotation, c = n.skewX, f = n.skewY, d = n.scaleX, p = n.scaleY, m = n.target, y = n.xOrigin, _ = n.yOrigin, x = n.xOffset, g = n.yOffset, A = n.forceCSS, M = parseFloat(o), S = parseFloat(a), C, T, R, B, b; l = parseFloat(l), c = parseFloat(c), f = parseFloat(f), f && (f = parseFloat(f), c += f, l += f), l || c ? (l *= Vf, c *= Vf, C = Math.cos(l) * d, T = Math.sin(l) * d, R = Math.sin(l - c) * -p, B = Math.cos(l - c) * p, c && (f *= Vf, b = Math.tan(c - f), b = Math.sqrt(1 + b * b), R *= b, B *= b, f && (b = Math.tan(f), b = Math.sqrt(1 + b * b), C *= b, T *= b)), C = Kn(C), T = Kn(T), R = Kn(R), B = Kn(B)) : (C = d, B = p, T = R = 0), (M && !~(o + "").indexOf("px") || S && !~(a + "").indexOf("px")) && (M = Ol(m, "x", o, "px"), S = Ol(m, "y", a, "px")), (y || _ || x || g) && (M = Kn(M + y - (y * C + _ * R) + x), S = Kn(S + _ - (y * T + _ * B) + g)), (r || s) && (b = m.getBBox(), M = Kn(M + r / 100 * b.width), S = Kn(S + s / 100 * b.height)), b = "matrix(" + C + "," + T + "," + R + "," + B + "," + M + "," + S + ")", m.setAttribute("transform", b), A && (m.style[In] = b) }, iG = function (e, t, n, r, s) { var o = 360, a = bi(s), l = parseFloat(s) * (a && ~s.indexOf("rad") ? vc : 1), c = l - r, f = r + c + "deg", d, p; return a && (d = s.split("_")[1], d === "short" && (c %= o, c !== c % (o / 2) && (c += c < 0 ? o : -o)), d === "cw" && c < 0 ? c = (c + o * oR) % o - ~~(c / o) * o : d === "ccw" && c > 0 && (c = (c - o * oR) % o - ~~(c / o) * o)), e._pt = p = new Nr(e._pt, t, n, r, c, zH), p.e = f, p.u = "deg", e._props.push(n), p }, hR = function (e, t) { for (var n in t) e[n] = t[n]; return e }, rG = function (e, t, n) { var r = hR({}, n._gsap), s = "perspective,force3D,transformOrigin,svgOrigin", o = n.style, a, l, c, f, d, p, m, y; r.svg ? (c = n.getAttribute("transform"), n.setAttribute("transform", ""), o[In] = t, a = Lp(n, 1), Ip(n, In), n.setAttribute("transform", c)) : (c = getComputedStyle(n)[In], o[In] = t, a = Lp(n, 1), o[In] = c); for (l in Ba) c = r[l], f = a[l], c !== f && s.indexOf(l) < 0 && (m = qi(c), y = qi(f), d = m !== y ? Ol(n, l, c, y) : parseFloat(c), p = parseFloat(f), e._pt = new Nr(e._pt, a, l, d, p - d, Sw), e._pt.u = y || 0, e._props.push(l)); hR(a, r) }; kr("padding,margin,Width,Radius", function (i, e) { var t = "Top", n = "Right", r = "Bottom", s = "Left", o = (e < 3 ? [t, n, r, s] : [t + s, t + n, r + n, r + s]).map(function (a) { return e < 2 ? i + a : "border" + a + i }); Wy[e > 1 ? "border" + i : i] = function (a, l, c, f, d) { var p, m; if (arguments.length < 4) return p = o.map(function (y) { return da(a, y, c) }), m = p.join(" "), m.split(p[0]).length === 5 ? p[0] : m; p = (f + "").split(" "), m = {}, o.forEach(function (y, _) { return m[y] = p[_] = p[_] || p[(_ - 1) / 2 | 0] }), a.init(l, m, d) } }); var mD = { name: "css", register: Cw, targetTest: function (e) { return e.style && e.nodeType }, init: function (e, t, n, r, s) { var o = this._props, a = e.style, l = n.vars.startAt, c, f, d, p, m, y, _, x, g, A, M, S, C, T, R, B; W1 || Cw(), this.styles = this.styles || lD(e), B = this.styles.props, this.tween = n; for (_ in t) if (_ !== "autoRound" && (f = t[_], !(Qr[_] && Q2(_, t, n, r, e, s)))) { if (m = typeof f, y = Wy[_], m === "function" && (f = f.call(n, r, e, s), m = typeof f), m === "string" && ~f.indexOf("random(") && (f = bp(f)), y) y(this, e, _, f, n) && (R = 1); else if (_.substr(0, 2) === "--") c = (getComputedStyle(e).getPropertyValue(_) + "").trim(), f += "", El.lastIndex = 0, El.test(c) || (x = qi(c), g = qi(f)), g ? x !== g && (c = Ol(e, _, c, g) + g) : x && (f += x), this.add(a, "setProperty", c, f, r, s, 0, 0, _), o.push(_), B.push(_, 0, a[_]); else if (m !== "undefined") { if (l && _ in l ? (c = typeof l[_] == "function" ? l[_].call(n, r, e, s) : l[_], bi(c) && ~c.indexOf("random(") && (c = bp(c)), qi(c + "") || (c += is.units[_] || qi(da(e, _)) || ""), (c + "").charAt(1) === "=" && (c = da(e, _))) : c = da(e, _), p = parseFloat(c), A = m === "string" && f.charAt(1) === "=" && f.substr(0, 2), A && (f = f.substr(2)), d = parseFloat(f), _ in Lo && (_ === "autoAlpha" && (p === 1 && da(e, "visibility") === "hidden" && d && (p = 0), B.push("visibility", 0, a.visibility), hl(this, a, "visibility", p ? "inherit" : "hidden", d ? "inherit" : "hidden", !d)), _ !== "scale" && _ !== "transform" && (_ = Lo[_], ~_.indexOf(",") && (_ = _.split(",")[0]))), M = _ in Ba, M) { if (this.styles.save(_), S || (C = e._gsap, C.renderTransform && !t.parseTransform || Lp(e, t.parseTransform), T = t.smoothOrigin !== !1 && C.smooth, S = this._pt = new Nr(this._pt, a, In, 0, 1, C.renderTransform, C, 0, -1), S.dep = 1), _ === "scale") this._pt = new Nr(this._pt, C, "scaleY", C.scaleY, (A ? Hf(C.scaleY, A + d) : d) - C.scaleY || 0, Sw), this._pt.u = 0, o.push("scaleY", _), _ += "X"; else if (_ === "transformOrigin") { B.push(lo, 0, a[lo]), f = $H(f), C.svg ? Tw(e, f, 0, T, 0, this) : (g = parseFloat(f.split(" ")[2]) || 0, g !== C.zOrigin && hl(this, C, "zOrigin", C.zOrigin, g), hl(this, a, _, Xy(c), Xy(f))); continue } else if (_ === "svgOrigin") { Tw(e, f, 1, T, 0, this); continue } else if (_ in hD) { iG(this, C, _, p, A ? Hf(p, A + f) : f); continue } else if (_ === "smoothOrigin") { hl(this, C, "smooth", C.smooth, f); continue } else if (_ === "force3D") { C[_] = f; continue } else if (_ === "transform") { rG(this, f, e); continue } } else _ in a || (_ = ch(_) || _); if (M || (d || d === 0) && (p || p === 0) && !UH.test(f) && _ in a) x = (c + "").substr((p + "").length), d || (d = 0), g = qi(f) || (_ in is.units ? is.units[_] : x), x !== g && (p = Ol(e, _, c, g)), this._pt = new Nr(this._pt, M ? C : a, _, p, (A ? Hf(p, A + d) : d) - p, !M && (g === "px" || _ === "zIndex") && t.autoRound !== !1 ? GH : Sw), this._pt.u = g || 0, x !== g && g !== "%" && (this._pt.b = c, this._pt.r = HH); else if (_ in a) ZH.call(this, e, _, c, A ? A + f : f); else if (_ in e) this.add(e, _, c || e[_], A ? A + f : f, r, s); else if (_ !== "parseTransform") { O1(_, f); continue } M || (_ in a ? B.push(_, 0, a[_]) : B.push(_, 1, c || e[_])), o.push(_) } } R && iD(this) }, render: function (e, t) { if (t.tween._time || !X1()) for (var n = t._pt; n;)n.r(e, n.d), n = n._next; else t.styles.revert() }, get: da, aliases: Lo, getSetter: function (e, t, n) { var r = Lo[t]; return r && r.indexOf(",") < 0 && (t = r), t in Ba && t !== lo && (e._gsap.x || da(e, "x")) ? n && sR === n ? t === "scale" ? JH : XH : (sR = n || {}) && (t === "scale" ? YH : jH) : e.style && !B1(e.style[t]) ? VH : ~t.indexOf("-") ? WH : G1(e, t) }, core: { _removeProperty: Ip, _getMatrix: Y1 } }; Ur.utils.checkPrefix = ch; Ur.core.getStyleSaver = lD; (function (i, e, t, n) { var r = kr(i + "," + e + "," + t, function (s) { Ba[s] = 1 }); kr(e, function (s) { is.units[s] = "deg", hD[s] = 1 }), Lo[r[13]] = i + "," + e, kr(n, function (s) { var o = s.split(":"); Lo[o[1]] = r[o[0]] }) })("x,y,z,scale,scaleX,scaleY,xPercent,yPercent", "rotation,rotationX,rotationY,skewX,skewY", "transform,transformOrigin,svgOrigin,force3D,smoothOrigin,transformPerspective", "0:translateX,1:translateY,2:translateZ,8:rotate,8:rotationZ,8:rotateZ,9:rotateX,10:rotateY"); kr("x,y,z,top,right,bottom,left,width,height,fontSize,padding,margin,perspective", function (i) { is.units[i] = "px" }); Ur.registerPlugin(mD); var va = Ur.registerPlugin(mD) || Ur; va.core.Tween; function dR(i, e) { for (var t = 0; t < e.length; t++) { var n = e[t]; n.enumerable = n.enumerable || !1, n.configurable = !0, "value" in n && (n.writable = !0), Object.defineProperty(i, n.key, n) } } function sG(i, e, t) { return e && dR(i.prototype, e), t && dR(i, t), i }/*!
 * Observer 3.12.2
 * https://greensock.com
 *
 * @license Copyright 2008-2023, GreenSock. All rights reserved.
 * Subject to the terms at https://greensock.com/standard-license or for
 * Club GreenSock members, the agreement issued with that membership.
 * @author: Jack Doyle, jack@greensock.com
*/var Oi, bw, $r, dl, pl, Wf, gD, _c, jd, yD, _a, Qs, vD, _D = function () { return Oi || typeof window < "u" && (Oi = window.gsap) && Oi.registerPlugin && Oi }, xD = 1, Cf = [], Ht = [], Uo = [], Kd = Date.now, Rw = function (e, t) { return t }, oG = function () { var e = jd.core, t = e.bridge || {}, n = e._scrollers, r = e._proxies; n.push.apply(n, Ht), r.push.apply(r, Uo), Ht = n, Uo = r, Rw = function (o, a) { return t[o](a) } }, Cl = function (e, t) { return ~Uo.indexOf(e) && Uo[Uo.indexOf(e) + 1][t] }, qd = function (e) { return !!~yD.indexOf(e) }, cr = function (e, t, n, r, s) { return e.addEventListener(t, n, { passive: !r, capture: !!s }) }, ar = function (e, t, n, r) { return e.removeEventListener(t, n, !!r) }, Rg = "scrollLeft", Pg = "scrollTop", Pw = function () { return _a && _a.isPressed || Ht.cache++ }, Jy = function (e, t) { var n = function r(s) { if (s || s === 0) { xD && ($r.history.scrollRestoration = "manual"); var o = _a && _a.isPressed; s = r.v = Math.round(s) || (_a && _a.iOS ? 1 : 0), e(s), r.cacheID = Ht.cache, o && Rw("ss", s) } else (t || Ht.cache !== r.cacheID || Rw("ref")) && (r.cacheID = Ht.cache, r.v = e()); return r.v + r.offset }; return n.offset = 0, e && n }, mr = { s: Rg, p: "left", p2: "Left", os: "right", os2: "Right", d: "width", d2: "Width", a: "x", sc: Jy(function (i) { return arguments.length ? $r.scrollTo(i, hi.sc()) : $r.pageXOffset || dl[Rg] || pl[Rg] || Wf[Rg] || 0 }) }, hi = { s: Pg, p: "top", p2: "Top", os: "bottom", os2: "Bottom", d: "height", d2: "Height", a: "y", op: mr, sc: Jy(function (i) { return arguments.length ? $r.scrollTo(mr.sc(), i) : $r.pageYOffset || dl[Pg] || pl[Pg] || Wf[Pg] || 0 }) }, Cr = function (e, t) { return (t && t._ctx && t._ctx.selector || Oi.utils.toArray)(e)[0] || (typeof e == "string" && Oi.config().nullTargetWarn !== !1 ? console.warn("Element not found:", e) : null) }, Fl = function (e, t) { var n = t.s, r = t.sc; qd(e) && (e = dl.scrollingElement || pl); var s = Ht.indexOf(e), o = r === hi.sc ? 1 : 2; !~s && (s = Ht.push(e) - 1), Ht[s + o] || cr(e, "scroll", Pw); var a = Ht[s + o], l = a || (Ht[s + o] = Jy(Cl(e, n), !0) || (qd(e) ? r : Jy(function (c) { return arguments.length ? e[n] = c : e[n] }))); return l.target = e, a || (l.smooth = Oi.getProperty(e, "scrollBehavior") === "smooth"), l }, Iw = function (e, t, n) { var r = e, s = e, o = Kd(), a = o, l = t || 50, c = Math.max(500, l * 3), f = function (y, _) { var x = Kd(); _ || x - o > l ? (s = r, r = y, a = o, o = x) : n ? r += y : r = s + (y - s) / (x - a) * (o - a) }, d = function () { s = r = n ? 0 : r, a = o = 0 }, p = function (y) { var _ = a, x = s, g = Kd(); return (y || y === 0) && y !== r && f(y), o === a || g - a > c ? 0 : (r + (n ? x : -x)) / ((n ? g : o) - _) * 1e3 }; return { update: f, reset: d, getVelocity: p } }, cd = function (e, t) { return t && !e._gsapAllow && e.preventDefault(), e.changedTouches ? e.changedTouches[0] : e }, pR = function (e) { var t = Math.max.apply(Math, e), n = Math.min.apply(Math, e); return Math.abs(t) >= Math.abs(n) ? t : n }, AD = function () { jd = Oi.core.globals().ScrollTrigger, jd && jd.core && oG() }, MD = function (e) { return Oi = e || _D(), Oi && typeof document < "u" && document.body && ($r = window, dl = document, pl = dl.documentElement, Wf = dl.body, yD = [$r, dl, pl, Wf], Oi.utils.clamp, vD = Oi.core.context || function () { }, _c = "onpointerenter" in Wf ? "pointer" : "mouse", gD = si.isTouch = $r.matchMedia && $r.matchMedia("(hover: none), (pointer: coarse)").matches ? 1 : "ontouchstart" in $r || navigator.maxTouchPoints > 0 || navigator.msMaxTouchPoints > 0 ? 2 : 0, Qs = si.eventTypes = ("ontouchstart" in pl ? "touchstart,touchmove,touchcancel,touchend" : "onpointerdown" in pl ? "pointerdown,pointermove,pointercancel,pointerup" : "mousedown,mousemove,mouseup,mouseup").split(","), setTimeout(function () { return xD = 0 }, 500), AD(), bw = 1), bw }; mr.op = hi; Ht.cache = 0; var si = function () { function i(t) { this.init(t) } var e = i.prototype; return e.init = function (n) { bw || MD(Oi) || console.warn("Please gsap.registerPlugin(Observer)"), jd || AD(); var r = n.tolerance, s = n.dragMinimum, o = n.type, a = n.target, l = n.lineHeight, c = n.debounce, f = n.preventDefault, d = n.onStop, p = n.onStopDelay, m = n.ignore, y = n.wheelSpeed, _ = n.event, x = n.onDragStart, g = n.onDragEnd, A = n.onDrag, M = n.onPress, S = n.onRelease, C = n.onRight, T = n.onLeft, R = n.onUp, B = n.onDown, b = n.onChangeX, I = n.onChangeY, N = n.onChange, V = n.onToggleX, J = n.onToggleY, j = n.onHover, q = n.onHoverEnd, ne = n.onMove, Q = n.ignoreCheck, F = n.isNormalizer, Y = n.onGestureStart, L = n.onGestureEnd, G = n.onWheel, K = n.onEnable, ye = n.onDisable, ge = n.onClick, xe = n.scrollSpeed, Be = n.capture, Ie = n.allowClicks, Je = n.lockAxis, ut = n.onLockAxis; this.target = a = Cr(a) || pl, this.vars = n, m && (m = Oi.utils.toArray(m)), r = r || 1e-9, s = s || 0, y = y || 1, xe = xe || 1, o = o || "wheel,touch,pointer", c = c !== !1, l || (l = parseFloat($r.getComputedStyle(Wf).lineHeight) || 22); var Bt, Ge, H, pe, fe, Ee, ve, Z = this, Fe = 0, Ve = 0, st = Fl(a, mr), ot = Fl(a, hi), Yt = st(), U = ot(), D = ~o.indexOf("touch") && !~o.indexOf("pointer") && Qs[0] === "pointerdown", re = qd(a), Ae = a.ownerDocument || dl, Me = [0, 0, 0], Ce = [0, 0, 0], qe = 0, Te = function () { return qe = Kd() }, oe = function (Ne, At) { return (Z.event = Ne) && m && ~m.indexOf(Ne.target) || At && D && Ne.pointerType !== "touch" || Q && Q(Ne, At) }, X = function () { Z._vx.reset(), Z._vy.reset(), Ge.pause(), d && d(Z) }, he = function () { var Ne = Z.deltaX = pR(Me), At = Z.deltaY = pR(Ce), Lt = Math.abs(Ne) >= r, je = Math.abs(At) >= r; N && (Lt || je) && N(Z, Ne, At, Me, Ce), Lt && (C && Z.deltaX > 0 && C(Z), T && Z.deltaX < 0 && T(Z), b && b(Z), V && Z.deltaX < 0 != Fe < 0 && V(Z), Fe = Z.deltaX, Me[0] = Me[1] = Me[2] = 0), je && (B && Z.deltaY > 0 && B(Z), R && Z.deltaY < 0 && R(Z), I && I(Z), J && Z.deltaY < 0 != Ve < 0 && J(Z), Ve = Z.deltaY, Ce[0] = Ce[1] = Ce[2] = 0), (pe || H) && (ne && ne(Z), H && (A(Z), H = !1), pe = !1), Ee && !(Ee = !1) && ut && ut(Z), fe && (G(Z), fe = !1), Bt = 0 }, we = function (Ne, At, Lt) { Me[Lt] += Ne, Ce[Lt] += At, Z._vx.update(Ne), Z._vy.update(At), c ? Bt || (Bt = requestAnimationFrame(he)) : he() }, be = function (Ne, At) { Je && !ve && (Z.axis = ve = Math.abs(Ne) > Math.abs(At) ? "x" : "y", Ee = !0), ve !== "y" && (Me[2] += Ne, Z._vx.update(Ne, !0)), ve !== "x" && (Ce[2] += At, Z._vy.update(At, !0)), c ? Bt || (Bt = requestAnimationFrame(he)) : he() }, De = function (Ne) { if (!oe(Ne, 1)) { Ne = cd(Ne, f); var At = Ne.clientX, Lt = Ne.clientY, je = At - Z.x, Ft = Lt - Z.y, pt = Z.isDragging; Z.x = At, Z.y = Lt, (pt || Math.abs(Z.startX - At) >= s || Math.abs(Z.startY - Lt) >= s) && (A && (H = !0), pt || (Z.isDragging = !0), be(je, Ft), pt || x && x(Z)) } }, lt = Z.onPress = function (ht) { oe(ht, 1) || ht && ht.button || (Z.axis = ve = null, Ge.pause(), Z.isPressed = !0, ht = cd(ht), Fe = Ve = 0, Z.startX = Z.x = ht.clientX, Z.startY = Z.y = ht.clientY, Z._vx.reset(), Z._vy.reset(), cr(F ? a : Ae, Qs[1], De, f, !0), Z.deltaX = Z.deltaY = 0, M && M(Z)) }, vt = Z.onRelease = function (ht) { if (!oe(ht, 1)) { ar(F ? a : Ae, Qs[1], De, !0); var Ne = !isNaN(Z.y - Z.startY), At = Z.isDragging && (Math.abs(Z.x - Z.startX) > 3 || Math.abs(Z.y - Z.startY) > 3), Lt = cd(ht); !At && Ne && (Z._vx.reset(), Z._vy.reset(), f && Ie && Oi.delayedCall(.08, function () { if (Kd() - qe > 300 && !ht.defaultPrevented) { if (ht.target.click) ht.target.click(); else if (Ae.createEvent) { var je = Ae.createEvent("MouseEvents"); je.initMouseEvent("click", !0, !0, $r, 1, Lt.screenX, Lt.screenY, Lt.clientX, Lt.clientY, !1, !1, !1, !1, 0, null), ht.target.dispatchEvent(je) } } })), Z.isDragging = Z.isGesturing = Z.isPressed = !1, d && !F && Ge.restart(!0), g && At && g(Z), S && S(Z, At) } }, W = function (Ne) { return Ne.touches && Ne.touches.length > 1 && (Z.isGesturing = !0) && Y(Ne, Z.isDragging) }, Oe = function () { return (Z.isGesturing = !1) || L(Z) }, se = function (Ne) { if (!oe(Ne)) { var At = st(), Lt = ot(); we((At - Yt) * xe, (Lt - U) * xe, 1), Yt = At, U = Lt, d && Ge.restart(!0) } }, Se = function (Ne) { if (!oe(Ne)) { Ne = cd(Ne, f), G && (fe = !0); var At = (Ne.deltaMode === 1 ? l : Ne.deltaMode === 2 ? $r.innerHeight : 1) * y; we(Ne.deltaX * At, Ne.deltaY * At, 0), d && !F && Ge.restart(!0) } }, ke = function (Ne) { if (!oe(Ne)) { var At = Ne.clientX, Lt = Ne.clientY, je = At - Z.x, Ft = Lt - Z.y; Z.x = At, Z.y = Lt, pe = !0, (je || Ft) && be(je, Ft) } }, St = function (Ne) { Z.event = Ne, j(Z) }, Qt = function (Ne) { Z.event = Ne, q(Z) }, $t = function (Ne) { return oe(Ne) || cd(Ne, f) && ge(Z) }; Ge = Z._dc = Oi.delayedCall(p || .25, X).pause(), Z.deltaX = Z.deltaY = 0, Z._vx = Iw(0, 50, !0), Z._vy = Iw(0, 50, !0), Z.scrollX = st, Z.scrollY = ot, Z.isDragging = Z.isGesturing = Z.isPressed = !1, vD(this), Z.enable = function (ht) { return Z.isEnabled || (cr(re ? Ae : a, "scroll", Pw), o.indexOf("scroll") >= 0 && cr(re ? Ae : a, "scroll", se, f, Be), o.indexOf("wheel") >= 0 && cr(a, "wheel", Se, f, Be), (o.indexOf("touch") >= 0 && gD || o.indexOf("pointer") >= 0) && (cr(a, Qs[0], lt, f, Be), cr(Ae, Qs[2], vt), cr(Ae, Qs[3], vt), Ie && cr(a, "click", Te, !1, !0), ge && cr(a, "click", $t), Y && cr(Ae, "gesturestart", W), L && cr(Ae, "gestureend", Oe), j && cr(a, _c + "enter", St), q && cr(a, _c + "leave", Qt), ne && cr(a, _c + "move", ke)), Z.isEnabled = !0, ht && ht.type && lt(ht), K && K(Z)), Z }, Z.disable = function () { Z.isEnabled && (Cf.filter(function (ht) { return ht !== Z && qd(ht.target) }).length || ar(re ? Ae : a, "scroll", Pw), Z.isPressed && (Z._vx.reset(), Z._vy.reset(), ar(F ? a : Ae, Qs[1], De, !0)), ar(re ? Ae : a, "scroll", se, Be), ar(a, "wheel", Se, Be), ar(a, Qs[0], lt, Be), ar(Ae, Qs[2], vt), ar(Ae, Qs[3], vt), ar(a, "click", Te, !0), ar(a, "click", $t), ar(Ae, "gesturestart", W), ar(Ae, "gestureend", Oe), ar(a, _c + "enter", St), ar(a, _c + "leave", Qt), ar(a, _c + "move", ke), Z.isEnabled = Z.isPressed = Z.isDragging = !1, ye && ye(Z)) }, Z.kill = Z.revert = function () { Z.disable(); var ht = Cf.indexOf(Z); ht >= 0 && Cf.splice(ht, 1), _a === Z && (_a = 0) }, Cf.push(Z), F && qd(a) && (_a = Z), Z.enable(_) }, sG(i, [{ key: "velocityX", get: function () { return this._vx.getVelocity() } }, { key: "velocityY", get: function () { return this._vy.getVelocity() } }]), i }(); si.version = "3.12.2"; si.create = function (i) { return new si(i) }; si.register = MD; si.getAll = function () { return Cf.slice() }; si.getById = function (i) { return Cf.filter(function (e) { return e.vars.id === i })[0] }; _D() && Oi.registerPlugin(si);/*!
 * ScrollTrigger 3.12.2
 * https://greensock.com
 *
 * @license Copyright 2008-2023, GreenSock. All rights reserved.
 * Subject to the terms at https://greensock.com/standard-license or for
 * Club GreenSock members, the agreement issued with that membership.
 * @author: Jack Doyle, jack@greensock.com
*/var tt, lf, Wt, Tn, no, gn, wD, Yy, jy, Tf, K0, Ig, ji, Iv, Bw, hr, mR, gR, cf, SD, Qx, ED, Jr, CD, TD, bD, el, Lw, j1, Xf, K1, Zx, Bg = 1, pr = Date.now, $x = pr(), Os = 0, Pd = 0, yR = function (e, t, n) { var r = qr(e) && (e.substr(0, 6) === "clamp(" || e.indexOf("max") > -1); return n["_" + t + "Clamp"] = r, r ? e.substr(6, e.length - 7) : e }, vR = function (e, t) { return t && (!qr(e) || e.substr(0, 6) !== "clamp(") ? "clamp(" + e + ")" : e }, aG = function i() { return Pd && requestAnimationFrame(i) }, _R = function () { return Iv = 1 }, xR = function () { return Iv = 0 }, Po = function (e) { return e }, Id = function (e) { return Math.round(e * 1e5) / 1e5 || 0 }, RD = function () { return typeof window < "u" }, PD = function () { return tt || RD() && (tt = window.gsap) && tt.registerPlugin && tt }, nu = function (e) { return !!~wD.indexOf(e) }, ID = function (e) { return (e === "Height" ? K1 : Wt["inner" + e]) || no["client" + e] || gn["client" + e] }, BD = function (e) { return Cl(e, "getBoundingClientRect") || (nu(e) ? function () { return ty.width = Wt.innerWidth, ty.height = K1, ty } : function () { return pa(e) }) }, lG = function (e, t, n) { var r = n.d, s = n.d2, o = n.a; return (o = Cl(e, "getBoundingClientRect")) ? function () { return o()[r] } : function () { return (t ? ID(s) : e["client" + s]) || 0 } }, cG = function (e, t) { return !t || ~Uo.indexOf(e) ? BD(e) : function () { return ty } }, xa = function (e, t) { var n = t.s, r = t.d2, s = t.d, o = t.a; return Math.max(0, (n = "scroll" + r) && (o = Cl(e, n)) ? o() - BD(e)()[s] : nu(e) ? (no[n] || gn[n]) - ID(r) : e[n] - e["offset" + r]) }, Lg = function (e, t) { for (var n = 0; n < cf.length; n += 3)(!t || ~t.indexOf(cf[n + 1])) && e(cf[n], cf[n + 1], cf[n + 2]) }, qr = function (e) { return typeof e == "string" }, gr = function (e) { return typeof e == "function" }, q0 = function (e) { return typeof e == "number" }, xc = function (e) { return typeof e == "object" }, ud = function (e, t, n) { return e && e.progress(t ? 0 : 1) && n && e.pause() }, eA = function (e, t) { if (e.enabled) { var n = t(e); n && n.totalTime && (e.callbackAnimation = n) } }, Du = Math.abs, LD = "left", DD = "top", q1 = "right", Q1 = "bottom", Vc = "width", Wc = "height", Qd = "Right", Zd = "Left", $d = "Top", ep = "Bottom", ni = "padding", bs = "margin", uh = "Width", Z1 = "Height", Ii = "px", Rs = function (e) { return Wt.getComputedStyle(e) }, uG = function (e) { var t = Rs(e).position; e.style.position = t === "absolute" || t === "fixed" ? t : "relative" }, AR = function (e, t) { for (var n in t) n in e || (e[n] = t[n]); return e }, pa = function (e, t) { var n = t && Rs(e)[Bw] !== "matrix(1, 0, 0, 1, 0, 0)" && tt.to(e, { x: 0, y: 0, xPercent: 0, yPercent: 0, rotation: 0, rotationX: 0, rotationY: 0, scale: 1, skewX: 0, skewY: 0 }).progress(1), r = e.getBoundingClientRect(); return n && n.progress(0).kill(), r }, Dw = function (e, t) { var n = t.d2; return e["offset" + n] || e["client" + n] || 0 }, OD = function (e) { var t = [], n = e.labels, r = e.duration(), s; for (s in n) t.push(n[s] / r); return t }, fG = function (e) { return function (t) { return tt.utils.snap(OD(e), t) } }, $1 = function (e) { var t = tt.utils.snap(e), n = Array.isArray(e) && e.slice(0).sort(function (r, s) { return r - s }); return n ? function (r, s, o) { o === void 0 && (o = .001); var a; if (!s) return t(r); if (s > 0) { for (r -= o, a = 0; a < n.length; a++)if (n[a] >= r) return n[a]; return n[a - 1] } else for (a = n.length, r += o; a--;)if (n[a] <= r) return n[a]; return n[0] } : function (r, s, o) { o === void 0 && (o = .001); var a = t(r); return !s || Math.abs(a - r) < o || a - r < 0 == s < 0 ? a : t(s < 0 ? r - e : r + e) } }, hG = function (e) { return function (t, n) { return $1(OD(e))(t, n.direction) } }, Dg = function (e, t, n, r) { return n.split(",").forEach(function (s) { return e(t, s, r) }) }, Mi = function (e, t, n, r, s) { return e.addEventListener(t, n, { passive: !r, capture: !!s }) }, Ai = function (e, t, n, r) { return e.removeEventListener(t, n, !!r) }, Og = function (e, t, n) { n = n && n.wheelHandler, n && (e(t, "wheel", n), e(t, "touchmove", n)) }, MR = { startColor: "green", endColor: "red", indent: 0, fontSize: "16px", fontWeight: "normal" }, Fg = { toggleActions: "play", anticipatePin: 0 }, Ky = { top: 0, left: 0, center: .5, bottom: 1, right: 1 }, Q0 = function (e, t) { if (qr(e)) { var n = e.indexOf("="), r = ~n ? +(e.charAt(n - 1) + 1) * parseFloat(e.substr(n + 1)) : 0; ~n && (e.indexOf("%") > n && (r *= t / 100), e = e.substr(0, n - 1)), e = r + (e in Ky ? Ky[e] * t : ~e.indexOf("%") ? parseFloat(e) * t / 100 : parseFloat(e) || 0) } return e }, kg = function (e, t, n, r, s, o, a, l) { var c = s.startColor, f = s.endColor, d = s.fontSize, p = s.indent, m = s.fontWeight, y = Tn.createElement("div"), _ = nu(n) || Cl(n, "pinType") === "fixed", x = e.indexOf("scroller") !== -1, g = _ ? gn : n, A = e.indexOf("start") !== -1, M = A ? c : f, S = "border-color:" + M + ";font-size:" + d + ";color:" + M + ";font-weight:" + m + ";pointer-events:none;white-space:nowrap;font-family:sans-serif,Arial;z-index:1000;padding:4px 8px;border-width:0;border-style:solid;"; return S += "position:" + ((x || l) && _ ? "fixed;" : "absolute;"), (x || l || !_) && (S += (r === hi ? q1 : Q1) + ":" + (o + parseFloat(p)) + "px;"), a && (S += "box-sizing:border-box;text-align:left;width:" + a.offsetWidth + "px;"), y._isStart = A, y.setAttribute("class", "gsap-marker-" + e + (t ? " marker-" + t : "")), y.style.cssText = S, y.innerText = t || t === 0 ? e + "-" + t : e, g.children[0] ? g.insertBefore(y, g.children[0]) : g.appendChild(y), y._offset = y["offset" + r.op.d2], Z0(y, 0, r, A), y }, Z0 = function (e, t, n, r) { var s = { display: "block" }, o = n[r ? "os2" : "p2"], a = n[r ? "p2" : "os2"]; e._isFlipped = r, s[n.a + "Percent"] = r ? -100 : 0, s[n.a] = r ? "1px" : 0, s["border" + o + uh] = 1, s["border" + a + uh] = 0, s[n.p] = t + "px", tt.set(e, s) }, Ut = [], Ow = {}, Dp, wR = function () { return pr() - Os > 34 && (Dp || (Dp = requestAnimationFrame(Sa))) }, Ou = function () { (!Jr || !Jr.isPressed || Jr.startX > gn.clientWidth) && (Ht.cache++, Jr ? Dp || (Dp = requestAnimationFrame(Sa)) : Sa(), Os || ru("scrollStart"), Os = pr()) }, tA = function () { bD = Wt.innerWidth, TD = Wt.innerHeight }, Bd = function () { Ht.cache++, !ji && !ED && !Tn.fullscreenElement && !Tn.webkitFullscreenElement && (!CD || bD !== Wt.innerWidth || Math.abs(Wt.innerHeight - TD) > Wt.innerHeight * .25) && Yy.restart(!0) }, iu = {}, dG = [], FD = function i() { return Ai(Gt, "scrollEnd", i) || Ic(!0) }, ru = function (e) { return iu[e] && iu[e].map(function (t) { return t() }) || dG }, Yr = [], kD = function (e) { for (var t = 0; t < Yr.length; t += 5)(!e || Yr[t + 4] && Yr[t + 4].query === e) && (Yr[t].style.cssText = Yr[t + 1], Yr[t].getBBox && Yr[t].setAttribute("transform", Yr[t + 2] || ""), Yr[t + 3].uncache = 1) }, eE = function (e, t) { var n; for (hr = 0; hr < Ut.length; hr++)n = Ut[hr], n && (!t || n._ctx === t) && (e ? n.kill(1) : n.revert(!0, !0)); t && kD(t), t || ru("revert") }, ND = function (e, t) { Ht.cache++, (t || !dr) && Ht.forEach(function (n) { return gr(n) && n.cacheID++ && (n.rec = 0) }), qr(e) && (Wt.history.scrollRestoration = j1 = e) }, dr, Xc = 0, SR, pG = function () { if (SR !== Xc) { var e = SR = Xc; requestAnimationFrame(function () { return e === Xc && Ic(!0) }) } }, UD = function () { gn.appendChild(Xf), K1 = Xf.offsetHeight || Wt.innerHeight, gn.removeChild(Xf) }, Ic = function (e, t) { if (Os && !e) { Mi(Gt, "scrollEnd", FD); return } UD(), dr = Gt.isRefreshing = !0, Ht.forEach(function (r) { return gr(r) && ++r.cacheID && (r.rec = r()) }); var n = ru("refreshInit"); SD && Gt.sort(), t || eE(), Ht.forEach(function (r) { gr(r) && (r.smooth && (r.target.style.scrollBehavior = "auto"), r(0)) }), Ut.slice(0).forEach(function (r) { return r.refresh() }), Ut.forEach(function (r, s) { if (r._subPinOffset && r.pin) { var o = r.vars.horizontal ? "offsetWidth" : "offsetHeight", a = r.pin[o]; r.revert(!0, 1), r.adjustPinSpacing(r.pin[o] - a), r.refresh() } }), Ut.forEach(function (r) { var s = xa(r.scroller, r._dir); (r.vars.end === "max" || r._endClamp && r.end > s) && r.setPositions(r.start, Math.max(r.start + 1, s), !0) }), n.forEach(function (r) { return r && r.render && r.render(-1) }), Ht.forEach(function (r) { gr(r) && (r.smooth && requestAnimationFrame(function () { return r.target.style.scrollBehavior = "smooth" }), r.rec && r(r.rec)) }), ND(j1, 1), Yy.pause(), Xc++, dr = 2, Sa(2), Ut.forEach(function (r) { return gr(r.vars.onRefresh) && r.vars.onRefresh(r) }), dr = Gt.isRefreshing = !1, ru("refresh") }, Fw = 0, $0 = 1, tp, Sa = function (e) { if (!dr || e === 2) { Gt.isUpdating = !0, tp && tp.update(0); var t = Ut.length, n = pr(), r = n - $x >= 50, s = t && Ut[0].scroll(); if ($0 = Fw > s ? -1 : 1, dr || (Fw = s), r && (Os && !Iv && n - Os > 200 && (Os = 0, ru("scrollEnd")), K0 = $x, $x = n), $0 < 0) { for (hr = t; hr-- > 0;)Ut[hr] && Ut[hr].update(0, r); $0 = 1 } else for (hr = 0; hr < t; hr++)Ut[hr] && Ut[hr].update(0, r); Gt.isUpdating = !1 } Dp = 0 }, kw = [LD, DD, Q1, q1, bs + ep, bs + Qd, bs + $d, bs + Zd, "display", "flexShrink", "float", "zIndex", "gridColumnStart", "gridColumnEnd", "gridRowStart", "gridRowEnd", "gridArea", "justifySelf", "alignSelf", "placeSelf", "order"], ey = kw.concat([Vc, Wc, "boxSizing", "max" + uh, "max" + Z1, "position", bs, ni, ni + $d, ni + Qd, ni + ep, ni + Zd]), mG = function (e, t, n) { Jf(n); var r = e._gsap; if (r.spacerIsNative) Jf(r.spacerState); else if (e._gsap.swappedIn) { var s = t.parentNode; s && (s.insertBefore(e, t), s.removeChild(t)) } e._gsap.swappedIn = !1 }, nA = function (e, t, n, r) { if (!e._gsap.swappedIn) { for (var s = kw.length, o = t.style, a = e.style, l; s--;)l = kw[s], o[l] = n[l]; o.position = n.position === "absolute" ? "absolute" : "relative", n.display === "inline" && (o.display = "inline-block"), a[Q1] = a[q1] = "auto", o.flexBasis = n.flexBasis || "auto", o.overflow = "visible", o.boxSizing = "border-box", o[Vc] = Dw(e, mr) + Ii, o[Wc] = Dw(e, hi) + Ii, o[ni] = a[bs] = a[DD] = a[LD] = "0", Jf(r), a[Vc] = a["max" + uh] = n[Vc], a[Wc] = a["max" + Z1] = n[Wc], a[ni] = n[ni], e.parentNode !== t && (e.parentNode.insertBefore(t, e), t.appendChild(e)), e._gsap.swappedIn = !0 } }, gG = /([A-Z])/g, Jf = function (e) { if (e) { var t = e.t.style, n = e.length, r = 0, s, o; for ((e.t._gsap || tt.core.getCache(e.t)).uncache = 1; r < n; r += 2)o = e[r + 1], s = e[r], o ? t[s] = o : t[s] && t.removeProperty(s.replace(gG, "-$1").toLowerCase()) } }, Ng = function (e) { for (var t = ey.length, n = e.style, r = [], s = 0; s < t; s++)r.push(ey[s], n[ey[s]]); return r.t = e, r }, yG = function (e, t, n) { for (var r = [], s = e.length, o = n ? 8 : 0, a; o < s; o += 2)a = e[o], r.push(a, a in t ? t[a] : e[o + 1]); return r.t = e.t, r }, ty = { left: 0, top: 0 }, ER = function (e, t, n, r, s, o, a, l, c, f, d, p, m, y) { gr(e) && (e = e(l)), qr(e) && e.substr(0, 3) === "max" && (e = p + (e.charAt(4) === "=" ? Q0("0" + e.substr(3), n) : 0)); var _ = m ? m.time() : 0, x, g, A; if (m && m.seek(0), isNaN(e) || (e = +e), q0(e)) m && (e = tt.utils.mapRange(m.scrollTrigger.start, m.scrollTrigger.end, 0, p, e)), a && Z0(a, n, r, !0); else { gr(t) && (t = t(l)); var M = (e || "0").split(" "), S, C, T, R; A = Cr(t, l) || gn, S = pa(A) || {}, (!S || !S.left && !S.top) && Rs(A).display === "none" && (R = A.style.display, A.style.display = "block", S = pa(A), R ? A.style.display = R : A.style.removeProperty("display")), C = Q0(M[0], S[r.d]), T = Q0(M[1] || "0", n), e = S[r.p] - c[r.p] - f + C + s - T, a && Z0(a, T, r, n - T < 20 || a._isStart && T > 20), n -= n - T } if (y && (l[y] = e || -.001, e < 0 && (e = 0)), o) { var B = e + n, b = o._isStart; x = "scroll" + r.d2, Z0(o, B, r, b && B > 20 || !b && (d ? Math.max(gn[x], no[x]) : o.parentNode[x]) <= B + 1), d && (c = pa(a), d && (o.style[r.op.p] = c[r.op.p] - r.op.m - o._offset + Ii)) } return m && A && (x = pa(A), m.seek(p), g = pa(A), m._caScrollDist = x[r.p] - g[r.p], e = e / m._caScrollDist * p), m && m.seek(_), m ? e : Math.round(e) }, vG = /(webkit|moz|length|cssText|inset)/i, CR = function (e, t, n, r) { if (e.parentNode !== t) { var s = e.style, o, a; if (t === gn) { e._stOrig = s.cssText, a = Rs(e); for (o in a) !+o && !vG.test(o) && a[o] && typeof s[o] == "string" && o !== "0" && (s[o] = a[o]); s.top = n, s.left = r } else s.cssText = e._stOrig; tt.core.getCache(e).uncache = 1, t.appendChild(e) } }, zD = function (e, t, n) { var r = t, s = r; return function (o) { var a = Math.round(e()); return a !== r && a !== s && Math.abs(a - r) > 3 && Math.abs(a - s) > 3 && (o = a, n && n()), s = r, r = o, o } }, Ug = function (e, t, n) { var r = {}; r[t.p] = "+=" + n, tt.set(e, r) }, TR = function (e, t) { var n = Fl(e, t), r = "_scroll" + t.p2, s = function o(a, l, c, f, d) { var p = o.tween, m = l.onComplete, y = {}; c = c || n(); var _ = zD(n, c, function () { p.kill(), o.tween = 0 }); return d = f && d || 0, f = f || a - c, p && p.kill(), l[r] = a, l.modifiers = y, y[r] = function () { return _(c + f * p.ratio + d * p.ratio * p.ratio) }, l.onUpdate = function () { Ht.cache++, Sa() }, l.onComplete = function () { o.tween = 0, m && m.call(p) }, p = o.tween = tt.to(e, l), p }; return e[r] = n, n.wheelHandler = function () { return s.tween && s.tween.kill() && (s.tween = 0) }, Mi(e, "wheel", n.wheelHandler), Gt.isTouch && Mi(e, "touchmove", n.wheelHandler), s }, Gt = function () { function i(t, n) { lf || i.register(tt) || console.warn("Please gsap.registerPlugin(ScrollTrigger)"), Lw(this), this.init(t, n) } var e = i.prototype; return e.init = function (n, r) { if (this.progress = this.start = 0, this.vars && this.kill(!0, !0), !Pd) { this.update = this.refresh = this.kill = Po; return } n = AR(qr(n) || q0(n) || n.nodeType ? { trigger: n } : n, Fg); var s = n, o = s.onUpdate, a = s.toggleClass, l = s.id, c = s.onToggle, f = s.onRefresh, d = s.scrub, p = s.trigger, m = s.pin, y = s.pinSpacing, _ = s.invalidateOnRefresh, x = s.anticipatePin, g = s.onScrubComplete, A = s.onSnapComplete, M = s.once, S = s.snap, C = s.pinReparent, T = s.pinSpacer, R = s.containerAnimation, B = s.fastScrollEnd, b = s.preventOverlaps, I = n.horizontal || n.containerAnimation && n.horizontal !== !1 ? mr : hi, N = !d && d !== 0, V = Cr(n.scroller || Wt), J = tt.core.getCache(V), j = nu(V), q = ("pinType" in n ? n.pinType : Cl(V, "pinType") || j && "fixed") === "fixed", ne = [n.onEnter, n.onLeave, n.onEnterBack, n.onLeaveBack], Q = N && n.toggleActions.split(" "), F = "markers" in n ? n.markers : Fg.markers, Y = j ? 0 : parseFloat(Rs(V)["border" + I.p2 + uh]) || 0, L = this, G = n.onRefreshInit && function () { return n.onRefreshInit(L) }, K = lG(V, j, I), ye = cG(V, j), ge = 0, xe = 0, Be = 0, Ie = Fl(V, I), Je, ut, Bt, Ge, H, pe, fe, Ee, ve, Z, Fe, Ve, st, ot, Yt, U, D, re, Ae, Me, Ce, qe, Te, oe, X, he, we, be, De, lt, vt, W, Oe, se, Se, ke, St, Qt, $t; if (L._startClamp = L._endClamp = !1, L._dir = I, x *= 45, L.scroller = V, L.scroll = R ? R.time.bind(R) : Ie, Ge = Ie(), L.vars = n, r = r || n.animation, "refreshPriority" in n && (SD = 1, n.refreshPriority === -9999 && (tp = L)), J.tweenScroll = J.tweenScroll || { top: TR(V, hi), left: TR(V, mr) }, L.tweenTo = Je = J.tweenScroll[I.p], L.scrubDuration = function (je) { Oe = q0(je) && je, Oe ? W ? W.duration(je) : W = tt.to(r, { ease: "expo", totalProgress: "+=0", duration: Oe, paused: !0, onComplete: function () { return g && g(L) } }) : (W && W.progress(1).kill(), W = 0) }, r && (r.vars.lazy = !1, r._initted && !L.isReverted || r.vars.immediateRender !== !1 && n.immediateRender !== !1 && r.duration() && r.render(0, !0, !0), L.animation = r.pause(), r.scrollTrigger = L, L.scrubDuration(d), lt = 0, l || (l = r.vars.id)), S && ((!xc(S) || S.push) && (S = { snapTo: S }), "scrollBehavior" in gn.style && tt.set(j ? [gn, no] : V, { scrollBehavior: "auto" }), Ht.forEach(function (je) { return gr(je) && je.target === (j ? Tn.scrollingElement || no : V) && (je.smooth = !1) }), Bt = gr(S.snapTo) ? S.snapTo : S.snapTo === "labels" ? fG(r) : S.snapTo === "labelsDirectional" ? hG(r) : S.directional !== !1 ? function (je, Ft) { return $1(S.snapTo)(je, pr() - xe < 500 ? 0 : Ft.direction) } : tt.utils.snap(S.snapTo), se = S.duration || { min: .1, max: 2 }, se = xc(se) ? Tf(se.min, se.max) : Tf(se, se), Se = tt.delayedCall(S.delay || Oe / 2 || .1, function () { var je = Ie(), Ft = pr() - xe < 500, pt = Je.tween; if ((Ft || Math.abs(L.getVelocity()) < 10) && !pt && !Iv && ge !== je) { var _t = (je - pe) / ot, Sn = r && !N ? r.totalProgress() : _t, Mt = Ft ? 0 : (Sn - vt) / (pr() - K0) * 1e3 || 0, hn = tt.utils.clamp(-_t, 1 - _t, Du(Mt / 2) * Mt / .185), ai = _t + (S.inertia === !1 ? 0 : hn), Jn = Tf(0, 1, Bt(ai, L)), ln = Math.round(pe + Jn * ot), O = S, ie = O.onStart, ae = O.onInterrupt, te = O.onComplete; if (je <= fe && je >= pe && ln !== je) { if (pt && !pt._initted && pt.data <= Du(ln - je)) return; S.inertia === !1 && (hn = Jn - _t), Je(ln, { duration: se(Du(Math.max(Du(ai - Sn), Du(Jn - Sn)) * .185 / Mt / .05 || 0)), ease: S.ease || "power3", data: Du(ln - je), onInterrupt: function () { return Se.restart(!0) && ae && ae(L) }, onComplete: function () { L.update(), ge = Ie(), lt = vt = r && !N ? r.totalProgress() : L.progress, A && A(L), te && te(L) } }, je, hn * ot, ln - je - hn * ot), ie && ie(L, Je.tween) } } else L.isActive && ge !== je && Se.restart(!0) }).pause()), l && (Ow[l] = L), p = L.trigger = Cr(p || m !== !0 && m), $t = p && p._gsap && p._gsap.stRevert, $t && ($t = $t(L)), m = m === !0 ? p : Cr(m), qr(a) && (a = { targets: p, className: a }), m && (y === !1 || y === bs || (y = !y && m.parentNode && m.parentNode.style && Rs(m.parentNode).display === "flex" ? !1 : ni), L.pin = m, ut = tt.core.getCache(m), ut.spacer ? Yt = ut.pinState : (T && (T = Cr(T), T && !T.nodeType && (T = T.current || T.nativeElement), ut.spacerIsNative = !!T, T && (ut.spacerState = Ng(T))), ut.spacer = re = T || Tn.createElement("div"), re.classList.add("pin-spacer"), l && re.classList.add("pin-spacer-" + l), ut.pinState = Yt = Ng(m)), n.force3D !== !1 && tt.set(m, { force3D: !0 }), L.spacer = re = ut.spacer, De = Rs(m), oe = De[y + I.os2], Me = tt.getProperty(m), Ce = tt.quickSetter(m, I.a, Ii), nA(m, re, De), D = Ng(m)), F) { Ve = xc(F) ? AR(F, MR) : MR, Z = kg("scroller-start", l, V, I, Ve, 0), Fe = kg("scroller-end", l, V, I, Ve, 0, Z), Ae = Z["offset" + I.op.d2]; var ht = Cr(Cl(V, "content") || V); Ee = this.markerStart = kg("start", l, ht, I, Ve, Ae, 0, R), ve = this.markerEnd = kg("end", l, ht, I, Ve, Ae, 0, R), R && (Qt = tt.quickSetter([Ee, ve], I.a, Ii)), !q && !(Uo.length && Cl(V, "fixedMarkers") === !0) && (uG(j ? gn : V), tt.set([Z, Fe], { force3D: !0 }), he = tt.quickSetter(Z, I.a, Ii), be = tt.quickSetter(Fe, I.a, Ii)) } if (R) { var Ne = R.vars.onUpdate, At = R.vars.onUpdateParams; R.eventCallback("onUpdate", function () { L.update(0, 0, 1), Ne && Ne.apply(R, At || []) }) } if (L.previous = function () { return Ut[Ut.indexOf(L) - 1] }, L.next = function () { return Ut[Ut.indexOf(L) + 1] }, L.revert = function (je, Ft) { if (!Ft) return L.kill(!0); var pt = je !== !1 || !L.enabled, _t = ji; pt !== L.isReverted && (pt && (ke = Math.max(Ie(), L.scroll.rec || 0), Be = L.progress, St = r && r.progress()), Ee && [Ee, ve, Z, Fe].forEach(function (Sn) { return Sn.style.display = pt ? "none" : "block" }), pt && (ji = L, L.update(pt)), m && (!C || !L.isActive) && (pt ? mG(m, re, Yt) : nA(m, re, Rs(m), X)), pt || L.update(pt), ji = _t, L.isReverted = pt) }, L.refresh = function (je, Ft, pt, _t) { if (!((ji || !L.enabled) && !Ft)) { if (m && je && Os) { Mi(i, "scrollEnd", FD); return } !dr && G && G(L), ji = L, Je.tween && !pt && (Je.tween.kill(), Je.tween = 0), W && W.pause(), _ && r && r.revert({ kill: !1 }).invalidate(), L.isReverted || L.revert(!0, !0), L._subPinOffset = !1; var Sn = K(), Mt = ye(), hn = R ? R.duration() : xa(V, I), ai = ot <= .01, Jn = 0, ln = _t || 0, O = xc(pt) ? pt.end : n.end, ie = n.endTrigger || p, ae = xc(pt) ? pt.start : n.start || (n.start === 0 || !p ? 0 : m ? "0 0" : "0 100%"), te = L.pinnedContainer = n.pinnedContainer && Cr(n.pinnedContainer, L), ue = p && Math.max(0, Ut.indexOf(L)) || 0, Ue = ue, Ke, nt, ft, wt, Qe, Ze, zt, sn, Ri, li, Nt, gt, jt; for (F && xc(pt) && (gt = tt.getProperty(Z, I.p), jt = tt.getProperty(Fe, I.p)); Ue--;)Ze = Ut[Ue], Ze.end || Ze.refresh(0, 1) || (ji = L), zt = Ze.pin, zt && (zt === p || zt === m || zt === te) && !Ze.isReverted && (li || (li = []), li.unshift(Ze), Ze.revert(!0, !0)), Ze !== Ut[Ue] && (ue--, Ue--); for (gr(ae) && (ae = ae(L)), ae = yR(ae, "start", L), pe = ER(ae, p, Sn, I, Ie(), Ee, Z, L, Mt, Y, q, hn, R, L._startClamp && "_startClamp") || (m ? -.001 : 0), gr(O) && (O = O(L)), qr(O) && !O.indexOf("+=") && (~O.indexOf(" ") ? O = (qr(ae) ? ae.split(" ")[0] : "") + O : (Jn = Q0(O.substr(2), Sn), O = qr(ae) ? ae : (R ? tt.utils.mapRange(0, R.duration(), R.scrollTrigger.start, R.scrollTrigger.end, pe) : pe) + Jn, ie = p)), O = yR(O, "end", L), fe = Math.max(pe, ER(O || (ie ? "100% 0" : hn), ie, Sn, I, Ie() + Jn, ve, Fe, L, Mt, Y, q, hn, R, L._endClamp && "_endClamp")) || -.001, Jn = 0, Ue = ue; Ue--;)Ze = Ut[Ue], zt = Ze.pin, zt && Ze.start - Ze._pinPush <= pe && !R && Ze.end > 0 && (Ke = Ze.end - (L._startClamp ? Math.max(0, Ze.start) : Ze.start), (zt === p && Ze.start - Ze._pinPush < pe || zt === te) && isNaN(ae) && (Jn += Ke * (1 - Ze.progress)), zt === m && (ln += Ke)); if (pe += Jn, fe += Jn, L._startClamp && (L._startClamp += Jn), L._endClamp && !dr && (L._endClamp = fe || -.001, fe = Math.min(fe, xa(V, I))), ot = fe - pe || (pe -= .01) && .001, ai && (Be = tt.utils.clamp(0, 1, tt.utils.normalize(pe, fe, ke))), L._pinPush = ln, Ee && Jn && (Ke = {}, Ke[I.a] = "+=" + Jn, te && (Ke[I.p] = "-=" + Ie()), tt.set([Ee, ve], Ke)), m) Ke = Rs(m), wt = I === hi, ft = Ie(), qe = parseFloat(Me(I.a)) + ln, !hn && fe > 1 && (Nt = (j ? Tn.scrollingElement || no : V).style, Nt = { style: Nt, value: Nt["overflow" + I.a.toUpperCase()] }, j && Rs(gn)["overflow" + I.a.toUpperCase()] !== "scroll" && (Nt.style["overflow" + I.a.toUpperCase()] = "scroll")), nA(m, re, Ke), D = Ng(m), nt = pa(m, !0), sn = q && Fl(V, wt ? mr : hi)(), y && (X = [y + I.os2, ot + ln + Ii], X.t = re, Ue = y === ni ? Dw(m, I) + ot + ln : 0, Ue && X.push(I.d, Ue + Ii), Jf(X), te && Ut.forEach(function (dt) { dt.pin === te && dt.vars.pinSpacing !== !1 && (dt._subPinOffset = !0) }), q && Ie(ke)), q && (Qe = { top: nt.top + (wt ? ft - pe : sn) + Ii, left: nt.left + (wt ? sn : ft - pe) + Ii, boxSizing: "border-box", position: "fixed" }, Qe[Vc] = Qe["max" + uh] = Math.ceil(nt.width) + Ii, Qe[Wc] = Qe["max" + Z1] = Math.ceil(nt.height) + Ii, Qe[bs] = Qe[bs + $d] = Qe[bs + Qd] = Qe[bs + ep] = Qe[bs + Zd] = "0", Qe[ni] = Ke[ni], Qe[ni + $d] = Ke[ni + $d], Qe[ni + Qd] = Ke[ni + Qd], Qe[ni + ep] = Ke[ni + ep], Qe[ni + Zd] = Ke[ni + Zd], U = yG(Yt, Qe, C), dr && Ie(0)), r ? (Ri = r._initted, Qx(1), r.render(r.duration(), !0, !0), Te = Me(I.a) - qe + ot + ln, we = Math.abs(ot - Te) > 1, q && we && U.splice(U.length - 2, 2), r.render(0, !0, !0), Ri || r.invalidate(!0), r.parent || r.totalTime(r.totalTime()), Qx(0)) : Te = ot, Nt && (Nt.value ? Nt.style["overflow" + I.a.toUpperCase()] = Nt.value : Nt.style.removeProperty("overflow-" + I.a)); else if (p && Ie() && !R) for (nt = p.parentNode; nt && nt !== gn;)nt._pinOffset && (pe -= nt._pinOffset, fe -= nt._pinOffset), nt = nt.parentNode; li && li.forEach(function (dt) { return dt.revert(!1, !0) }), L.start = pe, L.end = fe, Ge = H = dr ? ke : Ie(), !R && !dr && (Ge < ke && Ie(ke), L.scroll.rec = 0), L.revert(!1, !0), xe = pr(), Se && (ge = -1, Se.restart(!0)), ji = 0, r && N && (r._initted || St) && r.progress() !== St && r.progress(St || 0, !0).render(r.time(), !0, !0), (ai || Be !== L.progress || R) && (r && !N && r.totalProgress(R && pe < -.001 && !Be ? tt.utils.normalize(pe, fe, 0) : Be, !0), L.progress = ai || (Ge - pe) / ot === Be ? 0 : Be), m && y && (re._pinOffset = Math.round(L.progress * Te)), W && W.invalidate(), isNaN(gt) || (gt -= tt.getProperty(Z, I.p), jt -= tt.getProperty(Fe, I.p), Ug(Z, I, gt), Ug(Ee, I, gt - (_t || 0)), Ug(Fe, I, jt), Ug(ve, I, jt - (_t || 0))), ai && !dr && L.update(), f && !dr && !st && (st = !0, f(L), st = !1) } }, L.getVelocity = function () { return (Ie() - H) / (pr() - K0) * 1e3 || 0 }, L.endAnimation = function () { ud(L.callbackAnimation), r && (W ? W.progress(1) : r.paused() ? N || ud(r, L.direction < 0, 1) : ud(r, r.reversed())) }, L.labelToScroll = function (je) { return r && r.labels && (pe || L.refresh() || pe) + r.labels[je] / r.duration() * ot || 0 }, L.getTrailing = function (je) { var Ft = Ut.indexOf(L), pt = L.direction > 0 ? Ut.slice(0, Ft).reverse() : Ut.slice(Ft + 1); return (qr(je) ? pt.filter(function (_t) { return _t.vars.preventOverlaps === je }) : pt).filter(function (_t) { return L.direction > 0 ? _t.end <= pe : _t.start >= fe }) }, L.update = function (je, Ft, pt) { if (!(R && !pt && !je)) { var _t = dr === !0 ? ke : L.scroll(), Sn = je ? 0 : (_t - pe) / ot, Mt = Sn < 0 ? 0 : Sn > 1 ? 1 : Sn || 0, hn = L.progress, ai, Jn, ln, O, ie, ae, te, ue; if (Ft && (H = Ge, Ge = R ? Ie() : _t, S && (vt = lt, lt = r && !N ? r.totalProgress() : Mt)), x && !Mt && m && !ji && !Bg && Os && pe < _t + (_t - H) / (pr() - K0) * x && (Mt = 1e-4), Mt !== hn && L.enabled) { if (ai = L.isActive = !!Mt && Mt < 1, Jn = !!hn && hn < 1, ae = ai !== Jn, ie = ae || !!Mt != !!hn, L.direction = Mt > hn ? 1 : -1, L.progress = Mt, ie && !ji && (ln = Mt && !hn ? 0 : Mt === 1 ? 1 : hn === 1 ? 2 : 3, N && (O = !ae && Q[ln + 1] !== "none" && Q[ln + 1] || Q[ln], ue = r && (O === "complete" || O === "reset" || O in r))), b && (ae || ue) && (ue || d || !r) && (gr(b) ? b(L) : L.getTrailing(b).forEach(function (ft) { return ft.endAnimation() })), N || (W && !ji && !Bg ? (W._dp._time - W._start !== W._time && W.render(W._dp._time - W._start), W.resetTo ? W.resetTo("totalProgress", Mt, r._tTime / r._tDur) : (W.vars.totalProgress = Mt, W.invalidate().restart())) : r && r.totalProgress(Mt, !!(ji && (xe || je)))), m) { if (je && y && (re.style[y + I.os2] = oe), !q) Ce(Id(qe + Te * Mt)); else if (ie) { if (te = !je && Mt > hn && fe + 1 > _t && _t + 1 >= xa(V, I), C) if (!je && (ai || te)) { var Ue = pa(m, !0), Ke = _t - pe; CR(m, gn, Ue.top + (I === hi ? Ke : 0) + Ii, Ue.left + (I === hi ? 0 : Ke) + Ii) } else CR(m, re); Jf(ai || te ? U : D), we && Mt < 1 && ai || Ce(qe + (Mt === 1 && !te ? Te : 0)) } } S && !Je.tween && !ji && !Bg && Se.restart(!0), a && (ae || M && Mt && (Mt < 1 || !Zx)) && jy(a.targets).forEach(function (ft) { return ft.classList[ai || M ? "add" : "remove"](a.className) }), o && !N && !je && o(L), ie && !ji ? (N && (ue && (O === "complete" ? r.pause().totalProgress(1) : O === "reset" ? r.restart(!0).pause() : O === "restart" ? r.restart(!0) : r[O]()), o && o(L)), (ae || !Zx) && (c && ae && eA(L, c), ne[ln] && eA(L, ne[ln]), M && (Mt === 1 ? L.kill(!1, 1) : ne[ln] = 0), ae || (ln = Mt === 1 ? 1 : 3, ne[ln] && eA(L, ne[ln]))), B && !ai && Math.abs(L.getVelocity()) > (q0(B) ? B : 2500) && (ud(L.callbackAnimation), W ? W.progress(1) : ud(r, O === "reverse" ? 1 : !Mt, 1))) : N && o && !ji && o(L) } if (be) { var nt = R ? _t / R.duration() * (R._caScrollDist || 0) : _t; he(nt + (Z._isFlipped ? 1 : 0)), be(nt) } Qt && Qt(-_t / R.duration() * (R._caScrollDist || 0)) } }, L.enable = function (je, Ft) { L.enabled || (L.enabled = !0, Mi(V, "resize", Bd), j || Mi(V, "scroll", Ou), G && Mi(i, "refreshInit", G), je !== !1 && (L.progress = Be = 0, Ge = H = ge = Ie()), Ft !== !1 && L.refresh()) }, L.getTween = function (je) { return je && Je ? Je.tween : W }, L.setPositions = function (je, Ft, pt, _t) { if (R) { var Sn = R.scrollTrigger, Mt = R.duration(), hn = Sn.end - Sn.start; je = Sn.start + hn * je / Mt, Ft = Sn.start + hn * Ft / Mt } L.refresh(!1, !1, { start: vR(je, pt && !!L._startClamp), end: vR(Ft, pt && !!L._endClamp) }, _t), L.update() }, L.adjustPinSpacing = function (je) { if (X && je) { var Ft = X.indexOf(I.d) + 1; X[Ft] = parseFloat(X[Ft]) + je + Ii, X[1] = parseFloat(X[1]) + je + Ii, Jf(X) } }, L.disable = function (je, Ft) { if (L.enabled && (je !== !1 && L.revert(!0, !0), L.enabled = L.isActive = !1, Ft || W && W.pause(), ke = 0, ut && (ut.uncache = 1), G && Ai(i, "refreshInit", G), Se && (Se.pause(), Je.tween && Je.tween.kill() && (Je.tween = 0)), !j)) { for (var pt = Ut.length; pt--;)if (Ut[pt].scroller === V && Ut[pt] !== L) return; Ai(V, "resize", Bd), j || Ai(V, "scroll", Ou) } }, L.kill = function (je, Ft) { L.disable(je, Ft), W && !Ft && W.kill(), l && delete Ow[l]; var pt = Ut.indexOf(L); pt >= 0 && Ut.splice(pt, 1), pt === hr && $0 > 0 && hr--, pt = 0, Ut.forEach(function (_t) { return _t.scroller === L.scroller && (pt = 1) }), pt || dr || (L.scroll.rec = 0), r && (r.scrollTrigger = null, je && r.revert({ kill: !1 }), Ft || r.kill()), Ee && [Ee, ve, Z, Fe].forEach(function (_t) { return _t.parentNode && _t.parentNode.removeChild(_t) }), tp === L && (tp = 0), m && (ut && (ut.uncache = 1), pt = 0, Ut.forEach(function (_t) { return _t.pin === m && pt++ }), pt || (ut.spacer = 0)), n.onKill && n.onKill(L) }, Ut.push(L), L.enable(!1, !1), $t && $t(L), r && r.add && !ot) { var Lt = L.update; L.update = function () { L.update = Lt, pe || fe || L.refresh() }, tt.delayedCall(.01, L.update), ot = .01, pe = fe = 0 } else L.refresh(); m && pG() }, i.register = function (n) { return lf || (tt = n || PD(), RD() && window.document && i.enable(), lf = Pd), lf }, i.defaults = function (n) { if (n) for (var r in n) Fg[r] = n[r]; return Fg }, i.disable = function (n, r) { Pd = 0, Ut.forEach(function (o) { return o[r ? "kill" : "disable"](n) }), Ai(Wt, "wheel", Ou), Ai(Tn, "scroll", Ou), clearInterval(Ig), Ai(Tn, "touchcancel", Po), Ai(gn, "touchstart", Po), Dg(Ai, Tn, "pointerdown,touchstart,mousedown", _R), Dg(Ai, Tn, "pointerup,touchend,mouseup", xR), Yy.kill(), Lg(Ai); for (var s = 0; s < Ht.length; s += 3)Og(Ai, Ht[s], Ht[s + 1]), Og(Ai, Ht[s], Ht[s + 2]) }, i.enable = function () { if (Wt = window, Tn = document, no = Tn.documentElement, gn = Tn.body, tt && (jy = tt.utils.toArray, Tf = tt.utils.clamp, Lw = tt.core.context || Po, Qx = tt.core.suppressOverwrites || Po, j1 = Wt.history.scrollRestoration || "auto", Fw = Wt.pageYOffset, tt.core.globals("ScrollTrigger", i), gn)) { Pd = 1, Xf = document.createElement("div"), Xf.style.height = "100vh", Xf.style.position = "absolute", UD(), aG(), si.register(tt), i.isTouch = si.isTouch, el = si.isTouch && /(iPad|iPhone|iPod|Mac)/g.test(navigator.userAgent), Mi(Wt, "wheel", Ou), wD = [Wt, Tn, no, gn], tt.matchMedia ? (i.matchMedia = function (l) { var c = tt.matchMedia(), f; for (f in l) c.add(f, l[f]); return c }, tt.addEventListener("matchMediaInit", function () { return eE() }), tt.addEventListener("matchMediaRevert", function () { return kD() }), tt.addEventListener("matchMedia", function () { Ic(0, 1), ru("matchMedia") }), tt.matchMedia("(orientation: portrait)", function () { return tA(), tA })) : console.warn("Requires GSAP 3.11.0 or later"), tA(), Mi(Tn, "scroll", Ou); var n = gn.style, r = n.borderTopStyle, s = tt.core.Animation.prototype, o, a; for (s.revert || Object.defineProperty(s, "revert", { value: function () { return this.time(-.01, !0) } }), n.borderTopStyle = "solid", o = pa(gn), hi.m = Math.round(o.top + hi.sc()) || 0, mr.m = Math.round(o.left + mr.sc()) || 0, r ? n.borderTopStyle = r : n.removeProperty("border-top-style"), Ig = setInterval(wR, 250), tt.delayedCall(.5, function () { return Bg = 0 }), Mi(Tn, "touchcancel", Po), Mi(gn, "touchstart", Po), Dg(Mi, Tn, "pointerdown,touchstart,mousedown", _R), Dg(Mi, Tn, "pointerup,touchend,mouseup", xR), Bw = tt.utils.checkPrefix("transform"), ey.push(Bw), lf = pr(), Yy = tt.delayedCall(.2, Ic).pause(), cf = [Tn, "visibilitychange", function () { var l = Wt.innerWidth, c = Wt.innerHeight; Tn.hidden ? (mR = l, gR = c) : (mR !== l || gR !== c) && Bd() }, Tn, "DOMContentLoaded", Ic, Wt, "load", Ic, Wt, "resize", Bd], Lg(Mi), Ut.forEach(function (l) { return l.enable(0, 1) }), a = 0; a < Ht.length; a += 3)Og(Ai, Ht[a], Ht[a + 1]), Og(Ai, Ht[a], Ht[a + 2]) } }, i.config = function (n) { "limitCallbacks" in n && (Zx = !!n.limitCallbacks); var r = n.syncInterval; r && clearInterval(Ig) || (Ig = r) && setInterval(wR, r), "ignoreMobileResize" in n && (CD = i.isTouch === 1 && n.ignoreMobileResize), "autoRefreshEvents" in n && (Lg(Ai) || Lg(Mi, n.autoRefreshEvents || "none"), ED = (n.autoRefreshEvents + "").indexOf("resize") === -1) }, i.scrollerProxy = function (n, r) { var s = Cr(n), o = Ht.indexOf(s), a = nu(s); ~o && Ht.splice(o, a ? 6 : 2), r && (a ? Uo.unshift(Wt, r, gn, r, no, r) : Uo.unshift(s, r)) }, i.clearMatchMedia = function (n) { Ut.forEach(function (r) { return r._ctx && r._ctx.query === n && r._ctx.kill(!0, !0) }) }, i.isInViewport = function (n, r, s) { var o = (qr(n) ? Cr(n) : n).getBoundingClientRect(), a = o[s ? Vc : Wc] * r || 0; return s ? o.right - a > 0 && o.left + a < Wt.innerWidth : o.bottom - a > 0 && o.top + a < Wt.innerHeight }, i.positionInViewport = function (n, r, s) { qr(n) && (n = Cr(n)); var o = n.getBoundingClientRect(), a = o[s ? Vc : Wc], l = r == null ? a / 2 : r in Ky ? Ky[r] * a : ~r.indexOf("%") ? parseFloat(r) * a / 100 : parseFloat(r) || 0; return s ? (o.left + l) / Wt.innerWidth : (o.top + l) / Wt.innerHeight }, i.killAll = function (n) { if (Ut.slice(0).forEach(function (s) { return s.vars.id !== "ScrollSmoother" && s.kill() }), n !== !0) { var r = iu.killAll || []; iu = {}, r.forEach(function (s) { return s() }) } }, i }(); Gt.version = "3.12.2"; Gt.saveStyles = function (i) { return i ? jy(i).forEach(function (e) { if (e && e.style) { var t = Yr.indexOf(e); t >= 0 && Yr.splice(t, 5), Yr.push(e, e.style.cssText, e.getBBox && e.getAttribute("transform"), tt.core.getCache(e), Lw()) } }) : Yr }; Gt.revert = function (i, e) { return eE(!i, e) }; Gt.create = function (i, e) { return new Gt(i, e) }; Gt.refresh = function (i) { return i ? Bd() : (lf || Gt.register()) && Ic(!0) }; Gt.update = function (i) { return ++Ht.cache && Sa(i === !0 ? 2 : 0) }; Gt.clearScrollMemory = ND; Gt.maxScroll = function (i, e) { return xa(i, e ? mr : hi) }; Gt.getScrollFunc = function (i, e) { return Fl(Cr(i), e ? mr : hi) }; Gt.getById = function (i) { return Ow[i] }; Gt.getAll = function () { return Ut.filter(function (i) { return i.vars.id !== "ScrollSmoother" }) }; Gt.isScrolling = function () { return !!Os }; Gt.snapDirectional = $1; Gt.addEventListener = function (i, e) { var t = iu[i] || (iu[i] = []); ~t.indexOf(e) || t.push(e) }; Gt.removeEventListener = function (i, e) { var t = iu[i], n = t && t.indexOf(e); n >= 0 && t.splice(n, 1) }; Gt.batch = function (i, e) { var t = [], n = {}, r = e.interval || .016, s = e.batchMax || 1e9, o = function (c, f) { var d = [], p = [], m = tt.delayedCall(r, function () { f(d, p), d = [], p = [] }).pause(); return function (y) { d.length || m.restart(!0), d.push(y.trigger), p.push(y), s <= d.length && m.progress(1) } }, a; for (a in e) n[a] = a.substr(0, 2) === "on" && gr(e[a]) && a !== "onRefreshInit" ? o(a, e[a]) : e[a]; return gr(s) && (s = s(), Mi(Gt, "refresh", function () { return s = e.batchMax() })), jy(i).forEach(function (l) { var c = {}; for (a in n) c[a] = n[a]; c.trigger = l, t.push(Gt.create(c)) }), t }; var bR = function (e, t, n, r) { return t > r ? e(r) : t < 0 && e(0), n > r ? (r - t) / (n - t) : n < 0 ? t / (t - n) : 1 }, iA = function i(e, t) { t === !0 ? e.style.removeProperty("touch-action") : e.style.touchAction = t === !0 ? "auto" : t ? "pan-" + t + (si.isTouch ? " pinch-zoom" : "") : "none", e === no && i(gn, t) }, zg = { auto: 1, scroll: 1 }, _G = function (e) { var t = e.event, n = e.target, r = e.axis, s = (t.changedTouches ? t.changedTouches[0] : t).target, o = s._gsap || tt.core.getCache(s), a = pr(), l; if (!o._isScrollT || a - o._isScrollT > 2e3) { for (; s && s !== gn && (s.scrollHeight <= s.clientHeight && s.scrollWidth <= s.clientWidth || !(zg[(l = Rs(s)).overflowY] || zg[l.overflowX]));)s = s.parentNode; o._isScroll = s && s !== n && !nu(s) && (zg[(l = Rs(s)).overflowY] || zg[l.overflowX]), o._isScrollT = a } (o._isScroll || r === "x") && (t.stopPropagation(), t._gsapAllow = !0) }, HD = function (e, t, n, r) { return si.create({ target: e, capture: !0, debounce: !1, lockAxis: !0, type: t, onWheel: r = r && _G, onPress: r, onDrag: r, onScroll: r, onEnable: function () { return n && Mi(Tn, si.eventTypes[0], PR, !1, !0) }, onDisable: function () { return Ai(Tn, si.eventTypes[0], PR, !0) } }) }, xG = /(input|label|select|textarea)/i, RR, PR = function (e) { var t = xG.test(e.target.tagName); (t || RR) && (e._gsapAllow = !0, RR = t) }, AG = function (e) { xc(e) || (e = {}), e.preventDefault = e.isNormalizer = e.allowClicks = !0, e.type || (e.type = "wheel,touch"), e.debounce = !!e.debounce, e.id = e.id || "normalizer"; var t = e, n = t.normalizeScrollX, r = t.momentum, s = t.allowNestedScroll, o = t.onRelease, a, l, c = Cr(e.target) || no, f = tt.core.globals().ScrollSmoother, d = f && f.get(), p = el && (e.content && Cr(e.content) || d && e.content !== !1 && !d.smooth() && d.content()), m = Fl(c, hi), y = Fl(c, mr), _ = 1, x = (si.isTouch && Wt.visualViewport ? Wt.visualViewport.scale * Wt.visualViewport.width : Wt.outerWidth) / Wt.innerWidth, g = 0, A = gr(r) ? function () { return r(a) } : function () { return r || 2.8 }, M, S, C = HD(c, e.type, !0, s), T = function () { return S = !1 }, R = Po, B = Po, b = function () { l = xa(c, hi), B = Tf(el ? 1 : 0, l), n && (R = Tf(0, xa(c, mr))), M = Xc }, I = function () { p._gsap.y = Id(parseFloat(p._gsap.y) + m.offset) + "px", p.style.transform = "matrix3d(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, " + parseFloat(p._gsap.y) + ", 0, 1)", m.offset = m.cacheID = 0 }, N = function () { if (S) { requestAnimationFrame(T); var F = Id(a.deltaY / 2), Y = B(m.v - F); if (p && Y !== m.v + m.offset) { m.offset = Y - m.v; var L = Id((parseFloat(p && p._gsap.y) || 0) - m.offset); p.style.transform = "matrix3d(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, " + L + ", 0, 1)", p._gsap.y = L + "px", m.cacheID = Ht.cache, Sa() } return !0 } m.offset && I(), S = !0 }, V, J, j, q, ne = function () { b(), V.isActive() && V.vars.scrollY > l && (m() > l ? V.progress(1) && m(l) : V.resetTo("scrollY", l)) }; return p && tt.set(p, { y: "+=0" }), e.ignoreCheck = function (Q) { return el && Q.type === "touchmove" && N() || _ > 1.05 && Q.type !== "touchstart" || a.isGesturing || Q.touches && Q.touches.length > 1 }, e.onPress = function () { S = !1; var Q = _; _ = Id((Wt.visualViewport && Wt.visualViewport.scale || 1) / x), V.pause(), Q !== _ && iA(c, _ > 1.01 ? !0 : n ? !1 : "x"), J = y(), j = m(), b(), M = Xc }, e.onRelease = e.onGestureStart = function (Q, F) { if (m.offset && I(), !F) q.restart(!0); else { Ht.cache++; var Y = A(), L, G; n && (L = y(), G = L + Y * .05 * -Q.velocityX / .227, Y *= bR(y, L, G, xa(c, mr)), V.vars.scrollX = R(G)), L = m(), G = L + Y * .05 * -Q.velocityY / .227, Y *= bR(m, L, G, xa(c, hi)), V.vars.scrollY = B(G), V.invalidate().duration(Y).play(.01), (el && V.vars.scrollY >= l || L >= l - 1) && tt.to({}, { onUpdate: ne, duration: Y }) } o && o(Q) }, e.onWheel = function () { V._ts && V.pause(), pr() - g > 1e3 && (M = 0, g = pr()) }, e.onChange = function (Q, F, Y, L, G) { if (Xc !== M && b(), F && n && y(R(L[2] === F ? J + (Q.startX - Q.x) : y() + F - L[1])), Y) { m.offset && I(); var K = G[2] === Y, ye = K ? j + Q.startY - Q.y : m() + Y - G[1], ge = B(ye); K && ye !== ge && (j += ge - ye), m(ge) } (Y || F) && Sa() }, e.onEnable = function () { iA(c, n ? !1 : "x"), Gt.addEventListener("refresh", ne), Mi(Wt, "resize", ne), m.smooth && (m.target.style.scrollBehavior = "auto", m.smooth = y.smooth = !1), C.enable() }, e.onDisable = function () { iA(c, !0), Ai(Wt, "resize", ne), Gt.removeEventListener("refresh", ne), C.kill() }, e.lockAxis = e.lockAxis !== !1, a = new si(e), a.iOS = el, el && !m() && m(1), el && tt.ticker.add(Po), q = a._dc, V = tt.to(a, { ease: "power4", paused: !0, scrollX: n ? "+=0.1" : "+=0", scrollY: "+=0.1", modifiers: { scrollY: zD(m, m(), function () { return V.pause() }) }, onUpdate: Sa, onComplete: q.vars.onComplete }), a }; Gt.sort = function (i) { return Ut.sort(i || function (e, t) { return (e.vars.refreshPriority || 0) * -1e6 + e.start - (t.start + (t.vars.refreshPriority || 0) * -1e6) }) }; Gt.observe = function (i) { return new si(i) }; Gt.normalizeScroll = function (i) { if (typeof i > "u") return Jr; if (i === !0 && Jr) return Jr.enable(); if (i === !1) return Jr && Jr.kill(); var e = i instanceof si ? i : AG(i); return Jr && Jr.target === e.target && Jr.kill(), nu(e.target) && (Jr = e), e }; Gt.core = { _getVelocityProp: Iw, _inputObserver: HD, _scrollers: Ht, _proxies: Uo, bridge: { ss: function () { Os || ru("scrollStart"), Os = pr() }, ref: function () { return ji } } }; PD() && tt.registerPlugin(Gt); const np = "generated", MG = "pointerdown", wG = "pointerup", Nw = "pointerleave", SG = "pointerout", su = "pointermove", EG = "touchstart", IR = "touchend", CG = "touchmove", TG = "touchcancel", bG = "resize", RG = "visibilitychange", zs = "tsParticles - Error"; class jr { constructor(e, t, n) { if (this._updateFromAngle = (r, s) => { this.x = Math.cos(r) * s, this.y = Math.sin(r) * s }, !er(e) && e) { this.x = e.x, this.y = e.y; const r = e; this.z = r.z ? r.z : 0 } else if (e !== void 0 && t !== void 0) this.x = e, this.y = t, this.z = n ?? 0; else throw new Error(`${zs} Vector3d not initialized correctly`) } static get origin() { return jr.create(0, 0, 0) } get angle() { return Math.atan2(this.y, this.x) } set angle(e) { this._updateFromAngle(e, this.length) } get length() { return Math.sqrt(this.getLengthSq()) } set length(e) { this._updateFromAngle(this.angle, e) } static clone(e) { return jr.create(e.x, e.y, e.z) } static create(e, t, n) { return new jr(e, t, n) } add(e) { return jr.create(this.x + e.x, this.y + e.y, this.z + e.z) } addTo(e) { this.x += e.x, this.y += e.y, this.z += e.z } copy() { return jr.clone(this) } distanceTo(e) { return this.sub(e).length } distanceToSq(e) { return this.sub(e).getLengthSq() } div(e) { return jr.create(this.x / e, this.y / e, this.z / e) } divTo(e) { this.x /= e, this.y /= e, this.z /= e } getLengthSq() { return this.x ** 2 + this.y ** 2 } mult(e) { return jr.create(this.x * e, this.y * e, this.z * e) } multTo(e) { this.x *= e, this.y *= e, this.z *= e } normalize() { const e = this.length; e != 0 && this.multTo(1 / e) } rotate(e) { return jr.create(this.x * Math.cos(e) - this.y * Math.sin(e), this.x * Math.sin(e) + this.y * Math.cos(e), 0) } setTo(e) { this.x = e.x, this.y = e.y; const t = e; this.z = t.z ? t.z : 0 } sub(e) { return jr.create(this.x - e.x, this.y - e.y, this.z - e.z) } subFrom(e) { this.x -= e.x, this.y -= e.y, this.z -= e.z } } class dn extends jr { constructor(e, t) { super(e, t, 0) } static get origin() { return dn.create(0, 0) } static clone(e) { return dn.create(e.x, e.y) } static create(e, t) { return new dn(e, t) } } let PG = Math.random; const Uw = new Map; function rA(i, e) { Uw.get(i) || Uw.set(i, e) } function GD(i) { return Uw.get(i) || (e => e) } function Tt() { return fo(PG(), 0, 1 - 1e-16) } function fo(i, e, t) { return Math.min(Math.max(i, e), t) } function sA(i, e, t, n) { return Math.floor((i * t + e * n) / (t + n)) } function Si(i) { const e = ml(i); let t = tE(i); return e === t && (t = 0), Tt() * (e - t) + t } function ze(i) { return er(i) ? i : Si(i) } function tE(i) { return er(i) ? i : i.min } function ml(i) { return er(i) ? i : i.max } function it(i, e) { if (i === e || e === void 0 && er(i)) return i; const t = tE(i), n = ml(i); return e !== void 0 ? { min: Math.min(t, e), max: Math.max(n, e) } : it(t, n) } function La(i) { const e = i.random, { enable: t, minimumValue: n } = Tl(e) ? { enable: e, minimumValue: 0 } : e; return ze(t ? it(i.value, n) : i.value) } function $i(i, e) { const t = i.x - e.x, n = i.y - e.y; return { dx: t, dy: n, distance: Math.sqrt(t ** 2 + n ** 2) } } function vr(i, e) { return $i(i, e).distance } function IG(i, e, t) { if (er(i)) return i * Math.PI / 180; switch (i) { case "top": return -Math.PI / 2; case "top-right": return -Math.PI / 4; case "right": return 0; case "bottom-right": return Math.PI / 4; case "bottom": return Math.PI / 2; case "bottom-left": return 3 * Math.PI / 4; case "left": return Math.PI; case "top-left": return -3 * Math.PI / 4; case "inside": return Math.atan2(t.y - e.y, t.x - e.x); case "outside": return Math.atan2(e.y - t.y, e.x - t.x); default: return Tt() * Math.PI * 2 } } function BG(i) { const e = dn.origin; return e.length = 1, e.angle = i, e } function BR(i, e, t, n) { return dn.create(i.x * (t - n) / (t + n) + e.x * 2 * n / (t + n), i.y) } function VD(i) { var e, t; return { x: (((e = i.position) == null ? void 0 : e.x) ?? Tt() * 100) * i.size.width / 100, y: (((t = i.position) == null ? void 0 : t.y) ?? Tt() * 100) * i.size.height / 100 } } function WD(i) { var t, n; const e = { x: ((t = i.position) == null ? void 0 : t.x) !== void 0 ? ze(i.position.x) : void 0, y: ((n = i.position) == null ? void 0 : n.y) !== void 0 ? ze(i.position.y) : void 0 }; return VD({ size: i.size, position: e }) } function LG(i) { var e, t; return { x: ((e = i.position) == null ? void 0 : e.x) ?? Tt() * i.size.width, y: ((t = i.position) == null ? void 0 : t.y) ?? Tt() * i.size.height } } function XD(i) { return i ? i.endsWith("%") ? parseFloat(i) / 100 : parseFloat(i) : 1 } const DG = { debug: console.debug, error: console.error, info: console.info, log: console.log, verbose: console.log, warning: console.warn }; function ou() { return DG } function LR(i) { const e = { bounced: !1 }, { pSide: t, pOtherSide: n, rectSide: r, rectOtherSide: s, velocity: o, factor: a } = i; return n.min < s.min || n.min > s.max || n.max < s.min || n.max > s.max || (t.max >= r.min && t.max <= (r.max + r.min) / 2 && o > 0 || t.min <= r.max && t.min > (r.max + r.min) / 2 && o < 0) && (e.velocity = o * -a, e.bounced = !0), e } function OG(i, e) { const t = xn(e, n => i.matches(n)); return pi(t) ? t.some(n => n) : t } function fh() { return typeof window > "u" || !window || typeof window.document > "u" || !window.document } function FG() { return !fh() && typeof matchMedia < "u" } function JD(i) { if (FG()) return matchMedia(i) } function kG(i) { if (!(fh() || typeof MutationObserver > "u")) return new MutationObserver(i) } function _n(i, e) { return i === e || pi(e) && e.indexOf(i) > -1 } async function NG(i, e) { try { await document.fonts.load(`${e ?? "400"} 36px '${i ?? "Verdana"}'`) } catch { } } function YD(i) { return Math.floor(Tt() * i.length) } function tm(i, e, t = !0) { return i[e !== void 0 && t ? e % i.length : YD(i)] } function nm(i, e, t, n, r) { return UG(im(i, n ?? 0), e, t, r) } function UG(i, e, t, n) { let r = !0; return (!n || n === "bottom") && (r = i.top < e.height + t.x), r && (!n || n === "left") && (r = i.right > t.x), r && (!n || n === "right") && (r = i.left < e.width + t.y), r && (!n || n === "top") && (r = i.bottom > t.y), r } function im(i, e) { return { bottom: i.y + e, left: i.x - e, right: i.x + e, top: i.y - e } } function Qn(i, ...e) { for (const t of e) { if (t == null) continue; if (!bf(t)) { i = t; continue } const n = Array.isArray(t); n && (bf(i) || !i || !Array.isArray(i)) ? i = [] : !n && (bf(i) || !i || Array.isArray(i)) && (i = {}); for (const r in t) { if (r === "__proto__") continue; const s = t, o = s[r], a = i; a[r] = bf(o) && Array.isArray(o) ? o.map(l => Qn(a[r], l)) : Qn(a[r], o) } } return i } function nE(i, e) { return !!qD(e, t => t.enable && _n(i, t.mode)) } function iE(i, e, t) { xn(e, n => { const r = n.mode; n.enable && _n(i, r) && zG(n, t) }) } function zG(i, e) { const t = i.selectors; xn(t, n => { e(n, i) }) } function jD(i, e) { if (!(!e || !i)) return qD(i, t => OG(e, t.selectors)) } function zw(i) { return { position: i.getPosition(), radius: i.getRadius(), mass: i.getMass(), velocity: i.velocity, factor: dn.create(La(i.options.bounce.horizontal), La(i.options.bounce.vertical)) } } function KD(i, e) { const { x: t, y: n } = i.velocity.sub(e.velocity), [r, s] = [i.position, e.position], { dx: o, dy: a } = $i(s, r); if (t * o + n * a < 0) return; const l = -Math.atan2(a, o), c = i.mass, f = e.mass, d = i.velocity.rotate(l), p = e.velocity.rotate(l), m = BR(d, p, c, f), y = BR(p, d, c, f), _ = m.rotate(-l), x = y.rotate(-l); i.velocity.x = _.x * i.factor.x, i.velocity.y = _.y * i.factor.y, e.velocity.x = x.x * e.factor.x, e.velocity.y = x.y * e.factor.y } function HG(i, e) { const t = i.getPosition(), n = i.getRadius(), r = im(t, n), s = LR({ pSide: { min: r.left, max: r.right }, pOtherSide: { min: r.top, max: r.bottom }, rectSide: { min: e.left, max: e.right }, rectOtherSide: { min: e.top, max: e.bottom }, velocity: i.velocity.x, factor: La(i.options.bounce.horizontal) }); s.bounced && (s.velocity !== void 0 && (i.velocity.x = s.velocity), s.position !== void 0 && (i.position.x = s.position)); const o = LR({ pSide: { min: r.top, max: r.bottom }, pOtherSide: { min: r.left, max: r.right }, rectSide: { min: e.top, max: e.bottom }, rectOtherSide: { min: e.left, max: e.right }, velocity: i.velocity.y, factor: La(i.options.bounce.vertical) }); o.bounced && (o.velocity !== void 0 && (i.velocity.y = o.velocity), o.position !== void 0 && (i.position.y = o.position)) } function xn(i, e) { return pi(i) ? i.map((t, n) => e(t, n)) : e(i, 0) } function rs(i, e, t) { return pi(i) ? tm(i, e, t) : i } function qD(i, e) { return pi(i) ? i.find((t, n) => e(t, n)) : e(i, 0) ? i : void 0 } function QD(i, e) { const t = i.value, n = i.animation, r = { delayTime: ze(n.delay) * 1e3, enable: n.enable, value: ze(i.value) * e, max: ml(t) * e, min: tE(t) * e, loops: 0, maxLoops: ze(n.count), time: 0 }; if (n.enable) { switch (r.decay = 1 - ze(n.decay), n.mode) { case "increase": r.status = "increasing"; break; case "decrease": r.status = "decreasing"; break; case "random": r.status = Tt() >= .5 ? "increasing" : "decreasing"; break }const s = n.mode === "auto"; switch (n.startValue) { case "min": r.value = r.min, s && (r.status = "increasing"); break; case "max": r.value = r.max, s && (r.status = "decreasing"); break; case "random": default: r.value = Si(r), s && (r.status = Tt() >= .5 ? "increasing" : "decreasing"); break } } return r.initialValue = r.value, r } function ZD(i, e) { if (!(i.mode === "percent")) { const { mode: r, ...s } = i; return s } return "x" in i ? { x: i.x / 100 * e.width, y: i.y / 100 * e.height } : { width: i.width / 100 * e.width, height: i.height / 100 * e.height } } function $D(i, e) { return ZD(i, e) } function GG(i, e) { return ZD(i, e) } function Tl(i) { return typeof i == "boolean" } function co(i) { return typeof i == "string" } function er(i) { return typeof i == "number" } function eO(i) { return typeof i == "function" } function bf(i) { return typeof i == "object" && i !== null } function pi(i) { return Array.isArray(i) } const qy = "random", ny = "mid", Bv = new Map; function DR(i) { Bv.set(i.key, i) } function oA(i, e, t) { return t < 0 && (t += 1), t > 1 && (t -= 1), t < 1 / 6 ? i + (e - i) * 6 * t : t < 1 / 2 ? e : t < 2 / 3 ? i + (e - i) * (2 / 3 - t) * 6 : i } function VG(i) { for (const [, s] of Bv) if (i.startsWith(s.stringPrefix)) return s.parseString(i); const e = /^#?([a-f\d])([a-f\d])([a-f\d])([a-f\d])?$/i, t = i.replace(e, (s, o, a, l, c) => o + o + a + a + l + l + (c !== void 0 ? c + c : "")), n = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})?$/i, r = n.exec(t); return r ? { a: r[4] !== void 0 ? parseInt(r[4], 16) / 255 : 1, b: parseInt(r[3], 16), g: parseInt(r[2], 16), r: parseInt(r[1], 16) } : void 0 } function Fs(i, e, t = !0) { if (!i) return; const n = co(i) ? { value: i } : i; if (co(n.value)) return tO(n.value, e, t); if (pi(n.value)) return Fs({ value: tm(n.value, e, t) }); for (const [, r] of Bv) { const s = r.handleRangeColor(n); if (s) return s } } function tO(i, e, t = !0) { if (!i) return; const n = co(i) ? { value: i } : i; if (co(n.value)) return n.value === qy ? iO() : WG(n.value); if (pi(n.value)) return tO({ value: tm(n.value, e, t) }); for (const [, r] of Bv) { const s = r.handleColor(n); if (s) return s } } function kl(i, e, t = !0) { const n = Fs(i, e, t); return n ? nO(n) : void 0 } function nO(i) { const e = i.r / 255, t = i.g / 255, n = i.b / 255, r = Math.max(e, t, n), s = Math.min(e, t, n), o = { h: 0, l: (r + s) / 2, s: 0 }; return r !== s && (o.s = o.l < .5 ? (r - s) / (r + s) : (r - s) / (2 - r - s), o.h = e === r ? (t - n) / (r - s) : o.h = t === r ? 2 + (n - e) / (r - s) : 4 + (e - t) / (r - s)), o.l *= 100, o.s *= 100, o.h *= 60, o.h < 0 && (o.h += 360), o.h >= 360 && (o.h -= 360), o } function WG(i) { return VG(i) } function hh(i) { const e = { b: 0, g: 0, r: 0 }, t = { h: i.h / 360, l: i.l / 100, s: i.s / 100 }; if (!t.s) e.r = e.g = e.b = t.l; else { const n = t.l < .5 ? t.l * (1 + t.s) : t.l + t.s - t.l * t.s, r = 2 * t.l - n; e.r = oA(r, n, t.h + 1 / 3), e.g = oA(r, n, t.h), e.b = oA(r, n, t.h - 1 / 3) } return e.r = Math.floor(e.r * 255), e.g = Math.floor(e.g * 255), e.b = Math.floor(e.b * 255), e } function XG(i) { const e = hh(i); return { a: i.a, b: e.b, g: e.g, r: e.r } } function iO(i) { const e = i ?? 0; return { b: Math.floor(Si(it(e, 256))), g: Math.floor(Si(it(e, 256))), r: Math.floor(Si(it(e, 256))) } } function zo(i, e) { return `rgba(${i.r}, ${i.g}, ${i.b}, ${e ?? 1})` } function dh(i, e) { return `hsla(${i.h}, ${i.s}%, ${i.l}%, ${e ?? 1})` } function rE(i, e, t, n) { let r = i, s = e; return r.r === void 0 && (r = hh(i)), s.r === void 0 && (s = hh(e)), { b: sA(r.b, s.b, t, n), g: sA(r.g, s.g, t, n), r: sA(r.r, s.r, t, n) } } function Hw(i, e, t) { if (t === qy) return iO(); if (t === ny) { const n = i.getFillColor() ?? i.getStrokeColor(), r = (e == null ? void 0 : e.getFillColor()) ?? (e == null ? void 0 : e.getStrokeColor()); if (n && r && e) return rE(n, r, i.getRadius(), e.getRadius()); { const s = n ?? r; if (s) return hh(s) } } else return t } function rO(i, e, t) { const n = co(i) ? i : i.value; return n === qy ? t ? Fs({ value: n }) : e ? qy : ny : n === ny ? ny : Fs({ value: n }) } function OR(i) { return i !== void 0 ? { h: i.h.value, s: i.s.value, l: i.l.value } : void 0 } function sO(i, e, t) { const n = { h: { enable: !1, value: i.h }, s: { enable: !1, value: i.s }, l: { enable: !1, value: i.l } }; return e && (aA(n.h, e.h, t), aA(n.s, e.s, t), aA(n.l, e.l, t)), n } function aA(i, e, t) { i.enable = e.enable, i.enable ? (i.velocity = ze(e.speed) / 100 * t, i.decay = 1 - ze(e.decay), i.status = "increasing", i.loops = 0, i.maxLoops = ze(e.count), i.time = 0, i.delayTime = ze(e.delay) * 1e3, e.sync || (i.velocity *= Tt(), i.value *= Tt()), i.initialValue = i.value) : i.velocity = 0 } function ip(i, e, t) { i.beginPath(), i.moveTo(e.x, e.y), i.lineTo(t.x, t.y), i.closePath() } function JG(i, e, t, n) { i.beginPath(), i.moveTo(e.x, e.y), i.lineTo(t.x, t.y), i.lineTo(n.x, n.y), i.closePath() } function YG(i, e, t) { i.fillStyle = t ?? "rgba(0,0,0,0)", i.fillRect(0, 0, e.width, e.height) } function jG(i, e, t, n) { t && (i.globalAlpha = n, i.drawImage(t, 0, 0, e.width, e.height), i.globalAlpha = 1) } function lA(i, e) { i.clearRect(0, 0, e.width, e.height) } function KG(i) { const { container: e, context: t, particle: n, delta: r, colorStyles: s, backgroundMask: o, composite: a, radius: l, opacity: c, shadow: f, transform: d } = i, p = n.getPosition(), m = n.rotation + (n.pathRotation ? n.velocity.angle : 0), y = { sin: Math.sin(m), cos: Math.cos(m) }, _ = { a: y.cos * (d.a ?? 1), b: y.sin * (d.b ?? 1), c: -y.sin * (d.c ?? 1), d: y.cos * (d.d ?? 1) }; t.setTransform(_.a, _.b, _.c, _.d, p.x, p.y), t.beginPath(), o && (t.globalCompositeOperation = a); const x = n.shadowColor; f.enable && x && (t.shadowBlur = f.blur, t.shadowColor = zo(x), t.shadowOffsetX = f.offset.x, t.shadowOffsetY = f.offset.y), s.fill && (t.fillStyle = s.fill); const g = n.strokeWidth ?? 0; t.lineWidth = g, s.stroke && (t.strokeStyle = s.stroke), qG(e, t, n, l, c, r), g > 0 && t.stroke(), n.close && t.closePath(), n.fill && t.fill(), QG(e, t, n, l, c, r), t.globalCompositeOperation = "source-over", t.setTransform(1, 0, 0, 1, 0, 0) } function qG(i, e, t, n, r, s) { if (!t.shape) return; const o = i.drawers.get(t.shape); o && o.draw(e, t, n, r, s, i.retina.pixelRatio) } function QG(i, e, t, n, r, s) { if (!t.shape) return; const o = i.drawers.get(t.shape); !o || !o.afterEffect || o.afterEffect(e, t, n, r, s, i.retina.pixelRatio) } function ZG(i, e, t) { e.draw && e.draw(i, t) } function $G(i, e, t, n) { e.drawParticle && e.drawParticle(i, t, n) } function e4(i, e, t) { return { h: i.h, s: i.s, l: i.l + (e === "darken" ? -1 : 1) * t } } function t4(i, e, t) { const n = e[t]; n !== void 0 && (i[t] = (i[t] ?? 1) * n) } let n4 = class { constructor(e) { this.container = e, this._applyPostDrawUpdaters = t => { for (const n of this._postDrawUpdaters) n.afterDraw && n.afterDraw(t) }, this._applyPreDrawUpdaters = (t, n, r, s, o, a) => { for (const l of this._preDrawUpdaters) { if (l.getColorStyles) { const { fill: c, stroke: f } = l.getColorStyles(n, t, r, s); c && (o.fill = c), f && (o.stroke = f) } if (l.getTransformValues) { const c = l.getTransformValues(n); for (const f in c) t4(a, c, f) } l.beforeDraw && l.beforeDraw(n) } }, this._applyResizePlugins = () => { for (const t of this._resizePlugins) t.resize && t.resize() }, this._getPluginParticleColors = t => { let n, r; for (const s of this._colorPlugins) if (!n && s.particleFillColor && (n = kl(s.particleFillColor(t))), !r && s.particleStrokeColor && (r = kl(s.particleStrokeColor(t))), n && r) break; return [n, r] }, this._initCover = () => { const t = this.container.actualOptions, n = t.backgroundMask.cover, r = n.color, s = Fs(r); if (s) { const o = { ...s, a: n.opacity }; this._coverColorStyle = zo(o, o.a) } }, this._initStyle = () => { const t = this.element, n = this.container.actualOptions; if (t) { this._fullScreen ? (this._originalStyle = Qn({}, t.style), this._setFullScreenStyle()) : this._resetOriginalStyle(); for (const r in n.style) { if (!r || !n.style) continue; const s = n.style[r]; s && t.style.setProperty(r, s, "important") } } }, this._initTrail = async () => { const t = this.container.actualOptions, n = t.particles.move.trail, r = n.fill; if (n.enable) if (r.color) { const s = Fs(r.color); if (!s) return; const o = t.particles.move.trail; this._trailFill = { color: { ...s }, opacity: 1 / o.length } } else await new Promise((s, o) => { if (!r.image) return; const a = document.createElement("img"); a.addEventListener("load", () => { this._trailFill = { image: a, opacity: 1 / n.length }, s() }), a.addEventListener("error", l => { o(l.error) }), a.src = r.image }) }, this._paintBase = t => { this.draw(n => YG(n, this.size, t)) }, this._paintImage = (t, n) => { this.draw(r => jG(r, this.size, t, n)) }, this._repairStyle = () => { const t = this.element; t && (this._safeMutationObserver(n => n.disconnect()), this._initStyle(), this.initBackground(), this._safeMutationObserver(n => n.observe(t, { attributes: !0 }))) }, this._resetOriginalStyle = () => { const t = this.element, n = this._originalStyle; if (!(t && n)) return; const r = t.style; r.position = n.position, r.zIndex = n.zIndex, r.top = n.top, r.left = n.left, r.width = n.width, r.height = n.height }, this._safeMutationObserver = t => { this._mutationObserver && t(this._mutationObserver) }, this._setFullScreenStyle = () => { const t = this.element; if (!t) return; const n = "important", r = t.style; r.setProperty("position", "fixed", n), r.setProperty("z-index", this.container.actualOptions.fullScreen.zIndex.toString(10), n), r.setProperty("top", "0", n), r.setProperty("left", "0", n), r.setProperty("width", "100%", n), r.setProperty("height", "100%", n) }, this.size = { height: 0, width: 0 }, this._context = null, this._generated = !1, this._preDrawUpdaters = [], this._postDrawUpdaters = [], this._resizePlugins = [], this._colorPlugins = [] } get _fullScreen() { return this.container.actualOptions.fullScreen.enable } clear() { const e = this.container.actualOptions, t = e.particles.move.trail, n = this._trailFill; e.backgroundMask.enable ? this.paint() : t.enable && t.length > 0 && n ? n.color ? this._paintBase(zo(n.color, n.opacity)) : n.image && this._paintImage(n.image, n.opacity) : this.draw(r => { lA(r, this.size) }) } destroy() { if (this.stop(), this._generated) { const e = this.element; e && e.remove() } else this._resetOriginalStyle(); this._preDrawUpdaters = [], this._postDrawUpdaters = [], this._resizePlugins = [], this._colorPlugins = [] } draw(e) { const t = this._context; if (t) return e(t) } drawParticle(e, t) { if (e.spawning || e.destroyed) return; const n = e.getRadius(); if (n <= 0) return; const r = e.getFillColor(), s = e.getStrokeColor() ?? r; let [o, a] = this._getPluginParticleColors(e); o || (o = r), a || (a = s), !(!o && !a) && this.draw(l => { var M; const c = this.container, f = c.actualOptions, d = e.options.zIndex, p = (1 - e.zIndexFactor) ** d.opacityRate, m = e.bubble.opacity ?? ((M = e.opacity) == null ? void 0 : M.value) ?? 1, y = e.strokeOpacity ?? m, _ = m * p, x = y * p, g = {}, A = { fill: o ? dh(o, _) : void 0 }; A.stroke = a ? dh(a, x) : A.fill, this._applyPreDrawUpdaters(l, e, n, _, A, g), KG({ container: c, context: l, particle: e, delta: t, colorStyles: A, backgroundMask: f.backgroundMask.enable, composite: f.backgroundMask.composite, radius: n * (1 - e.zIndexFactor) ** d.sizeRate, opacity: _, shadow: e.options.shadow, transform: g }), this._applyPostDrawUpdaters(e) }) } drawParticlePlugin(e, t, n) { this.draw(r => $G(r, e, t, n)) } drawPlugin(e, t) { this.draw(n => ZG(n, e, t)) } async init() { this._safeMutationObserver(e => e.disconnect()), this._mutationObserver = kG(e => { for (const t of e) t.type === "attributes" && t.attributeName === "style" && this._repairStyle() }), this.resize(), this._initStyle(), this._initCover(); try { await this._initTrail() } catch (e) { ou().error(e) } this.initBackground(), this._safeMutationObserver(e => { this.element && e.observe(this.element, { attributes: !0 }) }), this.initUpdaters(), this.initPlugins(), this.paint() } initBackground() { const e = this.container.actualOptions, t = e.background, n = this.element; if (!n) return; const r = n.style; if (r) { if (t.color) { const s = Fs(t.color); r.backgroundColor = s ? zo(s, t.opacity) : "" } else r.backgroundColor = ""; r.backgroundImage = t.image || "", r.backgroundPosition = t.position || "", r.backgroundRepeat = t.repeat || "", r.backgroundSize = t.size || "" } } initPlugins() { this._resizePlugins = []; for (const [, e] of this.container.plugins) e.resize && this._resizePlugins.push(e), (e.particleFillColor || e.particleStrokeColor) && this._colorPlugins.push(e) } initUpdaters() { this._preDrawUpdaters = [], this._postDrawUpdaters = []; for (const e of this.container.particles.updaters) e.afterDraw && this._postDrawUpdaters.push(e), (e.getColorStyles || e.getTransformValues || e.beforeDraw) && this._preDrawUpdaters.push(e) } loadCanvas(e) { this._generated && this.element && this.element.remove(), this._generated = e.dataset && np in e.dataset ? e.dataset[np] === "true" : this._generated, this.element = e, this.element.ariaHidden = "true", this._originalStyle = Qn({}, this.element.style), this.size.height = e.offsetHeight, this.size.width = e.offsetWidth, this._context = this.element.getContext("2d"), this._safeMutationObserver(t => { this.element && t.observe(this.element, { attributes: !0 }) }), this.container.retina.init(), this.initBackground() } paint() { const e = this.container.actualOptions; this.draw(t => { e.backgroundMask.enable && e.backgroundMask.cover ? (lA(t, this.size), this._paintBase(this._coverColorStyle)) : this._paintBase() }) } resize() { if (!this.element) return !1; const e = this.container, t = e.retina.pixelRatio, n = e.canvas.size, r = { width: this.element.offsetWidth * t, height: this.element.offsetHeight * t }; if (r.height === n.height && r.width === n.width && r.height === this.element.height && r.width === this.element.width) return !1; const s = { ...n }; return this.element.width = n.width = this.element.offsetWidth * t, this.element.height = n.height = this.element.offsetHeight * t, this.container.started && (this.resizeFactor = { width: n.width / s.width, height: n.height / s.height }), !0 } stop() { this._safeMutationObserver(e => e.disconnect()), this._mutationObserver = void 0, this.draw(e => lA(e, this.size)) } async windowResize() { if (!this.element || !this.resize()) return; const e = this.container, t = e.updateActualOptions(); e.particles.setDensity(), this._applyResizePlugins(), t && await e.refresh() } }; function _s(i, e, t, n, r) { if (n) { let s = { passive: !0 }; Tl(r) ? s.capture = r : r !== void 0 && (s = r), i.addEventListener(e, t, s) } else { const s = r; i.removeEventListener(e, t, s) } } class i4 { constructor(e) { this.container = e, this._doMouseTouchClick = t => { const n = this.container, r = n.actualOptions; if (this._canPush) { const s = n.interactivity.mouse, o = s.position; if (!o) return; s.clickPosition = { ...o }, s.clickTime = new Date().getTime(); const a = r.interactivity.events.onClick; xn(a.mode, l => this.container.handleClickMode(l)) } t.type === "touchend" && setTimeout(() => this._mouseTouchFinish(), 500) }, this._handleThemeChange = t => { const n = t, r = this.container, s = r.options, o = s.defaultThemes, a = n.matches ? o.dark : o.light, l = s.themes.find(c => c.name === a); l && l.default.auto && r.loadTheme(a) }, this._handleVisibilityChange = () => { const t = this.container, n = t.actualOptions; this._mouseTouchFinish(), n.pauseOnBlur && (document && document.hidden ? (t.pageHidden = !0, t.pause()) : (t.pageHidden = !1, t.getAnimationStatus() ? t.play(!0) : t.draw(!0))) }, this._handleWindowResize = async () => { this._resizeTimeout && (clearTimeout(this._resizeTimeout), delete this._resizeTimeout), this._resizeTimeout = setTimeout(async () => { const t = this.container.canvas; t && await t.windowResize() }, this.container.actualOptions.interactivity.events.resize.delay * 1e3) }, this._manageInteractivityListeners = (t, n) => { const r = this._handlers, s = this.container, o = s.actualOptions, a = s.interactivity.element; if (!a) return; const l = a, c = s.canvas.element; c && (c.style.pointerEvents = l === c ? "initial" : "none"), (o.interactivity.events.onHover.enable || o.interactivity.events.onClick.enable) && (_s(a, su, r.mouseMove, n), _s(a, EG, r.touchStart, n), _s(a, CG, r.touchMove, n), o.interactivity.events.onClick.enable ? (_s(a, IR, r.touchEndClick, n), _s(a, wG, r.mouseUp, n), _s(a, MG, r.mouseDown, n)) : _s(a, IR, r.touchEnd, n), _s(a, t, r.mouseLeave, n), _s(a, TG, r.touchCancel, n)) }, this._manageListeners = t => { const n = this._handlers, r = this.container, s = r.actualOptions, o = s.interactivity.detectsOn, a = r.canvas.element; let l = Nw; o === "window" ? (r.interactivity.element = window, l = SG) : o === "parent" && a ? r.interactivity.element = a.parentElement ?? a.parentNode : r.interactivity.element = a, this._manageMediaMatch(t), this._manageResize(t), this._manageInteractivityListeners(l, t), document && _s(document, RG, n.visibilityChange, t, !1) }, this._manageMediaMatch = t => { const n = this._handlers, r = JD("(prefers-color-scheme: dark)"); if (r) { if (r.addEventListener !== void 0) { _s(r, "change", n.themeChange, t); return } r.addListener !== void 0 && (t ? r.addListener(n.oldThemeChange) : r.removeListener(n.oldThemeChange)) } }, this._manageResize = t => { const n = this._handlers, r = this.container; if (!r.actualOptions.interactivity.events.resize) return; if (typeof ResizeObserver > "u") { _s(window, bG, n.resize, t); return } const o = r.canvas.element; this._resizeObserver && !t ? (o && this._resizeObserver.unobserve(o), this._resizeObserver.disconnect(), delete this._resizeObserver) : !this._resizeObserver && t && o && (this._resizeObserver = new ResizeObserver(async a => { a.find(c => c.target === o) && await this._handleWindowResize() }), this._resizeObserver.observe(o)) }, this._mouseDown = () => { const { interactivity: t } = this.container; if (!t) return; const { mouse: n } = t; n.clicking = !0, n.downPosition = n.position }, this._mouseTouchClick = t => { const n = this.container, r = n.actualOptions, { mouse: s } = n.interactivity; s.inside = !0; let o = !1; const a = s.position; if (!(!a || !r.interactivity.events.onClick.enable)) { for (const [, l] of n.plugins) if (l.clickPositionValid && (o = l.clickPositionValid(a), o)) break; o || this._doMouseTouchClick(t), s.clicking = !1 } }, this._mouseTouchFinish = () => { const t = this.container.interactivity; if (!t) return; const n = t.mouse; delete n.position, delete n.clickPosition, delete n.downPosition, t.status = Nw, n.inside = !1, n.clicking = !1 }, this._mouseTouchMove = t => { const n = this.container, r = n.actualOptions, s = n.interactivity, o = n.canvas.element; if (!s || !s.element) return; s.mouse.inside = !0; let a; if (t.type.startsWith("pointer")) { this._canPush = !0; const c = t; if (s.element === window) { if (o) { const f = o.getBoundingClientRect(); a = { x: c.clientX - f.left, y: c.clientY - f.top } } } else if (r.interactivity.detectsOn === "parent") { const f = c.target, d = c.currentTarget; if (f && d && o) { const p = f.getBoundingClientRect(), m = d.getBoundingClientRect(), y = o.getBoundingClientRect(); a = { x: c.offsetX + 2 * p.left - (m.left + y.left), y: c.offsetY + 2 * p.top - (m.top + y.top) } } else a = { x: c.offsetX ?? c.clientX, y: c.offsetY ?? c.clientY } } else c.target === o && (a = { x: c.offsetX ?? c.clientX, y: c.offsetY ?? c.clientY }) } else if (this._canPush = t.type !== "touchmove", o) { const c = t, f = c.touches[c.touches.length - 1], d = o.getBoundingClientRect(); a = { x: f.clientX - (d.left ?? 0), y: f.clientY - (d.top ?? 0) } } const l = n.retina.pixelRatio; a && (a.x *= l, a.y *= l), s.mouse.position = a, s.status = su }, this._touchEnd = t => { const n = t, r = Array.from(n.changedTouches); for (const s of r) this._touches.delete(s.identifier); this._mouseTouchFinish() }, this._touchEndClick = t => { const n = t, r = Array.from(n.changedTouches); for (const s of r) this._touches.delete(s.identifier); this._mouseTouchClick(t) }, this._touchStart = t => { const n = t, r = Array.from(n.changedTouches); for (const s of r) this._touches.set(s.identifier, performance.now()); this._mouseTouchMove(t) }, this._canPush = !0, this._touches = new Map, this._handlers = { mouseDown: () => this._mouseDown(), mouseLeave: () => this._mouseTouchFinish(), mouseMove: t => this._mouseTouchMove(t), mouseUp: t => this._mouseTouchClick(t), touchStart: t => this._touchStart(t), touchMove: t => this._mouseTouchMove(t), touchEnd: t => this._touchEnd(t), touchCancel: t => this._touchEnd(t), touchEndClick: t => this._touchEndClick(t), visibilityChange: () => this._handleVisibilityChange(), themeChange: t => this._handleThemeChange(t), oldThemeChange: t => this._handleThemeChange(t), resize: () => { this._handleWindowResize() } } } addListeners() { this._manageListeners(!0) } removeListeners() { this._manageListeners(!1) } } class Xn { constructor() { this.value = "" } static create(e, t) { const n = new Xn; return n.load(e), t !== void 0 && (co(t) || pi(t) ? n.load({ value: t }) : n.load(t)), n } load(e) { (e == null ? void 0 : e.value) !== void 0 && (this.value = e.value) } } class r4 { constructor() { this.color = new Xn, this.color.value = "", this.image = "", this.position = "", this.repeat = "", this.size = "", this.opacity = 1 } load(e) { e && (e.color !== void 0 && (this.color = Xn.create(this.color, e.color)), e.image !== void 0 && (this.image = e.image), e.position !== void 0 && (this.position = e.position), e.repeat !== void 0 && (this.repeat = e.repeat), e.size !== void 0 && (this.size = e.size), e.opacity !== void 0 && (this.opacity = e.opacity)) } } class s4 { constructor() { this.color = new Xn, this.color.value = "#fff", this.opacity = 1 } load(e) { e && (e.color !== void 0 && (this.color = Xn.create(this.color, e.color)), e.opacity !== void 0 && (this.opacity = e.opacity)) } } class o4 { constructor() { this.composite = "destination-out", this.cover = new s4, this.enable = !1 } load(e) { if (e) { if (e.composite !== void 0 && (this.composite = e.composite), e.cover !== void 0) { const t = e.cover, n = co(e.cover) ? { color: e.cover } : e.cover; this.cover.load(t.color !== void 0 ? t : { color: n }) } e.enable !== void 0 && (this.enable = e.enable) } } } class a4 { constructor() { this.enable = !0, this.zIndex = 0 } load(e) { e && (e.enable !== void 0 && (this.enable = e.enable), e.zIndex !== void 0 && (this.zIndex = e.zIndex)) } } class l4 { constructor() { this.enable = !1, this.mode = [] } load(e) { e && (e.enable !== void 0 && (this.enable = e.enable), e.mode !== void 0 && (this.mode = e.mode)) } } class FR { constructor() { this.selectors = [], this.enable = !1, this.mode = [], this.type = "circle" } get el() { return this.elementId } set el(e) { this.elementId = e } get elementId() { return this.ids } set elementId(e) { this.ids = e } get ids() { return xn(this.selectors, e => e.replace("#", "")) } set ids(e) { this.selectors = xn(e, t => `#${t}`) } load(e) { if (!e) return; const t = e.ids ?? e.elementId ?? e.el; t !== void 0 && (this.ids = t), e.selectors !== void 0 && (this.selectors = e.selectors), e.enable !== void 0 && (this.enable = e.enable), e.mode !== void 0 && (this.mode = e.mode), e.type !== void 0 && (this.type = e.type) } } class c4 { constructor() { this.enable = !1, this.force = 2, this.smooth = 10 } load(e) { e && (e.enable !== void 0 && (this.enable = e.enable), e.force !== void 0 && (this.force = e.force), e.smooth !== void 0 && (this.smooth = e.smooth)) } } class u4 { constructor() { this.enable = !1, this.mode = [], this.parallax = new c4 } load(e) { e && (e.enable !== void 0 && (this.enable = e.enable), e.mode !== void 0 && (this.mode = e.mode), this.parallax.load(e.parallax)) } } class f4 { constructor() { this.delay = .5, this.enable = !0 } load(e) { e !== void 0 && (e.delay !== void 0 && (this.delay = e.delay), e.enable !== void 0 && (this.enable = e.enable)) } } class h4 { constructor() { this.onClick = new l4, this.onDiv = new FR, this.onHover = new u4, this.resize = new f4 } get onclick() { return this.onClick } set onclick(e) { this.onClick = e } get ondiv() { return this.onDiv } set ondiv(e) { this.onDiv = e } get onhover() { return this.onHover } set onhover(e) { this.onHover = e } load(e) { if (!e) return; this.onClick.load(e.onClick ?? e.onclick); const t = e.onDiv ?? e.ondiv; t !== void 0 && (this.onDiv = xn(t, n => { const r = new FR; return r.load(n), r })), this.onHover.load(e.onHover ?? e.onhover), Tl(e.resize) ? this.resize.enable = e.resize : this.resize.load(e.resize) } } class d4 { constructor(e, t) { this._engine = e, this._container = t } load(e) { if (!e || !this._container) return; const t = this._engine.plugins.interactors.get(this._container); if (t) for (const n of t) n.loadModeOptions && n.loadModeOptions(this, e) } } class oO { constructor(e, t) { this.detectsOn = "window", this.events = new h4, this.modes = new d4(e, t) } get detect_on() { return this.detectsOn } set detect_on(e) { this.detectsOn = e } load(e) { if (!e) return; const t = e.detectsOn ?? e.detect_on; t !== void 0 && (this.detectsOn = t), this.events.load(e.events), this.modes.load(e.modes) } } class p4 { load(e) { e && (e.position && (this.position = { x: e.position.x ?? 50, y: e.position.y ?? 50, mode: e.position.mode ?? "percent" }), e.options && (this.options = Qn({}, e.options))) } } class m4 { constructor() { this.maxWidth = 1 / 0, this.options = {}, this.mode = "canvas" } load(e) { e && (e.maxWidth !== void 0 && (this.maxWidth = e.maxWidth), e.mode !== void 0 && (e.mode === "screen" ? this.mode = "screen" : this.mode = "canvas"), e.options !== void 0 && (this.options = Qn({}, e.options))) } } class g4 { constructor() { this.auto = !1, this.mode = "any", this.value = !1 } load(e) { e && (e.auto !== void 0 && (this.auto = e.auto), e.mode !== void 0 && (this.mode = e.mode), e.value !== void 0 && (this.value = e.value)) } } class y4 { constructor() { this.name = "", this.default = new g4 } load(e) { e && (e.name !== void 0 && (this.name = e.name), this.default.load(e.default), e.options !== void 0 && (this.options = Qn({}, e.options))) } } class cA { constructor() { this.count = 0, this.enable = !1, this.offset = 0, this.speed = 1, this.delay = 0, this.decay = 0, this.sync = !0 } load(e) { e && (e.count !== void 0 && (this.count = it(e.count)), e.enable !== void 0 && (this.enable = e.enable), e.offset !== void 0 && (this.offset = it(e.offset)), e.speed !== void 0 && (this.speed = it(e.speed)), e.decay !== void 0 && (this.decay = it(e.decay)), e.delay !== void 0 && (this.delay = it(e.delay)), e.sync !== void 0 && (this.sync = e.sync)) } } class v4 { constructor() { this.h = new cA, this.s = new cA, this.l = new cA } load(e) { e && (this.h.load(e.h), this.s.load(e.s), this.l.load(e.l)) } } class ph extends Xn { constructor() { super(), this.animation = new v4 } static create(e, t) { const n = new ph; return n.load(e), t !== void 0 && (co(t) || pi(t) ? n.load({ value: t }) : n.load(t)), n } load(e) { if (super.load(e), !e) return; const t = e.animation; t !== void 0 && (t.enable !== void 0 ? this.animation.h.load(t) : this.animation.load(e.animation)) } } class _4 { constructor() { this.speed = 2 } load(e) { e && e.speed !== void 0 && (this.speed = e.speed) } } class x4 { constructor() { this.enable = !0, this.retries = 0 } load(e) { e && (e.enable !== void 0 && (this.enable = e.enable), e.retries !== void 0 && (this.retries = e.retries)) } } class A4 { constructor() { this.count = 0, this.enable = !1, this.speed = 1, this.decay = 0, this.delay = 0, this.sync = !1 } load(e) { e && (e.count !== void 0 && (this.count = it(e.count)), e.enable !== void 0 && (this.enable = e.enable), e.speed !== void 0 && (this.speed = it(e.speed)), e.decay !== void 0 && (this.decay = it(e.decay)), e.delay !== void 0 && (this.delay = it(e.delay)), e.sync !== void 0 && (this.sync = e.sync)) } } class aO extends A4 { constructor() { super(), this.mode = "auto", this.startValue = "random" } load(e) { super.load(e), e && (e.minimumValue !== void 0 && (this.minimumValue = e.minimumValue), e.mode !== void 0 && (this.mode = e.mode), e.startValue !== void 0 && (this.startValue = e.startValue)) } } class M4 { constructor() { this.enable = !1, this.minimumValue = 0 } load(e) { e && (e.enable !== void 0 && (this.enable = e.enable), e.minimumValue !== void 0 && (this.minimumValue = e.minimumValue)) } } class Hs { constructor() { this.random = new M4, this.value = 0 } load(e) { e && (Tl(e.random) ? this.random.enable = e.random : this.random.load(e.random), e.value !== void 0 && (this.value = it(e.value, this.random.enable ? this.random.minimumValue : void 0))) } } class kR extends Hs { constructor() { super(), this.random.minimumValue = .1, this.value = 1 } } class lO { constructor() { this.horizontal = new kR, this.vertical = new kR } load(e) { e && (this.horizontal.load(e.horizontal), this.vertical.load(e.vertical)) } } class w4 { constructor() { this.absorb = new _4, this.bounce = new lO, this.enable = !1, this.maxSpeed = 50, this.mode = "bounce", this.overlap = new x4 } load(e) { e && (this.absorb.load(e.absorb), this.bounce.load(e.bounce), e.enable !== void 0 && (this.enable = e.enable), e.maxSpeed !== void 0 && (this.maxSpeed = it(e.maxSpeed)), e.mode !== void 0 && (this.mode = e.mode), this.overlap.load(e.overlap)) } } class S4 { constructor() { this.offset = 0, this.value = 90 } load(e) { e && (e.offset !== void 0 && (this.offset = it(e.offset)), e.value !== void 0 && (this.value = it(e.value))) } } class E4 { constructor() { this.distance = 200, this.enable = !1, this.rotate = { x: 3e3, y: 3e3 } } get rotateX() { return this.rotate.x } set rotateX(e) { this.rotate.x = e } get rotateY() { return this.rotate.y } set rotateY(e) { this.rotate.y = e } load(e) { var r, s; if (!e) return; e.distance !== void 0 && (this.distance = it(e.distance)), e.enable !== void 0 && (this.enable = e.enable); const t = ((r = e.rotate) == null ? void 0 : r.x) ?? e.rotateX; t !== void 0 && (this.rotate.x = t); const n = ((s = e.rotate) == null ? void 0 : s.y) ?? e.rotateY; n !== void 0 && (this.rotate.y = n) } } class C4 { constructor() { this.x = 50, this.y = 50, this.mode = "percent", this.radius = 0 } load(e) { e && (e.x !== void 0 && (this.x = e.x), e.y !== void 0 && (this.y = e.y), e.mode !== void 0 && (this.mode = e.mode), e.radius !== void 0 && (this.radius = e.radius)) } } class T4 { constructor() { this.acceleration = 9.81, this.enable = !1, this.inverse = !1, this.maxSpeed = 50 } load(e) { e && (e.acceleration !== void 0 && (this.acceleration = it(e.acceleration)), e.enable !== void 0 && (this.enable = e.enable), e.inverse !== void 0 && (this.inverse = e.inverse), e.maxSpeed !== void 0 && (this.maxSpeed = it(e.maxSpeed))) } } class b4 { constructor() { this.clamp = !0, this.delay = new Hs, this.enable = !1, this.options = {} } load(e) { e && (e.clamp !== void 0 && (this.clamp = e.clamp), this.delay.load(e.delay), e.enable !== void 0 && (this.enable = e.enable), this.generator = e.generator, e.options && (this.options = Qn(this.options, e.options))) } } class R4 { load(e) { e && (e.color !== void 0 && (this.color = Xn.create(this.color, e.color)), e.image !== void 0 && (this.image = e.image)) } } class P4 { constructor() { this.enable = !1, this.length = 10, this.fill = new R4 } get fillColor() { return this.fill.color } set fillColor(e) { this.fill.load({ color: e }) } load(e) { e && (e.enable !== void 0 && (this.enable = e.enable), (e.fill !== void 0 || e.fillColor !== void 0) && this.fill.load(e.fill || { color: e.fillColor }), e.length !== void 0 && (this.length = e.length)) } } class I4 { constructor() { this.default = "out" } load(e) { e && (e.default !== void 0 && (this.default = e.default), this.bottom = e.bottom ?? e.default, this.left = e.left ?? e.default, this.right = e.right ?? e.default, this.top = e.top ?? e.default) } } class B4 { constructor() { this.acceleration = 0, this.enable = !1 } load(e) { e && (e.acceleration !== void 0 && (this.acceleration = it(e.acceleration)), e.enable !== void 0 && (this.enable = e.enable), e.position && (this.position = Qn({}, e.position))) } } class L4 { constructor() { this.angle = new S4, this.attract = new E4, this.center = new C4, this.decay = 0, this.distance = {}, this.direction = "none", this.drift = 0, this.enable = !1, this.gravity = new T4, this.path = new b4, this.outModes = new I4, this.random = !1, this.size = !1, this.speed = 2, this.spin = new B4, this.straight = !1, this.trail = new P4, this.vibrate = !1, this.warp = !1 } get bounce() { return this.collisions } set bounce(e) { this.collisions = e } get collisions() { return !1 } set collisions(e) { } get noise() { return this.path } set noise(e) { this.path = e } get outMode() { return this.outModes.default } set outMode(e) { this.outModes.default = e } get out_mode() { return this.outMode } set out_mode(e) { this.outMode = e } load(e) { if (!e) return; this.angle.load(er(e.angle) ? { value: e.angle } : e.angle), this.attract.load(e.attract), this.center.load(e.center), e.decay !== void 0 && (this.decay = it(e.decay)), e.direction !== void 0 && (this.direction = e.direction), e.distance !== void 0 && (this.distance = er(e.distance) ? { horizontal: e.distance, vertical: e.distance } : { ...e.distance }), e.drift !== void 0 && (this.drift = it(e.drift)), e.enable !== void 0 && (this.enable = e.enable), this.gravity.load(e.gravity); const t = e.outModes ?? e.outMode ?? e.out_mode; t !== void 0 && (bf(t) ? this.outModes.load(t) : this.outModes.load({ default: t })), this.path.load(e.path ?? e.noise), e.random !== void 0 && (this.random = e.random), e.size !== void 0 && (this.size = e.size), e.speed !== void 0 && (this.speed = it(e.speed)), this.spin.load(e.spin), e.straight !== void 0 && (this.straight = e.straight), this.trail.load(e.trail), e.vibrate !== void 0 && (this.vibrate = e.vibrate), e.warp !== void 0 && (this.warp = e.warp) } } class D4 extends aO { constructor() { super(), this.destroy = "none", this.speed = 2 } get opacity_min() { return this.minimumValue } set opacity_min(e) { this.minimumValue = e } load(e) { (e == null ? void 0 : e.opacity_min) !== void 0 && e.minimumValue === void 0 && (e.minimumValue = e.opacity_min), super.load(e), e && e.destroy !== void 0 && (this.destroy = e.destroy) } } class O4 extends Hs { constructor() { super(), this.animation = new D4, this.random.minimumValue = .1, this.value = 1 } get anim() { return this.animation } set anim(e) { this.animation = e } load(e) { if (!e) return; super.load(e); const t = e.animation ?? e.anim; t !== void 0 && (this.animation.load(t), this.value = it(this.value, this.animation.enable ? this.animation.minimumValue : void 0)) } } class F4 { constructor() { this.enable = !1, this.width = 1920, this.height = 1080 } get area() { return this.width } set area(e) { this.width = e } get factor() { return this.height } set factor(e) { this.height = e } get value_area() { return this.area } set value_area(e) { this.area = e } load(e) { if (!e) return; e.enable !== void 0 && (this.enable = e.enable); const t = e.width ?? e.area ?? e.value_area; t !== void 0 && (this.width = t); const n = e.height ?? e.factor; n !== void 0 && (this.height = n) } } class k4 { constructor() { this.density = new F4, this.limit = 0, this.value = 0 } get max() { return this.limit } set max(e) { this.limit = e } load(e) { if (!e) return; this.density.load(e.density); const t = e.limit ?? e.max; t !== void 0 && (this.limit = t), e.value !== void 0 && (this.value = e.value) } } class N4 { constructor() { this.blur = 0, this.color = new Xn, this.enable = !1, this.offset = { x: 0, y: 0 }, this.color.value = "#000" } load(e) { e && (e.blur !== void 0 && (this.blur = e.blur), this.color = Xn.create(this.color, e.color), e.enable !== void 0 && (this.enable = e.enable), e.offset !== void 0 && (e.offset.x !== void 0 && (this.offset.x = e.offset.x), e.offset.y !== void 0 && (this.offset.y = e.offset.y))) } } const uA = "character", fA = "char", hA = "image", dA = "images", pA = "polygon", mA = "star"; let U4 = class { constructor() { this.loadShape = (e, t, n, r) => { if (!e) return; const s = pi(e), o = s ? [] : {}, a = s !== pi(this.options[t]), l = s !== pi(this.options[n]); a && (this.options[t] = o), l && r && (this.options[n] = o), this.options[t] = Qn(this.options[t] ?? o, e), (!this.options[n] || r) && (this.options[n] = Qn(this.options[n] ?? o, e)) }, this.close = !0, this.fill = !0, this.options = {}, this.type = "circle" } get character() { return this.options[uA] ?? this.options[fA] } set character(e) { this.options[fA] = this.options[uA] = e } get custom() { return this.options } set custom(e) { this.options = e } get image() { return this.options[hA] ?? this.options[dA] } set image(e) { this.options[dA] = this.options[hA] = e } get images() { return this.image } set images(e) { this.image = e } get polygon() { return this.options[pA] ?? this.options[mA] } set polygon(e) { this.options[mA] = this.options[pA] = e } get stroke() { return [] } set stroke(e) { } load(e) { if (!e) return; const t = e.options ?? e.custom; if (t !== void 0) for (const n in t) { const r = t[n]; r && (this.options[n] = Qn(this.options[n] ?? {}, r)) } this.loadShape(e.character, uA, fA, !0), this.loadShape(e.polygon, pA, mA, !1), this.loadShape(e.image ?? e.images, hA, dA, !0), e.close !== void 0 && (this.close = e.close), e.fill !== void 0 && (this.fill = e.fill), e.type !== void 0 && (this.type = e.type) } }; class z4 extends aO { constructor() { super(), this.destroy = "none", this.speed = 5 } get size_min() { return this.minimumValue } set size_min(e) { this.minimumValue = e } load(e) { (e == null ? void 0 : e.size_min) !== void 0 && e.minimumValue === void 0 && (e.minimumValue = e.size_min), super.load(e), e && e.destroy !== void 0 && (this.destroy = e.destroy) } } class H4 extends Hs { constructor() { super(), this.animation = new z4, this.random.minimumValue = 1, this.value = 3 } get anim() { return this.animation } set anim(e) { this.animation = e } load(e) { if (super.load(e), !e) return; const t = e.animation ?? e.anim; t !== void 0 && (this.animation.load(t), this.value = it(this.value, this.animation.enable ? this.animation.minimumValue : void 0)) } } class NR { constructor() { this.width = 0 } load(e) { e && (e.color !== void 0 && (this.color = ph.create(this.color, e.color)), e.width !== void 0 && (this.width = it(e.width)), e.opacity !== void 0 && (this.opacity = it(e.opacity))) } } class G4 extends Hs { constructor() { super(), this.opacityRate = 1, this.sizeRate = 1, this.velocityRate = 1 } load(e) { super.load(e), e && (e.opacityRate !== void 0 && (this.opacityRate = e.opacityRate), e.sizeRate !== void 0 && (this.sizeRate = e.sizeRate), e.velocityRate !== void 0 && (this.velocityRate = e.velocityRate)) } } class V4 { constructor(e, t) { this._engine = e, this._container = t, this.bounce = new lO, this.collisions = new w4, this.color = new ph, this.color.value = "#fff", this.groups = {}, this.move = new L4, this.number = new k4, this.opacity = new O4, this.reduceDuplicates = !1, this.shadow = new N4, this.shape = new U4, this.size = new H4, this.stroke = new NR, this.zIndex = new G4 } load(e) { var r, s, o; if (!e) return; if (this.bounce.load(e.bounce), this.color.load(ph.create(this.color, e.color)), e.groups !== void 0) for (const a in e.groups) { const l = e.groups[a]; l !== void 0 && (this.groups[a] = Qn(this.groups[a] ?? {}, l)) } this.move.load(e.move), this.number.load(e.number), this.opacity.load(e.opacity), e.reduceDuplicates !== void 0 && (this.reduceDuplicates = e.reduceDuplicates), this.shape.load(e.shape), this.size.load(e.size), this.shadow.load(e.shadow), this.zIndex.load(e.zIndex); const t = ((r = e.move) == null ? void 0 : r.collisions) ?? ((s = e.move) == null ? void 0 : s.bounce); t !== void 0 && (this.collisions.enable = t), this.collisions.load(e.collisions), e.interactivity !== void 0 && (this.interactivity = Qn({}, e.interactivity)); const n = e.stroke ?? ((o = e.shape) == null ? void 0 : o.stroke); if (n && (this.stroke = xn(n, a => { const l = new NR; return l.load(a), l })), this._container) { const a = this._engine.plugins.updaters.get(this._container); if (a) for (const c of a) c.loadOptions && c.loadOptions(this, e); const l = this._engine.plugins.interactors.get(this._container); if (l) for (const c of l) c.loadParticlesOptions && c.loadParticlesOptions(this, e) } } } function cO(i, ...e) { for (const t of e) i.load(t) } function sE(i, e, ...t) { const n = new V4(i, e); return cO(n, ...t), n } class W4 { constructor(e, t) { this._findDefaultTheme = n => this.themes.find(r => r.default.value && r.default.mode === n) ?? this.themes.find(r => r.default.value && r.default.mode === "any"), this._importPreset = n => { this.load(this._engine.plugins.getPreset(n)) }, this._engine = e, this._container = t, this.autoPlay = !0, this.background = new r4, this.backgroundMask = new o4, this.defaultThemes = {}, this.delay = 0, this.fullScreen = new a4, this.detectRetina = !0, this.duration = 0, this.fpsLimit = 120, this.interactivity = new oO(e, t), this.manualParticles = [], this.particles = sE(this._engine, this._container), this.pauseOnBlur = !0, this.pauseOnOutsideViewport = !0, this.responsive = [], this.smooth = !1, this.style = {}, this.themes = [], this.zLayers = 100 } get backgroundMode() { return this.fullScreen } set backgroundMode(e) { this.fullScreen.load(e) } get fps_limit() { return this.fpsLimit } set fps_limit(e) { this.fpsLimit = e } get retina_detect() { return this.detectRetina } set retina_detect(e) { this.detectRetina = e } load(e) { var o, a; if (!e) return; e.preset !== void 0 && xn(e.preset, l => this._importPreset(l)), e.autoPlay !== void 0 && (this.autoPlay = e.autoPlay), e.delay !== void 0 && (this.delay = it(e.delay)); const t = e.detectRetina ?? e.retina_detect; t !== void 0 && (this.detectRetina = t), e.duration !== void 0 && (this.duration = it(e.duration)); const n = e.fpsLimit ?? e.fps_limit; n !== void 0 && (this.fpsLimit = n), e.pauseOnBlur !== void 0 && (this.pauseOnBlur = e.pauseOnBlur), e.pauseOnOutsideViewport !== void 0 && (this.pauseOnOutsideViewport = e.pauseOnOutsideViewport), e.zLayers !== void 0 && (this.zLayers = e.zLayers), this.background.load(e.background); const r = e.fullScreen ?? e.backgroundMode; Tl(r) ? this.fullScreen.enable = r : this.fullScreen.load(r), this.backgroundMask.load(e.backgroundMask), this.interactivity.load(e.interactivity), e.manualParticles && (this.manualParticles = e.manualParticles.map(l => { const c = new p4; return c.load(l), c })), this.particles.load(e.particles), this.style = Qn(this.style, e.style), this._engine.plugins.loadOptions(this, e), e.smooth !== void 0 && (this.smooth = e.smooth); const s = this._engine.plugins.interactors.get(this._container); if (s) for (const l of s) l.loadOptions && l.loadOptions(this, e); if (e.responsive !== void 0) for (const l of e.responsive) { const c = new m4; c.load(l), this.responsive.push(c) } if (this.responsive.sort((l, c) => l.maxWidth - c.maxWidth), e.themes !== void 0) for (const l of e.themes) { const c = this.themes.find(f => f.name === l.name); if (c) c.load(l); else { const f = new y4; f.load(l), this.themes.push(f) } } this.defaultThemes.dark = (o = this._findDefaultTheme("dark")) == null ? void 0 : o.name, this.defaultThemes.light = (a = this._findDefaultTheme("light")) == null ? void 0 : a.name } setResponsive(e, t, n) { this.load(n); const r = this.responsive.find(s => s.mode === "screen" && screen ? s.maxWidth > screen.availWidth : s.maxWidth * t > e); return this.load(r == null ? void 0 : r.options), r == null ? void 0 : r.maxWidth } setTheme(e) { if (e) { const t = this.themes.find(n => n.name === e); t && this.load(t.options) } else { const t = JD("(prefers-color-scheme: dark)"), n = t && t.matches, r = this._findDefaultTheme(n ? "dark" : "light"); r && this.load(r.options) } } } class X4 { constructor(e, t) { this.container = t, this._engine = e, this._interactors = e.plugins.getInteractors(this.container, !0), this._externalInteractors = [], this._particleInteractors = [] } async externalInteract(e) { for (const t of this._externalInteractors) t.isEnabled() && await t.interact(e) } handleClickMode(e) { for (const t of this._externalInteractors) t.handleClickMode && t.handleClickMode(e) } init() { this._externalInteractors = [], this._particleInteractors = []; for (const e of this._interactors) { switch (e.type) { case "external": this._externalInteractors.push(e); break; case "particles": this._particleInteractors.push(e); break }e.init() } } async particlesInteract(e, t) { for (const n of this._externalInteractors) n.clear(e, t); for (const n of this._particleInteractors) n.isEnabled(e) && await n.interact(e, t) } async reset(e) { for (const t of this._externalInteractors) t.isEnabled() && t.reset(e); for (const t of this._particleInteractors) t.isEnabled(e) && t.reset(e) } } const UR = i => { if (!_n(i.outMode, i.checkModes)) return; const e = i.radius * 2; i.coord > i.maxCoord - e ? i.setCb(-i.radius) : i.coord < e && i.setCb(i.radius) }; let J4 = class { constructor(e, t, n, r, s, o) { this.container = n, this._calcPosition = (a, l, c, f = 0) => { for (const [, A] of a.plugins) { const M = A.particlePosition !== void 0 ? A.particlePosition(l, this) : void 0; if (M) return jr.create(M.x, M.y, c) } const d = a.canvas.size, p = LG({ size: d, position: l }), m = jr.create(p.x, p.y, c), y = this.getRadius(), _ = this.options.move.outModes, x = A => { UR({ outMode: A, checkModes: ["bounce", "bounce-horizontal"], coord: m.x, maxCoord: a.canvas.size.width, setCb: M => m.x += M, radius: y }) }, g = A => { UR({ outMode: A, checkModes: ["bounce", "bounce-vertical"], coord: m.y, maxCoord: a.canvas.size.height, setCb: M => m.y += M, radius: y }) }; return x(_.left ?? _.default), x(_.right ?? _.default), g(_.top ?? _.default), g(_.bottom ?? _.default), this._checkOverlap(m, f) ? this._calcPosition(a, void 0, c, f + 1) : m }, this._calculateVelocity = () => { const a = BG(this.direction), l = a.copy(), c = this.options.move; if (c.direction === "inside" || c.direction === "outside") return l; const f = Math.PI / 180 * ze(c.angle.value), d = Math.PI / 180 * ze(c.angle.offset), p = { left: d - f / 2, right: d + f / 2 }; return c.straight || (l.angle += Si(it(p.left, p.right))), c.random && typeof c.speed == "number" && (l.length *= Tt()), l }, this._checkOverlap = (a, l = 0) => { const c = this.options.collisions, f = this.getRadius(); if (!c.enable) return !1; const d = c.overlap; if (d.enable) return !1; const p = d.retries; if (p >= 0 && l > p) throw new Error(`${zs} particle is overlapping and can't be placed`); return !!this.container.particles.find(m => vr(a, m.position) < f + m.getRadius()) }, this._getRollColor = a => { if (!a || !this.roll || !this.backColor && !this.roll.alter) return a; const l = this.roll.horizontal && this.roll.vertical ? 2 : 1, c = this.roll.horizontal ? Math.PI / 2 : 0; return Math.floor(((this.roll.angle ?? 0) + c) / (Math.PI / l)) % 2 ? this.backColor ? this.backColor : this.roll.alter ? e4(a, this.roll.alter.type, this.roll.alter.value) : a : a }, this._initPosition = a => { const l = this.container, c = ze(this.options.zIndex.value); this.position = this._calcPosition(l, a, fo(c, 0, l.zLayers)), this.initialPosition = this.position.copy(); const f = l.canvas.size; switch (this.moveCenter = { ...$D(this.options.move.center, f), radius: this.options.move.center.radius ?? 0, mode: this.options.move.center.mode ?? "percent" }, this.direction = IG(this.options.move.direction, this.position, this.moveCenter), this.options.move.direction) { case "inside": this.outType = "inside"; break; case "outside": this.outType = "outside"; break }this.offset = dn.origin }, this._loadShapeData = (a, l) => { const c = a.options[this.shape]; if (c) return Qn({ close: a.close, fill: a.fill }, rs(c, this.id, l)) }, this._engine = e, this.init(t, r, s, o) } destroy(e) { if (this.unbreakable || this.destroyed) return; this.destroyed = !0, this.bubble.inRange = !1, this.slow.inRange = !1; const t = this.container, n = this.pathGenerator; for (const [, r] of t.plugins) r.particleDestroyed && r.particleDestroyed(this, e); for (const r of t.particles.updaters) r.particleDestroyed && r.particleDestroyed(this, e); n && n.reset(this) } draw(e) { const t = this.container; for (const [, n] of t.plugins) t.canvas.drawParticlePlugin(n, this, e); t.canvas.drawParticle(this, e) } getFillColor() { return this._getRollColor(this.bubble.color ?? OR(this.color)) } getMass() { return this.getRadius() ** 2 * Math.PI / 2 } getPosition() { return { x: this.position.x + this.offset.x, y: this.position.y + this.offset.y, z: this.position.z } } getRadius() { return this.bubble.radius ?? this.size.value } getStrokeColor() { return this._getRollColor(this.bubble.color ?? OR(this.strokeColor)) } init(e, t, n, r) { const s = this.container, o = this._engine; this.id = e, this.group = r, this.fill = !0, this.pathRotation = !1, this.close = !0, this.lastPathTime = 0, this.destroyed = !1, this.unbreakable = !1, this.rotation = 0, this.misplaced = !1, this.retina = { maxDistance: {} }, this.outType = "normal", this.ignoresResizeRatio = !0; const a = s.retina.pixelRatio, l = s.actualOptions, c = sE(this._engine, s, l.particles), f = c.shape.type, { reduceDuplicates: d } = c; this.shape = rs(f, this.id, d); const p = c.shape; if (n && n.shape && n.shape.type) { const M = n.shape.type, S = rs(M, this.id, d); S && (this.shape = S, p.load(n.shape)) } this.shapeData = this._loadShapeData(p, d), c.load(n); const m = this.shapeData; m && c.load(m.particles); const y = new oO(o, s); y.load(s.actualOptions.interactivity), y.load(c.interactivity), this.interactivity = y, this.fill = (m == null ? void 0 : m.fill) ?? c.shape.fill, this.close = (m == null ? void 0 : m.close) ?? c.shape.close, this.options = c; const _ = this.options.move.path; this.pathDelay = La(_.delay) * 1e3, _.generator && (this.pathGenerator = this._engine.plugins.getPathGenerator(_.generator), this.pathGenerator && s.addPath(_.generator, this.pathGenerator) && this.pathGenerator.init(s)), s.retina.initParticle(this), this.size = QD(this.options.size, a), this.bubble = { inRange: !1 }, this.slow = { inRange: !1, factor: 1 }, this._initPosition(t), this.initialVelocity = this._calculateVelocity(), this.velocity = this.initialVelocity.copy(), this.moveDecay = 1 - ze(this.options.move.decay); const x = s.particles; x.needsSort = x.needsSort || x.lastZIndex < this.position.z, x.lastZIndex = this.position.z, this.zIndexFactor = this.position.z / s.zLayers, this.sides = 24; let g = s.drawers.get(this.shape); g || (g = this._engine.plugins.getShapeDrawer(this.shape), g && s.drawers.set(this.shape, g)), g && g.loadShape && g.loadShape(this); const A = g == null ? void 0 : g.getSidesCount; A && (this.sides = A(this)), this.spawning = !1, this.shadowColor = Fs(this.options.shadow.color); for (const M of s.particles.updaters) M.init(this); for (const M of s.particles.movers) M.init && M.init(this); g && g.particleInit && g.particleInit(s, this); for (const [, M] of s.plugins) M.particleCreated && M.particleCreated(this) } isInsideCanvas() { const e = this.getRadius(), t = this.container.canvas.size, n = this.position; return n.x >= -e && n.y >= -e && n.y <= t.height + e && n.x <= t.width + e } isVisible() { return !this.destroyed && !this.spawning && this.isInsideCanvas() } reset() { for (const e of this.container.particles.updaters) e.reset && e.reset(this) } }; class Y4 { constructor(e, t) { this.position = e, this.particle = t } } class uO { constructor(e, t) { this.position = { x: e, y: t } } } class ho extends uO { constructor(e, t, n, r) { super(e, t), this.size = { height: r, width: n } } contains(e) { const t = this.size.width, n = this.size.height, r = this.position; return e.x >= r.x && e.x <= r.x + t && e.y >= r.y && e.y <= r.y + n } intersects(e) { e instanceof tr && e.intersects(this); const t = this.size.width, n = this.size.height, r = this.position, s = e.position, o = e instanceof ho ? e.size : { width: 0, height: 0 }, a = o.width, l = o.height; return s.x < r.x + t && s.x + a > r.x && s.y < r.y + n && s.y + l > r.y } } class tr extends uO { constructor(e, t, n) { super(e, t), this.radius = n } contains(e) { return vr(e, this.position) <= this.radius } intersects(e) { const t = this.position, n = e.position, r = { x: Math.abs(n.x - t.x), y: Math.abs(n.y - t.y) }, s = this.radius; if (e instanceof tr) { const o = s + e.radius, a = Math.sqrt(r.x ** 2 + r.y ** 2); return o > a } else if (e instanceof ho) { const { width: o, height: a } = e.size; return Math.pow(r.x - o, 2) + Math.pow(r.y - a, 2) <= s ** 2 || r.x <= s + o && r.y <= s + a || r.x <= o || r.y <= a } return !1 } } class Qy { constructor(e, t) { this.rectangle = e, this.capacity = t, this._subdivide = () => { const { x: n, y: r } = this.rectangle.position, { width: s, height: o } = this.rectangle.size, { capacity: a } = this; for (let l = 0; l < 4; l++)this._subs.push(new Qy(new ho(n + s / 2 * (l % 2), r + o / 2 * (Math.round(l / 2) - l % 2), s / 2, o / 2), a)); this._divided = !0 }, this._points = [], this._divided = !1, this._subs = [] } insert(e) { return this.rectangle.contains(e.position) ? this._points.length < this.capacity ? (this._points.push(e), !0) : (this._divided || this._subdivide(), this._subs.some(t => t.insert(e))) : !1 } query(e, t, n) { const r = n || []; if (!e.intersects(this.rectangle)) return []; for (const s of this._points) !e.contains(s.position) && vr(e.position, s.position) > s.particle.getRadius() && (!t || t(s.particle)) || r.push(s.particle); if (this._divided) for (const s of this._subs) s.query(e, t, r); return r } queryCircle(e, t, n) { return this.query(new tr(e.x, e.y, t), n) } queryRectangle(e, t, n) { return this.query(new ho(e.x, e.y, t.width, t.height), n) } } const zR = 4, HR = i => new ho(-i.width / 4, -i.height / 4, i.width * 3 / 2, i.height * 3 / 2); let j4 = class { constructor(e, t) { this._applyDensity = (r, s, o) => { var m; if (!((m = r.number.density) != null && m.enable)) return; const a = r.number, l = this._initDensityFactor(a.density), c = a.value, f = a.limit > 0 ? a.limit : c, d = Math.min(c, f) * l + s, p = Math.min(this.count, this.filter(y => y.group === o).length); this.limit = a.limit * l, p < d ? this.push(Math.abs(d - p), void 0, r, o) : p > d && this.removeQuantity(p - d, o) }, this._initDensityFactor = r => { const s = this._container; if (!s.canvas.element || !r.enable) return 1; const o = s.canvas.element, a = s.retina.pixelRatio; return o.width * o.height / (r.factor * a ** 2 * r.area) }, this._pushParticle = (r, s, o, a) => { try { let l = this.pool.pop(); l ? l.init(this._nextId, r, s, o) : l = new J4(this._engine, this._nextId, this._container, r, s, o); let c = !0; return a && (c = a(l)), c ? (this._array.push(l), this._zArray.push(l), this._nextId++, this._engine.dispatchEvent("particleAdded", { container: this._container, data: { particle: l } }), l) : void 0 } catch (l) { ou().warning(`${zs} adding particle: ${l}`); return } }, this._removeParticle = (r, s, o) => { const a = this._array[r]; if (!a || a.group !== s) return !1; a.destroy(o); const l = this._zArray.indexOf(a); return this._array.splice(r, 1), this._zArray.splice(l, 1), this.pool.push(a), this._engine.dispatchEvent("particleRemoved", { container: this._container, data: { particle: a } }), !0 }, this._engine = e, this._container = t, this._nextId = 0, this._array = [], this._zArray = [], this.pool = [], this.limit = 0, this.needsSort = !1, this.lastZIndex = 0, this._interactionManager = new X4(e, t); const n = t.canvas.size; this.quadTree = new Qy(HR(n), zR), this.movers = this._engine.plugins.getMovers(t, !0), this.updaters = this._engine.plugins.getUpdaters(t, !0) } get count() { return this._array.length } addManualParticles() { const e = this._container, t = e.actualOptions; for (const n of t.manualParticles) this.addParticle(n.position ? $D(n.position, e.canvas.size) : void 0, n.options) } addParticle(e, t, n, r) { const s = this._container, o = s.actualOptions, a = o.particles.number.limit; if (a > 0) { const l = this.count + 1 - a; l > 0 && this.removeQuantity(l) } return this._pushParticle(e, t, n, r) } clear() { this._array = [], this._zArray = [] } destroy() { this._array = [], this._zArray = [], this.movers = [], this.updaters = [] } async draw(e) { const t = this._container; t.canvas.clear(), await this.update(e); for (const [, n] of t.plugins) t.canvas.drawPlugin(n, e); for (const n of this._zArray) n.draw(e) } filter(e) { return this._array.filter(e) } find(e) { return this._array.find(e) } handleClickMode(e) { this._interactionManager.handleClickMode(e) } init() { var r; const e = this._container, t = e.actualOptions; this.lastZIndex = 0, this.needsSort = !1; let n = !1; this.updaters = this._engine.plugins.getUpdaters(e, !0), this._interactionManager.init(); for (const [, s] of e.plugins) if (s.particlesInitialization !== void 0 && (n = s.particlesInitialization()), n) break; this._interactionManager.init(); for (const [, s] of e.pathGenerators) s.init(e); if (this.addManualParticles(), !n) { for (const s in t.particles.groups) { const o = t.particles.groups[s]; for (let a = this.count, l = 0; l < ((r = o.number) == null ? void 0 : r.value) && a < t.particles.number.value; a++, l++)this.addParticle(void 0, o, s) } for (let s = this.count; s < t.particles.number.value; s++)this.addParticle() } } push(e, t, n, r) { this.pushing = !0; for (let s = 0; s < e; s++)this.addParticle(t == null ? void 0 : t.position, n, r); this.pushing = !1 } async redraw() { this.clear(), this.init(), await this.draw({ value: 0, factor: 0 }) } remove(e, t, n) { this.removeAt(this._array.indexOf(e), void 0, t, n) } removeAt(e, t = 1, n, r) { if (e < 0 || e > this.count) return; let s = 0; for (let o = e; s < t && o < this.count; o++)this._removeParticle(o--, n, r) && s++ } removeQuantity(e, t) { this.removeAt(0, e, t) } setDensity() { const e = this._container.actualOptions, t = e.particles.groups; for (const n in t) this._applyDensity(t[n], 0, n); this._applyDensity(e.particles, e.manualParticles.length) } async update(e) { const t = this._container, n = new Set; this.quadTree = new Qy(HR(t.canvas.size), zR); for (const [, r] of t.pathGenerators) r.update(); for (const [, r] of t.plugins) r.update && r.update(e); for (const r of this._array) { const s = t.canvas.resizeFactor; s && !r.ignoresResizeRatio && (r.position.x *= s.width, r.position.y *= s.height, r.initialPosition.x *= s.width, r.initialPosition.y *= s.height), r.ignoresResizeRatio = !1, await this._interactionManager.reset(r); for (const [, o] of this._container.plugins) { if (r.destroyed) break; o.particleUpdate && o.particleUpdate(r, e) } for (const o of this.movers) o.isEnabled(r) && o.move(r, e); if (r.destroyed) { n.add(r); continue } this.quadTree.insert(new Y4(r.getPosition(), r)) } if (n.size) { const r = s => !n.has(s); this._array = this.filter(r), this._zArray = this._zArray.filter(r), this.pool.push(...n) } await this._interactionManager.externalInteract(e); for (const r of this._array) { for (const s of this.updaters) s.update(r, e); !r.destroyed && !r.spawning && await this._interactionManager.particlesInteract(r, e) } if (delete t.canvas.resizeFactor, this.needsSort) { const r = this._zArray; r.sort((s, o) => o.position.z - s.position.z || s.id - o.id), this.lastZIndex = r[r.length - 1].position.z, this.needsSort = !1 } } }; class K4 { constructor(e) { this.container = e, this.pixelRatio = 1, this.reduceFactor = 1 } init() { const e = this.container, t = e.actualOptions; this.pixelRatio = !t.detectRetina || fh() ? 1 : window.devicePixelRatio, this.reduceFactor = 1; const n = this.pixelRatio; if (e.canvas.element) { const o = e.canvas.element; e.canvas.size.width = o.offsetWidth * n, e.canvas.size.height = o.offsetHeight * n } const r = t.particles, s = r.move; this.attractDistance = ze(s.attract.distance) * n, this.maxSpeed = ze(s.gravity.maxSpeed) * n, this.sizeAnimationSpeed = ze(r.size.animation.speed) * n } initParticle(e) { const t = e.options, n = this.pixelRatio, r = t.move, s = r.distance, o = e.retina; o.attractDistance = ze(r.attract.distance) * n, o.moveDrift = ze(r.drift) * n, o.moveSpeed = ze(r.speed) * n, o.sizeAnimationSpeed = ze(t.size.animation.speed) * n; const a = o.maxDistance; a.horizontal = s.horizontal !== void 0 ? s.horizontal * n : void 0, a.vertical = s.vertical !== void 0 ? s.vertical * n : void 0, o.maxSpeed = ze(r.gravity.maxSpeed) * n } } function Cn(i) { return i && !i.destroyed } function q4(i, e = 60, t = !1) { return { value: i, factor: t ? 60 / e : 60 * i / 1e3 } } function Fu(i, e, ...t) { const n = new W4(i, e); return cO(n, ...t), n } const Q4 = "default", GR = { generate: i => i.velocity, init: () => { }, update: () => { }, reset: () => { } }; class Z4 { constructor(e, t, n) { this.id = t, this._intersectionManager = r => { if (!(!Cn(this) || !this.actualOptions.pauseOnOutsideViewport)) for (const s of r) s.target === this.interactivity.element && (s.isIntersecting ? this.play : this.pause)() }, this._nextFrame = async r => { try { if (!this.smooth && this.lastFrameTime !== void 0 && r < this.lastFrameTime + 1e3 / this.fpsLimit) { this.draw(!1); return } this.lastFrameTime ?? (this.lastFrameTime = r); const s = q4(r - this.lastFrameTime, this.fpsLimit, this.smooth); if (this.addLifeTime(s.value), this.lastFrameTime = r, s.value > 1e3) { this.draw(!1); return } if (await this.particles.draw(s), !this.alive()) { this.destroy(); return } this.getAnimationStatus() && this.draw(!1) } catch (s) { ou().error(`${zs} in animation loop`, s) } }, this._engine = e, this.fpsLimit = 120, this.smooth = !1, this._delay = 0, this._duration = 0, this._lifeTime = 0, this._firstStart = !0, this.started = !1, this.destroyed = !1, this._paused = !0, this.lastFrameTime = 0, this.zLayers = 100, this.pageHidden = !1, this._sourceOptions = n, this._initialSourceOptions = n, this.retina = new K4(this), this.canvas = new n4(this), this.particles = new j4(this._engine, this), this.pathGenerators = new Map, this.interactivity = { mouse: { clicking: !1, inside: !1 } }, this.plugins = new Map, this.drawers = new Map, this._options = Fu(this._engine, this), this.actualOptions = Fu(this._engine, this), this._eventListeners = new i4(this), typeof IntersectionObserver < "u" && IntersectionObserver && (this._intersectionObserver = new IntersectionObserver(r => this._intersectionManager(r))), this._engine.dispatchEvent("containerBuilt", { container: this }) } get options() { return this._options } get sourceOptions() { return this._sourceOptions } addClickHandler(e) { if (!Cn(this)) return; const t = this.interactivity.element; if (!t) return; const n = (d, p, m) => { if (!Cn(this)) return; const y = this.retina.pixelRatio, _ = { x: p.x * y, y: p.y * y }, x = this.particles.quadTree.queryCircle(_, m * y); e(d, x) }, r = d => { if (!Cn(this)) return; const p = d, m = { x: p.offsetX || p.clientX, y: p.offsetY || p.clientY }; n(d, m, 1) }, s = () => { Cn(this) && (c = !0, f = !1) }, o = () => { Cn(this) && (f = !0) }, a = d => { if (Cn(this)) { if (c && !f) { const p = d; let m = p.touches[p.touches.length - 1]; if (!m && (m = p.changedTouches[p.changedTouches.length - 1], !m)) return; const y = this.canvas.element, _ = y ? y.getBoundingClientRect() : void 0, x = { x: m.clientX - (_ ? _.left : 0), y: m.clientY - (_ ? _.top : 0) }; n(d, x, Math.max(m.radiusX, m.radiusY)) } c = !1, f = !1 } }, l = () => { Cn(this) && (c = !1, f = !1) }; let c = !1, f = !1; t.addEventListener("click", r), t.addEventListener("touchstart", s), t.addEventListener("touchmove", o), t.addEventListener("touchend", a), t.addEventListener("touchcancel", l) } addLifeTime(e) { this._lifeTime += e } addPath(e, t, n = !1) { return !Cn(this) || !n && this.pathGenerators.has(e) ? !1 : (this.pathGenerators.set(e, t ?? GR), !0) } alive() { return !this._duration || this._lifeTime <= this._duration } destroy() { if (!Cn(this)) return; this.stop(), this.particles.destroy(), this.canvas.destroy(); for (const [, n] of this.drawers) n.destroy && n.destroy(this); for (const n of this.drawers.keys()) this.drawers.delete(n); this._engine.plugins.destroy(this), this.destroyed = !0; const e = this._engine.dom(), t = e.findIndex(n => n === this); t >= 0 && e.splice(t, 1), this._engine.dispatchEvent("containerDestroyed", { container: this }) } draw(e) { if (!Cn(this)) return; let t = e; this._drawAnimationFrame = requestAnimationFrame(async n => { t && (this.lastFrameTime = void 0, t = !1), await this._nextFrame(n) }) } async export(e, t = {}) { for (const [, n] of this.plugins) { if (!n.export) continue; const r = await n.export(e, t); if (r.supported) return r.blob } ou().error(`${zs} - Export plugin with type ${e} not found`) } getAnimationStatus() { return !this._paused && !this.pageHidden && Cn(this) } handleClickMode(e) { if (Cn(this)) { this.particles.handleClickMode(e); for (const [, t] of this.plugins) t.handleClickMode && t.handleClickMode(e) } } async init() { if (!Cn(this)) return; const e = this._engine.plugins.getSupportedShapes(); for (const n of e) { const r = this._engine.plugins.getShapeDrawer(n); r && this.drawers.set(n, r) } this._options = Fu(this._engine, this, this._initialSourceOptions, this.sourceOptions), this.actualOptions = Fu(this._engine, this, this._options); const t = this._engine.plugins.getAvailablePlugins(this); for (const [n, r] of t) this.plugins.set(n, r); this.retina.init(), await this.canvas.init(), this.updateActualOptions(), this.canvas.initBackground(), this.canvas.resize(), this.zLayers = this.actualOptions.zLayers, this._duration = ze(this.actualOptions.duration) * 1e3, this._delay = ze(this.actualOptions.delay) * 1e3, this._lifeTime = 0, this.fpsLimit = this.actualOptions.fpsLimit > 0 ? this.actualOptions.fpsLimit : 120, this.smooth = this.actualOptions.smooth; for (const [, n] of this.drawers) n.init && await n.init(this); for (const [, n] of this.plugins) n.init && await n.init(); this._engine.dispatchEvent("containerInit", { container: this }), this.particles.init(), this.particles.setDensity(); for (const [, n] of this.plugins) n.particlesSetup && n.particlesSetup(); this._engine.dispatchEvent("particlesSetup", { container: this }) } async loadTheme(e) { Cn(this) && (this._currentTheme = e, await this.refresh()) } pause() { if (Cn(this) && (this._drawAnimationFrame !== void 0 && (cancelAnimationFrame(this._drawAnimationFrame), delete this._drawAnimationFrame), !this._paused)) { for (const [, e] of this.plugins) e.pause && e.pause(); this.pageHidden || (this._paused = !0), this._engine.dispatchEvent("containerPaused", { container: this }) } } play(e) { if (!Cn(this)) return; const t = this._paused || e; if (this._firstStart && !this.actualOptions.autoPlay) { this._firstStart = !1; return } if (this._paused && (this._paused = !1), t) for (const [, n] of this.plugins) n.play && n.play(); this._engine.dispatchEvent("containerPlay", { container: this }), this.draw(t || !1) } async refresh() { if (Cn(this)) return this.stop(), this.start() } async reset() { if (Cn(this)) return this._initialSourceOptions = void 0, this._options = Fu(this._engine, this), this.actualOptions = Fu(this._engine, this, this._options), this.refresh() } setNoise(e, t, n) { Cn(this) && this.setPath(e, t, n) } setPath(e, t, n) { if (!e || !Cn(this)) return; const r = { ...GR }; if (eO(e)) r.generate = e, t && (r.init = t), n && (r.update = n); else { const s = r; r.generate = e.generate || s.generate, r.init = e.init || s.init, r.update = e.update || s.update } this.addPath(Q4, r, !0) } async start() { !Cn(this) || this.started || (await this.init(), this.started = !0, await new Promise(e => { this._delayTimeout = setTimeout(async () => { this._eventListeners.addListeners(), this.interactivity.element instanceof HTMLElement && this._intersectionObserver && this._intersectionObserver.observe(this.interactivity.element); for (const [, t] of this.plugins) t.start && await t.start(); this._engine.dispatchEvent("containerStarted", { container: this }), this.play(), e() }, this._delay) })) } stop() { if (!(!Cn(this) || !this.started)) { this._delayTimeout && (clearTimeout(this._delayTimeout), delete this._delayTimeout), this._firstStart = !0, this.started = !1, this._eventListeners.removeListeners(), this.pause(), this.particles.clear(), this.canvas.stop(), this.interactivity.element instanceof HTMLElement && this._intersectionObserver && this._intersectionObserver.unobserve(this.interactivity.element); for (const [, e] of this.plugins) e.stop && e.stop(); for (const e of this.plugins.keys()) this.plugins.delete(e); this._sourceOptions = this._options, this._engine.dispatchEvent("containerStopped", { container: this }) } } updateActualOptions() { this.actualOptions.responsive = []; const e = this.actualOptions.setResponsive(this.canvas.size.width, this.retina.pixelRatio, this._options); return this.actualOptions.setTheme(this._currentTheme), this.responsiveMaxWidth === e ? !1 : (this.responsiveMaxWidth = e, !0) } } let $4 = class { constructor() { this._listeners = new Map } addEventListener(e, t) { this.removeEventListener(e, t); let n = this._listeners.get(e); n || (n = [], this._listeners.set(e, n)), n.push(t) } dispatchEvent(e, t) { const n = this._listeners.get(e); n && n.forEach(r => r(t)) } hasEventListener(e) { return !!this._listeners.get(e) } removeAllEventListeners(e) { e ? this._listeners.delete(e) : this._listeners = new Map } removeEventListener(e, t) { const n = this._listeners.get(e); if (!n) return; const r = n.length, s = n.indexOf(t); s < 0 || (r === 1 ? this._listeners.delete(e) : n.splice(s, 1)) } }; function gA(i, e, t, n = !1) { let r = e.get(i); return (!r || n) && (r = [...t.values()].map(s => s(i)), e.set(i, r)), r } class eV { constructor(e) { this._engine = e, this.plugins = [], this._initializers = { interactors: new Map, movers: new Map, updaters: new Map }, this.interactors = new Map, this.movers = new Map, this.updaters = new Map, this.presets = new Map, this.drawers = new Map, this.pathGenerators = new Map } addInteractor(e, t) { this._initializers.interactors.set(e, t) } addParticleMover(e, t) { this._initializers.movers.set(e, t) } addParticleUpdater(e, t) { this._initializers.updaters.set(e, t) } addPathGenerator(e, t) { !this.getPathGenerator(e) && this.pathGenerators.set(e, t) } addPlugin(e) { !this.getPlugin(e.id) && this.plugins.push(e) } addPreset(e, t, n = !1) { (n || !this.getPreset(e)) && this.presets.set(e, t) } addShapeDrawer(e, t) { xn(e, n => { !this.getShapeDrawer(n) && this.drawers.set(n, t) }) } destroy(e) { this.updaters.delete(e), this.movers.delete(e), this.interactors.delete(e) } getAvailablePlugins(e) { const t = new Map; for (const n of this.plugins) n.needsPlugin(e.actualOptions) && t.set(n.id, n.getPlugin(e)); return t } getInteractors(e, t = !1) { return gA(e, this.interactors, this._initializers.interactors, t) } getMovers(e, t = !1) { return gA(e, this.movers, this._initializers.movers, t) } getPathGenerator(e) { return this.pathGenerators.get(e) } getPlugin(e) { return this.plugins.find(t => t.id === e) } getPreset(e) { return this.presets.get(e) } getShapeDrawer(e) { return this.drawers.get(e) } getSupportedShapes() { return this.drawers.keys() } getUpdaters(e, t = !1) { return gA(e, this.updaters, this._initializers.updaters, t) } loadOptions(e, t) { for (const n of this.plugins) n.loadOptions(e, t) } loadParticlesOptions(e, t, ...n) { const r = this.updaters.get(e); if (r) for (const s of r) s.loadOptions && s.loadOptions(t, ...n) } } async function tV(i) { const e = rs(i.url, i.index); if (!e) return i.fallback; const t = await fetch(e); return t.ok ? t.json() : (ou().error(`${zs} ${t.status} while retrieving config file`), i.fallback) } function nV(i) { return !i.id && !i.element && !i.url && !i.options } function iV(i) { return !nV(i) } class rV { constructor() { this._configs = new Map, this._domArray = [], this._eventDispatcher = new $4, this._initialized = !1, this.plugins = new eV(this) } get configs() { const e = {}; for (const [t, n] of this._configs) e[t] = n; return e } get version() { return "2.12.0" } addConfig(e, t) { co(e) ? t && (t.name = e, this._configs.set(e, t)) : this._configs.set(e.name ?? "default", e) } addEventListener(e, t) { this._eventDispatcher.addEventListener(e, t) } async addInteractor(e, t, n = !0) { this.plugins.addInteractor(e, t), await this.refresh(n) } async addMover(e, t, n = !0) { this.plugins.addParticleMover(e, t), await this.refresh(n) } async addParticleUpdater(e, t, n = !0) { this.plugins.addParticleUpdater(e, t), await this.refresh(n) } async addPathGenerator(e, t, n = !0) { this.plugins.addPathGenerator(e, t), await this.refresh(n) } async addPlugin(e, t = !0) { this.plugins.addPlugin(e), await this.refresh(t) } async addPreset(e, t, n = !1, r = !0) { this.plugins.addPreset(e, t, n), await this.refresh(r) } async addShape(e, t, n, r, s, o = !0) { let a, l = o, c, f, d; Tl(n) ? (l = n, c = void 0) : c = n, Tl(r) ? (l = r, f = void 0) : f = r, Tl(s) ? (l = s, d = void 0) : d = s, eO(t) ? a = { afterEffect: f, destroy: d, draw: t, init: c } : a = t, this.plugins.addShapeDrawer(e, a), await this.refresh(l) } dispatchEvent(e, t) { this._eventDispatcher.dispatchEvent(e, t) } dom() { return this._domArray } domItem(e) { const t = this.dom(), n = t[e]; if (!n || n.destroyed) { t.splice(e, 1); return } return n } init() { this._initialized || (this._initialized = !0) } async load(e, t) { return this.loadFromArray(e, t) } async loadFromArray(e, t, n) { let r; return iV(e) ? r = e : (r = {}, co(e) ? r.id = e : r.options = e, er(t) ? r.index = t : r.options = t ?? r.options, r.index = n ?? r.index), this._loadParams(r) } async loadJSON(e, t, n) { let r, s; return er(t) || t === void 0 ? r = e : (s = e, r = t), this._loadParams({ id: s, url: r, index: n }) } async refresh(e = !0) { e && this.dom().forEach(t => t.refresh()) } removeEventListener(e, t) { this._eventDispatcher.removeEventListener(e, t) } async set(e, t, n, r) { const s = { index: r }; return co(e) ? s.id = e : s.element = e, t instanceof HTMLElement ? s.element = t : s.options = t, er(n) ? s.index = n : s.options = n ?? s.options, this._loadParams(s) } async setJSON(e, t, n, r) { const s = {}; return e instanceof HTMLElement ? (s.element = e, s.url = t, s.index = n) : (s.id = e, s.element = t, s.url = n, s.index = r), this._loadParams(s) } setOnClickHandler(e) { const t = this.dom(); if (!t.length) throw new Error(`${zs} can only set click handlers after calling tsParticles.load()`); for (const n of t) n.addClickHandler(e) } async _loadParams(e) { const t = e.id ?? `tsparticles${Math.floor(Tt() * 1e4)}`, { index: n, url: r } = e, s = r ? await tV({ fallback: e.options, url: r, index: n }) : e.options; let o = e.element ?? document.getElementById(t); o || (o = document.createElement("div"), o.id = t, document.body.append(o)); const a = rs(s, n), l = this.dom(), c = l.findIndex(p => p.id === t); if (c >= 0) { const p = this.domItem(c); p && !p.destroyed && (p.destroy(), l.splice(c, 1)) } let f; if (o.tagName.toLowerCase() === "canvas") f = o, f.dataset[np] = "false"; else { const p = o.getElementsByTagName("canvas"); p.length ? (f = p[0], f.dataset[np] = "false") : (f = document.createElement("canvas"), f.dataset[np] = "true", o.appendChild(f)) } f.style.width || (f.style.width = "100%"), f.style.height || (f.style.height = "100%"); const d = new Z4(this, t, a); return c >= 0 ? l.splice(c, 0, d) : l.push(d), d.canvas.loadCanvas(f), await d.start(), d } } class sV { constructor() { this.key = "hsl", this.stringPrefix = "hsl" } handleColor(e) { const t = e.value, n = t.hsl ?? e.value; if (n.h !== void 0 && n.s !== void 0 && n.l !== void 0) return hh(n) } handleRangeColor(e) { const t = e.value, n = t.hsl ?? e.value; if (n.h !== void 0 && n.l !== void 0) return hh({ h: ze(n.h), l: ze(n.l), s: ze(n.s) }) } parseString(e) { if (!e.startsWith("hsl")) return; const t = /hsla?\(\s*(\d+)\s*,\s*(\d+)%\s*,\s*(\d+)%\s*(,\s*([\d.%]+)\s*)?\)/i, n = t.exec(e); return n ? XG({ a: n.length > 4 ? XD(n[5]) : 1, h: parseInt(n[1], 10), l: parseInt(n[3], 10), s: parseInt(n[2], 10) }) : void 0 } } class oV { constructor() { this.key = "rgb", this.stringPrefix = "rgb" } handleColor(e) { const t = e.value, n = t.rgb ?? e.value; if (n.r !== void 0) return n } handleRangeColor(e) { const t = e.value, n = t.rgb ?? e.value; if (n.r !== void 0) return { r: ze(n.r), g: ze(n.g), b: ze(n.b) } } parseString(e) { if (!e.startsWith(this.stringPrefix)) return; const t = /rgba?\(\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(,\s*([\d.%]+)\s*)?\)/i, n = t.exec(e); return n ? { a: n.length > 4 ? XD(n[5]) : 1, b: parseInt(n[3], 10), g: parseInt(n[2], 10), r: parseInt(n[1], 10) } : void 0 } } function aV() { const i = new oV, e = new sV; DR(i), DR(e); const t = new rV; return t.init(), t } class go { constructor(e) { this.container = e, this.type = "external" } } class oE { constructor(e) { this.container = e, this.type = "particles" } } const Zy = aV(); fh() || (window.tsParticles = Zy); const Rf = i => typeof i == "object" && i !== null; function $y(i, e, t = () => !1) { if (!Rf(i) || !Rf(e)) return i === e; const n = Object.keys(i).filter(s => !t(s)), r = Object.keys(e).filter(s => !t(s)); if (n.length !== r.length) return !1; for (const s of n) { const o = i[s], a = e[s]; if (Rf(o) && Rf(a)) { if (o === e && a === i) continue; if (!$y(o, a, t)) return !1 } else if (Array.isArray(o) && Array.isArray(a)) { if (!fO(o, a, t)) return !1 } else if (o !== a) return !1 } return !0 } function fO(i, e, t) { if (i.length !== e.length) return !1; for (let n = 0; n < i.length; n++) { const r = i[n], s = e[n]; if (Array.isArray(r) && Array.isArray(s)) { if (!fO(r, s, t)) return !1 } else if (Rf(r) && Rf(s)) { if (!$y(r, s, t)) return !1 } else if (r !== s) return !1 } return !0 } const hO = "tsparticles"; let dO = class pO extends ce.Component { constructor(e) { super(e), this.state = { init: !1, library: void 0 } } destroy() { this.state.library && (this.state.library.destroy(), this.setState({ library: void 0 })) } shouldComponentUpdate(e) { const t = e.options ?? e.params, n = this.props.options ?? this.props.params; return e.url !== this.props.url || e.id !== this.props.id || e.canvasClassName !== this.props.canvasClassName || e.className !== this.props.className || e.height !== this.props.height || e.width !== this.props.width || !$y(e.style, this.props.style) || e.init !== this.props.init || e.loaded !== this.props.loaded || !$y(t, n, r => r.startsWith("_")) } componentDidUpdate() { this.refresh() } forceUpdate() { this.refresh().then(() => { super.forceUpdate() }) } componentDidMount() { (async () => (this.props.init && await this.props.init(Zy), this.setState({ init: !0 }, async () => { await this.loadParticles() })))() } componentWillUnmount() { this.destroy() } render() { const { width: e, height: t, className: n, canvasClassName: r, id: s } = this.props; return Qf.createElement("div", { className: n, id: s }, Qf.createElement("canvas", { className: r, style: { ...this.props.style, width: e, height: t } })) } async refresh() { this.destroy(), await this.loadParticles() } async loadParticles() { if (!this.state.init) return; const e = this.props.id ?? pO.defaultProps.id ?? hO, t = await Zy.load({ url: this.props.url, id: e, options: this.props.options ?? this.props.params }); this.props.container && (this.props.container.current = t), this.setState({ library: t }), this.props.loaded && await this.props.loaded(t) } }; dO.defaultProps = { width: "100%", height: "100%", options: {}, style: {}, url: void 0, id: hO }; class lV { constructor() { this.radius = 0, this.mass = 0 } load(e) { e && (e.mass !== void 0 && (this.mass = e.mass), e.radius !== void 0 && (this.radius = e.radius)) } } class cV extends Hs { constructor() { super(), this.density = 5, this.value = 50, this.limit = new lV } load(e) { e && (super.load(e), e.density !== void 0 && (this.density = e.density), er(e.limit) ? this.limit.radius = e.limit : this.limit.load(e.limit)) } } class ev { constructor() { this.color = new Xn, this.color.value = "#000000", this.draggable = !1, this.opacity = 1, this.destroy = !0, this.orbits = !1, this.size = new cV } load(e) { e !== void 0 && (e.color !== void 0 && (this.color = Xn.create(this.color, e.color)), e.draggable !== void 0 && (this.draggable = e.draggable), this.name = e.name, e.opacity !== void 0 && (this.opacity = e.opacity), e.position !== void 0 && (this.position = {}, e.position.x !== void 0 && (this.position.x = it(e.position.x)), e.position.y !== void 0 && (this.position.y = it(e.position.y))), e.size !== void 0 && this.size.load(e.size), e.destroy !== void 0 && (this.destroy = e.destroy), e.orbits !== void 0 && (this.orbits = e.orbits)) } } class uV { constructor(e, t, n, r) { var o; this.absorbers = e, this.container = t, this._calcPosition = () => { const a = WD({ size: this.container.canvas.size, position: this.options.position }); return dn.create(a.x, a.y) }, this._updateParticlePosition = (a, l) => { if (a.destroyed) return; const c = this.container, f = c.canvas.size; if (a.needsNewPosition) { const d = VD({ size: f }); a.position.setTo(d), a.velocity.setTo(a.initialVelocity), a.absorberOrbit = void 0, a.needsNewPosition = !1 } if (this.options.orbits) { if (a.absorberOrbit === void 0 && (a.absorberOrbit = dn.create(0, 0), a.absorberOrbit.length = vr(a.getPosition(), this.position), a.absorberOrbit.angle = Tt() * Math.PI * 2), a.absorberOrbit.length <= this.size && !this.options.destroy) { const _ = Math.min(f.width, f.height); a.absorberOrbit.length = _ * (1 + (Tt() * .2 - .1)) } a.absorberOrbitDirection === void 0 && (a.absorberOrbitDirection = a.velocity.x >= 0 ? "clockwise" : "counter-clockwise"); const d = a.absorberOrbit.length, p = a.absorberOrbit.angle, m = a.absorberOrbitDirection; a.velocity.setTo(dn.origin); const y = { x: m === "clockwise" ? Math.cos : Math.sin, y: m === "clockwise" ? Math.sin : Math.cos }; a.position.x = this.position.x + d * y.x(p), a.position.y = this.position.y + d * y.y(p), a.absorberOrbit.length -= l.length, a.absorberOrbit.angle += (a.retina.moveSpeed ?? 0) * c.retina.pixelRatio / 100 * c.retina.reduceFactor } else { const d = dn.origin; d.length = l.length, d.angle = l.angle, a.velocity.addTo(d) } }, this.initialPosition = r ? dn.create(r.x, r.y) : void 0, n instanceof ev ? this.options = n : (this.options = new ev, this.options.load(n)), this.dragging = !1, this.name = this.options.name, this.opacity = this.options.opacity, this.size = ze(this.options.size.value) * t.retina.pixelRatio, this.mass = this.size * this.options.size.density * t.retina.reduceFactor; const s = this.options.size.limit; this.limit = { radius: s.radius * t.retina.pixelRatio * t.retina.reduceFactor, mass: s.mass }, this.color = Fs(this.options.color) ?? { b: 0, g: 0, r: 0 }, this.position = ((o = this.initialPosition) == null ? void 0 : o.copy()) ?? this._calcPosition() } attract(e) { const t = this.container, n = this.options; if (n.draggable) { const c = t.interactivity.mouse; c.clicking && c.downPosition ? vr(this.position, c.downPosition) <= this.size && (this.dragging = !0) : this.dragging = !1, this.dragging && c.position && (this.position.x = c.position.x, this.position.y = c.position.y) } const r = e.getPosition(), { dx: s, dy: o, distance: a } = $i(this.position, r), l = dn.create(s, o); if (l.length = this.mass / Math.pow(a, 2) * t.retina.reduceFactor, a < this.size + e.getRadius()) { const c = e.getRadius() * .033 * t.retina.pixelRatio; this.size > e.getRadius() && a < this.size - e.getRadius() || e.absorberOrbit !== void 0 && e.absorberOrbit.length < 0 ? n.destroy ? e.destroy() : (e.needsNewPosition = !0, this._updateParticlePosition(e, l)) : (n.destroy && (e.size.value -= c), this._updateParticlePosition(e, l)), (this.limit.radius <= 0 || this.size < this.limit.radius) && (this.size += c), (this.limit.mass <= 0 || this.mass < this.limit.mass) && (this.mass += c * this.options.size.density * t.retina.reduceFactor) } else this._updateParticlePosition(e, l) } draw(e) { e.translate(this.position.x, this.position.y), e.beginPath(), e.arc(0, 0, this.size, 0, Math.PI * 2, !1), e.closePath(), e.fillStyle = zo(this.color, this.opacity), e.fill() } resize() { const e = this.initialPosition; this.position = e && nm(e, this.container.canvas.size, dn.origin) ? e : this._calcPosition() } } class fV { constructor(e) { this.container = e, this.array = [], this.absorbers = [], this.interactivityAbsorbers = [], e.getAbsorber = t => t === void 0 || er(t) ? this.array[t || 0] : this.array.find(n => n.name === t), e.addAbsorber = (t, n) => this.addAbsorber(t, n) } addAbsorber(e, t) { const n = new uV(this, this.container, e, t); return this.array.push(n), n } draw(e) { for (const t of this.array) t.draw(e) } handleClickMode(e) { const t = this.absorbers, n = this.interactivityAbsorbers; if (e === "absorber") { const r = rs(n), s = r ?? rs(t), o = this.container.interactivity.mouse.clickPosition; this.addAbsorber(s, o) } } async init() { this.absorbers = this.container.actualOptions.absorbers, this.interactivityAbsorbers = this.container.actualOptions.interactivity.modes.absorbers, xn(this.absorbers, e => { this.addAbsorber(e) }) } particleUpdate(e) { for (const t of this.array) if (t.attract(e), e.destroyed) break } removeAbsorber(e) { const t = this.array.indexOf(e); t >= 0 && this.array.splice(t, 1) } resize() { for (const e of this.array) e.resize() } stop() { this.array = [] } } class hV { constructor() { this.id = "absorbers" } getPlugin(e) { return new fV(e) } loadOptions(e, t) { var n, r; !this.needsPlugin(e) && !this.needsPlugin(t) || (t != null && t.absorbers && (e.absorbers = xn(t.absorbers, s => { const o = new ev; return o.load(s), o })), e.interactivity.modes.absorbers = xn((r = (n = t == null ? void 0 : t.interactivity) == null ? void 0 : n.modes) == null ? void 0 : r.absorbers, s => { const o = new ev; return o.load(s), o })) } needsPlugin(e) { var n, r, s; if (!e) return !1; const t = e.absorbers; return pi(t) ? !!t.length : t ? !0 : !!((s = (r = (n = e.interactivity) == null ? void 0 : n.events) == null ? void 0 : r.onClick) != null && s.mode && _n("absorber", e.interactivity.events.onClick.mode)) } } async function dV(i, e = !0) { await i.addPlugin(new hV, e) } class pV { load(e) { e && (e.bottom !== void 0 && (this.bottom = it(e.bottom)), e.left !== void 0 && (this.left = it(e.left)), e.right !== void 0 && (this.right = it(e.right)), e.top !== void 0 && (this.top = it(e.top))) } } class mV extends Hs { constructor() { super(), this.value = 3 } } class gV extends Hs { constructor() { super(), this.value = { min: 4, max: 9 } } } class yV { constructor() { this.count = 1, this.factor = new mV, this.rate = new gV, this.sizeOffset = !0 } load(e) { e && (e.color !== void 0 && (this.color = Xn.create(this.color, e.color)), e.count !== void 0 && (this.count = e.count), this.factor.load(e.factor), this.rate.load(e.rate), this.particles = xn(e.particles, t => Qn({}, t)), e.sizeOffset !== void 0 && (this.sizeOffset = e.sizeOffset), e.colorOffset && (this.colorOffset = this.colorOffset ?? {}, e.colorOffset.h !== void 0 && (this.colorOffset.h = e.colorOffset.h), e.colorOffset.s !== void 0 && (this.colorOffset.s = e.colorOffset.s), e.colorOffset.l !== void 0 && (this.colorOffset.l = e.colorOffset.l))) } } class vV { constructor() { this.bounds = new pV, this.mode = "none", this.split = new yV } load(e) { e && (e.mode && (this.mode = e.mode), e.bounds && this.bounds.load(e.bounds), this.split.load(e.split)) } } function _V(i, e, t, n) { const r = t.options.destroy; if (!r) return; const s = r.split, o = sE(i, e, t.options), a = La(s.factor), l = t.getFillColor(); s.color ? o.color.load(s.color) : s.colorOffset && l ? o.color.load({ value: { hsl: { h: l.h + ze(s.colorOffset.h ?? 0), s: l.s + ze(s.colorOffset.s ?? 0), l: l.l + ze(s.colorOffset.l ?? 0) } } }) : o.color.load({ value: { hsl: t.getFillColor() } }), o.move.load({ center: { x: t.position.x, y: t.position.y, mode: "precise" } }), er(o.size.value) ? o.size.value /= a : (o.size.value.min /= a, o.size.value.max /= a), o.load(n); const c = s.sizeOffset ? it(-t.size.value, t.size.value) : 0, f = { x: t.position.x + Si(c), y: t.position.y + Si(c) }; return e.particles.addParticle(f, o, t.group, d => d.size.value < .5 ? !1 : (d.velocity.length = Si(it(t.velocity.length, d.velocity.length)), d.splitCount = (t.splitCount ?? 0) + 1, d.unbreakable = !0, setTimeout(() => { d.unbreakable = !1 }, 500), !0)) } function xV(i, e, t) { const n = t.options.destroy; if (!n) return; const r = n.split; if (r.count >= 0 && (t.splitCount === void 0 || t.splitCount++ > r.count)) return; const s = La(r.rate), o = rs(r.particles); for (let a = 0; a < s; a++)_V(i, e, t, o) } class AV { constructor(e, t) { this.engine = e, this.container = t } init(e) { const t = this.container, n = e.options, r = n.destroy; if (!r) return; e.splitCount = 0; const s = r.bounds; e.destroyBounds || (e.destroyBounds = {}); const { bottom: o, left: a, right: l, top: c } = s, { destroyBounds: f } = e, d = t.canvas.size; o && (f.bottom = ze(o) * d.height / 100), a && (f.left = ze(a) * d.width / 100), l && (f.right = ze(l) * d.width / 100), c && (f.top = ze(c) * d.height / 100) } isEnabled(e) { return !e.destroyed } loadOptions(e, ...t) { e.destroy || (e.destroy = new vV); for (const n of t) e.destroy.load(n == null ? void 0 : n.destroy) } particleDestroyed(e, t) { if (t) return; const n = e.options.destroy; n && n.mode === "split" && xV(this.engine, this.container, e) } update(e) { if (!this.isEnabled(e)) return; const t = e.getPosition(), n = e.destroyBounds; n && (n.bottom !== void 0 && t.y >= n.bottom || n.left !== void 0 && t.x <= n.left || n.right !== void 0 && t.x >= n.right || n.top !== void 0 && t.y <= n.top) && e.destroy() } } async function MV(i, e = !0) { await i.addParticleUpdater("destroy", t => new AV(i, t), e) } class wV { randomPosition(e, t, n) { const r = (d, p) => { const m = Tt() / 4, y = Math.atan(p / d * Math.tan(2 * Math.PI * m)), _ = Tt(); return _ < .25 ? y : _ < .5 ? Math.PI - y : _ < .75 ? Math.PI + y : -y }, s = (d, p, m) => d * p / Math.sqrt((p * Math.cos(m)) ** 2 + (d * Math.sin(m)) ** 2), [o, a] = [t.width / 2, t.height / 2], l = r(o, a), c = s(o, a, l), f = n ? c * Math.sqrt(Tt()) : c; return { x: e.x + f * Math.cos(l), y: e.y + f * Math.sin(l) } } } class SV { constructor() { this.wait = !1 } load(e) { e && (e.count !== void 0 && (this.count = e.count), e.delay !== void 0 && (this.delay = it(e.delay)), e.duration !== void 0 && (this.duration = it(e.duration)), e.wait !== void 0 && (this.wait = e.wait)) } } class EV { constructor() { this.quantity = 1, this.delay = .1 } load(e) { e !== void 0 && (e.quantity !== void 0 && (this.quantity = it(e.quantity)), e.delay !== void 0 && (this.delay = it(e.delay))) } } class mO { constructor() { this.mode = "percent", this.height = 0, this.width = 0 } load(e) { e !== void 0 && (e.mode !== void 0 && (this.mode = e.mode), e.height !== void 0 && (this.height = e.height), e.width !== void 0 && (this.width = e.width)) } } class al { constructor() { this.autoPlay = !0, this.fill = !0, this.life = new SV, this.rate = new EV, this.shape = "square", this.startCount = 0 } load(e) { e && (e.autoPlay !== void 0 && (this.autoPlay = e.autoPlay), e.size !== void 0 && (this.size || (this.size = new mO), this.size.load(e.size)), e.direction !== void 0 && (this.direction = e.direction), this.domId = e.domId, e.fill !== void 0 && (this.fill = e.fill), this.life.load(e.life), this.name = e.name, this.particles = xn(e.particles, t => Qn({}, t)), this.rate.load(e.rate), e.shape !== void 0 && (this.shape = e.shape), e.position !== void 0 && (this.position = {}, e.position.x !== void 0 && (this.position.x = it(e.position.x)), e.position.y !== void 0 && (this.position.y = it(e.position.y))), e.spawnColor !== void 0 && (this.spawnColor === void 0 && (this.spawnColor = new ph), this.spawnColor.load(e.spawnColor)), e.startCount !== void 0 && (this.startCount = e.startCount)) } } class CV { constructor(e, t, n, r, s) { var a, l; this.emitters = t, this.container = n, this._calcPosition = () => WD({ size: this.container.canvas.size, position: this.options.position }), this._destroy = () => { this.emitters.removeEmitter(this), this._engine.dispatchEvent("emitterDestroyed", { container: this.container, data: { emitter: this } }) }, this._emit = () => { if (this._paused) return; const c = ze(this.options.rate.quantity); this._emitParticles(c) }, this._emitParticles = c => { var m, y; const f = this.getPosition(), d = this.getSize(), p = rs(this._particlesOptions); for (let _ = 0; _ < c; _++) { const x = Qn({}, p); if (this.spawnColor) { const A = (m = this.options.spawnColor) == null ? void 0 : m.animation; A && (this.spawnColor.h = this._setColorAnimation(A.h, this.spawnColor.h, 360), this.spawnColor.s = this._setColorAnimation(A.s, this.spawnColor.s, 100), this.spawnColor.l = this._setColorAnimation(A.l, this.spawnColor.l, 100)), x.color ? x.color.value = this.spawnColor : x.color = { value: this.spawnColor } } if (!f) return; const g = ((y = this._shape) == null ? void 0 : y.randomPosition(f, d, this.fill)) ?? f; this.container.particles.addParticle(g, x) } }, this._prepareToDie = () => { var f; if (this._paused) return; const c = ((f = this.options.life) == null ? void 0 : f.duration) !== void 0 ? ze(this.options.life.duration) : void 0; this.container.retina.reduceFactor && (this._lifeCount > 0 || this._immortal) && c !== void 0 && c > 0 && (this._duration = c * 1e3) }, this._setColorAnimation = (c, f, d) => { const p = this.container; if (!c.enable) return f; const m = Si(c.offset), y = ze(this.options.rate.delay), _ = 1e3 * y / p.retina.reduceFactor, x = ze(c.speed ?? 0); return (f + x * p.fpsLimit / _ + m * 3.6) % d }, this._engine = e, this._currentDuration = 0, this._currentEmitDelay = 0, this._currentSpawnDelay = 0, this._initialPosition = s, r instanceof al ? this.options = r : (this.options = new al, this.options.load(r)), this._spawnDelay = ze(this.options.life.delay ?? 0) * 1e3 / this.container.retina.reduceFactor, this.position = this._initialPosition ?? this._calcPosition(), this.name = this.options.name, this._shape = (a = this._engine.emitterShapeManager) == null ? void 0 : a.getShape(this.options.shape), this.fill = this.options.fill, this._firstSpawn = !this.options.life.wait, this._startParticlesAdded = !1; let o = Qn({}, this.options.particles); o ?? (o = {}), o.move ?? (o.move = {}), (l = o.move).direction ?? (l.direction = this.options.direction), this.options.spawnColor && (this.spawnColor = kl(this.options.spawnColor)), this._paused = !this.options.autoPlay, this._particlesOptions = o, this.size = this.options.size ?? (() => { const c = new mO; return c.load({ height: 0, mode: "percent", width: 0 }), c })(), this._lifeCount = this.options.life.count ?? -1, this._immortal = this._lifeCount <= 0, this._engine.dispatchEvent("emitterCreated", { container: n, data: { emitter: this } }), this.play() } externalPause() { this._paused = !0, this.pause() } externalPlay() { this._paused = !1, this.play() } getPosition() { if (this.options.domId) { const e = this.container, t = document.getElementById(this.options.domId); if (t) { const n = t.getBoundingClientRect(); return { x: (n.x + n.width / 2) * e.retina.pixelRatio, y: (n.y + n.height / 2) * e.retina.pixelRatio } } } return this.position } getSize() { const e = this.container; if (this.options.domId) { const t = document.getElementById(this.options.domId); if (t) { const n = t.getBoundingClientRect(); return { width: n.width * e.retina.pixelRatio, height: n.height * e.retina.pixelRatio } } } return GG(this.size, e.canvas.size) } pause() { this._paused || delete this._emitDelay } play() { if (!this._paused && this.container.retina.reduceFactor && (this._lifeCount > 0 || this._immortal || !this.options.life.count) && (this._firstSpawn || this._currentSpawnDelay >= (this._spawnDelay ?? 0))) { if (this._emitDelay === void 0) { const e = ze(this.options.rate.delay); this._emitDelay = 1e3 * e / this.container.retina.reduceFactor } (this._lifeCount > 0 || this._immortal) && this._prepareToDie() } } resize() { const e = this._initialPosition; this.position = e && nm(e, this.container.canvas.size, dn.origin) ? e : this._calcPosition() } update(e) { this._paused || (this._firstSpawn && (this._firstSpawn = !1, this._currentSpawnDelay = this._spawnDelay ?? 0, this._currentEmitDelay = this._emitDelay ?? 0), this._startParticlesAdded || (this._startParticlesAdded = !0, this._emitParticles(this.options.startCount)), this._duration !== void 0 && (this._currentDuration += e.value, this._currentDuration >= this._duration && (this.pause(), this._spawnDelay !== void 0 && delete this._spawnDelay, this._immortal || this._lifeCount--, this._lifeCount > 0 || this._immortal ? (this.position = this._calcPosition(), this._spawnDelay = ze(this.options.life.delay ?? 0) * 1e3 / this.container.retina.reduceFactor) : this._destroy(), this._currentDuration -= this._duration, delete this._duration)), this._spawnDelay !== void 0 && (this._currentSpawnDelay += e.value, this._currentSpawnDelay >= this._spawnDelay && (this._engine.dispatchEvent("emitterPlay", { container: this.container }), this.play(), this._currentSpawnDelay -= this._currentSpawnDelay, delete this._spawnDelay)), this._emitDelay !== void 0 && (this._currentEmitDelay += e.value, this._currentEmitDelay >= this._emitDelay && (this._emit(), this._currentEmitDelay -= this._emitDelay))) } } class TV { constructor(e, t) { this.container = t, this._engine = e, this.array = [], this.emitters = [], this.interactivityEmitters = { random: { count: 1, enable: !1 }, value: [] }, t.getEmitter = n => n === void 0 || er(n) ? this.array[n || 0] : this.array.find(r => r.name === n), t.addEmitter = (n, r) => this.addEmitter(n, r), t.removeEmitter = n => { const r = t.getEmitter(n); r && this.removeEmitter(r) }, t.playEmitter = n => { const r = t.getEmitter(n); r && r.externalPlay() }, t.pauseEmitter = n => { const r = t.getEmitter(n); r && r.externalPause() } } addEmitter(e, t) { const n = new al; n.load(e); const r = new CV(this._engine, this, this.container, n, t); return this.array.push(r), r } handleClickMode(e) { const t = this.emitters, n = this.interactivityEmitters; if (e !== "emitter") return; let r; if (n && pi(n.value)) if (n.value.length > 0 && n.random.enable) { r = []; const a = []; for (let l = 0; l < n.random.count; l++) { const c = YD(n.value); if (a.includes(c) && a.length < n.value.length) { l--; continue } a.push(c), r.push(tm(n.value, c)) } } else r = n.value; else r = n == null ? void 0 : n.value; const s = r ?? t, o = this.container.interactivity.mouse.clickPosition; xn(s, a => { this.addEmitter(a, o) }) } async init() { if (this.emitters = this.container.actualOptions.emitters, this.interactivityEmitters = this.container.actualOptions.interactivity.modes.emitters, !!this.emitters) if (pi(this.emitters)) for (const e of this.emitters) this.addEmitter(e); else this.addEmitter(this.emitters) } pause() { for (const e of this.array) e.pause() } play() { for (const e of this.array) e.play() } removeEmitter(e) { const t = this.array.indexOf(e); t >= 0 && this.array.splice(t, 1) } resize() { for (const e of this.array) e.resize() } stop() { this.array = [] } update(e) { for (const t of this.array) t.update(e) } } const yA = new Map; class bV { constructor(e) { this._engine = e } addShape(e, t) { this.getShape(e) || yA.set(e, t) } getShape(e) { return yA.get(e) } getSupportedShapes() { return yA.keys() } } function VR(i, e) { return i + e * (Tt() - .5) } class RV { randomPosition(e, t, n) { if (n) return { x: VR(e.x, t.width), y: VR(e.y, t.height) }; { const r = t.width / 2, s = t.height / 2, o = Math.floor(Tt() * 4), a = (Tt() - .5) * 2; switch (o) { case 0: return { x: e.x + a * r, y: e.y - s }; case 1: return { x: e.x - r, y: e.y + a * s }; case 2: return { x: e.x + a * r, y: e.y + s }; case 3: default: return { x: e.x + r, y: e.y + a * s } } } } } class PV { constructor(e) { this._engine = e, this.id = "emitters" } getPlugin(e) { return new TV(this._engine, e) } loadOptions(e, t) { var r, s; if (!this.needsPlugin(e) && !this.needsPlugin(t)) return; t != null && t.emitters && (e.emitters = xn(t.emitters, o => { const a = new al; return a.load(o), a })); const n = (s = (r = t == null ? void 0 : t.interactivity) == null ? void 0 : r.modes) == null ? void 0 : s.emitters; if (n) if (pi(n)) e.interactivity.modes.emitters = { random: { count: 1, enable: !0 }, value: n.map(o => { const a = new al; return a.load(o), a }) }; else { const o = n; if (o.value !== void 0) if (pi(o.value)) e.interactivity.modes.emitters = { random: { count: o.random.count ?? 1, enable: o.random.enable ?? !1 }, value: o.value.map(a => { const l = new al; return l.load(a), l }) }; else { const a = new al; a.load(o.value), e.interactivity.modes.emitters = { random: { count: o.random.count ?? 1, enable: o.random.enable ?? !1 }, value: a } } else (e.interactivity.modes.emitters = { random: { count: 1, enable: !1 }, value: new al }).value.load(n) } } needsPlugin(e) { var n, r, s; if (!e) return !1; const t = e.emitters; return pi(t) && !!t.length || t !== void 0 || !!((s = (r = (n = e.interactivity) == null ? void 0 : n.events) == null ? void 0 : r.onClick) != null && s.mode) && _n("emitter", e.interactivity.events.onClick.mode) } } async function IV(i, e = !0) { i.emitterShapeManager || (i.emitterShapeManager = new bV(i)), i.addEmitterShape || (i.addEmitterShape = (n, r) => { var s; (s = i.emitterShapeManager) == null || s.addShape(n, r) }); const t = new PV(i); await i.addPlugin(t, e), i.addEmitterShape("circle", new wV), i.addEmitterShape("square", new RV) } class BV { constructor() { this.delay = 1, this.pauseOnStop = !1, this.quantity = 1 } load(e) { e && (e.delay !== void 0 && (this.delay = e.delay), e.quantity !== void 0 && (this.quantity = e.quantity), e.particles !== void 0 && (this.particles = Qn({}, e.particles)), e.pauseOnStop !== void 0 && (this.pauseOnStop = e.pauseOnStop)) } } class LV extends go { constructor(e) { super(e), this._delay = 0 } clear() { } init() { } async interact(e) { var c, f, d, p; const t = this.container, { interactivity: n } = t; if (!t.retina.reduceFactor) return; const r = t.actualOptions, s = r.interactivity.modes.trail; if (!s) return; const o = s.delay * 1e3 / this.container.retina.reduceFactor; if (this._delay < o && (this._delay += e.value), this._delay < o) return; const a = !(s.pauseOnStop && (n.mouse.position === this._lastPosition || ((c = n.mouse.position) == null ? void 0 : c.x) === ((f = this._lastPosition) == null ? void 0 : f.x) && ((d = n.mouse.position) == null ? void 0 : d.y) === ((p = this._lastPosition) == null ? void 0 : p.y))), l = t.interactivity.mouse.position; l ? this._lastPosition = { ...l } : delete this._lastPosition, a && t.particles.push(s.quantity, t.interactivity.mouse, s.particles), this._delay -= o } isEnabled(e) { const t = this.container, n = t.actualOptions, r = t.interactivity.mouse, s = ((e == null ? void 0 : e.interactivity) ?? n.interactivity).events; return r.clicking && r.inside && !!r.position && _n("trail", s.onClick.mode) || r.inside && !!r.position && _n("trail", s.onHover.mode) } loadModeOptions(e, ...t) { e.trail || (e.trail = new BV); for (const n of t) e.trail.load(n == null ? void 0 : n.trail) } reset() { } } async function DV(i, e = !0) { await i.addInteractor("externalTrail", t => new LV(t), e) } function OV(i) { const e = i.options.roll; if (!(e != null && e.enable)) { i.roll = { enable: !1, horizontal: !1, vertical: !1, angle: 0, speed: 0 }; return } if (i.roll = { enable: e.enable, horizontal: e.mode === "horizontal" || e.mode === "both", vertical: e.mode === "vertical" || e.mode === "both", angle: Tt() * Math.PI * 2, speed: ze(e.speed) / 360 }, e.backColor) i.backColor = kl(e.backColor); else if (e.darken.enable && e.enlighten.enable) { const t = Tt() >= .5 ? "darken" : "enlighten"; i.roll.alter = { type: t, value: ze(t === "darken" ? e.darken.value : e.enlighten.value) } } else e.darken.enable ? i.roll.alter = { type: "darken", value: ze(e.darken.value) } : e.enlighten.enable && (i.roll.alter = { type: "enlighten", value: ze(e.enlighten.value) }) } function FV(i, e) { const t = i.options.roll, n = i.roll; if (!n || !(t != null && t.enable)) return; const r = n.speed * e.factor, s = 2 * Math.PI; n.angle += r, n.angle > s && (n.angle -= s) } class WR { constructor() { this.enable = !1, this.value = 0 } load(e) { e && (e.enable !== void 0 && (this.enable = e.enable), e.value !== void 0 && (this.value = it(e.value))) } } class kV { constructor() { this.darken = new WR, this.enable = !1, this.enlighten = new WR, this.mode = "vertical", this.speed = 25 } load(e) { e && (e.backColor !== void 0 && (this.backColor = Xn.create(this.backColor, e.backColor)), this.darken.load(e.darken), e.enable !== void 0 && (this.enable = e.enable), this.enlighten.load(e.enlighten), e.mode !== void 0 && (this.mode = e.mode), e.speed !== void 0 && (this.speed = it(e.speed))) } } class NV { getTransformValues(e) { var s; const t = ((s = e.roll) == null ? void 0 : s.enable) && e.roll, n = t && t.horizontal, r = t && t.vertical; return { a: n ? Math.cos(t.angle) : void 0, d: r ? Math.sin(t.angle) : void 0 } } init(e) { OV(e) } isEnabled(e) { const t = e.options.roll; return !e.destroyed && !e.spawning && !!(t != null && t.enable) } loadOptions(e, ...t) { e.roll || (e.roll = new kV); for (const n of t) e.roll.load(n == null ? void 0 : n.roll) } update(e, t) { this.isEnabled(e) && FV(e, t) } } async function UV(i, e = !0) { await i.addParticleUpdater("roll", () => new NV, e) } class tv { static init(e) { var s; const t = new tv, n = e.selector; if (!n) throw new Error("No selector provided"); const r = document.querySelector(n); if (!r) throw new Error("No element found for selector"); return Zy.set(n.replace(".", "").replace("!", ""), r, { fullScreen: { enable: !1 }, particles: { color: { value: e.color ?? "!000000" }, links: { color: "random", distance: e.minDistance ?? 120, enable: e.connectParticles ?? !1 }, move: { enable: !0, speed: e.speed ?? .5 }, number: { value: e.maxParticles ?? 100 }, size: { value: { min: 1, max: e.sizeVariations ?? 3 } } }, responsive: (s = e.responsive) == null ? void 0 : s.map(o => { var a, l, c, f, d; return { maxWidth: o.breakpoint, options: { particles: { color: { value: (a = o.options) == null ? void 0 : a.color }, links: { distance: (l = o.options) == null ? void 0 : l.minDistance, enable: (c = o.options) == null ? void 0 : c.connectParticles }, number: { value: e.maxParticles }, move: { enable: !0, speed: (f = o.options) == null ? void 0 : f.speed }, size: { value: (d = o.options) == null ? void 0 : d.sizeVariations } } } } }) }).then(o => { t._container = o }), t } destroy() { const e = this._container; e && e.destroy() } pauseAnimation() { const e = this._container; e && e.pause() } resumeAnimation() { const e = this._container; e && e.play() } } const zV = i => { const e = (n, r) => i.load(n, r); e.load = (n, r, s) => { i.loadJSON(n, r).then(o => { o && s(o) }).catch(() => { s(void 0) }) }, e.setOnClickHandler = n => { i.setOnClickHandler(n) }; const t = i.dom(); return { particlesJS: e, pJSDom: t } }, HV = i => { const { particlesJS: e, pJSDom: t } = zV(i); return window.particlesJS = e, window.pJSDom = t, window.Particles = tv, { particlesJS: e, pJSDom: t, Particles: tv } }; function GV(i) { const e = i.initialPosition, { dx: t, dy: n } = $i(e, i.position), r = Math.abs(t), s = Math.abs(n), { maxDistance: o } = i.retina, a = o.horizontal, l = o.vertical; if (!(!a && !l)) { if ((a && r >= a || l && s >= l) && !i.misplaced) i.misplaced = !!a && r > a || !!l && s > l, a && (i.velocity.x = i.velocity.y / 2 - i.velocity.x), l && (i.velocity.y = i.velocity.x / 2 - i.velocity.y); else if ((!a || r < a) && (!l || s < l) && i.misplaced) i.misplaced = !1; else if (i.misplaced) { const c = i.position, f = i.velocity; a && (c.x < e.x && f.x < 0 || c.x > e.x && f.x > 0) && (f.x *= -Tt()), l && (c.y < e.y && f.y < 0 || c.y > e.y && f.y > 0) && (f.y *= -Tt()) } } } function VV(i, e, t, n, r, s) { XV(i, s); const o = i.gravity, a = o != null && o.enable && o.inverse ? -1 : 1; r && t && (i.velocity.x += r * s.factor / (60 * t)), o != null && o.enable && t && (i.velocity.y += a * (o.acceleration * s.factor) / (60 * t)); const l = i.moveDecay; i.velocity.multTo(l); const c = i.velocity.mult(t); o != null && o.enable && n > 0 && (!o.inverse && c.y >= 0 && c.y >= n || o.inverse && c.y <= 0 && c.y <= -n) && (c.y = a * n, t && (i.velocity.y = c.y / t)); const f = i.options.zIndex, d = (1 - i.zIndexFactor) ** f.velocityRate; c.multTo(d); const { position: p } = i; p.addTo(c), e.vibrate && (p.x += Math.sin(p.x * Math.cos(p.y)), p.y += Math.cos(p.y * Math.sin(p.x))) } function WV(i, e) { const t = i.container; if (!i.spin) return; const n = { x: i.spin.direction === "clockwise" ? Math.cos : Math.sin, y: i.spin.direction === "clockwise" ? Math.sin : Math.cos }; i.position.x = i.spin.center.x + i.spin.radius * n.x(i.spin.angle), i.position.y = i.spin.center.y + i.spin.radius * n.y(i.spin.angle), i.spin.radius += i.spin.acceleration; const r = Math.max(t.canvas.size.width, t.canvas.size.height); i.spin.radius > r / 2 ? (i.spin.radius = r / 2, i.spin.acceleration *= -1) : i.spin.radius < 0 && (i.spin.radius = 0, i.spin.acceleration *= -1), i.spin.angle += e / 100 * (1 - i.spin.radius / r) } function XV(i, e) { var o; const t = i.options, n = t.move.path; if (!n.enable) return; if (i.lastPathTime <= i.pathDelay) { i.lastPathTime += e.value; return } const s = (o = i.pathGenerator) == null ? void 0 : o.generate(i, e); s && i.velocity.addTo(s), n.clamp && (i.velocity.x = fo(i.velocity.x, -1, 1), i.velocity.y = fo(i.velocity.y, -1, 1)), i.lastPathTime -= i.pathDelay } function JV(i) { return i.slow.inRange ? i.slow.factor : 1 } const YV = 2; class jV { constructor() { this._initSpin = e => { const t = e.container, n = e.options, r = n.move.spin; if (!r.enable) return; const s = r.position ?? { x: 50, y: 50 }, o = { x: s.x / 100 * t.canvas.size.width, y: s.y / 100 * t.canvas.size.height }, a = e.getPosition(), l = vr(a, o), c = ze(r.acceleration); e.retina.spinAcceleration = c * t.retina.pixelRatio, e.spin = { center: o, direction: e.velocity.x >= 0 ? "clockwise" : "counter-clockwise", angle: e.velocity.angle, radius: l, acceleration: e.retina.spinAcceleration } } } init(e) { const t = e.options, n = t.move.gravity; e.gravity = { enable: n.enable, acceleration: ze(n.acceleration), inverse: n.inverse }, this._initSpin(e) } isEnabled(e) { return !e.destroyed && e.options.move.enable } move(e, t) { var y, _; const n = e.options, r = n.move; if (!r.enable) return; const s = e.container, o = s.retina.pixelRatio, a = JV(e), l = ((y = e.retina).moveSpeed ?? (y.moveSpeed = ze(r.speed) * o)) * s.retina.reduceFactor, c = (_ = e.retina).moveDrift ?? (_.moveDrift = ze(e.options.move.drift) * o), f = ml(n.size.value) * o, d = r.size ? e.getRadius() / f : 1, p = l * d * a * (t.factor || 1) / YV, m = e.retina.maxSpeed ?? s.retina.maxSpeed; r.spin.enable ? WV(e, p) : VV(e, r, p, m, c, t), GV(e) } } async function KV(i, e = !0) { await i.addMover("base", () => new jV, e) } class qV { draw(e, t, n) { t.circleRange || (t.circleRange = { min: 0, max: Math.PI * 2 }); const r = t.circleRange; e.arc(0, 0, n, r.min, r.max, !1) } getSidesCount() { return 12 } particleInit(e, t) { const n = t.shapeData, r = (n == null ? void 0 : n.angle) ?? { max: 360, min: 0 }; t.circleRange = bf(r) ? { min: r.min * Math.PI / 180, max: r.max * Math.PI / 180 } : { min: 0, max: r * Math.PI / 180 } } } async function QV(i, e = !0) { await i.addShape("circle", new qV, e) } function vA(i, e, t, n, r) { if (!e || !t.enable || (e.maxLoops ?? 0) > 0 && (e.loops ?? 0) > (e.maxLoops ?? 0) || (e.time || (e.time = 0), (e.delayTime ?? 0) > 0 && e.time < (e.delayTime ?? 0) && (e.time += i.value), (e.delayTime ?? 0) > 0 && e.time < (e.delayTime ?? 0))) return; const s = Si(t.offset), o = (e.velocity ?? 0) * i.factor + s * 3.6, a = e.decay ?? 1; !r || e.status === "increasing" ? (e.value += o, e.value > n && (e.loops || (e.loops = 0), e.loops++, r && (e.status = "decreasing", e.value -= e.value % n))) : (e.value -= o, e.value < 0 && (e.loops || (e.loops = 0), e.loops++, e.status = "increasing", e.value += e.value)), e.velocity && a !== 1 && (e.velocity *= a), e.value > n && (e.value %= n) } function ZV(i, e) { const { h: t, s: n, l: r } = i.options.color.animation, { color: s } = i; if (!s) return; const { h: o, s: a, l } = s; o && vA(e, o, t, 360, !1), a && vA(e, a, n, 100, !0), l && vA(e, l, r, 100, !0) } class $V { constructor(e) { this.container = e } init(e) { const t = kl(e.options.color, e.id, e.options.reduceDuplicates); t && (e.color = sO(t, e.options.color.animation, this.container.retina.reduceFactor)) } isEnabled(e) { const { h: t, s: n, l: r } = e.options.color.animation, { color: s } = e; return !e.destroyed && !e.spawning && ((s == null ? void 0 : s.h.value) !== void 0 && t.enable || (s == null ? void 0 : s.s.value) !== void 0 && n.enable || (s == null ? void 0 : s.l.value) !== void 0 && r.enable) } update(e, t) { ZV(e, t) } } async function e5(i, e = !0) { await i.addParticleUpdater("color", t => new $V(t), e) } function t5(i, e, t, n) { switch (i.options.opacity.animation.destroy) { case "max": e >= n && i.destroy(); break; case "min": e <= t && i.destroy(); break } } function n5(i, e) { const t = i.opacity; if (i.destroyed || !(t != null && t.enable) || (t.maxLoops ?? 0) > 0 && (t.loops ?? 0) > (t.maxLoops ?? 0)) return; const n = t.min, r = t.max, s = t.decay ?? 1; if (t.time || (t.time = 0), (t.delayTime ?? 0) > 0 && t.time < (t.delayTime ?? 0) && (t.time += e.value), !((t.delayTime ?? 0) > 0 && t.time < (t.delayTime ?? 0))) { switch (t.status) { case "increasing": t.value >= r ? (t.status = "decreasing", t.loops || (t.loops = 0), t.loops++) : t.value += (t.velocity ?? 0) * e.factor; break; case "decreasing": t.value <= n ? (t.status = "increasing", t.loops || (t.loops = 0), t.loops++) : t.value -= (t.velocity ?? 0) * e.factor; break }t.velocity && t.decay !== 1 && (t.velocity *= s), t5(i, t.value, n, r), i.destroyed || (t.value = fo(t.value, n, r)) } } class i5 { constructor(e) { this.container = e } init(e) { const t = e.options.opacity; e.opacity = QD(t, 1); const n = t.animation; n.enable && (e.opacity.velocity = ze(n.speed) / 100 * this.container.retina.reduceFactor, n.sync || (e.opacity.velocity *= Tt())) } isEnabled(e) { return !e.destroyed && !e.spawning && !!e.opacity && e.opacity.enable && ((e.opacity.maxLoops ?? 0) <= 0 || (e.opacity.maxLoops ?? 0) > 0 && (e.opacity.loops ?? 0) < (e.opacity.maxLoops ?? 0)) } reset(e) { e.opacity && (e.opacity.time = 0, e.opacity.loops = 0) } update(e, t) { this.isEnabled(e) && n5(e, t) } } async function r5(i, e = !0) { await i.addParticleUpdater("opacity", t => new i5(t), e) } function s5(i) { if (i.outMode !== "bounce" && i.outMode !== "bounce-horizontal" && i.outMode !== "bounceHorizontal" && i.outMode !== "split" || i.direction !== "left" && i.direction !== "right") return; i.bounds.right < 0 && i.direction === "left" ? i.particle.position.x = i.size + i.offset.x : i.bounds.left > i.canvasSize.width && i.direction === "right" && (i.particle.position.x = i.canvasSize.width - i.size - i.offset.x); const e = i.particle.velocity.x; let t = !1; if (i.direction === "right" && i.bounds.right >= i.canvasSize.width && e > 0 || i.direction === "left" && i.bounds.left <= 0 && e < 0) { const r = La(i.particle.options.bounce.horizontal); i.particle.velocity.x *= -r, t = !0 } if (!t) return; const n = i.offset.x + i.size; i.bounds.right >= i.canvasSize.width && i.direction === "right" ? i.particle.position.x = i.canvasSize.width - n : i.bounds.left <= 0 && i.direction === "left" && (i.particle.position.x = n), i.outMode === "split" && i.particle.destroy() } function o5(i) { if (i.outMode !== "bounce" && i.outMode !== "bounce-vertical" && i.outMode !== "bounceVertical" && i.outMode !== "split" || i.direction !== "bottom" && i.direction !== "top") return; i.bounds.bottom < 0 && i.direction === "top" ? i.particle.position.y = i.size + i.offset.y : i.bounds.top > i.canvasSize.height && i.direction === "bottom" && (i.particle.position.y = i.canvasSize.height - i.size - i.offset.y); const e = i.particle.velocity.y; let t = !1; if (i.direction === "bottom" && i.bounds.bottom >= i.canvasSize.height && e > 0 || i.direction === "top" && i.bounds.top <= 0 && e < 0) { const r = La(i.particle.options.bounce.vertical); i.particle.velocity.y *= -r, t = !0 } if (!t) return; const n = i.offset.y + i.size; i.bounds.bottom >= i.canvasSize.height && i.direction === "bottom" ? i.particle.position.y = i.canvasSize.height - n : i.bounds.top <= 0 && i.direction === "top" && (i.particle.position.y = n), i.outMode === "split" && i.particle.destroy() } class a5 { constructor(e) { this.container = e, this.modes = ["bounce", "bounce-vertical", "bounce-horizontal", "bounceVertical", "bounceHorizontal", "split"] } update(e, t, n, r) { if (!this.modes.includes(r)) return; const s = this.container; let o = !1; for (const [, p] of s.plugins) if (p.particleBounce !== void 0 && (o = p.particleBounce(e, n, t)), o) break; if (o) return; const a = e.getPosition(), l = e.offset, c = e.getRadius(), f = im(a, c), d = s.canvas.size; s5({ particle: e, outMode: r, direction: t, bounds: f, canvasSize: d, offset: l, size: c }), o5({ particle: e, outMode: r, direction: t, bounds: f, canvasSize: d, offset: l, size: c }) } } class l5 { constructor(e) { this.container = e, this.modes = ["destroy"] } update(e, t, n, r) { if (!this.modes.includes(r)) return; const s = this.container; switch (e.outType) { case "normal": case "outside": if (nm(e.position, s.canvas.size, dn.origin, e.getRadius(), t)) return; break; case "inside": { const { dx: o, dy: a } = $i(e.position, e.moveCenter), { x: l, y: c } = e.velocity; if (l < 0 && o > e.moveCenter.radius || c < 0 && a > e.moveCenter.radius || l >= 0 && o < -e.moveCenter.radius || c >= 0 && a < -e.moveCenter.radius) return; break } }s.particles.remove(e, void 0, !0) } } class c5 { constructor(e) { this.container = e, this.modes = ["none"] } update(e, t, n, r) { if (!this.modes.includes(r) || e.options.move.distance.horizontal && (t === "left" || t === "right") || e.options.move.distance.vertical && (t === "top" || t === "bottom")) return; const s = e.options.move.gravity, o = this.container, a = o.canvas.size, l = e.getRadius(); if (s.enable) { const c = e.position; (!s.inverse && c.y > a.height + l && t === "bottom" || s.inverse && c.y < -l && t === "top") && o.particles.remove(e) } else { if (e.velocity.y > 0 && e.position.y <= a.height + l || e.velocity.y < 0 && e.position.y >= -l || e.velocity.x > 0 && e.position.x <= a.width + l || e.velocity.x < 0 && e.position.x >= -l) return; nm(e.position, o.canvas.size, dn.origin, l, t) || o.particles.remove(e) } } } class u5 { constructor(e) { this.container = e, this.modes = ["out"] } update(e, t, n, r) { if (!this.modes.includes(r)) return; const s = this.container; switch (e.outType) { case "inside": { const { x: o, y: a } = e.velocity, l = dn.origin; l.length = e.moveCenter.radius, l.angle = e.velocity.angle + Math.PI, l.addTo(dn.create(e.moveCenter)); const { dx: c, dy: f } = $i(e.position, l); if (o <= 0 && c >= 0 || a <= 0 && f >= 0 || o >= 0 && c <= 0 || a >= 0 && f <= 0) return; e.position.x = Math.floor(Si({ min: 0, max: s.canvas.size.width })), e.position.y = Math.floor(Si({ min: 0, max: s.canvas.size.height })); const { dx: d, dy: p } = $i(e.position, e.moveCenter); e.direction = Math.atan2(-p, -d), e.velocity.angle = e.direction; break } default: { if (nm(e.position, s.canvas.size, dn.origin, e.getRadius(), t)) return; switch (e.outType) { case "outside": { e.position.x = Math.floor(Si({ min: -e.moveCenter.radius, max: e.moveCenter.radius })) + e.moveCenter.x, e.position.y = Math.floor(Si({ min: -e.moveCenter.radius, max: e.moveCenter.radius })) + e.moveCenter.y; const { dx: o, dy: a } = $i(e.position, e.moveCenter); e.moveCenter.radius && (e.direction = Math.atan2(a, o), e.velocity.angle = e.direction); break } case "normal": { const o = e.options.move.warp, a = s.canvas.size, l = { bottom: a.height + e.getRadius() + e.offset.y, left: -e.getRadius() - e.offset.x, right: a.width + e.getRadius() + e.offset.x, top: -e.getRadius() - e.offset.y }, c = e.getRadius(), f = im(e.position, c); t === "right" && f.left > a.width + e.offset.x ? (e.position.x = l.left, e.initialPosition.x = e.position.x, o || (e.position.y = Tt() * a.height, e.initialPosition.y = e.position.y)) : t === "left" && f.right < -e.offset.x && (e.position.x = l.right, e.initialPosition.x = e.position.x, o || (e.position.y = Tt() * a.height, e.initialPosition.y = e.position.y)), t === "bottom" && f.top > a.height + e.offset.y ? (o || (e.position.x = Tt() * a.width, e.initialPosition.x = e.position.x), e.position.y = l.top, e.initialPosition.y = e.position.y) : t === "top" && f.bottom < -e.offset.y && (o || (e.position.x = Tt() * a.width, e.initialPosition.x = e.position.x), e.position.y = l.bottom, e.initialPosition.y = e.position.y); break } }break } } } } class f5 { constructor(e) { this.container = e, this._updateOutMode = (t, n, r, s) => { for (const o of this.updaters) o.update(t, s, n, r) }, this.updaters = [new a5(e), new l5(e), new u5(e), new c5(e)] } init() { } isEnabled(e) { return !e.destroyed && !e.spawning } update(e, t) { const n = e.options.move.outModes; this._updateOutMode(e, t, n.bottom ?? n.default, "bottom"), this._updateOutMode(e, t, n.left ?? n.default, "left"), this._updateOutMode(e, t, n.right ?? n.default, "right"), this._updateOutMode(e, t, n.top ?? n.default, "top") } } async function h5(i, e = !0) { await i.addParticleUpdater("outModes", t => new f5(t), e) } function d5(i, e, t, n) { switch (i.options.size.animation.destroy) { case "max": e >= n && i.destroy(); break; case "min": e <= t && i.destroy(); break } } function p5(i, e) { const t = i.size; if (i.destroyed || !t || !t.enable || (t.maxLoops ?? 0) > 0 && (t.loops ?? 0) > (t.maxLoops ?? 0)) return; const n = (t.velocity ?? 0) * e.factor, r = t.min, s = t.max, o = t.decay ?? 1; if (t.time || (t.time = 0), (t.delayTime ?? 0) > 0 && t.time < (t.delayTime ?? 0) && (t.time += e.value), !((t.delayTime ?? 0) > 0 && t.time < (t.delayTime ?? 0))) { switch (t.status) { case "increasing": t.value >= s ? (t.status = "decreasing", t.loops || (t.loops = 0), t.loops++) : t.value += n; break; case "decreasing": t.value <= r ? (t.status = "increasing", t.loops || (t.loops = 0), t.loops++) : t.value -= n }t.velocity && o !== 1 && (t.velocity *= o), d5(i, t.value, r, s), i.destroyed || (t.value = fo(t.value, r, s)) } } class m5 { init(e) { const t = e.container, n = e.options.size, r = n.animation; r.enable && (e.size.velocity = (e.retina.sizeAnimationSpeed ?? t.retina.sizeAnimationSpeed) / 100 * t.retina.reduceFactor, r.sync || (e.size.velocity *= Tt())) } isEnabled(e) { return !e.destroyed && !e.spawning && e.size.enable && ((e.size.maxLoops ?? 0) <= 0 || (e.size.maxLoops ?? 0) > 0 && (e.size.loops ?? 0) < (e.size.maxLoops ?? 0)) } reset(e) { e.size.loops = 0 } update(e, t) { this.isEnabled(e) && p5(e, t) } } async function g5(i, e = !0) { await i.addParticleUpdater("size", () => new m5, e) } async function y5(i, e = !0) { await KV(i, !1), await QV(i, !1), await e5(i, !1), await r5(i, !1), await h5(i, !1), await g5(i, !1), await i.refresh(e) } async function v5() { rA("ease-in-quad", i => i ** 2), rA("ease-out-quad", i => 1 - (1 - i) ** 2), rA("ease-in-out-quad", i => i < .5 ? 2 * i ** 2 : 1 - (-2 * i + 2) ** 2 / 2) } class _5 { constructor() { this.distance = 200, this.duration = .4, this.easing = "ease-out-quad", this.factor = 1, this.maxSpeed = 50, this.speed = 1 } load(e) { e && (e.distance !== void 0 && (this.distance = e.distance), e.duration !== void 0 && (this.duration = e.duration), e.easing !== void 0 && (this.easing = e.easing), e.factor !== void 0 && (this.factor = e.factor), e.maxSpeed !== void 0 && (this.maxSpeed = e.maxSpeed), e.speed !== void 0 && (this.speed = e.speed)) } } let x5 = class extends go { constructor(e, t) { super(t), this._clickAttract = () => { const n = this.container; n.attract || (n.attract = { particles: [] }); const { attract: r } = n; if (r.finish || (r.count || (r.count = 0), r.count++, r.count === n.particles.count && (r.finish = !0)), r.clicking) { const s = n.interactivity.mouse.clickPosition, o = n.retina.attractModeDistance; if (!o || o < 0 || !s) return; this._processAttract(s, o, new tr(s.x, s.y, o)) } else r.clicking === !1 && (r.particles = []) }, this._hoverAttract = () => { const n = this.container, r = n.interactivity.mouse.position, s = n.retina.attractModeDistance; !s || s < 0 || !r || this._processAttract(r, s, new tr(r.x, r.y, s)) }, this._processAttract = (n, r, s) => { const o = this.container, a = o.actualOptions.interactivity.modes.attract; if (!a) return; const l = o.particles.quadTree.query(s, c => this.isEnabled(c)); for (const c of l) { const { dx: f, dy: d, distance: p } = $i(c.position, n), m = a.speed * a.factor, y = fo(GD(a.easing)(1 - p / r) * m, 0, a.maxSpeed), _ = dn.create(p === 0 ? m : f / p * y, p === 0 ? m : d / p * y); c.position.subFrom(_) } }, this._engine = e, t.attract || (t.attract = { particles: [] }), this.handleClickMode = n => { const r = this.container.actualOptions, s = r.interactivity.modes.attract; if (!(!s || n !== "attract")) { t.attract || (t.attract = { particles: [] }), t.attract.clicking = !0, t.attract.count = 0; for (const o of t.attract.particles) this.isEnabled(o) && o.velocity.setTo(o.initialVelocity); t.attract.particles = [], t.attract.finish = !1, setTimeout(() => { t.destroyed || (t.attract || (t.attract = { particles: [] }), t.attract.clicking = !1) }, s.duration * 1e3) } } } clear() { } init() { const e = this.container, t = e.actualOptions.interactivity.modes.attract; t && (e.retina.attractModeDistance = t.distance * e.retina.pixelRatio) } async interact() { const e = this.container, t = e.actualOptions, n = e.interactivity.status === su, r = t.interactivity.events, s = r.onHover.enable, o = r.onHover.mode, a = r.onClick.enable, l = r.onClick.mode; n && s && _n("attract", o) ? this._hoverAttract() : a && _n("attract", l) && this._clickAttract() } isEnabled(e) { const t = this.container, n = t.actualOptions, r = t.interactivity.mouse, s = ((e == null ? void 0 : e.interactivity) ?? n.interactivity).events; if ((!r.position || !s.onHover.enable) && (!r.clickPosition || !s.onClick.enable)) return !1; const o = s.onHover.mode, a = s.onClick.mode; return _n("attract", o) || _n("attract", a) } loadModeOptions(e, ...t) { e.attract || (e.attract = new _5); for (const n of t) e.attract.load(n == null ? void 0 : n.attract) } reset() { } }; async function A5(i, e = !0) { await i.addInteractor("externalAttract", t => new x5(i, t), e) } class M5 { constructor() { this.distance = 200 } load(e) { e && e.distance !== void 0 && (this.distance = e.distance) } } class w5 extends go { constructor(e) { super(e), this._processBounce = (t, n, r) => { const s = this.container.particles.quadTree.query(r, o => this.isEnabled(o)); for (const o of s) r instanceof tr ? KD(zw(o), { position: t, radius: n, mass: n ** 2 * Math.PI / 2, velocity: dn.origin, factor: dn.origin }) : r instanceof ho && HG(o, im(t, n)) }, this._processMouseBounce = () => { const t = this.container, n = t.retina.pixelRatio, r = 10 * n, s = t.interactivity.mouse.position, o = t.retina.bounceModeDistance; !o || o < 0 || !s || this._processBounce(s, o, new tr(s.x, s.y, o + r)) }, this._singleSelectorBounce = (t, n) => { const r = this.container, s = document.querySelectorAll(t); s.length && s.forEach(o => { const a = o, l = r.retina.pixelRatio, c = { x: (a.offsetLeft + a.offsetWidth / 2) * l, y: (a.offsetTop + a.offsetHeight / 2) * l }, f = a.offsetWidth / 2 * l, d = 10 * l, p = n.type === "circle" ? new tr(c.x, c.y, f + d) : new ho(a.offsetLeft * l - d, a.offsetTop * l - d, a.offsetWidth * l + d * 2, a.offsetHeight * l + d * 2); this._processBounce(c, f, p) }) } } clear() { } init() { const e = this.container, t = e.actualOptions.interactivity.modes.bounce; t && (e.retina.bounceModeDistance = t.distance * e.retina.pixelRatio) } async interact() { const e = this.container, t = e.actualOptions, n = t.interactivity.events, r = e.interactivity.status === su, s = n.onHover.enable, o = n.onHover.mode, a = n.onDiv; r && s && _n("bounce", o) ? this._processMouseBounce() : iE("bounce", a, (l, c) => this._singleSelectorBounce(l, c)) } isEnabled(e) { const t = this.container, n = t.actualOptions, r = t.interactivity.mouse, s = ((e == null ? void 0 : e.interactivity) ?? n.interactivity).events, o = s.onDiv; return r.position && s.onHover.enable && _n("bounce", s.onHover.mode) || nE("bounce", o) } loadModeOptions(e, ...t) { e.bounce || (e.bounce = new M5); for (const n of t) e.bounce.load(n == null ? void 0 : n.bounce) } reset() { } } async function S5(i, e = !0) { await i.addInteractor("externalBounce", t => new w5(t), e) } class gO { constructor() { this.distance = 200, this.duration = .4, this.mix = !1 } load(e) { if (e) { if (e.distance !== void 0 && (this.distance = e.distance), e.duration !== void 0 && (this.duration = e.duration), e.mix !== void 0 && (this.mix = e.mix), e.opacity !== void 0 && (this.opacity = e.opacity), e.color !== void 0) { const t = pi(this.color) ? void 0 : this.color; this.color = xn(e.color, n => Xn.create(t, n)) } e.size !== void 0 && (this.size = e.size) } } } class E5 extends gO { constructor() { super(), this.selectors = [] } get ids() { return xn(this.selectors, e => e.replace("#", "")) } set ids(e) { this.selectors = xn(e, t => `#${t}`) } load(e) { super.load(e), e && (e.ids !== void 0 && (this.ids = e.ids), e.selectors !== void 0 && (this.selectors = e.selectors)) } } class C5 extends gO { load(e) { super.load(e), e && (this.divs = xn(e.divs, t => { const n = new E5; return n.load(t), n })) } } function XR(i, e, t, n) { if (e >= t) { const r = i + (e - t) * n; return fo(r, i, e) } else if (e < t) { const r = i - (t - e) * n; return fo(r, e, i) } } class T5 extends go { constructor(e) { super(e), this._clickBubble = () => { var c; const t = this.container, n = t.actualOptions, r = t.interactivity.mouse.clickPosition, s = n.interactivity.modes.bubble; if (!s || !r) return; t.bubble || (t.bubble = {}); const o = t.retina.bubbleModeDistance; if (!o || o < 0) return; const a = t.particles.quadTree.queryCircle(r, o, f => this.isEnabled(f)), { bubble: l } = t; for (const f of a) { if (!l.clicking) continue; f.bubble.inRange = !l.durationEnd; const d = f.getPosition(), p = vr(d, r), m = (new Date().getTime() - (t.interactivity.mouse.clickTime || 0)) / 1e3; m > s.duration && (l.durationEnd = !0), m > s.duration * 2 && (l.clicking = !1, l.durationEnd = !1); const y = { bubbleObj: { optValue: t.retina.bubbleModeSize, value: f.bubble.radius }, particlesObj: { optValue: ml(f.options.size.value) * t.retina.pixelRatio, value: f.size.value }, type: "size" }; this._process(f, p, m, y); const _ = { bubbleObj: { optValue: s.opacity, value: f.bubble.opacity }, particlesObj: { optValue: ml(f.options.opacity.value), value: ((c = f.opacity) == null ? void 0 : c.value) ?? 1 }, type: "opacity" }; this._process(f, p, m, _), !l.durationEnd && p <= o ? this._hoverBubbleColor(f, p) : delete f.bubble.color } }, this._hoverBubble = () => { const t = this.container, n = t.interactivity.mouse.position, r = t.retina.bubbleModeDistance; if (!r || r < 0 || n === void 0) return; const s = t.particles.quadTree.queryCircle(n, r, o => this.isEnabled(o)); for (const o of s) { o.bubble.inRange = !0; const a = o.getPosition(), l = vr(a, n), c = 1 - l / r; l <= r ? c >= 0 && t.interactivity.status === su && (this._hoverBubbleSize(o, c), this._hoverBubbleOpacity(o, c), this._hoverBubbleColor(o, c)) : this.reset(o), t.interactivity.status === Nw && this.reset(o) } }, this._hoverBubbleColor = (t, n, r) => { const s = this.container.actualOptions, o = r ?? s.interactivity.modes.bubble; if (o) { if (!t.bubble.finalColor) { const a = o.color; if (!a) return; const l = rs(a); t.bubble.finalColor = kl(l) } if (t.bubble.finalColor) if (o.mix) { t.bubble.color = void 0; const a = t.getFillColor(); t.bubble.color = a ? nO(rE(a, t.bubble.finalColor, 1 - n, n)) : t.bubble.finalColor } else t.bubble.color = t.bubble.finalColor } }, this._hoverBubbleOpacity = (t, n, r) => { var d, p; const s = this.container, o = s.actualOptions, a = (r == null ? void 0 : r.opacity) ?? ((d = o.interactivity.modes.bubble) == null ? void 0 : d.opacity); if (!a) return; const l = t.options.opacity.value, c = ((p = t.opacity) == null ? void 0 : p.value) ?? 1, f = XR(c, a, ml(l), n); f !== void 0 && (t.bubble.opacity = f) }, this._hoverBubbleSize = (t, n, r) => { const s = this.container, o = r != null && r.size ? r.size * s.retina.pixelRatio : s.retina.bubbleModeSize; if (o === void 0) return; const a = ml(t.options.size.value) * s.retina.pixelRatio, l = t.size.value, c = XR(l, o, a, n); c !== void 0 && (t.bubble.radius = c) }, this._process = (t, n, r, s) => { const o = this.container, a = s.bubbleObj.optValue, l = o.actualOptions, c = l.interactivity.modes.bubble; if (!c || a === void 0) return; const f = c.duration, d = o.retina.bubbleModeDistance, p = s.particlesObj.optValue, m = s.bubbleObj.value, y = s.particlesObj.value || 0, _ = s.type; if (!(!d || d < 0 || a === p)) if (o.bubble || (o.bubble = {}), o.bubble.durationEnd) m && (_ === "size" && delete t.bubble.radius, _ === "opacity" && delete t.bubble.opacity); else if (n <= d) { if ((m ?? y) !== a) { const g = y - r * (y - a) / f; _ === "size" && (t.bubble.radius = g), _ === "opacity" && (t.bubble.opacity = g) } } else _ === "size" && delete t.bubble.radius, _ === "opacity" && delete t.bubble.opacity }, this._singleSelectorHover = (t, n, r) => { const s = this.container, o = document.querySelectorAll(n), a = s.actualOptions.interactivity.modes.bubble; !a || !o.length || o.forEach(l => { const c = l, f = s.retina.pixelRatio, d = { x: (c.offsetLeft + c.offsetWidth / 2) * f, y: (c.offsetTop + c.offsetHeight / 2) * f }, p = c.offsetWidth / 2 * f, m = r.type === "circle" ? new tr(d.x, d.y, p) : new ho(c.offsetLeft * f, c.offsetTop * f, c.offsetWidth * f, c.offsetHeight * f), y = s.particles.quadTree.query(m, _ => this.isEnabled(_)); for (const _ of y) { if (!m.contains(_.getPosition())) continue; _.bubble.inRange = !0; const x = a.divs, g = jD(x, c); (!_.bubble.div || _.bubble.div !== c) && (this.clear(_, t, !0), _.bubble.div = c), this._hoverBubbleSize(_, 1, g), this._hoverBubbleOpacity(_, 1, g), this._hoverBubbleColor(_, 1, g) } }) }, e.bubble || (e.bubble = {}), this.handleClickMode = t => { t === "bubble" && (e.bubble || (e.bubble = {}), e.bubble.clicking = !0) } } clear(e, t, n) { e.bubble.inRange && !n || (delete e.bubble.div, delete e.bubble.opacity, delete e.bubble.radius, delete e.bubble.color) } init() { const e = this.container, t = e.actualOptions.interactivity.modes.bubble; t && (e.retina.bubbleModeDistance = t.distance * e.retina.pixelRatio, t.size !== void 0 && (e.retina.bubbleModeSize = t.size * e.retina.pixelRatio)) } async interact(e) { const t = this.container.actualOptions, n = t.interactivity.events, r = n.onHover, s = n.onClick, o = r.enable, a = r.mode, l = s.enable, c = s.mode, f = n.onDiv; o && _n("bubble", a) ? this._hoverBubble() : l && _n("bubble", c) ? this._clickBubble() : iE("bubble", f, (d, p) => this._singleSelectorHover(e, d, p)) } isEnabled(e) { const t = this.container, n = t.actualOptions, r = t.interactivity.mouse, s = ((e == null ? void 0 : e.interactivity) ?? n.interactivity).events, { onClick: o, onDiv: a, onHover: l } = s, c = nE("bubble", a); return c || l.enable && r.position || o.enable && r.clickPosition ? _n("bubble", l.mode) || _n("bubble", o.mode) || c : !1 } loadModeOptions(e, ...t) { e.bubble || (e.bubble = new C5); for (const n of t) e.bubble.load(n == null ? void 0 : n.bubble) } reset(e) { e.bubble.inRange = !1 } } async function b5(i, e = !0) { await i.addInteractor("externalBubble", t => new T5(t), e) } class R5 { constructor() { this.opacity = .5 } load(e) { e && e.opacity !== void 0 && (this.opacity = e.opacity) } } class P5 { constructor() { this.distance = 80, this.links = new R5, this.radius = 60 } get lineLinked() { return this.links } set lineLinked(e) { this.links = e } get line_linked() { return this.links } set line_linked(e) { this.links = e } load(e) { e && (e.distance !== void 0 && (this.distance = e.distance), this.links.load(e.links ?? e.lineLinked ?? e.line_linked), e.radius !== void 0 && (this.radius = e.radius)) } } function I5(i, e, t, n) { const r = Math.floor(t.getRadius() / e.getRadius()), s = e.getFillColor(), o = t.getFillColor(); if (!s || !o) return; const a = e.getPosition(), l = t.getPosition(), c = rE(s, o, e.getRadius(), t.getRadius()), f = i.createLinearGradient(a.x, a.y, l.x, l.y); return f.addColorStop(0, dh(s, n)), f.addColorStop(r > 1 ? 1 : r, zo(c, n)), f.addColorStop(1, dh(o, n)), f } function B5(i, e, t, n, r) { ip(i, n, r), i.lineWidth = e, i.strokeStyle = t, i.stroke() } function L5(i, e, t, n) { const r = i.actualOptions, s = r.interactivity.modes.connect; if (s) return I5(e, t, n, s.links.opacity) } function D5(i, e, t) { i.canvas.draw(n => { const r = L5(i, n, e, t); if (!r) return; const s = e.getPosition(), o = t.getPosition(); B5(n, e.retina.linksWidth ?? 0, r, s, o) }) } class O5 extends go { constructor(e) { super(e) } clear() { } init() { const e = this.container, t = e.actualOptions.interactivity.modes.connect; t && (e.retina.connectModeDistance = t.distance * e.retina.pixelRatio, e.retina.connectModeRadius = t.radius * e.retina.pixelRatio) } async interact() { const e = this.container; if (e.actualOptions.interactivity.events.onHover.enable && e.interactivity.status === "pointermove") { const n = e.interactivity.mouse.position; if (!e.retina.connectModeDistance || e.retina.connectModeDistance < 0 || !e.retina.connectModeRadius || e.retina.connectModeRadius < 0 || !n) return; const r = Math.abs(e.retina.connectModeRadius), s = e.particles.quadTree.queryCircle(n, r, a => this.isEnabled(a)); let o = 0; for (const a of s) { const l = a.getPosition(); for (const c of s.slice(o + 1)) { const f = c.getPosition(), d = Math.abs(e.retina.connectModeDistance), p = Math.abs(l.x - f.x), m = Math.abs(l.y - f.y); p < d && m < d && D5(e, a, c) } ++o } } } isEnabled(e) { const t = this.container, n = t.interactivity.mouse, r = ((e == null ? void 0 : e.interactivity) ?? t.actualOptions.interactivity).events; return r.onHover.enable && n.position ? _n("connect", r.onHover.mode) : !1 } loadModeOptions(e, ...t) { e.connect || (e.connect = new P5); for (const n of t) e.connect.load(n == null ? void 0 : n.connect) } reset() { } } async function F5(i, e = !0) { await i.addInteractor("externalConnect", t => new O5(t), e) } class k5 { constructor() { this.blink = !1, this.consent = !1, this.opacity = 1 } load(e) { e && (e.blink !== void 0 && (this.blink = e.blink), e.color !== void 0 && (this.color = Xn.create(this.color, e.color)), e.consent !== void 0 && (this.consent = e.consent), e.opacity !== void 0 && (this.opacity = e.opacity)) } } class N5 { constructor() { this.distance = 100, this.links = new k5 } get lineLinked() { return this.links } set lineLinked(e) { this.links = e } get line_linked() { return this.links } set line_linked(e) { this.links = e } load(e) { e && (e.distance !== void 0 && (this.distance = e.distance), this.links.load(e.links ?? e.lineLinked ?? e.line_linked)) } } function U5(i, e, t, n, r, s) { ip(i, t, n), i.strokeStyle = zo(r, s), i.lineWidth = e, i.stroke() } function z5(i, e, t, n, r) { i.canvas.draw(s => { const o = e.getPosition(); U5(s, e.retina.linksWidth ?? 0, o, r, t, n) }) } class H5 extends go { constructor(e) { super(e) } clear() { } init() { const e = this.container, t = e.actualOptions.interactivity.modes.grab; t && (e.retina.grabModeDistance = t.distance * e.retina.pixelRatio) } async interact() { var a; const e = this.container, t = e.actualOptions, n = t.interactivity; if (!n.modes.grab || !n.events.onHover.enable || e.interactivity.status !== su) return; const r = e.interactivity.mouse.position; if (!r) return; const s = e.retina.grabModeDistance; if (!s || s < 0) return; const o = e.particles.quadTree.queryCircle(r, s, l => this.isEnabled(l)); for (const l of o) { const c = l.getPosition(), f = vr(c, r); if (f > s) continue; const d = n.modes.grab.links, p = d.opacity, m = p - f * p / s; if (m <= 0) continue; const y = d.color ?? ((a = l.options.links) == null ? void 0 : a.color); if (!e.particles.grabLineColor && y) { const x = n.modes.grab.links; e.particles.grabLineColor = rO(y, x.blink, x.consent) } const _ = Hw(l, void 0, e.particles.grabLineColor); _ && z5(e, l, _, m, r) } } isEnabled(e) { const t = this.container, n = t.interactivity.mouse, r = ((e == null ? void 0 : e.interactivity) ?? t.actualOptions.interactivity).events; return r.onHover.enable && !!n.position && _n("grab", r.onHover.mode) } loadModeOptions(e, ...t) { e.grab || (e.grab = new N5); for (const n of t) e.grab.load(n == null ? void 0 : n.grab) } reset() { } } async function G5(i, e = !0) { await i.addInteractor("externalGrab", t => new H5(t), e) } class V5 extends go { constructor(e) { super(e), this.handleClickMode = t => { if (t !== "pause") return; const n = this.container; n.getAnimationStatus() ? n.pause() : n.play() } } clear() { } init() { } async interact() { } isEnabled() { return !0 } reset() { } } async function W5(i, e = !0) { await i.addInteractor("externalPause", t => new V5(t), e) } class X5 { constructor() { this.default = !0, this.groups = [], this.quantity = 4 } get particles_nb() { return this.quantity } set particles_nb(e) { this.quantity = it(e) } load(e) { if (!e) return; e.default !== void 0 && (this.default = e.default), e.groups !== void 0 && (this.groups = e.groups.map(n => n)), this.groups.length || (this.default = !0); const t = e.quantity ?? e.particles_nb; t !== void 0 && (this.quantity = it(t)) } } class J5 extends go { constructor(e) { super(e), this.handleClickMode = t => { if (t !== "push") return; const n = this.container, r = n.actualOptions, s = r.interactivity.modes.push; if (!s) return; const o = ze(s.quantity); if (o <= 0) return; const a = tm([void 0, ...s.groups]), l = a !== void 0 ? n.actualOptions.particles.groups[a] : void 0; n.particles.push(o, n.interactivity.mouse, l, a) } } clear() { } init() { } async interact() { } isEnabled() { return !0 } loadModeOptions(e, ...t) { e.push || (e.push = new X5); for (const n of t) e.push.load(n == null ? void 0 : n.push) } reset() { } } async function Y5(i, e = !0) { await i.addInteractor("externalPush", t => new J5(t), e) } class j5 { constructor() { this.quantity = 2 } get particles_nb() { return this.quantity } set particles_nb(e) { this.quantity = it(e) } load(e) { if (!e) return; const t = e.quantity ?? e.particles_nb; t !== void 0 && (this.quantity = it(t)) } } class K5 extends go { constructor(e) { super(e), this.handleClickMode = t => { const n = this.container, r = n.actualOptions; if (!r.interactivity.modes.remove || t !== "remove") return; const s = ze(r.interactivity.modes.remove.quantity); n.particles.removeQuantity(s) } } clear() { } init() { } async interact() { } isEnabled() { return !0 } loadModeOptions(e, ...t) { e.remove || (e.remove = new j5); for (const n of t) e.remove.load(n == null ? void 0 : n.remove) } reset() { } } async function q5(i, e = !0) { await i.addInteractor("externalRemove", t => new K5(t), e) } class yO { constructor() { this.distance = 200, this.duration = .4, this.factor = 100, this.speed = 1, this.maxSpeed = 50, this.easing = "ease-out-quad" } load(e) { e && (e.distance !== void 0 && (this.distance = e.distance), e.duration !== void 0 && (this.duration = e.duration), e.easing !== void 0 && (this.easing = e.easing), e.factor !== void 0 && (this.factor = e.factor), e.speed !== void 0 && (this.speed = e.speed), e.maxSpeed !== void 0 && (this.maxSpeed = e.maxSpeed)) } } class Q5 extends yO { constructor() { super(), this.selectors = [] } get ids() { return xn(this.selectors, e => e.replace("#", "")) } set ids(e) { this.selectors = xn(e, t => `#${t}`) } load(e) { super.load(e), e && (e.ids !== void 0 && (this.ids = e.ids), e.selectors !== void 0 && (this.selectors = e.selectors)) } } class Z5 extends yO { load(e) { super.load(e), e && (this.divs = xn(e.divs, t => { const n = new Q5; return n.load(t), n })) } } class $5 extends go { constructor(e, t) { super(t), this._clickRepulse = () => { const n = this.container, r = n.actualOptions.interactivity.modes.repulse; if (!r) return; const s = n.repulse || { particles: [] }; if (s.finish || (s.count || (s.count = 0), s.count++, s.count === n.particles.count && (s.finish = !0)), s.clicking) { const o = n.retina.repulseModeDistance; if (!o || o < 0) return; const a = Math.pow(o / 6, 3), l = n.interactivity.mouse.clickPosition; if (l === void 0) return; const c = new tr(l.x, l.y, a), f = n.particles.quadTree.query(c, d => this.isEnabled(d)); for (const d of f) { const { dx: p, dy: m, distance: y } = $i(l, d.position), _ = y ** 2, x = r.speed, g = -a * x / _; if (_ <= a) { s.particles.push(d); const A = dn.create(p, m); A.length = g, d.velocity.setTo(A) } } } else if (s.clicking === !1) { for (const o of s.particles) o.velocity.setTo(o.initialVelocity); s.particles = [] } }, this._hoverRepulse = () => { const n = this.container, r = n.interactivity.mouse.position, s = n.retina.repulseModeDistance; !s || s < 0 || !r || this._processRepulse(r, s, new tr(r.x, r.y, s)) }, this._processRepulse = (n, r, s, o) => { const a = this.container, l = a.particles.quadTree.query(s, f => this.isEnabled(f)), c = a.actualOptions.interactivity.modes.repulse; if (c) for (const f of l) { const { dx: d, dy: p, distance: m } = $i(f.position, n), y = ((o == null ? void 0 : o.speed) ?? c.speed) * c.factor, _ = fo(GD(c.easing)(1 - m / r) * y, 0, c.maxSpeed), x = dn.create(m === 0 ? y : d / m * _, m === 0 ? y : p / m * _); f.position.addTo(x) } }, this._singleSelectorRepulse = (n, r) => { const s = this.container, o = s.actualOptions.interactivity.modes.repulse; if (!o) return; const a = document.querySelectorAll(n); a.length && a.forEach(l => { const c = l, f = s.retina.pixelRatio, d = { x: (c.offsetLeft + c.offsetWidth / 2) * f, y: (c.offsetTop + c.offsetHeight / 2) * f }, p = c.offsetWidth / 2 * f, m = r.type === "circle" ? new tr(d.x, d.y, p) : new ho(c.offsetLeft * f, c.offsetTop * f, c.offsetWidth * f, c.offsetHeight * f), y = o.divs, _ = jD(y, c); this._processRepulse(d, p, m, _) }) }, this._engine = e, t.repulse || (t.repulse = { particles: [] }), this.handleClickMode = n => { const r = this.container.actualOptions, s = r.interactivity.modes.repulse; if (!s || n !== "repulse") return; t.repulse || (t.repulse = { particles: [] }); const o = t.repulse; o.clicking = !0, o.count = 0; for (const a of t.repulse.particles) this.isEnabled(a) && a.velocity.setTo(a.initialVelocity); o.particles = [], o.finish = !1, setTimeout(() => { t.destroyed || (o.clicking = !1) }, s.duration * 1e3) } } clear() { } init() { const e = this.container, t = e.actualOptions.interactivity.modes.repulse; t && (e.retina.repulseModeDistance = t.distance * e.retina.pixelRatio) } async interact() { const e = this.container, t = e.actualOptions, n = e.interactivity.status === su, r = t.interactivity.events, s = r.onHover, o = s.enable, a = s.mode, l = r.onClick, c = l.enable, f = l.mode, d = r.onDiv; n && o && _n("repulse", a) ? this._hoverRepulse() : c && _n("repulse", f) ? this._clickRepulse() : iE("repulse", d, (p, m) => this._singleSelectorRepulse(p, m)) } isEnabled(e) { const t = this.container, n = t.actualOptions, r = t.interactivity.mouse, s = ((e == null ? void 0 : e.interactivity) ?? n.interactivity).events, o = s.onDiv, a = s.onHover, l = s.onClick, c = nE("repulse", o); if (!(c || a.enable && r.position || l.enable && r.clickPosition)) return !1; const f = a.mode, d = l.mode; return _n("repulse", f) || _n("repulse", d) || c } loadModeOptions(e, ...t) { e.repulse || (e.repulse = new Z5); for (const n of t) e.repulse.load(n == null ? void 0 : n.repulse) } reset() { } } async function e9(i, e = !0) { await i.addInteractor("externalRepulse", t => new $5(i, t), e) } class t9 { constructor() { this.factor = 3, this.radius = 200 } load(e) { e && (e.factor !== void 0 && (this.factor = e.factor), e.radius !== void 0 && (this.radius = e.radius)) } } class n9 extends go { constructor(e) { super(e) } clear(e, t, n) { e.slow.inRange && !n || (e.slow.factor = 1) } init() { const e = this.container, t = e.actualOptions.interactivity.modes.slow; t && (e.retina.slowModeRadius = t.radius * e.retina.pixelRatio) } async interact() { } isEnabled(e) { const t = this.container, n = t.interactivity.mouse, r = ((e == null ? void 0 : e.interactivity) ?? t.actualOptions.interactivity).events; return r.onHover.enable && !!n.position && _n("slow", r.onHover.mode) } loadModeOptions(e, ...t) { e.slow || (e.slow = new t9); for (const n of t) e.slow.load(n == null ? void 0 : n.slow) } reset(e) { e.slow.inRange = !1; const t = this.container, n = t.actualOptions, r = t.interactivity.mouse.position, s = t.retina.slowModeRadius, o = n.interactivity.modes.slow; if (!o || !s || s < 0 || !r) return; const a = e.getPosition(), l = vr(r, a), c = l / s, f = o.factor, { slow: d } = e; l > s || (d.inRange = !0, d.factor = c / f) } } async function i9(i, e = !0) { await i.addInteractor("externalSlow", t => new n9(t), e) } const _A = [0, 4, 2, 1], JR = [8, 8, 4, 2]; class r9 { constructor(e) { this.pos = 0, this.data = new Uint8ClampedArray(e) } getString(e) { const t = this.data.slice(this.pos, this.pos + e); return this.pos += t.length, t.reduce((n, r) => n + String.fromCharCode(r), "") } nextByte() { return this.data[this.pos++] } nextTwoBytes() { return this.pos += 2, this.data[this.pos - 2] + (this.data[this.pos - 1] << 8) } readSubBlocks() { let e = "", t = 0; do { t = this.data[this.pos++]; for (let n = t; --n >= 0; e += String.fromCharCode(this.data[this.pos++])); } while (t !== 0); return e } readSubBlocksBin() { let e = 0, t = 0; for (let r = 0; (e = this.data[this.pos + r]) !== 0; r += e + 1)t += e; const n = new Uint8Array(t); for (let r = 0; (e = this.data[this.pos++]) !== 0;)for (let s = e; --s >= 0; n[r++] = this.data[this.pos++]); return n } skipSubBlocks() { for (; this.data[this.pos] !== 0; this.pos += this.data[this.pos] + 1); this.pos++ } } function vO(i, e) { const t = []; for (let n = 0; n < e; n++)t.push({ r: i.data[i.pos], g: i.data[i.pos + 1], b: i.data[i.pos + 2] }), i.pos += 3; return t } async function s9(i, e, t, n) { switch (i.nextByte()) { case 249: { const r = e.frames[t(!1)]; i.pos++; const s = i.nextByte(); r.GCreserved = (s & 224) >>> 5, r.disposalMethod = (s & 28) >>> 2, r.userInputDelayFlag = (s & 2) === 2; const o = (s & 1) === 1; r.delayTime = i.nextTwoBytes() * 10; const a = i.nextByte(); o && n(a), i.pos++; break } case 255: { i.pos++; const r = { identifier: i.getString(8), authenticationCode: i.getString(3), data: i.readSubBlocksBin() }; e.applicationExtensions.push(r); break } case 254: { e.comments.push([t(!1), i.readSubBlocks()]); break } case 1: { if (e.globalColorTable.length === 0) throw new EvalError("plain text extension without global color table"); i.pos++, e.frames[t(!1)].plainTextData = { left: i.nextTwoBytes(), top: i.nextTwoBytes(), width: i.nextTwoBytes(), height: i.nextTwoBytes(), charSize: { width: i.nextTwoBytes(), height: i.nextTwoBytes() }, foregroundColor: i.nextByte(), backgroundColor: i.nextByte(), text: i.readSubBlocks() }; break } default: i.skipSubBlocks(); break } } async function o9(i, e, t, n, r, s) { const o = e.frames[n(!0)]; o.left = i.nextTwoBytes(), o.top = i.nextTwoBytes(), o.width = i.nextTwoBytes(), o.height = i.nextTwoBytes(); const a = i.nextByte(), l = (a & 128) === 128, c = (a & 64) === 64; o.sortFlag = (a & 32) === 32, o.reserved = (a & 24) >>> 3; const f = 1 << (a & 7) + 1; l && (o.localColorTable = vO(i, f)); const d = g => { const { r: A, g: M, b: S } = (l ? o.localColorTable : e.globalColorTable)[g]; return { r: A, g: M, b: S, a: g === r(null) ? t ? ~~((A + M + S) / 3) : 0 : 255 } }, p = (() => { try { return new ImageData(o.width, o.height, { colorSpace: "srgb" }) } catch (g) { if (g instanceof DOMException && g.name === "IndexSizeError") return null; throw g } })(); if (p == null) throw new EvalError("GIF frame size is to large"); const m = i.nextByte(), y = i.readSubBlocksBin(), _ = 1 << m, x = (g, A) => { const M = g >>> 3, S = g & 7; return (y[M] + (y[M + 1] << 8) + (y[M + 2] << 16) & (1 << A) - 1 << S) >>> S }; if (c) { for (let g = 0, A = m + 1, M = 0, S = [[0]], C = 0; C < 4; C++) { if (_A[C] < o.height) for (let T = 0, R = 0; ;) { const B = g; if (g = x(M, A), M += A + 1, g === _) { A = m + 1, S.length = _ + 2; for (let b = 0; b < S.length; b++)S[b] = b < _ ? [b] : [] } else { g >= S.length ? S.push(S[B].concat(S[B][0])) : B !== _ && S.push(S[B].concat(S[g][0])); for (let b = 0; b < S[g].length; b++) { const { r: I, g: N, b: V, a: J } = d(S[g][b]); p.data.set([I, N, V, J], _A[C] * o.width + JR[C] * R + T % (o.width * 4)), T += 4 } S.length === 1 << A && A < 12 && A++ } if (T === o.width * 4 * (R + 1) && (R++, _A[C] + JR[C] * R >= o.height)) break } s == null || s(i.pos / (i.data.length - 1), n(!1) + 1, p, { x: o.left, y: o.top }, { width: e.width, height: e.height }) } o.image = p, o.bitmap = await createImageBitmap(p) } else { for (let g = 0, A = m + 1, M = 0, S = [[0]], C = -4; ;) { const T = g; if (g = x(M, A), M += A, g === _) { A = m + 1, S.length = _ + 2; for (let R = 0; R < S.length; R++)S[R] = R < _ ? [R] : [] } else { if (g === _ + 1) break; g >= S.length ? S.push(S[T].concat(S[T][0])) : T !== _ && S.push(S[T].concat(S[g][0])); for (let R = 0; R < S[g].length; R++) { const { r: B, g: b, b: I, a: N } = d(S[g][R]); p.data.set([B, b, I, N], C += 4) } S.length >= 1 << A && A < 12 && A++ } } o.image = p, o.bitmap = await createImageBitmap(p), s == null || s((i.pos + 1) / i.data.length, n(!1) + 1, o.image, { x: o.left, y: o.top }, { width: e.width, height: e.height }) } } async function a9(i, e, t, n, r, s) { switch (i.nextByte()) { case 59: return !0; case 44: await o9(i, e, t, n, r, s); break; case 33: await s9(i, e, n, r); break; default: throw new EvalError("undefined block found") }return !1 } function l9(i) { for (const e of i.applicationExtensions) if (e.identifier + e.authenticationCode === "NETSCAPE2.0") return e.data[1] + (e.data[2] << 8); return NaN } async function c9(i, e, t) { t || (t = !1); const n = await fetch(i); if (!n.ok && n.status === 404) throw new EvalError("file not found"); const r = await n.arrayBuffer(), s = { width: 0, height: 0, totalTime: 0, colorRes: 0, pixelAspectRatio: 0, frames: [], sortFlag: !1, globalColorTable: [], backgroundImage: new ImageData(1, 1, { colorSpace: "srgb" }), comments: [], applicationExtensions: [] }, o = new r9(new Uint8ClampedArray(r)); if (o.getString(6) !== "GIF89a") throw new Error("not a supported GIF file"); s.width = o.nextTwoBytes(), s.height = o.nextTwoBytes(); const a = o.nextByte(), l = (a & 128) === 128; s.colorRes = (a & 112) >>> 4, s.sortFlag = (a & 8) === 8; const c = 1 << (a & 7) + 1, f = o.nextByte(); s.pixelAspectRatio = o.nextByte(), s.pixelAspectRatio !== 0 && (s.pixelAspectRatio = (s.pixelAspectRatio + 15) / 64), l && (s.globalColorTable = vO(o, c)); const d = (() => { try { return new ImageData(s.width, s.height, { colorSpace: "srgb" }) } catch (S) { if (S instanceof DOMException && S.name === "IndexSizeError") return null; throw S } })(); if (d == null) throw new Error("GIF frame size is to large"); const { r: p, g: m, b: y } = s.globalColorTable[f]; d.data.set(l ? [p, m, y, 255] : [0, 0, 0, 0]); for (let S = 4; S < d.data.length; S *= 2)d.data.copyWithin(S, 0, S); s.backgroundImage = d; let _ = -1, x = !0, g = -1; const A = S => (S && (x = !0), _), M = S => (S != null && (g = S), g); try { do x && (s.frames.push({ left: 0, top: 0, width: 0, height: 0, disposalMethod: 0, image: new ImageData(1, 1, { colorSpace: "srgb" }), plainTextData: null, userInputDelayFlag: !1, delayTime: 0, sortFlag: !1, localColorTable: [], reserved: 0, GCreserved: 0 }), _++, g = -1, x = !1); while (!await a9(o, s, t, A, M, e)); s.frames.length--; for (const S of s.frames) { if (S.userInputDelayFlag && S.delayTime === 0) { s.totalTime = 1 / 0; break } s.totalTime += S.delayTime } return s } catch (S) { throw S instanceof EvalError ? new Error(`error while parsing frame ${_} "${S.message}"`) : S } } const u9 = /(#(?:[0-9a-f]{2}){2,4}|(#[0-9a-f]{3})|(rgb|hsl)a?\((-?\d+%?[,\s]+){2,3}\s*[\d.]+%?\))|currentcolor/gi; function f9(i, e, t) { const { svgData: n } = i; if (!n) return ""; const r = dh(e, t); if (n.includes("fill")) return n.replace(u9, () => r); const s = n.indexOf(">"); return `${n.substring(0, s)} fill="${r}"${n.substring(s)}` } async function Lv(i) { return new Promise(e => { i.loading = !0; const t = new Image; i.element = t, t.addEventListener("load", () => { i.loading = !1, e() }), t.addEventListener("error", () => { i.element = void 0, i.error = !0, i.loading = !1, ou().error(`${zs} loading image: ${i.source}`), e() }), t.src = i.source }) } async function h9(i) { if (i.type !== "gif") { await Lv(i); return } i.loading = !0; try { i.gifData = await c9(i.source), i.gifLoopCount = l9(i.gifData) ?? 0, i.gifLoopCount === 0 && (i.gifLoopCount = 1 / 0) } catch { i.error = !0 } i.loading = !1 } async function d9(i) { if (i.type !== "svg") { await Lv(i); return } i.loading = !0; const e = await fetch(i.source); e.ok ? i.svgData = await e.text() : (ou().error(`${zs} Image not found`), i.error = !0), i.loading = !1 } function p9(i, e, t, n) { var o; const r = f9(i, t, ((o = n.opacity) == null ? void 0 : o.value) ?? 1), s = { color: t, gif: e.gif, data: { ...i, svgData: r }, loaded: !1, ratio: e.width / e.height, replaceColor: e.replaceColor ?? e.replace_color, source: e.src }; return new Promise(a => { const l = new Blob([r], { type: "image/svg+xml" }), c = URL || window.URL || window.webkitURL || window, f = c.createObjectURL(l), d = new Image; d.addEventListener("load", () => { s.loaded = !0, s.element = d, a(s), c.revokeObjectURL(f) }), d.addEventListener("error", async () => { c.revokeObjectURL(f); const p = { ...i, error: !1, loading: !0 }; await Lv(p), s.loaded = !0, s.element = p.element, a(s) }), d.src = f }) } class m9 { constructor(e) { this.loadImageShape = async t => { if (!this._engine.loadImage) throw new Error(`${zs} image shape not initialized`); await this._engine.loadImage({ gif: t.gif, name: t.name, replaceColor: t.replaceColor ?? t.replace_color ?? !1, src: t.src }) }, this._engine = e } addImage(e) { this._engine.images || (this._engine.images = []), this._engine.images.push(e) } draw(e, t, n, r, s) { const o = t.image, a = o == null ? void 0 : o.element; if (o) { if (e.globalAlpha = r, o.gif && o.gifData) { const l = new OffscreenCanvas(o.gifData.width, o.gifData.height), c = l.getContext("2d"); if (!c) throw new Error("could not create offscreen canvas context"); c.imageSmoothingQuality = "low", c.imageSmoothingEnabled = !1, c.clearRect(0, 0, l.width, l.height), t.gifLoopCount === void 0 && (t.gifLoopCount = o.gifLoopCount ?? 0); let f = t.gifFrame ?? 0; const d = { x: -o.gifData.width * .5, y: -o.gifData.height * .5 }, p = o.gifData.frames[f]; if (t.gifTime === void 0 && (t.gifTime = 0), !p.bitmap) return; switch (e.scale(n / o.gifData.width, n / o.gifData.height), p.disposalMethod) { case 4: case 5: case 6: case 7: case 0: c.drawImage(p.bitmap, p.left, p.top), e.drawImage(l, d.x, d.y), c.clearRect(0, 0, l.width, l.height); break; case 1: c.drawImage(p.bitmap, p.left, p.top), e.drawImage(l, d.x, d.y); break; case 2: c.drawImage(p.bitmap, p.left, p.top), e.drawImage(l, d.x, d.y), c.clearRect(0, 0, l.width, l.height), o.gifData.globalColorTable.length === 0 ? c.putImageData(o.gifData.frames[0].image, d.x + p.left, d.y + p.top) : c.putImageData(o.gifData.backgroundImage, d.x, d.y); break; case 3: { const m = c.getImageData(0, 0, l.width, l.height); c.drawImage(p.bitmap, p.left, p.top), e.drawImage(l, d.x, d.y), c.clearRect(0, 0, l.width, l.height), c.putImageData(m, 0, 0) } break }if (t.gifTime += s.value, t.gifTime > p.delayTime) { if (t.gifTime -= p.delayTime, ++f >= o.gifData.frames.length) { if (--t.gifLoopCount <= 0) return; f = 0, c.clearRect(0, 0, l.width, l.height) } t.gifFrame = f } e.scale(o.gifData.width / n, o.gifData.height / n) } else if (a) { const l = o.ratio, c = { x: -n, y: -n }; e.drawImage(a, c.x, c.y, n * 2, n * 2 / l) } e.globalAlpha = 1 } } getSidesCount() { return 12 } async init(e) { const t = e.actualOptions; if (!(!t.preload || !this._engine.loadImage)) for (const n of t.preload) await this._engine.loadImage(n) } loadShape(e) { if (e.shape !== "image" && e.shape !== "images") return; this._engine.images || (this._engine.images = []); const t = e.shapeData; this._engine.images.find(r => r.name === t.name || r.source === t.src) || this.loadImageShape(t).then(() => { this.loadShape(e) }) } particleInit(e, t) { if (t.shape !== "image" && t.shape !== "images") return; this._engine.images || (this._engine.images = []); const n = this._engine.images, r = t.shapeData, s = t.getFillColor(), o = n.find(l => l.name === r.name || l.source === r.src); if (!o) return; const a = r.replaceColor ?? r.replace_color ?? o.replaceColor; if (o.loading) { setTimeout(() => { this.particleInit(e, t) }); return } (async () => { let l; o.svgData && s ? l = await p9(o, r, s, t) : l = { color: s, data: o, element: o.element, gif: o.gif, gifData: o.gifData, gifLoopCount: o.gifLoopCount, loaded: !0, ratio: r.width && r.height ? r.width / r.height : o.ratio ?? 1, replaceColor: a, source: r.src }, l.ratio || (l.ratio = 1); const c = r.fill ?? t.fill, f = r.close ?? t.close, d = { image: l, fill: c, close: f }; t.image = d.image, t.fill = d.fill, t.close = d.close })() } } class g9 { constructor() { this.src = "", this.gif = !1 } load(e) { e && (e.gif !== void 0 && (this.gif = e.gif), e.height !== void 0 && (this.height = e.height), e.name !== void 0 && (this.name = e.name), e.replaceColor !== void 0 && (this.replaceColor = e.replaceColor), e.src !== void 0 && (this.src = e.src), e.width !== void 0 && (this.width = e.width)) } } class y9 { constructor(e) { this.id = "imagePreloader", this._engine = e } getPlugin() { return {} } loadOptions(e, t) { if (!t || !t.preload) return; e.preload || (e.preload = []); const n = e.preload; for (const r of t.preload) { const s = n.find(o => o.name === r.name || o.src === r.src); if (s) s.load(r); else { const o = new g9; o.load(r), n.push(o) } } } needsPlugin() { return !0 } } function v9(i) { i.loadImage || (i.loadImage = async e => { if (!e.name && !e.src) throw new Error(`${zs} no image source provided`); if (i.images || (i.images = []), !i.images.find(t => t.name === e.name || t.source === e.src)) try { const t = { gif: e.gif ?? !1, name: e.name ?? e.src, source: e.src, type: e.src.substring(e.src.length - 3), error: !1, loading: !0, replaceColor: e.replaceColor, ratio: e.width && e.height ? e.width / e.height : void 0 }; i.images.push(t), await (e.gif ? h9 : e.replaceColor ? d9 : Lv)(t) } catch { throw new Error(`${zs} ${e.name ?? e.src} not found`) } }) } async function _9(i, e = !0) { v9(i); const t = new y9(i); await i.addPlugin(t, e), await i.addShape(["image", "images"], new m9(i), e) } class x9 extends Hs { constructor() { super(), this.sync = !1 } load(e) { e && (super.load(e), e.sync !== void 0 && (this.sync = e.sync)) } } class A9 extends Hs { constructor() { super(), this.random.minimumValue = 1e-4, this.sync = !1 } load(e) { e && (super.load(e), e.sync !== void 0 && (this.sync = e.sync)) } } class M9 { constructor() { this.count = 0, this.delay = new x9, this.duration = new A9 } load(e) { e && (e.count !== void 0 && (this.count = e.count), this.delay.load(e.delay), this.duration.load(e.duration)) } } class w9 { constructor(e) { this.container = e } init(e) { const t = this.container, n = e.options, r = n.life; r && (e.life = { delay: t.retina.reduceFactor ? ze(r.delay.value) * (r.delay.sync ? 1 : Tt()) / t.retina.reduceFactor * 1e3 : 0, delayTime: 0, duration: t.retina.reduceFactor ? ze(r.duration.value) * (r.duration.sync ? 1 : Tt()) / t.retina.reduceFactor * 1e3 : 0, time: 0, count: r.count }, e.life.duration <= 0 && (e.life.duration = -1), e.life.count <= 0 && (e.life.count = -1), e.life && (e.spawning = e.life.delay > 0)) } isEnabled(e) { return !e.destroyed } loadOptions(e, ...t) { e.life || (e.life = new M9); for (const n of t) e.life.load(n == null ? void 0 : n.life) } update(e, t) { if (!this.isEnabled(e) || !e.life) return; const n = e.life; let r = !1; if (e.spawning) if (n.delayTime += t.value, n.delayTime >= e.life.delay) r = !0, e.spawning = !1, n.delayTime = 0, n.time = 0; else return; if (n.duration === -1 || e.spawning || (r ? n.time = 0 : n.time += t.value, n.time < n.duration)) return; if (n.time = 0, e.life.count > 0 && e.life.count--, e.life.count === 0) { e.destroy(); return } const s = this.container.canvas.size, o = it(0, s.width), a = it(0, s.width); e.position.x = Si(o), e.position.y = Si(a), e.spawning = !0, n.delayTime = 0, n.time = 0, e.reset(); const l = e.options.life; l && (n.delay = ze(l.delay.value) * 1e3, n.duration = ze(l.duration.value) * 1e3) } } async function S9(i, e = !0) { await i.addParticleUpdater("life", t => new w9(t), e) } class E9 { draw(e, t, n) { const r = t.shapeData; e.moveTo(-n / 2, 0), e.lineTo(n / 2, 0), e.lineCap = (r == null ? void 0 : r.cap) ?? "butt" } getSidesCount() { return 1 } } async function C9(i, e = !0) { await i.addShape("line", new E9, e) } class T9 { init() { } isEnabled(e) { return !fh() && !e.destroyed && e.container.actualOptions.interactivity.events.onHover.parallax.enable } move(e) { const t = e.container, n = t.actualOptions, r = n.interactivity.events.onHover.parallax; if (fh() || !r.enable) return; const s = r.force, o = t.interactivity.mouse.position; if (!o) return; const a = t.canvas.size, l = { x: a.width / 2, y: a.height / 2 }, c = r.smooth, f = e.getRadius() / s, d = { x: (o.x - l.x) * f, y: (o.y - l.y) * f }, { offset: p } = e; p.x += (d.x - p.x) / c, p.y += (d.y - p.y) / c } } async function b9(i, e = !0) { await i.addMover("parallax", () => new T9, e) } class R9 extends oE { constructor(e) { super(e) } clear() { } init() { } async interact(e) { const t = this.container, n = e.retina.attractDistance ?? t.retina.attractDistance, r = e.getPosition(), s = t.particles.quadTree.queryCircle(r, n); for (const o of s) { if (e === o || !o.options.move.attract.enable || o.destroyed || o.spawning) continue; const a = o.getPosition(), { dx: l, dy: c } = $i(r, a), f = e.options.move.attract.rotate, d = l / (f.x * 1e3), p = c / (f.y * 1e3), m = o.size.value / e.size.value, y = 1 / m; e.velocity.x -= d * m, e.velocity.y -= p * m, o.velocity.x += d * y, o.velocity.y += p * y } } isEnabled(e) { return e.options.move.attract.enable } reset() { } } async function P9(i, e = !0) { await i.addInteractor("particlesAttract", t => new R9(t), e) } function YR(i, e, t, n, r, s) { const o = fo(i.options.collisions.absorb.speed * r.factor / 10, 0, n); i.size.value += o / 2, t.size.value -= o, n <= s && (t.size.value = 0, t.destroy()) } function I9(i, e, t, n) { const r = i.getRadius(), s = e.getRadius(); r === void 0 && s !== void 0 ? i.destroy() : r !== void 0 && s === void 0 ? e.destroy() : r !== void 0 && s !== void 0 && (r >= s ? YR(i, r, e, s, t, n) : YR(e, s, i, r, t, n)) } const jR = i => { i.collisionMaxSpeed === void 0 && (i.collisionMaxSpeed = ze(i.options.collisions.maxSpeed)), i.velocity.length > i.collisionMaxSpeed && (i.velocity.length = i.collisionMaxSpeed) }; function _O(i, e) { KD(zw(i), zw(e)), jR(i), jR(e) } function B9(i, e) { !i.unbreakable && !e.unbreakable && _O(i, e), i.getRadius() === void 0 && e.getRadius() !== void 0 ? i.destroy() : i.getRadius() !== void 0 && e.getRadius() === void 0 ? e.destroy() : i.getRadius() !== void 0 && e.getRadius() !== void 0 && (i.getRadius() >= e.getRadius() ? e : i).destroy() } function L9(i, e, t, n) { switch (i.options.collisions.mode) { case "absorb": { I9(i, e, t, n); break } case "bounce": { _O(i, e); break } case "destroy": { B9(i, e); break } } } class D9 extends oE { constructor(e) { super(e) } clear() { } init() { } async interact(e, t) { if (e.destroyed || e.spawning) return; const n = this.container, r = e.getPosition(), s = e.getRadius(), o = n.particles.quadTree.queryCircle(r, s * 2); for (const a of o) { if (e === a || !a.options.collisions.enable || e.options.collisions.mode !== a.options.collisions.mode || a.destroyed || a.spawning) continue; const l = a.getPosition(), c = a.getRadius(); if (Math.abs(Math.round(r.z) - Math.round(l.z)) > s + c) continue; const f = vr(r, l), d = s + c; f > d || L9(e, a, t, n.retina.pixelRatio) } } isEnabled(e) { return e.options.collisions.enable } reset() { } } async function O9(i, e = !0) { await i.addInteractor("particlesCollisions", t => new D9(t), e) } class F9 extends tr { constructor(e, t, n, r) { super(e, t, n), this.canvasSize = r, this.canvasSize = { ...r } } contains(e) { const { width: t, height: n } = this.canvasSize, { x: r, y: s } = e; return super.contains(e) || super.contains({ x: r - t, y: s }) || super.contains({ x: r - t, y: s - n }) || super.contains({ x: r, y: s - n }) } intersects(e) { if (super.intersects(e)) return !0; const t = e, n = e, r = { x: e.position.x - this.canvasSize.width, y: e.position.y - this.canvasSize.height }; if (n.radius !== void 0) { const s = new tr(r.x, r.y, n.radius * 2); return super.intersects(s) } else if (t.size !== void 0) { const s = new ho(r.x, r.y, t.size.width * 2, t.size.height * 2); return super.intersects(s) } return !1 } } class k9 { constructor() { this.blur = 5, this.color = new Xn, this.color.value = "#000", this.enable = !1 } load(e) { e && (e.blur !== void 0 && (this.blur = e.blur), this.color = Xn.create(this.color, e.color), e.enable !== void 0 && (this.enable = e.enable)) } } class N9 { constructor() { this.enable = !1, this.frequency = 1 } load(e) { e && (e.color !== void 0 && (this.color = Xn.create(this.color, e.color)), e.enable !== void 0 && (this.enable = e.enable), e.frequency !== void 0 && (this.frequency = e.frequency), e.opacity !== void 0 && (this.opacity = e.opacity)) } } class U9 { constructor() { this.blink = !1, this.color = new Xn, this.color.value = "#fff", this.consent = !1, this.distance = 100, this.enable = !1, this.frequency = 1, this.opacity = 1, this.shadow = new k9, this.triangles = new N9, this.width = 1, this.warp = !1 } load(e) { e && (e.id !== void 0 && (this.id = e.id), e.blink !== void 0 && (this.blink = e.blink), this.color = Xn.create(this.color, e.color), e.consent !== void 0 && (this.consent = e.consent), e.distance !== void 0 && (this.distance = e.distance), e.enable !== void 0 && (this.enable = e.enable), e.frequency !== void 0 && (this.frequency = e.frequency), e.opacity !== void 0 && (this.opacity = e.opacity), this.shadow.load(e.shadow), this.triangles.load(e.triangles), e.width !== void 0 && (this.width = e.width), e.warp !== void 0 && (this.warp = e.warp)) } } function z9(i, e, t, n, r) { const { dx: s, dy: o, distance: a } = $i(i, e); if (!r || a <= t) return a; const l = { x: Math.abs(s), y: Math.abs(o) }, c = { x: Math.min(l.x, n.width - l.x), y: Math.min(l.y, n.height - l.y) }; return Math.sqrt(c.x ** 2 + c.y ** 2) } class H9 extends oE { constructor(e) { super(e), this._setColor = t => { if (!t.options.links) return; const n = this.linkContainer, r = t.options.links; let s = r.id === void 0 ? n.particles.linksColor : n.particles.linksColors.get(r.id); if (s) return; const o = r.color; s = rO(o, r.blink, r.consent), r.id === void 0 ? n.particles.linksColor = s : n.particles.linksColors.set(r.id, s) }, this.linkContainer = e } clear() { } init() { this.linkContainer.particles.linksColor = void 0, this.linkContainer.particles.linksColors = new Map } async interact(e) { if (!e.options.links) return; e.links = []; const t = e.getPosition(), n = this.container, r = n.canvas.size; if (t.x < 0 || t.y < 0 || t.x > r.width || t.y > r.height) return; const s = e.options.links, o = s.opacity, a = e.retina.linksDistance ?? 0, l = s.warp, c = l ? new F9(t.x, t.y, a, r) : new tr(t.x, t.y, a), f = n.particles.quadTree.query(c); for (const d of f) { const p = d.options.links; if (e === d || !(p != null && p.enable) || s.id !== p.id || d.spawning || d.destroyed || !d.links || e.links.some(x => x.destination === d) || d.links.some(x => x.destination === e)) continue; const m = d.getPosition(); if (m.x < 0 || m.y < 0 || m.x > r.width || m.y > r.height) continue; const y = z9(t, m, a, r, l && p.warp); if (y > a) continue; const _ = (1 - y / a) * o; this._setColor(e), e.links.push({ destination: d, opacity: _ }) } } isEnabled(e) { var t; return !!((t = e.options.links) != null && t.enable) } loadParticlesOptions(e, ...t) { e.links || (e.links = new U9); for (const n of t) e.links.load((n == null ? void 0 : n.links) ?? (n == null ? void 0 : n.lineLinked) ?? (n == null ? void 0 : n.line_linked)) } reset() { } } async function G9(i, e = !0) { await i.addInteractor("particlesLinks", t => new H9(t), e) } function V9(i) { let e = !1; const { begin: t, end: n, maxDistance: r, context: s, canvasSize: o, width: a, backgroundMask: l, colorLine: c, opacity: f, links: d } = i; if (vr(t, n) <= r) ip(s, t, n), e = !0; else if (d.warp) { let m, y; const _ = { x: n.x - o.width, y: n.y }, x = $i(t, _); if (x.distance <= r) { const g = t.y - x.dy / x.dx * t.x; m = { x: 0, y: g }, y = { x: o.width, y: g } } else { const g = { x: n.x, y: n.y - o.height }, A = $i(t, g); if (A.distance <= r) { const S = -(t.y - A.dy / A.dx * t.x) / (A.dy / A.dx); m = { x: S, y: 0 }, y = { x: S, y: o.height } } else { const M = { x: n.x - o.width, y: n.y - o.height }, S = $i(t, M); if (S.distance <= r) { const C = t.y - S.dy / S.dx * t.x; m = { x: -C / (S.dy / S.dx), y: C }, y = { x: m.x + o.width, y: m.y + o.height } } } } m && y && (ip(s, t, m), ip(s, n, y), e = !0) } if (!e) return; s.lineWidth = a, l.enable && (s.globalCompositeOperation = l.composite), s.strokeStyle = zo(c, f); const { shadow: p } = d; if (p.enable) { const m = Fs(p.color); m && (s.shadowBlur = p.blur, s.shadowColor = zo(m)) } s.stroke() } function W9(i) { const { context: e, pos1: t, pos2: n, pos3: r, backgroundMask: s, colorTriangle: o, opacityTriangle: a } = i; JG(e, t, n, r), s.enable && (e.globalCompositeOperation = s.composite), e.fillStyle = zo(o, a), e.fill() } function X9(i) { return i.sort((e, t) => e - t), i.join("_") } function KR(i, e) { const t = X9(i.map(r => r.id)); let n = e.get(t); return n === void 0 && (n = Tt(), e.set(t, n)), n } class J9 { constructor(e) { this.container = e, this._drawLinkLine = (t, n) => { const r = t.options.links; if (!(r != null && r.enable)) return; const s = this.container, o = s.actualOptions, a = n.destination, l = t.getPosition(), c = a.getPosition(); let f = n.opacity; s.canvas.draw(d => { var g; let p; const m = (g = t.options.twinkle) == null ? void 0 : g.lines; if (m != null && m.enable) { const A = m.frequency, M = Fs(m.color); Tt() < A && M && (p = M, f = ze(m.opacity)) } if (!p) { const A = r.id !== void 0 ? s.particles.linksColors.get(r.id) : s.particles.linksColor; p = Hw(t, a, A) } if (!p) return; const y = t.retina.linksWidth ?? 0, _ = t.retina.linksDistance ?? 0, { backgroundMask: x } = o; V9({ context: d, width: y, begin: l, end: c, maxDistance: _, canvasSize: s.canvas.size, links: r, backgroundMask: x, colorLine: p, opacity: f }) }) }, this._drawLinkTriangle = (t, n, r) => { const s = t.options.links; if (!(s != null && s.enable)) return; const o = s.triangles; if (!o.enable) return; const a = this.container, l = a.actualOptions, c = n.destination, f = r.destination, d = o.opacity ?? (n.opacity + r.opacity) / 2; d <= 0 || a.canvas.draw(p => { const m = t.getPosition(), y = c.getPosition(), _ = f.getPosition(), x = t.retina.linksDistance ?? 0; if (vr(m, y) > x || vr(_, y) > x || vr(_, m) > x) return; let g = Fs(o.color); if (!g) { const A = s.id !== void 0 ? a.particles.linksColors.get(s.id) : a.particles.linksColor; g = Hw(t, c, A) } g && W9({ context: p, pos1: m, pos2: y, pos3: _, backgroundMask: l.backgroundMask, colorTriangle: g, opacityTriangle: d }) }) }, this._drawTriangles = (t, n, r, s) => { var l, c, f; const o = r.destination; if (!((l = t.links) != null && l.triangles.enable && ((c = o.options.links) != null && c.triangles.enable))) return; const a = (f = o.links) == null ? void 0 : f.filter(d => { const p = this._getLinkFrequency(o, d.destination); return o.options.links && p <= o.options.links.frequency && s.findIndex(m => m.destination === d.destination) >= 0 }); if (a != null && a.length) for (const d of a) { const p = d.destination; this._getTriangleFrequency(n, o, p) > t.links.triangles.frequency || this._drawLinkTriangle(n, r, d) } }, this._getLinkFrequency = (t, n) => KR([t, n], this._freqs.links), this._getTriangleFrequency = (t, n, r) => KR([t, n, r], this._freqs.triangles), this._freqs = { links: new Map, triangles: new Map } } drawParticle(e, t) { const { links: n, options: r } = t; if (!n || n.length <= 0) return; const s = n.filter(o => r.links && this._getLinkFrequency(t, o.destination) <= r.links.frequency); for (const o of s) this._drawTriangles(r, t, o, s), o.opacity > 0 && (t.retina.linksWidth ?? 0) > 0 && this._drawLinkLine(t, o) } async init() { this._freqs.links = new Map, this._freqs.triangles = new Map } particleCreated(e) { if (e.links = [], !e.options.links) return; const t = this.container.retina.pixelRatio, { retina: n } = e, { distance: r, width: s } = e.options.links; n.linksDistance = r * t, n.linksWidth = s * t } particleDestroyed(e) { e.links = [] } } class Y9 { constructor() { this.id = "links" } getPlugin(e) { return new J9(e) } loadOptions() { } needsPlugin() { return !0 } } async function j9(i, e = !0) { const t = new Y9; await i.addPlugin(t, e) } async function K9(i, e = !0) { await G9(i, e), await j9(i, e) } class xO { draw(e, t, n) { const r = this.getCenter(t, n), s = this.getSidesData(t, n), o = s.count.numerator * s.count.denominator, a = s.count.numerator / s.count.denominator, l = 180 * (a - 2) / a, c = Math.PI - Math.PI * l / 180; if (e) { e.beginPath(), e.translate(r.x, r.y), e.moveTo(0, 0); for (let f = 0; f < o; f++)e.lineTo(s.length, 0), e.translate(s.length, 0), e.rotate(c) } } getSidesCount(e) { const t = e.shapeData; return Math.round(ze((t == null ? void 0 : t.sides) ?? (t == null ? void 0 : t.nb_sides) ?? 5)) } } class q9 extends xO { getCenter(e, t) { return { x: -t / (e.sides / 3.5), y: -t / (2.66 / 3.5) } } getSidesData(e, t) { const n = e.sides; return { count: { denominator: 1, numerator: n }, length: t * 2.66 / (n / 3) } } } class Q9 extends xO { getCenter(e, t) { return { x: -t, y: t / 1.66 } } getSidesCount() { return 3 } getSidesData(e, t) { return { count: { denominator: 2, numerator: 3 }, length: t * 2 } } } async function Z9(i, e = !0) { await i.addShape("polygon", new q9, e) } async function $9(i, e = !0) { await i.addShape("triangle", new Q9, e) } async function e8(i, e = !0) { await Z9(i, e), await $9(i, e) } class t8 { constructor() { this.enable = !1, this.speed = 0, this.decay = 0, this.sync = !1 } load(e) { e && (e.enable !== void 0 && (this.enable = e.enable), e.speed !== void 0 && (this.speed = it(e.speed)), e.decay !== void 0 && (this.decay = it(e.decay)), e.sync !== void 0 && (this.sync = e.sync)) } } class n8 extends Hs { constructor() { super(), this.animation = new t8, this.direction = "clockwise", this.path = !1, this.value = 0 } load(e) { e && (super.load(e), e.direction !== void 0 && (this.direction = e.direction), this.animation.load(e.animation), e.path !== void 0 && (this.path = e.path)) } } function i8(i, e) { const t = i.rotate, n = i.options.rotate; if (!t || !n) return; const r = n.animation, s = (t.velocity ?? 0) * e.factor, o = 2 * Math.PI, a = t.decay ?? 1; if (r.enable) { switch (t.status) { case "increasing": t.value += s, t.value > o && (t.value -= o); break; case "decreasing": default: t.value -= s, t.value < 0 && (t.value += o); break }t.velocity && a !== 1 && (t.velocity *= a) } } class r8 { constructor(e) { this.container = e } init(e) { const t = e.options.rotate; if (!t) return; e.rotate = { enable: t.animation.enable, value: ze(t.value) * Math.PI / 180 }, e.pathRotation = t.path; let n = t.direction; switch (n === "random" && (n = Math.floor(Tt() * 2) > 0 ? "counter-clockwise" : "clockwise"), n) { case "counter-clockwise": case "counterClockwise": e.rotate.status = "decreasing"; break; case "clockwise": e.rotate.status = "increasing"; break }const r = t.animation; r.enable && (e.rotate.decay = 1 - ze(r.decay), e.rotate.velocity = ze(r.speed) / 360 * this.container.retina.reduceFactor, r.sync || (e.rotate.velocity *= Tt())), e.rotation = e.rotate.value } isEnabled(e) { const t = e.options.rotate; return t ? !e.destroyed && !e.spawning && t.animation.enable && !t.path : !1 } loadOptions(e, ...t) { e.rotate || (e.rotate = new n8); for (const n of t) e.rotate.load(n == null ? void 0 : n.rotate) } update(e, t) { var n; this.isEnabled(e) && (i8(e, t), e.rotation = ((n = e.rotate) == null ? void 0 : n.value) ?? 0) } } async function s8(i, e = !0) { await i.addParticleUpdater("rotate", t => new r8(t), e) } const o8 = Math.sqrt(2); class a8 { draw(e, t, n) { const r = n / o8, s = r * 2; e.rect(-r, -r, s, s) } getSidesCount() { return 4 } } async function l8(i, e = !0) { await i.addShape(["edge", "square"], new a8, e) } class c8 { draw(e, t, n) { const r = t.sides, s = t.starInset ?? 2; e.moveTo(0, 0 - n); for (let o = 0; o < r; o++)e.rotate(Math.PI / r), e.lineTo(0, 0 - n * s), e.rotate(Math.PI / r), e.lineTo(0, 0 - n) } getSidesCount(e) { const t = e.shapeData; return Math.round(ze((t == null ? void 0 : t.sides) ?? (t == null ? void 0 : t.nb_sides) ?? 5)) } particleInit(e, t) { const n = t.shapeData, r = ze((n == null ? void 0 : n.inset) ?? 2); t.starInset = r } } async function u8(i, e = !0) { await i.addShape("star", new c8, e) } function xA(i, e, t, n, r) { if (!e || !t.enable || (e.maxLoops ?? 0) > 0 && (e.loops ?? 0) > (e.maxLoops ?? 0) || (e.time || (e.time = 0), (e.delayTime ?? 0) > 0 && e.time < (e.delayTime ?? 0) && (e.time += i.value), (e.delayTime ?? 0) > 0 && e.time < (e.delayTime ?? 0))) return; const s = Si(t.offset), o = (e.velocity ?? 0) * i.factor + s * 3.6, a = e.decay ?? 1; !r || e.status === "increasing" ? (e.value += o, e.value > n && (e.loops || (e.loops = 0), e.loops++, r && (e.status = "decreasing", e.value -= e.value % n))) : (e.value -= o, e.value < 0 && (e.loops || (e.loops = 0), e.loops++, e.status = "increasing", e.value += e.value)), e.velocity && a !== 1 && (e.velocity *= a), e.value > n && (e.value %= n) } function f8(i, e) { if (!i.strokeColor || !i.strokeAnimation) return; const { h: t, s: n, l: r } = i.strokeColor, { h: s, s: o, l: a } = i.strokeAnimation; t && xA(e, t, s, 360, !1), n && xA(e, n, o, 100, !0), r && xA(e, r, a, 100, !0) } class h8 { constructor(e) { this.container = e } init(e) { var o; const t = this.container, n = e.options, r = rs(n.stroke, e.id, n.reduceDuplicates); e.strokeWidth = ze(r.width) * t.retina.pixelRatio, e.strokeOpacity = ze(r.opacity ?? 1), e.strokeAnimation = (o = r.color) == null ? void 0 : o.animation; const s = kl(r.color) ?? e.getFillColor(); s && (e.strokeColor = sO(s, e.strokeAnimation, t.retina.reduceFactor)) } isEnabled(e) { const t = e.strokeAnimation, { strokeColor: n } = e; return !e.destroyed && !e.spawning && !!t && ((n == null ? void 0 : n.h.value) !== void 0 && n.h.enable || (n == null ? void 0 : n.s.value) !== void 0 && n.s.enable || (n == null ? void 0 : n.l.value) !== void 0 && n.l.enable) } update(e, t) { this.isEnabled(e) && f8(e, t) } } async function d8(i, e = !0) { await i.addParticleUpdater("strokeColor", t => new h8(t), e) } const iy = ["text", "character", "char"]; class p8 { draw(e, t, n, r) { const s = t.shapeData; if (s === void 0) return; const o = s.value; if (o === void 0) return; t.text === void 0 && (t.text = rs(o, t.randomIndexData)); const a = t.text, l = s.style ?? "", c = s.weight ?? "400", f = Math.round(n) * 2, d = s.font ?? "Verdana", p = t.fill, m = a.length * n / 2; e.font = `${l} ${c} ${f}px "${d}"`; const y = { x: -m, y: n / 2 }; e.globalAlpha = r, p ? e.fillText(a, y.x, y.y) : e.strokeText(a, y.x, y.y), e.globalAlpha = 1 } getSidesCount() { return 12 } async init(e) { const t = e.actualOptions; if (iy.find(n => _n(n, t.particles.shape.type))) { const n = iy.map(s => t.particles.shape.options[s]).find(s => !!s), r = []; xn(n, s => { r.push(NG(s.font, s.weight)) }), await Promise.all(r) } } particleInit(e, t) { if (!t.shape || !iy.includes(t.shape)) return; const n = t.shapeData; if (n === void 0) return; const r = n.value; r !== void 0 && (t.text = rs(r, t.randomIndexData)) } } async function m8(i, e = !0) { await i.addShape(iy, new p8, e) } async function g8(i, e = !0) { HV(i), await b9(i, !1), await A5(i, !1), await S5(i, !1), await b5(i, !1), await F5(i, !1), await G5(i, !1), await W5(i, !1), await Y5(i, !1), await q5(i, !1), await e9(i, !1), await i9(i, !1), await P9(i, !1), await O9(i, !1), await K9(i, !1), await v5(), await _9(i, !1), await C9(i, !1), await e8(i, !1), await l8(i, !1), await u8(i, !1), await m8(i, !1), await S9(i, !1), await s8(i, !1), await d8(i, !1), await y5(i, e) } class y8 { constructor() { this.enable = !1, this.speed = 0, this.decay = 0, this.sync = !1 } load(e) { e && (e.enable !== void 0 && (this.enable = e.enable), e.speed !== void 0 && (this.speed = it(e.speed)), e.decay !== void 0 && (this.decay = it(e.decay)), e.sync !== void 0 && (this.sync = e.sync)) } } class v8 extends Hs { constructor() { super(), this.animation = new y8, this.direction = "clockwise", this.enable = !1, this.value = 0 } load(e) { super.load(e), e && (this.animation.load(e.animation), e.direction !== void 0 && (this.direction = e.direction), e.enable !== void 0 && (this.enable = e.enable)) } } function _8(i, e) { if (!i.tilt || !i.options.tilt) return; const t = i.options.tilt, n = t.animation, r = (i.tilt.velocity ?? 0) * e.factor, s = 2 * Math.PI, o = i.tilt.decay ?? 1; if (n.enable) { switch (i.tilt.status) { case "increasing": i.tilt.value += r, i.tilt.value > s && (i.tilt.value -= s); break; case "decreasing": default: i.tilt.value -= r, i.tilt.value < 0 && (i.tilt.value += s); break }i.tilt.velocity && o !== 1 && (i.tilt.velocity *= o) } } class x8 { constructor(e) { this.container = e } getTransformValues(e) { var n; const t = ((n = e.tilt) == null ? void 0 : n.enable) && e.tilt; return { b: t ? Math.cos(t.value) * t.cosDirection : void 0, c: t ? Math.sin(t.value) * t.sinDirection : void 0 } } init(e) { var s; const t = e.options.tilt; if (!t) return; e.tilt = { enable: t.enable, value: ze(t.value) * Math.PI / 180, sinDirection: Tt() >= .5 ? 1 : -1, cosDirection: Tt() >= .5 ? 1 : -1 }; let n = t.direction; switch (n === "random" && (n = Math.floor(Tt() * 2) > 0 ? "counter-clockwise" : "clockwise"), n) { case "counter-clockwise": case "counterClockwise": e.tilt.status = "decreasing"; break; case "clockwise": e.tilt.status = "increasing"; break }const r = (s = e.options.tilt) == null ? void 0 : s.animation; r != null && r.enable && (e.tilt.decay = 1 - ze(r.decay), e.tilt.velocity = ze(r.speed) / 360 * this.container.retina.reduceFactor, r.sync || (e.tilt.velocity *= Tt())) } isEnabled(e) { var n; const t = (n = e.options.tilt) == null ? void 0 : n.animation; return !e.destroyed && !e.spawning && !!(t != null && t.enable) } loadOptions(e, ...t) { e.tilt || (e.tilt = new v8); for (const n of t) e.tilt.load(n == null ? void 0 : n.tilt) } update(e, t) { this.isEnabled(e) && _8(e, t) } } async function A8(i, e = !0) { await i.addParticleUpdater("tilt", t => new x8(t), e) } class qR { constructor() { this.enable = !1, this.frequency = .05, this.opacity = 1 } load(e) { e && (e.color !== void 0 && (this.color = Xn.create(this.color, e.color)), e.enable !== void 0 && (this.enable = e.enable), e.frequency !== void 0 && (this.frequency = e.frequency), e.opacity !== void 0 && (this.opacity = it(e.opacity))) } } class M8 { constructor() { this.lines = new qR, this.particles = new qR } load(e) { e && (this.lines.load(e.lines), this.particles.load(e.particles)) } } class w8 { getColorStyles(e, t, n, r) { const s = e.options, o = s.twinkle; if (!o) return {}; const a = o.particles, l = a.enable && Tt() < a.frequency, c = e.options.zIndex, f = (1 - e.zIndexFactor) ** c.opacityRate, d = l ? ze(a.opacity) * f : r, p = kl(a.color), m = p ? dh(p, d) : void 0, y = {}, _ = l && m; return y.fill = _ ? m : void 0, y.stroke = _ ? m : void 0, y } init() { } isEnabled(e) { const t = e.options, n = t.twinkle; return n ? n.particles.enable : !1 } loadOptions(e, ...t) { e.twinkle || (e.twinkle = new M8); for (const n of t) e.twinkle.load(n == null ? void 0 : n.twinkle) } update() { } } async function S8(i, e = !0) { await i.addParticleUpdater("twinkle", () => new w8, e) } class E8 { constructor() { this.angle = 50, this.move = 10 } load(e) { e && (e.angle !== void 0 && (this.angle = it(e.angle)), e.move !== void 0 && (this.move = it(e.move))) } } class C8 { constructor() { this.distance = 5, this.enable = !1, this.speed = new E8 } load(e) { if (e && (e.distance !== void 0 && (this.distance = it(e.distance)), e.enable !== void 0 && (this.enable = e.enable), e.speed !== void 0)) if (er(e.speed)) this.speed.load({ angle: e.speed }); else { const t = e.speed; t.min !== void 0 ? this.speed.load({ angle: t }) : this.speed.load(e.speed) } } } function T8(i, e) { const { wobble: t } = i.options, { wobble: n } = i; if (!(t != null && t.enable) || !n) return; const r = n.angleSpeed * e.factor, s = n.moveSpeed * e.factor, o = s * ((i.retina.wobbleDistance ?? 0) * e.factor) / (1e3 / 60), a = 2 * Math.PI, { position: l } = i; n.angle += r, n.angle > a && (n.angle -= a), l.x += o * Math.cos(n.angle), l.y += o * Math.abs(Math.sin(n.angle)) } class b8 { constructor(e) { this.container = e } init(e) { const t = e.options.wobble; t != null && t.enable ? e.wobble = { angle: Tt() * Math.PI * 2, angleSpeed: ze(t.speed.angle) / 360, moveSpeed: ze(t.speed.move) / 10 } : e.wobble = { angle: 0, angleSpeed: 0, moveSpeed: 0 }, e.retina.wobbleDistance = ze((t == null ? void 0 : t.distance) ?? 0) * this.container.retina.pixelRatio } isEnabled(e) { var t; return !e.destroyed && !e.spawning && !!((t = e.options.wobble) != null && t.enable) } loadOptions(e, ...t) { e.wobble || (e.wobble = new C8); for (const n of t) e.wobble.load(n == null ? void 0 : n.wobble) } update(e, t) { this.isEnabled(e) && T8(e, t) } } async function R8(i, e = !0) { await i.addParticleUpdater("wobble", t => new b8(t), e) } async function P8(i, e = !0) { await MV(i, !1), await UV(i, !1), await A8(i, !1), await S8(i, !1), await R8(i, !1), await DV(i, !1), await dV(i, !1), await IV(i, !1), await g8(i, e) } function I8() { async function i(e) { await P8(e) } return Re.jsx(dO, { id: "tsparticles", init: i, options: { fullScreen: { enable: !0, zIndex: 0 }, particles: { number: { value: 80, density: { enable: !0, value_area: 236 } }, color: { value: "#000" }, shape: { type: "circle" }, opacity: { value: 1, random: !0, anim: { enable: !1, speed: 2, opacity_min: .1, sync: !1 } }, size: { value: 2, random: !0, anim: { enable: !1, speed: 40, size_min: .1, sync: !1 } }, rotate: { value: 0, random: !0, direction: "clockwise", animation: { enable: !0, speed: 5, sync: !1 } }, line_linked: { enable: !1, distance: 40, color: "#000", opacity: 1, width: .5 }, move: { enable: !0, speed: .5, direction: "none", random: !1, straight: !1, out_mode: "out", attract: { enable: !1, rotateX: 3e3, rotateY: 3e3 } } }, interactivity: { events: { onhover: { enable: !0, mode: ["grab"] }, onclick: { enable: !1, mode: "push" }, resize: !0 }, modes: { grab: { distance: 200, line_linked: { opacity: 1 } }, bubble: { distance: 200, size: 80, duration: .4, opacity: 8, speed: 3 }, repulse: { distance: 200 }, push: { particles_nb: 4 }, remove: { particles_nb: 2 } } }, retina_detect: !1, background: { color: "#EAEAEE", image: "", position: "50% 50%", repeat: "no-repeat", size: "cover" } } }) } va.registerPlugin(Gt); const AA = { WebkitLineClamp: 2, WebkitBoxOrient: "vertical", overflow: "hidden", display: "-webkit-box" }, MA = {}, wA = { display: "none" }, SA = { marginTop: "auto", marginBottom: "auto" }, B8 = () => { const i = ce.useRef(null); ce.useEffect(() => { const a = i.current; va.timeline({ scrollTrigger: { trigger: a, start: "10% center", end: "80% center", scrub: !1, markers: !1, toggleActions: "play reverse play reverse" } }).to(a, { opacity: 1, x: 300, duration: .5 }) }); const [e, t] = ce.useState(!1), [n, r] = ce.useState(!1), [s, o] = ce.useState(!1); return Re.jsxs("div", { className: "projects", id: "projects", children: [Re.jsx("div", { className: "polygon2" }), Re.jsxs("div", { className: "proContainer", ref: i, children: [Re.jsx("div", { className: "proTitle", children: "My Projects" }), Re.jsx("div", { className: "proExamples", children: Re.jsxs("ul", { className: "proUl", children: [Re.jsxs("li", { className: "proLi", children: [Re.jsx("div", { className: "proPhoto1", style: e ? wA : null }), Re.jsxs("div", { className: "proDesc", style: e ? SA : null, children: [Re.jsx("div", { className: "proName", children: "SOWA" }), Re.jsx("div", { className: "proText", style: e ? MA : AA, children: "The application responsible for conducting student elections. Working in a multi-person team and using git. The technologies I use are mainly Javascript with frameworks, php and sql. It was my first serious project where I worked with other programmers and learned a lot of practical things" })] }), Re.jsx("button", { onClick: () => t(!e), className: "proSeeMore", children: e ? "Read Less" : "Read More" })] }), Re.jsxs("li", { className: "proLi", children: [Re.jsx("div", { className: "proPhoto2", style: n ? wA : null }), Re.jsxs("div", { className: "proDesc", style: n ? SA : null, children: [Re.jsx("div", { className: "proName", children: "SEARCH BLOG" }), Re.jsx("div", { className: "proText", style: n ? MA : AA, children: 'A simple web application that will allow me to search the "Blog" archive. Blog entries are open API - jsonplaceholder. Searching consists in searching for entries by title and displaying them from the longest to the shortest and vice versa. Application created in React with the ability to change the theme depending on the default theme of the computer (light / dark).I used Tailwind to change the theme of the website' })] }), Re.jsx("button", { onClick: () => r(!n), className: "proSeeMore", children: n ? "Read Less" : "Read More" })] }), Re.jsxs("li", { className: "proLi", children: [Re.jsx("div", { className: "proPhoto3", style: s ? wA : null }), Re.jsxs("div", { className: "proDesc", style: s ? SA : null, children: [Re.jsx("div", { className: "proName", children: "FLAPPY BIRD" }), Re.jsx("div", { className: "proText", style: s ? MA : AA, children: "I wrote a famous browser game flappy bird using 3js and react. For the needs of the university, I had to remake it in such a style that the main motif was a horse. The game was used at the polytechnic fair of Student Research Groups. In addition, I was the organizer of the department responsible for digitization at this fair" })] }), Re.jsx("button", { onClick: () => o(!s), className: "proSeeMore", children: s ? "Read Less" : "Read More" })] })] }) })] }), Re.jsx("div", { className: "polygon3" })] }) }; const L8 = { display: "none" }, Hg = { display: "none" }, D8 = () => { const [i, e] = ce.useState(!1), [t, n] = ce.useState(!1), [r, s] = ce.useState(!1), [o, a] = ce.useState(!1), l = ce.useRef(), c = ce.useRef(), f = ce.useRef(), d = ce.useRef(), p = ce.useRef(null), m = ce.useRef(null), y = ce.useRef(null), _ = ce.useRef(null); ce.useEffect(() => { const S = p.current; l.current = va.timeline({ paused: !0 }), l.current.to(S, { opacity: 1, duration: .7 }) }, []), ce.useEffect(() => { const S = m.current; c.current = va.timeline({ paused: !0 }), c.current.to(S, { opacity: 1, duration: .7 }) }, []), ce.useEffect(() => { const S = y.current; f.current = va.timeline({ paused: !0 }), f.current.to(S, { opacity: 1, duration: .7 }) }, []), ce.useEffect(() => { const S = _.current; d.current = va.timeline({ paused: !0 }), d.current.to(S, { opacity: 1, duration: .7 }) }, []), ce.useEffect(() => { i ? l.current.play() : l.current.reverse() }, [i]), ce.useEffect(() => { t ? c.current.play() : c.current.reverse() }, [t]), ce.useEffect(() => { r ? f.current.play() : f.current.reverse() }, [r]), ce.useEffect(() => { o ? d.current.play() : d.current.reverse() }, [o]); const x = () => { n(null), e(!i), s(null), a(null) }, g = () => { n(!t), e(null), s(null), a(null) }, A = () => { n(null), e(null), s(!r), a(null) }, M = () => { n(null), e(null), s(null), a(!o) }; return Re.jsxs("div", { className: "interests", id: "interests", children: [Re.jsx("div", { className: "polygon4" }), Re.jsx("div", { className: "intLeft", children: Re.jsxs("div", { className: "intContainer", children: [Re.jsxs("div", { className: "intRow", children: [Re.jsx("div", { className: "intSection", children: "Web development " }), Re.jsx("i", { onClick: x, className: "fa-regular fa-plus" })] }), Re.jsxs("div", { className: "intRow", children: [Re.jsx("div", { className: "intSection", children: "Cyber Security" }), Re.jsx("i", { onClick: g, className: "fa-regular fa-plus" })] }), Re.jsxs("div", { className: "intRow", children: [Re.jsx("div", { className: "intSection", children: "Web Design" }), Re.jsx("i", { onClick: A, className: "fa-regular fa-plus" })] }), Re.jsxs("div", { id: "selfdev", className: "intRow", children: [Re.jsx("div", { className: "intSection", children: "Self-development" }), Re.jsx("i", { onClick: M, id: "selfdev", className: "fa-regular fa-plus" })] })] }) }), Re.jsxs("div", { className: "intRight", children: [Re.jsx("div", { className: "intTitle", style: i || t || r || o ? L8 : null, children: "Interests" }), Re.jsx("p", { className: "intDesc", style: i ? null : Hg, ref: p, children: "I really like creating new websites or web applications because it is a combination of creative and artistic thinking with logical programming. When writing new websites, I use various technologies: React, Vue, Angular or even Next. Here I can also add that I have experience in programming in many less important frameworks, for example: Materialize , bootstrat or sass." }), Re.jsx("p", { className: "intDesc", style: t ? null : Hg, ref: m, children: "In addition to creating websites, I like to spend my time learning about new network security. I regularly use Linux, ubuntu and windows server. I often solve various CTFs using sql, php, python or c++. I know the basics of computer networks, I use wireshark and postman" }), Re.jsx("p", { className: "intDesc", style: r ? null : Hg, ref: y, children: "In addition, when creating websites and web applications, I attach great importance to its styling and overall appearance. When programming, I often use new libraries that allow me to create new animations and various types of models. I use such libraries as Gsap, 3js, Figma or even a simple canva with html. For this I also use Particlejs, Tailwind or Materialize" }), Re.jsx("p", { className: "intDesc", style: o ? null : Hg, ref: _, children: "I am a 3rd year student at the Warsaw University of Technology at the Faculty of Mechatronics. In addition to developing in the direction of programming, I am active in the student government. I help solve IT problems by acting in the digitization committee. I took part in the organization of the Juwenalia and the fair of scientific circles. In my free time, I like to spend it actively. I often go out for a run and in the winter I go skiing with my friends" })] }), Re.jsx("div", { className: "polygon5" })] }) }; function Op() { return Op = Object.assign ? Object.assign.bind() : function (i) { for (var e = 1; e < arguments.length; e++) { var t = arguments[e]; for (var n in t) Object.prototype.hasOwnProperty.call(t, n) && (i[n] = t[n]) } return i }, Op.apply(this, arguments) }/**
 * @license
 * Copyright 2010-2023 Three.js Authors
 * SPDX-License-Identifier: MIT
 */const rm = "155", Ac = { LEFT: 0, MIDDLE: 1, RIGHT: 2, ROTATE: 0, DOLLY: 1, PAN: 2 }, Mc = { ROTATE: 0, PAN: 1, DOLLY_PAN: 2, DOLLY_ROTATE: 3 }, AO = 0, Gw = 1, MO = 2, O8 = 3, wO = 0, Dv = 1, rp = 2, $s = 3, Jo = 0, _r = 1, ro = 2, F8 = 2, Ea = 0, Jc = 1, Vw = 2, Ww = 3, Xw = 4, SO = 5, Sc = 100, EO = 101, CO = 102, Jw = 103, Yw = 104, TO = 200, bO = 201, RO = 202, PO = 203, aE = 204, lE = 205, IO = 206, BO = 207, LO = 208, DO = 209, OO = 210, FO = 0, kO = 1, NO = 2, nv = 3, UO = 4, zO = 5, HO = 6, GO = 7, sm = 0, VO = 1, WO = 2, Ho = 0, XO = 1, JO = 2, YO = 3, cE = 4, jO = 5, Ov = 300, Da = 301, Nl = 302, Fp = 303, kp = 304, Rh = 306, Ul = 1e3, Di = 1001, mh = 1002, zn = 1003, Np = 1004, k8 = 1004, Yf = 1005, N8 = 1005, Pn = 1006, Fv = 1007, U8 = 1007, Yo = 1008, z8 = 1008, Go = 1009, KO = 1010, qO = 1011, kv = 1012, uE = 1013, Aa = 1014, Do = 1015, gh = 1016, fE = 1017, hE = 1018, bl = 1020, QO = 1021, Pr = 1023, ZO = 1024, $O = 1025, Rl = 1026, au = 1027, eF = 1028, dE = 1029, tF = 1030, pE = 1031, mE = 1033, ry = 33776, sy = 33777, oy = 33778, ay = 33779, jw = 35840, Kw = 35841, qw = 35842, Qw = 35843, nF = 36196, Zw = 37492, $w = 37496, eS = 37808, tS = 37809, nS = 37810, iS = 37811, rS = 37812, sS = 37813, oS = 37814, aS = 37815, lS = 37816, cS = 37817, uS = 37818, fS = 37819, hS = 37820, dS = 37821, ly = 36492, iF = 36283, pS = 36284, mS = 36285, gS = 36286, rF = 2200, sF = 2201, oF = 2202, yh = 2300, lu = 2301, cy = 2302, Bc = 2400, Lc = 2401, Up = 2402, Nv = 2500, gE = 2501, aF = 0, yE = 1, iv = 2, vE = 3e3, Pl = 3001, lF = 3200, cF = 3201, Jl = 0, uF = 1, Il = "", bt = "srgb", po = "srgb-linear", _E = "display-p3", H8 = 0, uy = 7680, G8 = 7681, V8 = 7682, W8 = 7683, X8 = 34055, J8 = 34056, Y8 = 5386, j8 = 512, K8 = 513, q8 = 514, Q8 = 515, Z8 = 516, $8 = 517, eW = 518, fF = 519, hF = 512, dF = 513, pF = 514, mF = 515, gF = 516, yF = 517, vF = 518, _F = 519, zp = 35044, tW = 35048, nW = 35040, iW = 35045, rW = 35049, sW = 35041, oW = 35046, aW = 35050, lW = 35042, cW = "100", yS = "300 es", rv = 1035, Oo = 2e3, Hp = 2001; class Ko { addEventListener(e, t) { this._listeners === void 0 && (this._listeners = {}); const n = this._listeners; n[e] === void 0 && (n[e] = []), n[e].indexOf(t) === -1 && n[e].push(t) } hasEventListener(e, t) { if (this._listeners === void 0) return !1; const n = this._listeners; return n[e] !== void 0 && n[e].indexOf(t) !== -1 } removeEventListener(e, t) { if (this._listeners === void 0) return; const r = this._listeners[e]; if (r !== void 0) { const s = r.indexOf(t); s !== -1 && r.splice(s, 1) } } dispatchEvent(e) { if (this._listeners === void 0) return; const n = this._listeners[e.type]; if (n !== void 0) { e.target = this; const r = n.slice(0); for (let s = 0, o = r.length; s < o; s++)r[s].call(this, e); e.target = null } } } const Ji = ["00", "01", "02", "03", "04", "05", "06", "07", "08", "09", "0a", "0b", "0c", "0d", "0e", "0f", "10", "11", "12", "13", "14", "15", "16", "17", "18", "19", "1a", "1b", "1c", "1d", "1e", "1f", "20", "21", "22", "23", "24", "25", "26", "27", "28", "29", "2a", "2b", "2c", "2d", "2e", "2f", "30", "31", "32", "33", "34", "35", "36", "37", "38", "39", "3a", "3b", "3c", "3d", "3e", "3f", "40", "41", "42", "43", "44", "45", "46", "47", "48", "49", "4a", "4b", "4c", "4d", "4e", "4f", "50", "51", "52", "53", "54", "55", "56", "57", "58", "59", "5a", "5b", "5c", "5d", "5e", "5f", "60", "61", "62", "63", "64", "65", "66", "67", "68", "69", "6a", "6b", "6c", "6d", "6e", "6f", "70", "71", "72", "73", "74", "75", "76", "77", "78", "79", "7a", "7b", "7c", "7d", "7e", "7f", "80", "81", "82", "83", "84", "85", "86", "87", "88", "89", "8a", "8b", "8c", "8d", "8e", "8f", "90", "91", "92", "93", "94", "95", "96", "97", "98", "99", "9a", "9b", "9c", "9d", "9e", "9f", "a0", "a1", "a2", "a3", "a4", "a5", "a6", "a7", "a8", "a9", "aa", "ab", "ac", "ad", "ae", "af", "b0", "b1", "b2", "b3", "b4", "b5", "b6", "b7", "b8", "b9", "ba", "bb", "bc", "bd", "be", "bf", "c0", "c1", "c2", "c3", "c4", "c5", "c6", "c7", "c8", "c9", "ca", "cb", "cc", "cd", "ce", "cf", "d0", "d1", "d2", "d3", "d4", "d5", "d6", "d7", "d8", "d9", "da", "db", "dc", "dd", "de", "df", "e0", "e1", "e2", "e3", "e4", "e5", "e6", "e7", "e8", "e9", "ea", "eb", "ec", "ed", "ee", "ef", "f0", "f1", "f2", "f3", "f4", "f5", "f6", "f7", "f8", "f9", "fa", "fb", "fc", "fd", "fe", "ff"]; let QR = 1234567; const Yc = Math.PI / 180, vh = 180 / Math.PI; function ss() { const i = Math.random() * 4294967295 | 0, e = Math.random() * 4294967295 | 0, t = Math.random() * 4294967295 | 0, n = Math.random() * 4294967295 | 0; return (Ji[i & 255] + Ji[i >> 8 & 255] + Ji[i >> 16 & 255] + Ji[i >> 24 & 255] + "-" + Ji[e & 255] + Ji[e >> 8 & 255] + "-" + Ji[e >> 16 & 15 | 64] + Ji[e >> 24 & 255] + "-" + Ji[t & 63 | 128] + Ji[t >> 8 & 255] + "-" + Ji[t >> 16 & 255] + Ji[t >> 24 & 255] + Ji[n & 255] + Ji[n >> 8 & 255] + Ji[n >> 16 & 255] + Ji[n >> 24 & 255]).toLowerCase() } function Gn(i, e, t) { return Math.max(e, Math.min(t, i)) } function xE(i, e) { return (i % e + e) % e } function uW(i, e, t, n, r) { return n + (i - e) * (r - n) / (t - e) } function fW(i, e, t) { return i !== e ? (t - i) / (e - i) : 0 } function sp(i, e, t) { return (1 - t) * i + t * e } function hW(i, e, t, n) { return sp(i, e, 1 - Math.exp(-t * n)) } function dW(i, e = 1) { return e - Math.abs(xE(i, e * 2) - e) } function pW(i, e, t) { return i <= e ? 0 : i >= t ? 1 : (i = (i - e) / (t - e), i * i * (3 - 2 * i)) } function mW(i, e, t) { return i <= e ? 0 : i >= t ? 1 : (i = (i - e) / (t - e), i * i * i * (i * (i * 6 - 15) + 10)) } function gW(i, e) { return i + Math.floor(Math.random() * (e - i + 1)) } function yW(i, e) { return i + Math.random() * (e - i) } function vW(i) { return i * (.5 - Math.random()) } function _W(i) { i !== void 0 && (QR = i); let e = QR += 1831565813; return e = Math.imul(e ^ e >>> 15, e | 1), e ^= e + Math.imul(e ^ e >>> 7, e | 61), ((e ^ e >>> 14) >>> 0) / 4294967296 } function xW(i) { return i * Yc } function AW(i) { return i * vh } function vS(i) { return (i & i - 1) === 0 && i !== 0 } function xF(i) { return Math.pow(2, Math.ceil(Math.log(i) / Math.LN2)) } function sv(i) { return Math.pow(2, Math.floor(Math.log(i) / Math.LN2)) } function MW(i, e, t, n, r) { const s = Math.cos, o = Math.sin, a = s(t / 2), l = o(t / 2), c = s((e + n) / 2), f = o((e + n) / 2), d = s((e - n) / 2), p = o((e - n) / 2), m = s((n - e) / 2), y = o((n - e) / 2); switch (r) { case "XYX": i.set(a * f, l * d, l * p, a * c); break; case "YZY": i.set(l * p, a * f, l * d, a * c); break; case "ZXZ": i.set(l * d, l * p, a * f, a * c); break; case "XZX": i.set(a * f, l * y, l * m, a * c); break; case "YXY": i.set(l * m, a * f, l * y, a * c); break; case "ZYZ": i.set(l * y, l * m, a * f, a * c); break; default: console.warn("THREE.MathUtils: .setQuaternionFromProperEuler() encountered an unknown order: " + r) } } function Ir(i, e) { switch (e.constructor) { case Float32Array: return i; case Uint32Array: return i / 4294967295; case Uint16Array: return i / 65535; case Uint8Array: return i / 255; case Int32Array: return Math.max(i / 2147483647, -1); case Int16Array: return Math.max(i / 32767, -1); case Int8Array: return Math.max(i / 127, -1); default: throw new Error("Invalid component type.") } } function It(i, e) { switch (e.constructor) { case Float32Array: return i; case Uint32Array: return Math.round(i * 4294967295); case Uint16Array: return Math.round(i * 65535); case Uint8Array: return Math.round(i * 255); case Int32Array: return Math.round(i * 2147483647); case Int16Array: return Math.round(i * 32767); case Int8Array: return Math.round(i * 127); default: throw new Error("Invalid component type.") } } const AF = { DEG2RAD: Yc, RAD2DEG: vh, generateUUID: ss, clamp: Gn, euclideanModulo: xE, mapLinear: uW, inverseLerp: fW, lerp: sp, damp: hW, pingpong: dW, smoothstep: pW, smootherstep: mW, randInt: gW, randFloat: yW, randFloatSpread: vW, seededRandom: _W, degToRad: xW, radToDeg: AW, isPowerOfTwo: vS, ceilPowerOfTwo: xF, floorPowerOfTwo: sv, setQuaternionFromProperEuler: MW, normalize: It, denormalize: Ir }; class _e { constructor(e = 0, t = 0) { _e.prototype.isVector2 = !0, this.x = e, this.y = t } get width() { return this.x } set width(e) { this.x = e } get height() { return this.y } set height(e) { this.y = e } set(e, t) { return this.x = e, this.y = t, this } setScalar(e) { return this.x = e, this.y = e, this } setX(e) { return this.x = e, this } setY(e) { return this.y = e, this } setComponent(e, t) { switch (e) { case 0: this.x = t; break; case 1: this.y = t; break; default: throw new Error("index is out of range: " + e) }return this } getComponent(e) { switch (e) { case 0: return this.x; case 1: return this.y; default: throw new Error("index is out of range: " + e) } } clone() { return new this.constructor(this.x, this.y) } copy(e) { return this.x = e.x, this.y = e.y, this } add(e) { return this.x += e.x, this.y += e.y, this } addScalar(e) { return this.x += e, this.y += e, this } addVectors(e, t) { return this.x = e.x + t.x, this.y = e.y + t.y, this } addScaledVector(e, t) { return this.x += e.x * t, this.y += e.y * t, this } sub(e) { return this.x -= e.x, this.y -= e.y, this } subScalar(e) { return this.x -= e, this.y -= e, this } subVectors(e, t) { return this.x = e.x - t.x, this.y = e.y - t.y, this } multiply(e) { return this.x *= e.x, this.y *= e.y, this } multiplyScalar(e) { return this.x *= e, this.y *= e, this } divide(e) { return this.x /= e.x, this.y /= e.y, this } divideScalar(e) { return this.multiplyScalar(1 / e) } applyMatrix3(e) { const t = this.x, n = this.y, r = e.elements; return this.x = r[0] * t + r[3] * n + r[6], this.y = r[1] * t + r[4] * n + r[7], this } min(e) { return this.x = Math.min(this.x, e.x), this.y = Math.min(this.y, e.y), this } max(e) { return this.x = Math.max(this.x, e.x), this.y = Math.max(this.y, e.y), this } clamp(e, t) { return this.x = Math.max(e.x, Math.min(t.x, this.x)), this.y = Math.max(e.y, Math.min(t.y, this.y)), this } clampScalar(e, t) { return this.x = Math.max(e, Math.min(t, this.x)), this.y = Math.max(e, Math.min(t, this.y)), this } clampLength(e, t) { const n = this.length(); return this.divideScalar(n || 1).multiplyScalar(Math.max(e, Math.min(t, n))) } floor() { return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this } ceil() { return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this } round() { return this.x = Math.round(this.x), this.y = Math.round(this.y), this } roundToZero() { return this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x), this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y), this } negate() { return this.x = -this.x, this.y = -this.y, this } dot(e) { return this.x * e.x + this.y * e.y } cross(e) { return this.x * e.y - this.y * e.x } lengthSq() { return this.x * this.x + this.y * this.y } length() { return Math.sqrt(this.x * this.x + this.y * this.y) } manhattanLength() { return Math.abs(this.x) + Math.abs(this.y) } normalize() { return this.divideScalar(this.length() || 1) } angle() { return Math.atan2(-this.y, -this.x) + Math.PI } angleTo(e) { const t = Math.sqrt(this.lengthSq() * e.lengthSq()); if (t === 0) return Math.PI / 2; const n = this.dot(e) / t; return Math.acos(Gn(n, -1, 1)) } distanceTo(e) { return Math.sqrt(this.distanceToSquared(e)) } distanceToSquared(e) { const t = this.x - e.x, n = this.y - e.y; return t * t + n * n } manhattanDistanceTo(e) { return Math.abs(this.x - e.x) + Math.abs(this.y - e.y) } setLength(e) { return this.normalize().multiplyScalar(e) } lerp(e, t) { return this.x += (e.x - this.x) * t, this.y += (e.y - this.y) * t, this } lerpVectors(e, t, n) { return this.x = e.x + (t.x - e.x) * n, this.y = e.y + (t.y - e.y) * n, this } equals(e) { return e.x === this.x && e.y === this.y } fromArray(e, t = 0) { return this.x = e[t], this.y = e[t + 1], this } toArray(e = [], t = 0) { return e[t] = this.x, e[t + 1] = this.y, e } fromBufferAttribute(e, t) { return this.x = e.getX(t), this.y = e.getY(t), this } rotateAround(e, t) { const n = Math.cos(t), r = Math.sin(t), s = this.x - e.x, o = this.y - e.y; return this.x = s * n - o * r + e.x, this.y = s * r + o * n + e.y, this } random() { return this.x = Math.random(), this.y = Math.random(), this } *[Symbol.iterator]() { yield this.x, yield this.y } } class Ot { constructor(e, t, n, r, s, o, a, l, c) { Ot.prototype.isMatrix3 = !0, this.elements = [1, 0, 0, 0, 1, 0, 0, 0, 1], e !== void 0 && this.set(e, t, n, r, s, o, a, l, c) } set(e, t, n, r, s, o, a, l, c) { const f = this.elements; return f[0] = e, f[1] = r, f[2] = a, f[3] = t, f[4] = s, f[5] = l, f[6] = n, f[7] = o, f[8] = c, this } identity() { return this.set(1, 0, 0, 0, 1, 0, 0, 0, 1), this } copy(e) { const t = this.elements, n = e.elements; return t[0] = n[0], t[1] = n[1], t[2] = n[2], t[3] = n[3], t[4] = n[4], t[5] = n[5], t[6] = n[6], t[7] = n[7], t[8] = n[8], this } extractBasis(e, t, n) { return e.setFromMatrix3Column(this, 0), t.setFromMatrix3Column(this, 1), n.setFromMatrix3Column(this, 2), this } setFromMatrix4(e) { const t = e.elements; return this.set(t[0], t[4], t[8], t[1], t[5], t[9], t[2], t[6], t[10]), this } multiply(e) { return this.multiplyMatrices(this, e) } premultiply(e) { return this.multiplyMatrices(e, this) } multiplyMatrices(e, t) { const n = e.elements, r = t.elements, s = this.elements, o = n[0], a = n[3], l = n[6], c = n[1], f = n[4], d = n[7], p = n[2], m = n[5], y = n[8], _ = r[0], x = r[3], g = r[6], A = r[1], M = r[4], S = r[7], C = r[2], T = r[5], R = r[8]; return s[0] = o * _ + a * A + l * C, s[3] = o * x + a * M + l * T, s[6] = o * g + a * S + l * R, s[1] = c * _ + f * A + d * C, s[4] = c * x + f * M + d * T, s[7] = c * g + f * S + d * R, s[2] = p * _ + m * A + y * C, s[5] = p * x + m * M + y * T, s[8] = p * g + m * S + y * R, this } multiplyScalar(e) { const t = this.elements; return t[0] *= e, t[3] *= e, t[6] *= e, t[1] *= e, t[4] *= e, t[7] *= e, t[2] *= e, t[5] *= e, t[8] *= e, this } determinant() { const e = this.elements, t = e[0], n = e[1], r = e[2], s = e[3], o = e[4], a = e[5], l = e[6], c = e[7], f = e[8]; return t * o * f - t * a * c - n * s * f + n * a * l + r * s * c - r * o * l } invert() { const e = this.elements, t = e[0], n = e[1], r = e[2], s = e[3], o = e[4], a = e[5], l = e[6], c = e[7], f = e[8], d = f * o - a * c, p = a * l - f * s, m = c * s - o * l, y = t * d + n * p + r * m; if (y === 0) return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0); const _ = 1 / y; return e[0] = d * _, e[1] = (r * c - f * n) * _, e[2] = (a * n - r * o) * _, e[3] = p * _, e[4] = (f * t - r * l) * _, e[5] = (r * s - a * t) * _, e[6] = m * _, e[7] = (n * l - c * t) * _, e[8] = (o * t - n * s) * _, this } transpose() { let e; const t = this.elements; return e = t[1], t[1] = t[3], t[3] = e, e = t[2], t[2] = t[6], t[6] = e, e = t[5], t[5] = t[7], t[7] = e, this } getNormalMatrix(e) { return this.setFromMatrix4(e).invert().transpose() } transposeIntoArray(e) { const t = this.elements; return e[0] = t[0], e[1] = t[3], e[2] = t[6], e[3] = t[1], e[4] = t[4], e[5] = t[7], e[6] = t[2], e[7] = t[5], e[8] = t[8], this } setUvTransform(e, t, n, r, s, o, a) { const l = Math.cos(s), c = Math.sin(s); return this.set(n * l, n * c, -n * (l * o + c * a) + o + e, -r * c, r * l, -r * (-c * o + l * a) + a + t, 0, 0, 1), this } scale(e, t) { return this.premultiply(EA.makeScale(e, t)), this } rotate(e) { return this.premultiply(EA.makeRotation(-e)), this } translate(e, t) { return this.premultiply(EA.makeTranslation(e, t)), this } makeTranslation(e, t) { return e.isVector2 ? this.set(1, 0, e.x, 0, 1, e.y, 0, 0, 1) : this.set(1, 0, e, 0, 1, t, 0, 0, 1), this } makeRotation(e) { const t = Math.cos(e), n = Math.sin(e); return this.set(t, -n, 0, n, t, 0, 0, 0, 1), this } makeScale(e, t) { return this.set(e, 0, 0, 0, t, 0, 0, 0, 1), this } equals(e) { const t = this.elements, n = e.elements; for (let r = 0; r < 9; r++)if (t[r] !== n[r]) return !1; return !0 } fromArray(e, t = 0) { for (let n = 0; n < 9; n++)this.elements[n] = e[n + t]; return this } toArray(e = [], t = 0) { const n = this.elements; return e[t] = n[0], e[t + 1] = n[1], e[t + 2] = n[2], e[t + 3] = n[3], e[t + 4] = n[4], e[t + 5] = n[5], e[t + 6] = n[6], e[t + 7] = n[7], e[t + 8] = n[8], e } clone() { return new this.constructor().fromArray(this.elements) } } const EA = new Ot; function MF(i) { for (let e = i.length - 1; e >= 0; --e)if (i[e] >= 65535) return !0; return !1 } const wW = { Int8Array, Uint8Array, Uint8ClampedArray, Int16Array, Uint16Array, Int32Array, Uint32Array, Float32Array, Float64Array }; function Pf(i, e) { return new wW[i](e) } function Gp(i) { return document.createElementNS("http://www.w3.org/1999/xhtml", i) } const ZR = {}; function op(i) { i in ZR || (ZR[i] = !0, console.warn(i)) } function jf(i) { return i < .04045 ? i * .0773993808 : Math.pow(i * .9478672986 + .0521327014, 2.4) } function CA(i) { return i < .0031308 ? i * 12.92 : 1.055 * Math.pow(i, .41666) - .055 } const SW = new Ot().fromArray([.8224621, .0331941, .0170827, .177538, .9668058, .0723974, -1e-7, 1e-7, .9105199]), EW = new Ot().fromArray([1.2249401, -.0420569, -.0196376, -.2249404, 1.0420571, -.0786361, 1e-7, 0, 1.0982735]); function CW(i) { return i.convertSRGBToLinear().applyMatrix3(EW) } function TW(i) { return i.applyMatrix3(SW).convertLinearToSRGB() } const bW = { [po]: i => i, [bt]: i => i.convertSRGBToLinear(), [_E]: CW }, RW = { [po]: i => i, [bt]: i => i.convertLinearToSRGB(), [_E]: TW }, As = { enabled: !0, get legacyMode() { return console.warn("THREE.ColorManagement: .legacyMode=false renamed to .enabled=true in r150."), !this.enabled }, set legacyMode(i) { console.warn("THREE.ColorManagement: .legacyMode=false renamed to .enabled=true in r150."), this.enabled = !i }, get workingColorSpace() { return po }, set workingColorSpace(i) { console.warn("THREE.ColorManagement: .workingColorSpace is readonly.") }, convert: function (i, e, t) { if (this.enabled === !1 || e === t || !e || !t) return i; const n = bW[e], r = RW[t]; if (n === void 0 || r === void 0) throw new Error(`Unsupported color space conversion, "${e}" to "${t}".`); return r(n(i)) }, fromWorkingColorSpace: function (i, e) { return this.convert(i, this.workingColorSpace, e) }, toWorkingColorSpace: function (i, e) { return this.convert(i, e, this.workingColorSpace) } }; let ku; class AE { static getDataURL(e) { if (/^data:/i.test(e.src) || typeof HTMLCanvasElement > "u") return e.src; let t; if (e instanceof HTMLCanvasElement) t = e; else { ku === void 0 && (ku = Gp("canvas")), ku.width = e.width, ku.height = e.height; const n = ku.getContext("2d"); e instanceof ImageData ? n.putImageData(e, 0, 0) : n.drawImage(e, 0, 0, e.width, e.height), t = ku } return t.width > 2048 || t.height > 2048 ? (console.warn("THREE.ImageUtils.getDataURL: Image converted to jpg for performance reasons", e), t.toDataURL("image/jpeg", .6)) : t.toDataURL("image/png") } static sRGBToLinear(e) { if (typeof HTMLImageElement < "u" && e instanceof HTMLImageElement || typeof HTMLCanvasElement < "u" && e instanceof HTMLCanvasElement || typeof ImageBitmap < "u" && e instanceof ImageBitmap) { const t = Gp("canvas"); t.width = e.width, t.height = e.height; const n = t.getContext("2d"); n.drawImage(e, 0, 0, e.width, e.height); const r = n.getImageData(0, 0, e.width, e.height), s = r.data; for (let o = 0; o < s.length; o++)s[o] = jf(s[o] / 255) * 255; return n.putImageData(r, 0, 0), t } else if (e.data) { const t = e.data.slice(0); for (let n = 0; n < t.length; n++)t instanceof Uint8Array || t instanceof Uint8ClampedArray ? t[n] = Math.floor(jf(t[n] / 255) * 255) : t[n] = jf(t[n]); return { data: t, width: e.width, height: e.height } } else return console.warn("THREE.ImageUtils.sRGBToLinear(): Unsupported image type. No color space conversion applied."), e } } let PW = 0; class Dc { constructor(e = null) { this.isSource = !0, Object.defineProperty(this, "id", { value: PW++ }), this.uuid = ss(), this.data = e, this.version = 0 } set needsUpdate(e) { e === !0 && this.version++ } toJSON(e) { const t = e === void 0 || typeof e == "string"; if (!t && e.images[this.uuid] !== void 0) return e.images[this.uuid]; const n = { uuid: this.uuid, url: "" }, r = this.data; if (r !== null) { let s; if (Array.isArray(r)) { s = []; for (let o = 0, a = r.length; o < a; o++)r[o].isDataTexture ? s.push(TA(r[o].image)) : s.push(TA(r[o])) } else s = TA(r); n.url = s } return t || (e.images[this.uuid] = n), n } } function TA(i) { return typeof HTMLImageElement < "u" && i instanceof HTMLImageElement || typeof HTMLCanvasElement < "u" && i instanceof HTMLCanvasElement || typeof ImageBitmap < "u" && i instanceof ImageBitmap ? AE.getDataURL(i) : i.data ? { data: Array.from(i.data), width: i.width, height: i.height, type: i.data.constructor.name } : (console.warn("THREE.Texture: Unable to serialize Texture."), {}) } let IW = 0; class wn extends Ko { constructor(e = wn.DEFAULT_IMAGE, t = wn.DEFAULT_MAPPING, n = Di, r = Di, s = Pn, o = Yo, a = Pr, l = Go, c = wn.DEFAULT_ANISOTROPY, f = Il) { super(), this.isTexture = !0, Object.defineProperty(this, "id", { value: IW++ }), this.uuid = ss(), this.name = "", this.source = new Dc(e), this.mipmaps = [], this.mapping = t, this.channel = 0, this.wrapS = n, this.wrapT = r, this.magFilter = s, this.minFilter = o, this.anisotropy = c, this.format = a, this.internalFormat = null, this.type = l, this.offset = new _e(0, 0), this.repeat = new _e(1, 1), this.center = new _e(0, 0), this.rotation = 0, this.matrixAutoUpdate = !0, this.matrix = new Ot, this.generateMipmaps = !0, this.premultiplyAlpha = !1, this.flipY = !0, this.unpackAlignment = 4, typeof f == "string" ? this.colorSpace = f : (op("THREE.Texture: Property .encoding has been replaced by .colorSpace."), this.colorSpace = f === Pl ? bt : Il), this.userData = {}, this.version = 0, this.onUpdate = null, this.isRenderTargetTexture = !1, this.needsPMREMUpdate = !1 } get image() { return this.source.data } set image(e = null) { this.source.data = e } updateMatrix() { this.matrix.setUvTransform(this.offset.x, this.offset.y, this.repeat.x, this.repeat.y, this.rotation, this.center.x, this.center.y) } clone() { return new this.constructor().copy(this) } copy(e) { return this.name = e.name, this.source = e.source, this.mipmaps = e.mipmaps.slice(0), this.mapping = e.mapping, this.channel = e.channel, this.wrapS = e.wrapS, this.wrapT = e.wrapT, this.magFilter = e.magFilter, this.minFilter = e.minFilter, this.anisotropy = e.anisotropy, this.format = e.format, this.internalFormat = e.internalFormat, this.type = e.type, this.offset.copy(e.offset), this.repeat.copy(e.repeat), this.center.copy(e.center), this.rotation = e.rotation, this.matrixAutoUpdate = e.matrixAutoUpdate, this.matrix.copy(e.matrix), this.generateMipmaps = e.generateMipmaps, this.premultiplyAlpha = e.premultiplyAlpha, this.flipY = e.flipY, this.unpackAlignment = e.unpackAlignment, this.colorSpace = e.colorSpace, this.userData = JSON.parse(JSON.stringify(e.userData)), this.needsUpdate = !0, this } toJSON(e) { const t = e === void 0 || typeof e == "string"; if (!t && e.textures[this.uuid] !== void 0) return e.textures[this.uuid]; const n = { metadata: { version: 4.6, type: "Texture", generator: "Texture.toJSON" }, uuid: this.uuid, name: this.name, image: this.source.toJSON(e).uuid, mapping: this.mapping, channel: this.channel, repeat: [this.repeat.x, this.repeat.y], offset: [this.offset.x, this.offset.y], center: [this.center.x, this.center.y], rotation: this.rotation, wrap: [this.wrapS, this.wrapT], format: this.format, internalFormat: this.internalFormat, type: this.type, colorSpace: this.colorSpace, minFilter: this.minFilter, magFilter: this.magFilter, anisotropy: this.anisotropy, flipY: this.flipY, generateMipmaps: this.generateMipmaps, premultiplyAlpha: this.premultiplyAlpha, unpackAlignment: this.unpackAlignment }; return Object.keys(this.userData).length > 0 && (n.userData = this.userData), t || (e.textures[this.uuid] = n), n } dispose() { this.dispatchEvent({ type: "dispose" }) } transformUv(e) { if (this.mapping !== Ov) return e; if (e.applyMatrix3(this.matrix), e.x < 0 || e.x > 1) switch (this.wrapS) { case Ul: e.x = e.x - Math.floor(e.x); break; case Di: e.x = e.x < 0 ? 0 : 1; break; case mh: Math.abs(Math.floor(e.x) % 2) === 1 ? e.x = Math.ceil(e.x) - e.x : e.x = e.x - Math.floor(e.x); break }if (e.y < 0 || e.y > 1) switch (this.wrapT) { case Ul: e.y = e.y - Math.floor(e.y); break; case Di: e.y = e.y < 0 ? 0 : 1; break; case mh: Math.abs(Math.floor(e.y) % 2) === 1 ? e.y = Math.ceil(e.y) - e.y : e.y = e.y - Math.floor(e.y); break }return this.flipY && (e.y = 1 - e.y), e } set needsUpdate(e) { e === !0 && (this.version++, this.source.needsUpdate = !0) } get encoding() { return op("THREE.Texture: Property .encoding has been replaced by .colorSpace."), this.colorSpace === bt ? Pl : vE } set encoding(e) { op("THREE.Texture: Property .encoding has been replaced by .colorSpace."), this.colorSpace = e === Pl ? bt : Il } } wn.DEFAULT_IMAGE = null; wn.DEFAULT_MAPPING = Ov; wn.DEFAULT_ANISOTROPY = 1; class on { constructor(e = 0, t = 0, n = 0, r = 1) { on.prototype.isVector4 = !0, this.x = e, this.y = t, this.z = n, this.w = r } get width() { return this.z } set width(e) { this.z = e } get height() { return this.w } set height(e) { this.w = e } set(e, t, n, r) { return this.x = e, this.y = t, this.z = n, this.w = r, this } setScalar(e) { return this.x = e, this.y = e, this.z = e, this.w = e, this } setX(e) { return this.x = e, this } setY(e) { return this.y = e, this } setZ(e) { return this.z = e, this } setW(e) { return this.w = e, this } setComponent(e, t) { switch (e) { case 0: this.x = t; break; case 1: this.y = t; break; case 2: this.z = t; break; case 3: this.w = t; break; default: throw new Error("index is out of range: " + e) }return this } getComponent(e) { switch (e) { case 0: return this.x; case 1: return this.y; case 2: return this.z; case 3: return this.w; default: throw new Error("index is out of range: " + e) } } clone() { return new this.constructor(this.x, this.y, this.z, this.w) } copy(e) { return this.x = e.x, this.y = e.y, this.z = e.z, this.w = e.w !== void 0 ? e.w : 1, this } add(e) { return this.x += e.x, this.y += e.y, this.z += e.z, this.w += e.w, this } addScalar(e) { return this.x += e, this.y += e, this.z += e, this.w += e, this } addVectors(e, t) { return this.x = e.x + t.x, this.y = e.y + t.y, this.z = e.z + t.z, this.w = e.w + t.w, this } addScaledVector(e, t) { return this.x += e.x * t, this.y += e.y * t, this.z += e.z * t, this.w += e.w * t, this } sub(e) { return this.x -= e.x, this.y -= e.y, this.z -= e.z, this.w -= e.w, this } subScalar(e) { return this.x -= e, this.y -= e, this.z -= e, this.w -= e, this } subVectors(e, t) { return this.x = e.x - t.x, this.y = e.y - t.y, this.z = e.z - t.z, this.w = e.w - t.w, this } multiply(e) { return this.x *= e.x, this.y *= e.y, this.z *= e.z, this.w *= e.w, this } multiplyScalar(e) { return this.x *= e, this.y *= e, this.z *= e, this.w *= e, this } applyMatrix4(e) { const t = this.x, n = this.y, r = this.z, s = this.w, o = e.elements; return this.x = o[0] * t + o[4] * n + o[8] * r + o[12] * s, this.y = o[1] * t + o[5] * n + o[9] * r + o[13] * s, this.z = o[2] * t + o[6] * n + o[10] * r + o[14] * s, this.w = o[3] * t + o[7] * n + o[11] * r + o[15] * s, this } divideScalar(e) { return this.multiplyScalar(1 / e) } setAxisAngleFromQuaternion(e) { this.w = 2 * Math.acos(e.w); const t = Math.sqrt(1 - e.w * e.w); return t < 1e-4 ? (this.x = 1, this.y = 0, this.z = 0) : (this.x = e.x / t, this.y = e.y / t, this.z = e.z / t), this } setAxisAngleFromRotationMatrix(e) { let t, n, r, s; const l = e.elements, c = l[0], f = l[4], d = l[8], p = l[1], m = l[5], y = l[9], _ = l[2], x = l[6], g = l[10]; if (Math.abs(f - p) < .01 && Math.abs(d - _) < .01 && Math.abs(y - x) < .01) { if (Math.abs(f + p) < .1 && Math.abs(d + _) < .1 && Math.abs(y + x) < .1 && Math.abs(c + m + g - 3) < .1) return this.set(1, 0, 0, 0), this; t = Math.PI; const M = (c + 1) / 2, S = (m + 1) / 2, C = (g + 1) / 2, T = (f + p) / 4, R = (d + _) / 4, B = (y + x) / 4; return M > S && M > C ? M < .01 ? (n = 0, r = .707106781, s = .707106781) : (n = Math.sqrt(M), r = T / n, s = R / n) : S > C ? S < .01 ? (n = .707106781, r = 0, s = .707106781) : (r = Math.sqrt(S), n = T / r, s = B / r) : C < .01 ? (n = .707106781, r = .707106781, s = 0) : (s = Math.sqrt(C), n = R / s, r = B / s), this.set(n, r, s, t), this } let A = Math.sqrt((x - y) * (x - y) + (d - _) * (d - _) + (p - f) * (p - f)); return Math.abs(A) < .001 && (A = 1), this.x = (x - y) / A, this.y = (d - _) / A, this.z = (p - f) / A, this.w = Math.acos((c + m + g - 1) / 2), this } min(e) { return this.x = Math.min(this.x, e.x), this.y = Math.min(this.y, e.y), this.z = Math.min(this.z, e.z), this.w = Math.min(this.w, e.w), this } max(e) { return this.x = Math.max(this.x, e.x), this.y = Math.max(this.y, e.y), this.z = Math.max(this.z, e.z), this.w = Math.max(this.w, e.w), this } clamp(e, t) { return this.x = Math.max(e.x, Math.min(t.x, this.x)), this.y = Math.max(e.y, Math.min(t.y, this.y)), this.z = Math.max(e.z, Math.min(t.z, this.z)), this.w = Math.max(e.w, Math.min(t.w, this.w)), this } clampScalar(e, t) { return this.x = Math.max(e, Math.min(t, this.x)), this.y = Math.max(e, Math.min(t, this.y)), this.z = Math.max(e, Math.min(t, this.z)), this.w = Math.max(e, Math.min(t, this.w)), this } clampLength(e, t) { const n = this.length(); return this.divideScalar(n || 1).multiplyScalar(Math.max(e, Math.min(t, n))) } floor() { return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this.z = Math.floor(this.z), this.w = Math.floor(this.w), this } ceil() { return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this.z = Math.ceil(this.z), this.w = Math.ceil(this.w), this } round() { return this.x = Math.round(this.x), this.y = Math.round(this.y), this.z = Math.round(this.z), this.w = Math.round(this.w), this } roundToZero() { return this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x), this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y), this.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z), this.w = this.w < 0 ? Math.ceil(this.w) : Math.floor(this.w), this } negate() { return this.x = -this.x, this.y = -this.y, this.z = -this.z, this.w = -this.w, this } dot(e) { return this.x * e.x + this.y * e.y + this.z * e.z + this.w * e.w } lengthSq() { return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w } length() { return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w) } manhattanLength() { return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z) + Math.abs(this.w) } normalize() { return this.divideScalar(this.length() || 1) } setLength(e) { return this.normalize().multiplyScalar(e) } lerp(e, t) { return this.x += (e.x - this.x) * t, this.y += (e.y - this.y) * t, this.z += (e.z - this.z) * t, this.w += (e.w - this.w) * t, this } lerpVectors(e, t, n) { return this.x = e.x + (t.x - e.x) * n, this.y = e.y + (t.y - e.y) * n, this.z = e.z + (t.z - e.z) * n, this.w = e.w + (t.w - e.w) * n, this } equals(e) { return e.x === this.x && e.y === this.y && e.z === this.z && e.w === this.w } fromArray(e, t = 0) { return this.x = e[t], this.y = e[t + 1], this.z = e[t + 2], this.w = e[t + 3], this } toArray(e = [], t = 0) { return e[t] = this.x, e[t + 1] = this.y, e[t + 2] = this.z, e[t + 3] = this.w, e } fromBufferAttribute(e, t) { return this.x = e.getX(t), this.y = e.getY(t), this.z = e.getZ(t), this.w = e.getW(t), this } random() { return this.x = Math.random(), this.y = Math.random(), this.z = Math.random(), this.w = Math.random(), this } *[Symbol.iterator]() { yield this.x, yield this.y, yield this.z, yield this.w } } class wF extends Ko { constructor(e = 1, t = 1, n = {}) { super(), this.isRenderTarget = !0, this.width = e, this.height = t, this.depth = 1, this.scissor = new on(0, 0, e, t), this.scissorTest = !1, this.viewport = new on(0, 0, e, t); const r = { width: e, height: t, depth: 1 }; n.encoding !== void 0 && (op("THREE.WebGLRenderTarget: option.encoding has been replaced by option.colorSpace."), n.colorSpace = n.encoding === Pl ? bt : Il), this.texture = new wn(r, n.mapping, n.wrapS, n.wrapT, n.magFilter, n.minFilter, n.format, n.type, n.anisotropy, n.colorSpace), this.texture.isRenderTargetTexture = !0, this.texture.flipY = !1, this.texture.generateMipmaps = n.generateMipmaps !== void 0 ? n.generateMipmaps : !1, this.texture.internalFormat = n.internalFormat !== void 0 ? n.internalFormat : null, this.texture.minFilter = n.minFilter !== void 0 ? n.minFilter : Pn, this.depthBuffer = n.depthBuffer !== void 0 ? n.depthBuffer : !0, this.stencilBuffer = n.stencilBuffer !== void 0 ? n.stencilBuffer : !1, this.depthTexture = n.depthTexture !== void 0 ? n.depthTexture : null, this.samples = n.samples !== void 0 ? n.samples : 0 } setSize(e, t, n = 1) { (this.width !== e || this.height !== t || this.depth !== n) && (this.width = e, this.height = t, this.depth = n, this.texture.image.width = e, this.texture.image.height = t, this.texture.image.depth = n, this.dispose()), this.viewport.set(0, 0, e, t), this.scissor.set(0, 0, e, t) } clone() { return new this.constructor().copy(this) } copy(e) { this.width = e.width, this.height = e.height, this.depth = e.depth, this.scissor.copy(e.scissor), this.scissorTest = e.scissorTest, this.viewport.copy(e.viewport), this.texture = e.texture.clone(), this.texture.isRenderTargetTexture = !0; const t = Object.assign({}, e.texture.image); return this.texture.source = new Dc(t), this.depthBuffer = e.depthBuffer, this.stencilBuffer = e.stencilBuffer, e.depthTexture !== null && (this.depthTexture = e.depthTexture.clone()), this.samples = e.samples, this } dispose() { this.dispatchEvent({ type: "dispose" }) } } class mo extends wF { constructor(e = 1, t = 1, n = {}) { super(e, t, n), this.isWebGLRenderTarget = !0 } } class Uv extends wn { constructor(e = null, t = 1, n = 1, r = 1) { super(null), this.isDataArrayTexture = !0, this.image = { data: e, width: t, height: n, depth: r }, this.magFilter = zn, this.minFilter = zn, this.wrapR = Di, this.generateMipmaps = !1, this.flipY = !1, this.unpackAlignment = 1 } } class BW extends mo { constructor(e = 1, t = 1, n = 1) { super(e, t), this.isWebGLArrayRenderTarget = !0, this.depth = n, this.texture = new Uv(null, e, t, n), this.texture.isRenderTargetTexture = !0 } } class ME extends wn { constructor(e = null, t = 1, n = 1, r = 1) { super(null), this.isData3DTexture = !0, this.image = { data: e, width: t, height: n, depth: r }, this.magFilter = zn, this.minFilter = zn, this.wrapR = Di, this.generateMipmaps = !1, this.flipY = !1, this.unpackAlignment = 1 } } class LW extends mo { constructor(e = 1, t = 1, n = 1) { super(e, t), this.isWebGL3DRenderTarget = !0, this.depth = n, this.texture = new ME(null, e, t, n), this.texture.isRenderTargetTexture = !0 } } class DW extends mo { constructor(e = 1, t = 1, n = 1, r = {}) { super(e, t, r), this.isWebGLMultipleRenderTargets = !0; const s = this.texture; this.texture = []; for (let o = 0; o < n; o++)this.texture[o] = s.clone(), this.texture[o].isRenderTargetTexture = !0 } setSize(e, t, n = 1) { if (this.width !== e || this.height !== t || this.depth !== n) { this.width = e, this.height = t, this.depth = n; for (let r = 0, s = this.texture.length; r < s; r++)this.texture[r].image.width = e, this.texture[r].image.height = t, this.texture[r].image.depth = n; this.dispose() } this.viewport.set(0, 0, e, t), this.scissor.set(0, 0, e, t) } copy(e) { this.dispose(), this.width = e.width, this.height = e.height, this.depth = e.depth, this.scissor.copy(e.scissor), this.scissorTest = e.scissorTest, this.viewport.copy(e.viewport), this.depthBuffer = e.depthBuffer, this.stencilBuffer = e.stencilBuffer, e.depthTexture !== null && (this.depthTexture = e.depthTexture.clone()), this.texture.length = 0; for (let t = 0, n = e.texture.length; t < n; t++)this.texture[t] = e.texture[t].clone(), this.texture[t].isRenderTargetTexture = !0; return this } } class Ti { constructor(e = 0, t = 0, n = 0, r = 1) { this.isQuaternion = !0, this._x = e, this._y = t, this._z = n, this._w = r } static slerpFlat(e, t, n, r, s, o, a) { let l = n[r + 0], c = n[r + 1], f = n[r + 2], d = n[r + 3]; const p = s[o + 0], m = s[o + 1], y = s[o + 2], _ = s[o + 3]; if (a === 0) { e[t + 0] = l, e[t + 1] = c, e[t + 2] = f, e[t + 3] = d; return } if (a === 1) { e[t + 0] = p, e[t + 1] = m, e[t + 2] = y, e[t + 3] = _; return } if (d !== _ || l !== p || c !== m || f !== y) { let x = 1 - a; const g = l * p + c * m + f * y + d * _, A = g >= 0 ? 1 : -1, M = 1 - g * g; if (M > Number.EPSILON) { const C = Math.sqrt(M), T = Math.atan2(C, g * A); x = Math.sin(x * T) / C, a = Math.sin(a * T) / C } const S = a * A; if (l = l * x + p * S, c = c * x + m * S, f = f * x + y * S, d = d * x + _ * S, x === 1 - a) { const C = 1 / Math.sqrt(l * l + c * c + f * f + d * d); l *= C, c *= C, f *= C, d *= C } } e[t] = l, e[t + 1] = c, e[t + 2] = f, e[t + 3] = d } static multiplyQuaternionsFlat(e, t, n, r, s, o) { const a = n[r], l = n[r + 1], c = n[r + 2], f = n[r + 3], d = s[o], p = s[o + 1], m = s[o + 2], y = s[o + 3]; return e[t] = a * y + f * d + l * m - c * p, e[t + 1] = l * y + f * p + c * d - a * m, e[t + 2] = c * y + f * m + a * p - l * d, e[t + 3] = f * y - a * d - l * p - c * m, e } get x() { return this._x } set x(e) { this._x = e, this._onChangeCallback() } get y() { return this._y } set y(e) { this._y = e, this._onChangeCallback() } get z() { return this._z } set z(e) { this._z = e, this._onChangeCallback() } get w() { return this._w } set w(e) { this._w = e, this._onChangeCallback() } set(e, t, n, r) { return this._x = e, this._y = t, this._z = n, this._w = r, this._onChangeCallback(), this } clone() { return new this.constructor(this._x, this._y, this._z, this._w) } copy(e) { return this._x = e.x, this._y = e.y, this._z = e.z, this._w = e.w, this._onChangeCallback(), this } setFromEuler(e, t) { const n = e._x, r = e._y, s = e._z, o = e._order, a = Math.cos, l = Math.sin, c = a(n / 2), f = a(r / 2), d = a(s / 2), p = l(n / 2), m = l(r / 2), y = l(s / 2); switch (o) { case "XYZ": this._x = p * f * d + c * m * y, this._y = c * m * d - p * f * y, this._z = c * f * y + p * m * d, this._w = c * f * d - p * m * y; break; case "YXZ": this._x = p * f * d + c * m * y, this._y = c * m * d - p * f * y, this._z = c * f * y - p * m * d, this._w = c * f * d + p * m * y; break; case "ZXY": this._x = p * f * d - c * m * y, this._y = c * m * d + p * f * y, this._z = c * f * y + p * m * d, this._w = c * f * d - p * m * y; break; case "ZYX": this._x = p * f * d - c * m * y, this._y = c * m * d + p * f * y, this._z = c * f * y - p * m * d, this._w = c * f * d + p * m * y; break; case "YZX": this._x = p * f * d + c * m * y, this._y = c * m * d + p * f * y, this._z = c * f * y - p * m * d, this._w = c * f * d - p * m * y; break; case "XZY": this._x = p * f * d - c * m * y, this._y = c * m * d - p * f * y, this._z = c * f * y + p * m * d, this._w = c * f * d + p * m * y; break; default: console.warn("THREE.Quaternion: .setFromEuler() encountered an unknown order: " + o) }return t !== !1 && this._onChangeCallback(), this } setFromAxisAngle(e, t) { const n = t / 2, r = Math.sin(n); return this._x = e.x * r, this._y = e.y * r, this._z = e.z * r, this._w = Math.cos(n), this._onChangeCallback(), this } setFromRotationMatrix(e) { const t = e.elements, n = t[0], r = t[4], s = t[8], o = t[1], a = t[5], l = t[9], c = t[2], f = t[6], d = t[10], p = n + a + d; if (p > 0) { const m = .5 / Math.sqrt(p + 1); this._w = .25 / m, this._x = (f - l) * m, this._y = (s - c) * m, this._z = (o - r) * m } else if (n > a && n > d) { const m = 2 * Math.sqrt(1 + n - a - d); this._w = (f - l) / m, this._x = .25 * m, this._y = (r + o) / m, this._z = (s + c) / m } else if (a > d) { const m = 2 * Math.sqrt(1 + a - n - d); this._w = (s - c) / m, this._x = (r + o) / m, this._y = .25 * m, this._z = (l + f) / m } else { const m = 2 * Math.sqrt(1 + d - n - a); this._w = (o - r) / m, this._x = (s + c) / m, this._y = (l + f) / m, this._z = .25 * m } return this._onChangeCallback(), this } setFromUnitVectors(e, t) { let n = e.dot(t) + 1; return n < Number.EPSILON ? (n = 0, Math.abs(e.x) > Math.abs(e.z) ? (this._x = -e.y, this._y = e.x, this._z = 0, this._w = n) : (this._x = 0, this._y = -e.z, this._z = e.y, this._w = n)) : (this._x = e.y * t.z - e.z * t.y, this._y = e.z * t.x - e.x * t.z, this._z = e.x * t.y - e.y * t.x, this._w = n), this.normalize() } angleTo(e) { return 2 * Math.acos(Math.abs(Gn(this.dot(e), -1, 1))) } rotateTowards(e, t) { const n = this.angleTo(e); if (n === 0) return this; const r = Math.min(1, t / n); return this.slerp(e, r), this } identity() { return this.set(0, 0, 0, 1) } invert() { return this.conjugate() } conjugate() { return this._x *= -1, this._y *= -1, this._z *= -1, this._onChangeCallback(), this } dot(e) { return this._x * e._x + this._y * e._y + this._z * e._z + this._w * e._w } lengthSq() { return this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w } length() { return Math.sqrt(this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w) } normalize() { let e = this.length(); return e === 0 ? (this._x = 0, this._y = 0, this._z = 0, this._w = 1) : (e = 1 / e, this._x = this._x * e, this._y = this._y * e, this._z = this._z * e, this._w = this._w * e), this._onChangeCallback(), this } multiply(e) { return this.multiplyQuaternions(this, e) } premultiply(e) { return this.multiplyQuaternions(e, this) } multiplyQuaternions(e, t) { const n = e._x, r = e._y, s = e._z, o = e._w, a = t._x, l = t._y, c = t._z, f = t._w; return this._x = n * f + o * a + r * c - s * l, this._y = r * f + o * l + s * a - n * c, this._z = s * f + o * c + n * l - r * a, this._w = o * f - n * a - r * l - s * c, this._onChangeCallback(), this } slerp(e, t) { if (t === 0) return this; if (t === 1) return this.copy(e); const n = this._x, r = this._y, s = this._z, o = this._w; let a = o * e._w + n * e._x + r * e._y + s * e._z; if (a < 0 ? (this._w = -e._w, this._x = -e._x, this._y = -e._y, this._z = -e._z, a = -a) : this.copy(e), a >= 1) return this._w = o, this._x = n, this._y = r, this._z = s, this; const l = 1 - a * a; if (l <= Number.EPSILON) { const m = 1 - t; return this._w = m * o + t * this._w, this._x = m * n + t * this._x, this._y = m * r + t * this._y, this._z = m * s + t * this._z, this.normalize(), this._onChangeCallback(), this } const c = Math.sqrt(l), f = Math.atan2(c, a), d = Math.sin((1 - t) * f) / c, p = Math.sin(t * f) / c; return this._w = o * d + this._w * p, this._x = n * d + this._x * p, this._y = r * d + this._y * p, this._z = s * d + this._z * p, this._onChangeCallback(), this } slerpQuaternions(e, t, n) { return this.copy(e).slerp(t, n) } random() { const e = Math.random(), t = Math.sqrt(1 - e), n = Math.sqrt(e), r = 2 * Math.PI * Math.random(), s = 2 * Math.PI * Math.random(); return this.set(t * Math.cos(r), n * Math.sin(s), n * Math.cos(s), t * Math.sin(r)) } equals(e) { return e._x === this._x && e._y === this._y && e._z === this._z && e._w === this._w } fromArray(e, t = 0) { return this._x = e[t], this._y = e[t + 1], this._z = e[t + 2], this._w = e[t + 3], this._onChangeCallback(), this } toArray(e = [], t = 0) { return e[t] = this._x, e[t + 1] = this._y, e[t + 2] = this._z, e[t + 3] = this._w, e } fromBufferAttribute(e, t) { return this._x = e.getX(t), this._y = e.getY(t), this._z = e.getZ(t), this._w = e.getW(t), this } toJSON() { return this.toArray() } _onChange(e) { return this._onChangeCallback = e, this } _onChangeCallback() { } *[Symbol.iterator]() { yield this._x, yield this._y, yield this._z, yield this._w } } class k { constructor(e = 0, t = 0, n = 0) { k.prototype.isVector3 = !0, this.x = e, this.y = t, this.z = n } set(e, t, n) { return n === void 0 && (n = this.z), this.x = e, this.y = t, this.z = n, this } setScalar(e) { return this.x = e, this.y = e, this.z = e, this } setX(e) { return this.x = e, this } setY(e) { return this.y = e, this } setZ(e) { return this.z = e, this } setComponent(e, t) { switch (e) { case 0: this.x = t; break; case 1: this.y = t; break; case 2: this.z = t; break; default: throw new Error("index is out of range: " + e) }return this } getComponent(e) { switch (e) { case 0: return this.x; case 1: return this.y; case 2: return this.z; default: throw new Error("index is out of range: " + e) } } clone() { return new this.constructor(this.x, this.y, this.z) } copy(e) { return this.x = e.x, this.y = e.y, this.z = e.z, this } add(e) { return this.x += e.x, this.y += e.y, this.z += e.z, this } addScalar(e) { return this.x += e, this.y += e, this.z += e, this } addVectors(e, t) { return this.x = e.x + t.x, this.y = e.y + t.y, this.z = e.z + t.z, this } addScaledVector(e, t) { return this.x += e.x * t, this.y += e.y * t, this.z += e.z * t, this } sub(e) { return this.x -= e.x, this.y -= e.y, this.z -= e.z, this } subScalar(e) { return this.x -= e, this.y -= e, this.z -= e, this } subVectors(e, t) { return this.x = e.x - t.x, this.y = e.y - t.y, this.z = e.z - t.z, this } multiply(e) { return this.x *= e.x, this.y *= e.y, this.z *= e.z, this } multiplyScalar(e) { return this.x *= e, this.y *= e, this.z *= e, this } multiplyVectors(e, t) { return this.x = e.x * t.x, this.y = e.y * t.y, this.z = e.z * t.z, this } applyEuler(e) { return this.applyQuaternion($R.setFromEuler(e)) } applyAxisAngle(e, t) { return this.applyQuaternion($R.setFromAxisAngle(e, t)) } applyMatrix3(e) { const t = this.x, n = this.y, r = this.z, s = e.elements; return this.x = s[0] * t + s[3] * n + s[6] * r, this.y = s[1] * t + s[4] * n + s[7] * r, this.z = s[2] * t + s[5] * n + s[8] * r, this } applyNormalMatrix(e) { return this.applyMatrix3(e).normalize() } applyMatrix4(e) { const t = this.x, n = this.y, r = this.z, s = e.elements, o = 1 / (s[3] * t + s[7] * n + s[11] * r + s[15]); return this.x = (s[0] * t + s[4] * n + s[8] * r + s[12]) * o, this.y = (s[1] * t + s[5] * n + s[9] * r + s[13]) * o, this.z = (s[2] * t + s[6] * n + s[10] * r + s[14]) * o, this } applyQuaternion(e) { const t = this.x, n = this.y, r = this.z, s = e.x, o = e.y, a = e.z, l = e.w, c = l * t + o * r - a * n, f = l * n + a * t - s * r, d = l * r + s * n - o * t, p = -s * t - o * n - a * r; return this.x = c * l + p * -s + f * -a - d * -o, this.y = f * l + p * -o + d * -s - c * -a, this.z = d * l + p * -a + c * -o - f * -s, this } project(e) { return this.applyMatrix4(e.matrixWorldInverse).applyMatrix4(e.projectionMatrix) } unproject(e) { return this.applyMatrix4(e.projectionMatrixInverse).applyMatrix4(e.matrixWorld) } transformDirection(e) { const t = this.x, n = this.y, r = this.z, s = e.elements; return this.x = s[0] * t + s[4] * n + s[8] * r, this.y = s[1] * t + s[5] * n + s[9] * r, this.z = s[2] * t + s[6] * n + s[10] * r, this.normalize() } divide(e) { return this.x /= e.x, this.y /= e.y, this.z /= e.z, this } divideScalar(e) { return this.multiplyScalar(1 / e) } min(e) { return this.x = Math.min(this.x, e.x), this.y = Math.min(this.y, e.y), this.z = Math.min(this.z, e.z), this } max(e) { return this.x = Math.max(this.x, e.x), this.y = Math.max(this.y, e.y), this.z = Math.max(this.z, e.z), this } clamp(e, t) { return this.x = Math.max(e.x, Math.min(t.x, this.x)), this.y = Math.max(e.y, Math.min(t.y, this.y)), this.z = Math.max(e.z, Math.min(t.z, this.z)), this } clampScalar(e, t) { return this.x = Math.max(e, Math.min(t, this.x)), this.y = Math.max(e, Math.min(t, this.y)), this.z = Math.max(e, Math.min(t, this.z)), this } clampLength(e, t) { const n = this.length(); return this.divideScalar(n || 1).multiplyScalar(Math.max(e, Math.min(t, n))) } floor() { return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this.z = Math.floor(this.z), this } ceil() { return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this.z = Math.ceil(this.z), this } round() { return this.x = Math.round(this.x), this.y = Math.round(this.y), this.z = Math.round(this.z), this } roundToZero() { return this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x), this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y), this.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z), this } negate() { return this.x = -this.x, this.y = -this.y, this.z = -this.z, this } dot(e) { return this.x * e.x + this.y * e.y + this.z * e.z } lengthSq() { return this.x * this.x + this.y * this.y + this.z * this.z } length() { return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z) } manhattanLength() { return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z) } normalize() { return this.divideScalar(this.length() || 1) } setLength(e) { return this.normalize().multiplyScalar(e) } lerp(e, t) { return this.x += (e.x - this.x) * t, this.y += (e.y - this.y) * t, this.z += (e.z - this.z) * t, this } lerpVectors(e, t, n) { return this.x = e.x + (t.x - e.x) * n, this.y = e.y + (t.y - e.y) * n, this.z = e.z + (t.z - e.z) * n, this } cross(e) { return this.crossVectors(this, e) } crossVectors(e, t) { const n = e.x, r = e.y, s = e.z, o = t.x, a = t.y, l = t.z; return this.x = r * l - s * a, this.y = s * o - n * l, this.z = n * a - r * o, this } projectOnVector(e) { const t = e.lengthSq(); if (t === 0) return this.set(0, 0, 0); const n = e.dot(this) / t; return this.copy(e).multiplyScalar(n) } projectOnPlane(e) { return bA.copy(this).projectOnVector(e), this.sub(bA) } reflect(e) { return this.sub(bA.copy(e).multiplyScalar(2 * this.dot(e))) } angleTo(e) { const t = Math.sqrt(this.lengthSq() * e.lengthSq()); if (t === 0) return Math.PI / 2; const n = this.dot(e) / t; return Math.acos(Gn(n, -1, 1)) } distanceTo(e) { return Math.sqrt(this.distanceToSquared(e)) } distanceToSquared(e) { const t = this.x - e.x, n = this.y - e.y, r = this.z - e.z; return t * t + n * n + r * r } manhattanDistanceTo(e) { return Math.abs(this.x - e.x) + Math.abs(this.y - e.y) + Math.abs(this.z - e.z) } setFromSpherical(e) { return this.setFromSphericalCoords(e.radius, e.phi, e.theta) } setFromSphericalCoords(e, t, n) { const r = Math.sin(t) * e; return this.x = r * Math.sin(n), this.y = Math.cos(t) * e, this.z = r * Math.cos(n), this } setFromCylindrical(e) { return this.setFromCylindricalCoords(e.radius, e.theta, e.y) } setFromCylindricalCoords(e, t, n) { return this.x = e * Math.sin(t), this.y = n, this.z = e * Math.cos(t), this } setFromMatrixPosition(e) { const t = e.elements; return this.x = t[12], this.y = t[13], this.z = t[14], this } setFromMatrixScale(e) { const t = this.setFromMatrixColumn(e, 0).length(), n = this.setFromMatrixColumn(e, 1).length(), r = this.setFromMatrixColumn(e, 2).length(); return this.x = t, this.y = n, this.z = r, this } setFromMatrixColumn(e, t) { return this.fromArray(e.elements, t * 4) } setFromMatrix3Column(e, t) { return this.fromArray(e.elements, t * 3) } setFromEuler(e) { return this.x = e._x, this.y = e._y, this.z = e._z, this } setFromColor(e) { return this.x = e.r, this.y = e.g, this.z = e.b, this } equals(e) { return e.x === this.x && e.y === this.y && e.z === this.z } fromArray(e, t = 0) { return this.x = e[t], this.y = e[t + 1], this.z = e[t + 2], this } toArray(e = [], t = 0) { return e[t] = this.x, e[t + 1] = this.y, e[t + 2] = this.z, e } fromBufferAttribute(e, t) { return this.x = e.getX(t), this.y = e.getY(t), this.z = e.getZ(t), this } random() { return this.x = Math.random(), this.y = Math.random(), this.z = Math.random(), this } randomDirection() { const e = (Math.random() - .5) * 2, t = Math.random() * Math.PI * 2, n = Math.sqrt(1 - e ** 2); return this.x = n * Math.cos(t), this.y = n * Math.sin(t), this.z = e, this } *[Symbol.iterator]() { yield this.x, yield this.y, yield this.z } } const bA = new k, $R = new Ti; class yo { constructor(e = new k(1 / 0, 1 / 0, 1 / 0), t = new k(-1 / 0, -1 / 0, -1 / 0)) { this.isBox3 = !0, this.min = e, this.max = t } set(e, t) { return this.min.copy(e), this.max.copy(t), this } setFromArray(e) { this.makeEmpty(); for (let t = 0, n = e.length; t < n; t += 3)this.expandByPoint(ra.fromArray(e, t)); return this } setFromBufferAttribute(e) { this.makeEmpty(); for (let t = 0, n = e.count; t < n; t++)this.expandByPoint(ra.fromBufferAttribute(e, t)); return this } setFromPoints(e) { this.makeEmpty(); for (let t = 0, n = e.length; t < n; t++)this.expandByPoint(e[t]); return this } setFromCenterAndSize(e, t) { const n = ra.copy(t).multiplyScalar(.5); return this.min.copy(e).sub(n), this.max.copy(e).add(n), this } setFromObject(e, t = !1) { return this.makeEmpty(), this.expandByObject(e, t) } clone() { return new this.constructor().copy(this) } copy(e) { return this.min.copy(e.min), this.max.copy(e.max), this } makeEmpty() { return this.min.x = this.min.y = this.min.z = 1 / 0, this.max.x = this.max.y = this.max.z = -1 / 0, this } isEmpty() { return this.max.x < this.min.x || this.max.y < this.min.y || this.max.z < this.min.z } getCenter(e) { return this.isEmpty() ? e.set(0, 0, 0) : e.addVectors(this.min, this.max).multiplyScalar(.5) } getSize(e) { return this.isEmpty() ? e.set(0, 0, 0) : e.subVectors(this.max, this.min) } expandByPoint(e) { return this.min.min(e), this.max.max(e), this } expandByVector(e) { return this.min.sub(e), this.max.add(e), this } expandByScalar(e) { return this.min.addScalar(-e), this.max.addScalar(e), this } expandByObject(e, t = !1) { if (e.updateWorldMatrix(!1, !1), e.boundingBox !== void 0) e.boundingBox === null && e.computeBoundingBox(), Nu.copy(e.boundingBox), Nu.applyMatrix4(e.matrixWorld), this.union(Nu); else { const r = e.geometry; if (r !== void 0) if (t && r.attributes !== void 0 && r.attributes.position !== void 0) { const s = r.attributes.position; for (let o = 0, a = s.count; o < a; o++)ra.fromBufferAttribute(s, o).applyMatrix4(e.matrixWorld), this.expandByPoint(ra) } else r.boundingBox === null && r.computeBoundingBox(), Nu.copy(r.boundingBox), Nu.applyMatrix4(e.matrixWorld), this.union(Nu) } const n = e.children; for (let r = 0, s = n.length; r < s; r++)this.expandByObject(n[r], t); return this } containsPoint(e) { return !(e.x < this.min.x || e.x > this.max.x || e.y < this.min.y || e.y > this.max.y || e.z < this.min.z || e.z > this.max.z) } containsBox(e) { return this.min.x <= e.min.x && e.max.x <= this.max.x && this.min.y <= e.min.y && e.max.y <= this.max.y && this.min.z <= e.min.z && e.max.z <= this.max.z } getParameter(e, t) { return t.set((e.x - this.min.x) / (this.max.x - this.min.x), (e.y - this.min.y) / (this.max.y - this.min.y), (e.z - this.min.z) / (this.max.z - this.min.z)) } intersectsBox(e) { return !(e.max.x < this.min.x || e.min.x > this.max.x || e.max.y < this.min.y || e.min.y > this.max.y || e.max.z < this.min.z || e.min.z > this.max.z) } intersectsSphere(e) { return this.clampPoint(e.center, ra), ra.distanceToSquared(e.center) <= e.radius * e.radius } intersectsPlane(e) { let t, n; return e.normal.x > 0 ? (t = e.normal.x * this.min.x, n = e.normal.x * this.max.x) : (t = e.normal.x * this.max.x, n = e.normal.x * this.min.x), e.normal.y > 0 ? (t += e.normal.y * this.min.y, n += e.normal.y * this.max.y) : (t += e.normal.y * this.max.y, n += e.normal.y * this.min.y), e.normal.z > 0 ? (t += e.normal.z * this.min.z, n += e.normal.z * this.max.z) : (t += e.normal.z * this.max.z, n += e.normal.z * this.min.z), t <= -e.constant && n >= -e.constant } intersectsTriangle(e) { if (this.isEmpty()) return !1; this.getCenter(fd), Gg.subVectors(this.max, fd), Uu.subVectors(e.a, fd), zu.subVectors(e.b, fd), Hu.subVectors(e.c, fd), Ya.subVectors(zu, Uu), ja.subVectors(Hu, zu), oc.subVectors(Uu, Hu); let t = [0, -Ya.z, Ya.y, 0, -ja.z, ja.y, 0, -oc.z, oc.y, Ya.z, 0, -Ya.x, ja.z, 0, -ja.x, oc.z, 0, -oc.x, -Ya.y, Ya.x, 0, -ja.y, ja.x, 0, -oc.y, oc.x, 0]; return !RA(t, Uu, zu, Hu, Gg) || (t = [1, 0, 0, 0, 1, 0, 0, 0, 1], !RA(t, Uu, zu, Hu, Gg)) ? !1 : (Vg.crossVectors(Ya, ja), t = [Vg.x, Vg.y, Vg.z], RA(t, Uu, zu, Hu, Gg)) } clampPoint(e, t) { return t.copy(e).clamp(this.min, this.max) } distanceToPoint(e) { return this.clampPoint(e, ra).distanceTo(e) } getBoundingSphere(e) { return this.isEmpty() ? e.makeEmpty() : (this.getCenter(e.center), e.radius = this.getSize(ra).length() * .5), e } intersect(e) { return this.min.max(e.min), this.max.min(e.max), this.isEmpty() && this.makeEmpty(), this } union(e) { return this.min.min(e.min), this.max.max(e.max), this } applyMatrix4(e) { return this.isEmpty() ? this : (ia[0].set(this.min.x, this.min.y, this.min.z).applyMatrix4(e), ia[1].set(this.min.x, this.min.y, this.max.z).applyMatrix4(e), ia[2].set(this.min.x, this.max.y, this.min.z).applyMatrix4(e), ia[3].set(this.min.x, this.max.y, this.max.z).applyMatrix4(e), ia[4].set(this.max.x, this.min.y, this.min.z).applyMatrix4(e), ia[5].set(this.max.x, this.min.y, this.max.z).applyMatrix4(e), ia[6].set(this.max.x, this.max.y, this.min.z).applyMatrix4(e), ia[7].set(this.max.x, this.max.y, this.max.z).applyMatrix4(e), this.setFromPoints(ia), this) } translate(e) { return this.min.add(e), this.max.add(e), this } equals(e) { return e.min.equals(this.min) && e.max.equals(this.max) } } const ia = [new k, new k, new k, new k, new k, new k, new k, new k], ra = new k, Nu = new yo, Uu = new k, zu = new k, Hu = new k, Ya = new k, ja = new k, oc = new k, fd = new k, Gg = new k, Vg = new k, ac = new k; function RA(i, e, t, n, r) { for (let s = 0, o = i.length - 3; s <= o; s += 3) { ac.fromArray(i, s); const a = r.x * Math.abs(ac.x) + r.y * Math.abs(ac.y) + r.z * Math.abs(ac.z), l = e.dot(ac), c = t.dot(ac), f = n.dot(ac); if (Math.max(-Math.max(l, c, f), Math.min(l, c, f)) > a) return !1 } return !0 } const OW = new yo, hd = new k, PA = new k; class Gs { constructor(e = new k, t = -1) { this.center = e, this.radius = t } set(e, t) { return this.center.copy(e), this.radius = t, this } setFromPoints(e, t) { const n = this.center; t !== void 0 ? n.copy(t) : OW.setFromPoints(e).getCenter(n); let r = 0; for (let s = 0, o = e.length; s < o; s++)r = Math.max(r, n.distanceToSquared(e[s])); return this.radius = Math.sqrt(r), this } copy(e) { return this.center.copy(e.center), this.radius = e.radius, this } isEmpty() { return this.radius < 0 } makeEmpty() { return this.center.set(0, 0, 0), this.radius = -1, this } containsPoint(e) { return e.distanceToSquared(this.center) <= this.radius * this.radius } distanceToPoint(e) { return e.distanceTo(this.center) - this.radius } intersectsSphere(e) { const t = this.radius + e.radius; return e.center.distanceToSquared(this.center) <= t * t } intersectsBox(e) { return e.intersectsSphere(this) } intersectsPlane(e) { return Math.abs(e.distanceToPoint(this.center)) <= this.radius } clampPoint(e, t) { const n = this.center.distanceToSquared(e); return t.copy(e), n > this.radius * this.radius && (t.sub(this.center).normalize(), t.multiplyScalar(this.radius).add(this.center)), t } getBoundingBox(e) { return this.isEmpty() ? (e.makeEmpty(), e) : (e.set(this.center, this.center), e.expandByScalar(this.radius), e) } applyMatrix4(e) { return this.center.applyMatrix4(e), this.radius = this.radius * e.getMaxScaleOnAxis(), this } translate(e) { return this.center.add(e), this } expandByPoint(e) { if (this.isEmpty()) return this.center.copy(e), this.radius = 0, this; hd.subVectors(e, this.center); const t = hd.lengthSq(); if (t > this.radius * this.radius) { const n = Math.sqrt(t), r = (n - this.radius) * .5; this.center.addScaledVector(hd, r / n), this.radius += r } return this } union(e) { return e.isEmpty() ? this : this.isEmpty() ? (this.copy(e), this) : (this.center.equals(e.center) === !0 ? this.radius = Math.max(this.radius, e.radius) : (PA.subVectors(e.center, this.center).setLength(e.radius), this.expandByPoint(hd.copy(e.center).add(PA)), this.expandByPoint(hd.copy(e.center).sub(PA))), this) } equals(e) { return e.center.equals(this.center) && e.radius === this.radius } clone() { return new this.constructor().copy(this) } } const sa = new k, IA = new k, Wg = new k, Ka = new k, BA = new k, Xg = new k, LA = new k; class Ph { constructor(e = new k, t = new k(0, 0, -1)) { this.origin = e, this.direction = t } set(e, t) { return this.origin.copy(e), this.direction.copy(t), this } copy(e) { return this.origin.copy(e.origin), this.direction.copy(e.direction), this } at(e, t) { return t.copy(this.origin).addScaledVector(this.direction, e) } lookAt(e) { return this.direction.copy(e).sub(this.origin).normalize(), this } recast(e) { return this.origin.copy(this.at(e, sa)), this } closestPointToPoint(e, t) { t.subVectors(e, this.origin); const n = t.dot(this.direction); return n < 0 ? t.copy(this.origin) : t.copy(this.origin).addScaledVector(this.direction, n) } distanceToPoint(e) { return Math.sqrt(this.distanceSqToPoint(e)) } distanceSqToPoint(e) { const t = sa.subVectors(e, this.origin).dot(this.direction); return t < 0 ? this.origin.distanceToSquared(e) : (sa.copy(this.origin).addScaledVector(this.direction, t), sa.distanceToSquared(e)) } distanceSqToSegment(e, t, n, r) { IA.copy(e).add(t).multiplyScalar(.5), Wg.copy(t).sub(e).normalize(), Ka.copy(this.origin).sub(IA); const s = e.distanceTo(t) * .5, o = -this.direction.dot(Wg), a = Ka.dot(this.direction), l = -Ka.dot(Wg), c = Ka.lengthSq(), f = Math.abs(1 - o * o); let d, p, m, y; if (f > 0) if (d = o * l - a, p = o * a - l, y = s * f, d >= 0) if (p >= -y) if (p <= y) { const _ = 1 / f; d *= _, p *= _, m = d * (d + o * p + 2 * a) + p * (o * d + p + 2 * l) + c } else p = s, d = Math.max(0, -(o * p + a)), m = -d * d + p * (p + 2 * l) + c; else p = -s, d = Math.max(0, -(o * p + a)), m = -d * d + p * (p + 2 * l) + c; else p <= -y ? (d = Math.max(0, -(-o * s + a)), p = d > 0 ? -s : Math.min(Math.max(-s, -l), s), m = -d * d + p * (p + 2 * l) + c) : p <= y ? (d = 0, p = Math.min(Math.max(-s, -l), s), m = p * (p + 2 * l) + c) : (d = Math.max(0, -(o * s + a)), p = d > 0 ? s : Math.min(Math.max(-s, -l), s), m = -d * d + p * (p + 2 * l) + c); else p = o > 0 ? -s : s, d = Math.max(0, -(o * p + a)), m = -d * d + p * (p + 2 * l) + c; return n && n.copy(this.origin).addScaledVector(this.direction, d), r && r.copy(IA).addScaledVector(Wg, p), m } intersectSphere(e, t) { sa.subVectors(e.center, this.origin); const n = sa.dot(this.direction), r = sa.dot(sa) - n * n, s = e.radius * e.radius; if (r > s) return null; const o = Math.sqrt(s - r), a = n - o, l = n + o; return l < 0 ? null : a < 0 ? this.at(l, t) : this.at(a, t) } intersectsSphere(e) { return this.distanceSqToPoint(e.center) <= e.radius * e.radius } distanceToPlane(e) { const t = e.normal.dot(this.direction); if (t === 0) return e.distanceToPoint(this.origin) === 0 ? 0 : null; const n = -(this.origin.dot(e.normal) + e.constant) / t; return n >= 0 ? n : null } intersectPlane(e, t) { const n = this.distanceToPlane(e); return n === null ? null : this.at(n, t) } intersectsPlane(e) { const t = e.distanceToPoint(this.origin); return t === 0 || e.normal.dot(this.direction) * t < 0 } intersectBox(e, t) { let n, r, s, o, a, l; const c = 1 / this.direction.x, f = 1 / this.direction.y, d = 1 / this.direction.z, p = this.origin; return c >= 0 ? (n = (e.min.x - p.x) * c, r = (e.max.x - p.x) * c) : (n = (e.max.x - p.x) * c, r = (e.min.x - p.x) * c), f >= 0 ? (s = (e.min.y - p.y) * f, o = (e.max.y - p.y) * f) : (s = (e.max.y - p.y) * f, o = (e.min.y - p.y) * f), n > o || s > r || ((s > n || isNaN(n)) && (n = s), (o < r || isNaN(r)) && (r = o), d >= 0 ? (a = (e.min.z - p.z) * d, l = (e.max.z - p.z) * d) : (a = (e.max.z - p.z) * d, l = (e.min.z - p.z) * d), n > l || a > r) || ((a > n || n !== n) && (n = a), (l < r || r !== r) && (r = l), r < 0) ? null : this.at(n >= 0 ? n : r, t) } intersectsBox(e) { return this.intersectBox(e, sa) !== null } intersectTriangle(e, t, n, r, s) { BA.subVectors(t, e), Xg.subVectors(n, e), LA.crossVectors(BA, Xg); let o = this.direction.dot(LA), a; if (o > 0) { if (r) return null; a = 1 } else if (o < 0) a = -1, o = -o; else return null; Ka.subVectors(this.origin, e); const l = a * this.direction.dot(Xg.crossVectors(Ka, Xg)); if (l < 0) return null; const c = a * this.direction.dot(BA.cross(Ka)); if (c < 0 || l + c > o) return null; const f = -a * Ka.dot(LA); return f < 0 ? null : this.at(f / o, s) } applyMatrix4(e) { return this.origin.applyMatrix4(e), this.direction.transformDirection(e), this } equals(e) { return e.origin.equals(this.origin) && e.direction.equals(this.direction) } clone() { return new this.constructor().copy(this) } } class yt { constructor(e, t, n, r, s, o, a, l, c, f, d, p, m, y, _, x) { yt.prototype.isMatrix4 = !0, this.elements = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1], e !== void 0 && this.set(e, t, n, r, s, o, a, l, c, f, d, p, m, y, _, x) } set(e, t, n, r, s, o, a, l, c, f, d, p, m, y, _, x) { const g = this.elements; return g[0] = e, g[4] = t, g[8] = n, g[12] = r, g[1] = s, g[5] = o, g[9] = a, g[13] = l, g[2] = c, g[6] = f, g[10] = d, g[14] = p, g[3] = m, g[7] = y, g[11] = _, g[15] = x, this } identity() { return this.set(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this } clone() { return new yt().fromArray(this.elements) } copy(e) { const t = this.elements, n = e.elements; return t[0] = n[0], t[1] = n[1], t[2] = n[2], t[3] = n[3], t[4] = n[4], t[5] = n[5], t[6] = n[6], t[7] = n[7], t[8] = n[8], t[9] = n[9], t[10] = n[10], t[11] = n[11], t[12] = n[12], t[13] = n[13], t[14] = n[14], t[15] = n[15], this } copyPosition(e) { const t = this.elements, n = e.elements; return t[12] = n[12], t[13] = n[13], t[14] = n[14], this } setFromMatrix3(e) { const t = e.elements; return this.set(t[0], t[3], t[6], 0, t[1], t[4], t[7], 0, t[2], t[5], t[8], 0, 0, 0, 0, 1), this } extractBasis(e, t, n) { return e.setFromMatrixColumn(this, 0), t.setFromMatrixColumn(this, 1), n.setFromMatrixColumn(this, 2), this } makeBasis(e, t, n) { return this.set(e.x, t.x, n.x, 0, e.y, t.y, n.y, 0, e.z, t.z, n.z, 0, 0, 0, 0, 1), this } extractRotation(e) { const t = this.elements, n = e.elements, r = 1 / Gu.setFromMatrixColumn(e, 0).length(), s = 1 / Gu.setFromMatrixColumn(e, 1).length(), o = 1 / Gu.setFromMatrixColumn(e, 2).length(); return t[0] = n[0] * r, t[1] = n[1] * r, t[2] = n[2] * r, t[3] = 0, t[4] = n[4] * s, t[5] = n[5] * s, t[6] = n[6] * s, t[7] = 0, t[8] = n[8] * o, t[9] = n[9] * o, t[10] = n[10] * o, t[11] = 0, t[12] = 0, t[13] = 0, t[14] = 0, t[15] = 1, this } makeRotationFromEuler(e) { const t = this.elements, n = e.x, r = e.y, s = e.z, o = Math.cos(n), a = Math.sin(n), l = Math.cos(r), c = Math.sin(r), f = Math.cos(s), d = Math.sin(s); if (e.order === "XYZ") { const p = o * f, m = o * d, y = a * f, _ = a * d; t[0] = l * f, t[4] = -l * d, t[8] = c, t[1] = m + y * c, t[5] = p - _ * c, t[9] = -a * l, t[2] = _ - p * c, t[6] = y + m * c, t[10] = o * l } else if (e.order === "YXZ") { const p = l * f, m = l * d, y = c * f, _ = c * d; t[0] = p + _ * a, t[4] = y * a - m, t[8] = o * c, t[1] = o * d, t[5] = o * f, t[9] = -a, t[2] = m * a - y, t[6] = _ + p * a, t[10] = o * l } else if (e.order === "ZXY") { const p = l * f, m = l * d, y = c * f, _ = c * d; t[0] = p - _ * a, t[4] = -o * d, t[8] = y + m * a, t[1] = m + y * a, t[5] = o * f, t[9] = _ - p * a, t[2] = -o * c, t[6] = a, t[10] = o * l } else if (e.order === "ZYX") { const p = o * f, m = o * d, y = a * f, _ = a * d; t[0] = l * f, t[4] = y * c - m, t[8] = p * c + _, t[1] = l * d, t[5] = _ * c + p, t[9] = m * c - y, t[2] = -c, t[6] = a * l, t[10] = o * l } else if (e.order === "YZX") { const p = o * l, m = o * c, y = a * l, _ = a * c; t[0] = l * f, t[4] = _ - p * d, t[8] = y * d + m, t[1] = d, t[5] = o * f, t[9] = -a * f, t[2] = -c * f, t[6] = m * d + y, t[10] = p - _ * d } else if (e.order === "XZY") { const p = o * l, m = o * c, y = a * l, _ = a * c; t[0] = l * f, t[4] = -d, t[8] = c * f, t[1] = p * d + _, t[5] = o * f, t[9] = m * d - y, t[2] = y * d - m, t[6] = a * f, t[10] = _ * d + p } return t[3] = 0, t[7] = 0, t[11] = 0, t[12] = 0, t[13] = 0, t[14] = 0, t[15] = 1, this } makeRotationFromQuaternion(e) { return this.compose(FW, e, kW) } lookAt(e, t, n) { const r = this.elements; return Wr.subVectors(e, t), Wr.lengthSq() === 0 && (Wr.z = 1), Wr.normalize(), qa.crossVectors(n, Wr), qa.lengthSq() === 0 && (Math.abs(n.z) === 1 ? Wr.x += 1e-4 : Wr.z += 1e-4, Wr.normalize(), qa.crossVectors(n, Wr)), qa.normalize(), Jg.crossVectors(Wr, qa), r[0] = qa.x, r[4] = Jg.x, r[8] = Wr.x, r[1] = qa.y, r[5] = Jg.y, r[9] = Wr.y, r[2] = qa.z, r[6] = Jg.z, r[10] = Wr.z, this } multiply(e) { return this.multiplyMatrices(this, e) } premultiply(e) { return this.multiplyMatrices(e, this) } multiplyMatrices(e, t) { const n = e.elements, r = t.elements, s = this.elements, o = n[0], a = n[4], l = n[8], c = n[12], f = n[1], d = n[5], p = n[9], m = n[13], y = n[2], _ = n[6], x = n[10], g = n[14], A = n[3], M = n[7], S = n[11], C = n[15], T = r[0], R = r[4], B = r[8], b = r[12], I = r[1], N = r[5], V = r[9], J = r[13], j = r[2], q = r[6], ne = r[10], Q = r[14], F = r[3], Y = r[7], L = r[11], G = r[15]; return s[0] = o * T + a * I + l * j + c * F, s[4] = o * R + a * N + l * q + c * Y, s[8] = o * B + a * V + l * ne + c * L, s[12] = o * b + a * J + l * Q + c * G, s[1] = f * T + d * I + p * j + m * F, s[5] = f * R + d * N + p * q + m * Y, s[9] = f * B + d * V + p * ne + m * L, s[13] = f * b + d * J + p * Q + m * G, s[2] = y * T + _ * I + x * j + g * F, s[6] = y * R + _ * N + x * q + g * Y, s[10] = y * B + _ * V + x * ne + g * L, s[14] = y * b + _ * J + x * Q + g * G, s[3] = A * T + M * I + S * j + C * F, s[7] = A * R + M * N + S * q + C * Y, s[11] = A * B + M * V + S * ne + C * L, s[15] = A * b + M * J + S * Q + C * G, this } multiplyScalar(e) { const t = this.elements; return t[0] *= e, t[4] *= e, t[8] *= e, t[12] *= e, t[1] *= e, t[5] *= e, t[9] *= e, t[13] *= e, t[2] *= e, t[6] *= e, t[10] *= e, t[14] *= e, t[3] *= e, t[7] *= e, t[11] *= e, t[15] *= e, this } determinant() { const e = this.elements, t = e[0], n = e[4], r = e[8], s = e[12], o = e[1], a = e[5], l = e[9], c = e[13], f = e[2], d = e[6], p = e[10], m = e[14], y = e[3], _ = e[7], x = e[11], g = e[15]; return y * (+s * l * d - r * c * d - s * a * p + n * c * p + r * a * m - n * l * m) + _ * (+t * l * m - t * c * p + s * o * p - r * o * m + r * c * f - s * l * f) + x * (+t * c * d - t * a * m - s * o * d + n * o * m + s * a * f - n * c * f) + g * (-r * a * f - t * l * d + t * a * p + r * o * d - n * o * p + n * l * f) } transpose() { const e = this.elements; let t; return t = e[1], e[1] = e[4], e[4] = t, t = e[2], e[2] = e[8], e[8] = t, t = e[6], e[6] = e[9], e[9] = t, t = e[3], e[3] = e[12], e[12] = t, t = e[7], e[7] = e[13], e[13] = t, t = e[11], e[11] = e[14], e[14] = t, this } setPosition(e, t, n) { const r = this.elements; return e.isVector3 ? (r[12] = e.x, r[13] = e.y, r[14] = e.z) : (r[12] = e, r[13] = t, r[14] = n), this } invert() { const e = this.elements, t = e[0], n = e[1], r = e[2], s = e[3], o = e[4], a = e[5], l = e[6], c = e[7], f = e[8], d = e[9], p = e[10], m = e[11], y = e[12], _ = e[13], x = e[14], g = e[15], A = d * x * c - _ * p * c + _ * l * m - a * x * m - d * l * g + a * p * g, M = y * p * c - f * x * c - y * l * m + o * x * m + f * l * g - o * p * g, S = f * _ * c - y * d * c + y * a * m - o * _ * m - f * a * g + o * d * g, C = y * d * l - f * _ * l - y * a * p + o * _ * p + f * a * x - o * d * x, T = t * A + n * M + r * S + s * C; if (T === 0) return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0); const R = 1 / T; return e[0] = A * R, e[1] = (_ * p * s - d * x * s - _ * r * m + n * x * m + d * r * g - n * p * g) * R, e[2] = (a * x * s - _ * l * s + _ * r * c - n * x * c - a * r * g + n * l * g) * R, e[3] = (d * l * s - a * p * s - d * r * c + n * p * c + a * r * m - n * l * m) * R, e[4] = M * R, e[5] = (f * x * s - y * p * s + y * r * m - t * x * m - f * r * g + t * p * g) * R, e[6] = (y * l * s - o * x * s - y * r * c + t * x * c + o * r * g - t * l * g) * R, e[7] = (o * p * s - f * l * s + f * r * c - t * p * c - o * r * m + t * l * m) * R, e[8] = S * R, e[9] = (y * d * s - f * _ * s - y * n * m + t * _ * m + f * n * g - t * d * g) * R, e[10] = (o * _ * s - y * a * s + y * n * c - t * _ * c - o * n * g + t * a * g) * R, e[11] = (f * a * s - o * d * s - f * n * c + t * d * c + o * n * m - t * a * m) * R, e[12] = C * R, e[13] = (f * _ * r - y * d * r + y * n * p - t * _ * p - f * n * x + t * d * x) * R, e[14] = (y * a * r - o * _ * r - y * n * l + t * _ * l + o * n * x - t * a * x) * R, e[15] = (o * d * r - f * a * r + f * n * l - t * d * l - o * n * p + t * a * p) * R, this } scale(e) { const t = this.elements, n = e.x, r = e.y, s = e.z; return t[0] *= n, t[4] *= r, t[8] *= s, t[1] *= n, t[5] *= r, t[9] *= s, t[2] *= n, t[6] *= r, t[10] *= s, t[3] *= n, t[7] *= r, t[11] *= s, this } getMaxScaleOnAxis() { const e = this.elements, t = e[0] * e[0] + e[1] * e[1] + e[2] * e[2], n = e[4] * e[4] + e[5] * e[5] + e[6] * e[6], r = e[8] * e[8] + e[9] * e[9] + e[10] * e[10]; return Math.sqrt(Math.max(t, n, r)) } makeTranslation(e, t, n) { return e.isVector3 ? this.set(1, 0, 0, e.x, 0, 1, 0, e.y, 0, 0, 1, e.z, 0, 0, 0, 1) : this.set(1, 0, 0, e, 0, 1, 0, t, 0, 0, 1, n, 0, 0, 0, 1), this } makeRotationX(e) { const t = Math.cos(e), n = Math.sin(e); return this.set(1, 0, 0, 0, 0, t, -n, 0, 0, n, t, 0, 0, 0, 0, 1), this } makeRotationY(e) { const t = Math.cos(e), n = Math.sin(e); return this.set(t, 0, n, 0, 0, 1, 0, 0, -n, 0, t, 0, 0, 0, 0, 1), this } makeRotationZ(e) { const t = Math.cos(e), n = Math.sin(e); return this.set(t, -n, 0, 0, n, t, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this } makeRotationAxis(e, t) { const n = Math.cos(t), r = Math.sin(t), s = 1 - n, o = e.x, a = e.y, l = e.z, c = s * o, f = s * a; return this.set(c * o + n, c * a - r * l, c * l + r * a, 0, c * a + r * l, f * a + n, f * l - r * o, 0, c * l - r * a, f * l + r * o, s * l * l + n, 0, 0, 0, 0, 1), this } makeScale(e, t, n) { return this.set(e, 0, 0, 0, 0, t, 0, 0, 0, 0, n, 0, 0, 0, 0, 1), this } makeShear(e, t, n, r, s, o) { return this.set(1, n, s, 0, e, 1, o, 0, t, r, 1, 0, 0, 0, 0, 1), this } compose(e, t, n) { const r = this.elements, s = t._x, o = t._y, a = t._z, l = t._w, c = s + s, f = o + o, d = a + a, p = s * c, m = s * f, y = s * d, _ = o * f, x = o * d, g = a * d, A = l * c, M = l * f, S = l * d, C = n.x, T = n.y, R = n.z; return r[0] = (1 - (_ + g)) * C, r[1] = (m + S) * C, r[2] = (y - M) * C, r[3] = 0, r[4] = (m - S) * T, r[5] = (1 - (p + g)) * T, r[6] = (x + A) * T, r[7] = 0, r[8] = (y + M) * R, r[9] = (x - A) * R, r[10] = (1 - (p + _)) * R, r[11] = 0, r[12] = e.x, r[13] = e.y, r[14] = e.z, r[15] = 1, this } decompose(e, t, n) { const r = this.elements; let s = Gu.set(r[0], r[1], r[2]).length(); const o = Gu.set(r[4], r[5], r[6]).length(), a = Gu.set(r[8], r[9], r[10]).length(); this.determinant() < 0 && (s = -s), e.x = r[12], e.y = r[13], e.z = r[14], js.copy(this); const c = 1 / s, f = 1 / o, d = 1 / a; return js.elements[0] *= c, js.elements[1] *= c, js.elements[2] *= c, js.elements[4] *= f, js.elements[5] *= f, js.elements[6] *= f, js.elements[8] *= d, js.elements[9] *= d, js.elements[10] *= d, t.setFromRotationMatrix(js), n.x = s, n.y = o, n.z = a, this } makePerspective(e, t, n, r, s, o, a = Oo) { const l = this.elements, c = 2 * s / (t - e), f = 2 * s / (n - r), d = (t + e) / (t - e), p = (n + r) / (n - r); let m, y; if (a === Oo) m = -(o + s) / (o - s), y = -2 * o * s / (o - s); else if (a === Hp) m = -o / (o - s), y = -o * s / (o - s); else throw new Error("THREE.Matrix4.makePerspective(): Invalid coordinate system: " + a); return l[0] = c, l[4] = 0, l[8] = d, l[12] = 0, l[1] = 0, l[5] = f, l[9] = p, l[13] = 0, l[2] = 0, l[6] = 0, l[10] = m, l[14] = y, l[3] = 0, l[7] = 0, l[11] = -1, l[15] = 0, this } makeOrthographic(e, t, n, r, s, o, a = Oo) { const l = this.elements, c = 1 / (t - e), f = 1 / (n - r), d = 1 / (o - s), p = (t + e) * c, m = (n + r) * f; let y, _; if (a === Oo) y = (o + s) * d, _ = -2 * d; else if (a === Hp) y = s * d, _ = -1 * d; else throw new Error("THREE.Matrix4.makeOrthographic(): Invalid coordinate system: " + a); return l[0] = 2 * c, l[4] = 0, l[8] = 0, l[12] = -p, l[1] = 0, l[5] = 2 * f, l[9] = 0, l[13] = -m, l[2] = 0, l[6] = 0, l[10] = _, l[14] = -y, l[3] = 0, l[7] = 0, l[11] = 0, l[15] = 1, this } equals(e) { const t = this.elements, n = e.elements; for (let r = 0; r < 16; r++)if (t[r] !== n[r]) return !1; return !0 } fromArray(e, t = 0) { for (let n = 0; n < 16; n++)this.elements[n] = e[n + t]; return this } toArray(e = [], t = 0) { const n = this.elements; return e[t] = n[0], e[t + 1] = n[1], e[t + 2] = n[2], e[t + 3] = n[3], e[t + 4] = n[4], e[t + 5] = n[5], e[t + 6] = n[6], e[t + 7] = n[7], e[t + 8] = n[8], e[t + 9] = n[9], e[t + 10] = n[10], e[t + 11] = n[11], e[t + 12] = n[12], e[t + 13] = n[13], e[t + 14] = n[14], e[t + 15] = n[15], e } } const Gu = new k, js = new yt, FW = new k(0, 0, 0), kW = new k(1, 1, 1), qa = new k, Jg = new k, Wr = new k, eP = new yt, tP = new Ti; class om { constructor(e = 0, t = 0, n = 0, r = om.DEFAULT_ORDER) { this.isEuler = !0, this._x = e, this._y = t, this._z = n, this._order = r } get x() { return this._x } set x(e) { this._x = e, this._onChangeCallback() } get y() { return this._y } set y(e) { this._y = e, this._onChangeCallback() } get z() { return this._z } set z(e) { this._z = e, this._onChangeCallback() } get order() { return this._order } set order(e) { this._order = e, this._onChangeCallback() } set(e, t, n, r = this._order) { return this._x = e, this._y = t, this._z = n, this._order = r, this._onChangeCallback(), this } clone() { return new this.constructor(this._x, this._y, this._z, this._order) } copy(e) { return this._x = e._x, this._y = e._y, this._z = e._z, this._order = e._order, this._onChangeCallback(), this } setFromRotationMatrix(e, t = this._order, n = !0) { const r = e.elements, s = r[0], o = r[4], a = r[8], l = r[1], c = r[5], f = r[9], d = r[2], p = r[6], m = r[10]; switch (t) { case "XYZ": this._y = Math.asin(Gn(a, -1, 1)), Math.abs(a) < .9999999 ? (this._x = Math.atan2(-f, m), this._z = Math.atan2(-o, s)) : (this._x = Math.atan2(p, c), this._z = 0); break; case "YXZ": this._x = Math.asin(-Gn(f, -1, 1)), Math.abs(f) < .9999999 ? (this._y = Math.atan2(a, m), this._z = Math.atan2(l, c)) : (this._y = Math.atan2(-d, s), this._z = 0); break; case "ZXY": this._x = Math.asin(Gn(p, -1, 1)), Math.abs(p) < .9999999 ? (this._y = Math.atan2(-d, m), this._z = Math.atan2(-o, c)) : (this._y = 0, this._z = Math.atan2(l, s)); break; case "ZYX": this._y = Math.asin(-Gn(d, -1, 1)), Math.abs(d) < .9999999 ? (this._x = Math.atan2(p, m), this._z = Math.atan2(l, s)) : (this._x = 0, this._z = Math.atan2(-o, c)); break; case "YZX": this._z = Math.asin(Gn(l, -1, 1)), Math.abs(l) < .9999999 ? (this._x = Math.atan2(-f, c), this._y = Math.atan2(-d, s)) : (this._x = 0, this._y = Math.atan2(a, m)); break; case "XZY": this._z = Math.asin(-Gn(o, -1, 1)), Math.abs(o) < .9999999 ? (this._x = Math.atan2(p, c), this._y = Math.atan2(a, s)) : (this._x = Math.atan2(-f, m), this._y = 0); break; default: console.warn("THREE.Euler: .setFromRotationMatrix() encountered an unknown order: " + t) }return this._order = t, n === !0 && this._onChangeCallback(), this } setFromQuaternion(e, t, n) { return eP.makeRotationFromQuaternion(e), this.setFromRotationMatrix(eP, t, n) } setFromVector3(e, t = this._order) { return this.set(e.x, e.y, e.z, t) } reorder(e) { return tP.setFromEuler(this), this.setFromQuaternion(tP, e) } equals(e) { return e._x === this._x && e._y === this._y && e._z === this._z && e._order === this._order } fromArray(e) { return this._x = e[0], this._y = e[1], this._z = e[2], e[3] !== void 0 && (this._order = e[3]), this._onChangeCallback(), this } toArray(e = [], t = 0) { return e[t] = this._x, e[t + 1] = this._y, e[t + 2] = this._z, e[t + 3] = this._order, e } _onChange(e) { return this._onChangeCallback = e, this } _onChangeCallback() { } *[Symbol.iterator]() { yield this._x, yield this._y, yield this._z, yield this._order } } om.DEFAULT_ORDER = "XYZ"; class jc { constructor() { this.mask = 1 } set(e) { this.mask = (1 << e | 0) >>> 0 } enable(e) { this.mask |= 1 << e | 0 } enableAll() { this.mask = -1 } toggle(e) { this.mask ^= 1 << e | 0 } disable(e) { this.mask &= ~(1 << e | 0) } disableAll() { this.mask = 0 } test(e) { return (this.mask & e.mask) !== 0 } isEnabled(e) { return (this.mask & (1 << e | 0)) !== 0 } } let NW = 0; const nP = new k, Vu = new Ti, oa = new yt, Yg = new k, dd = new k, UW = new k, zW = new Ti, iP = new k(1, 0, 0), rP = new k(0, 1, 0), sP = new k(0, 0, 1), HW = { type: "added" }, oP = { type: "removed" }; class qt extends Ko { constructor() { super(), this.isObject3D = !0, Object.defineProperty(this, "id", { value: NW++ }), this.uuid = ss(), this.name = "", this.type = "Object3D", this.parent = null, this.children = [], this.up = qt.DEFAULT_UP.clone(); const e = new k, t = new om, n = new Ti, r = new k(1, 1, 1); function s() { n.setFromEuler(t, !1) } function o() { t.setFromQuaternion(n, void 0, !1) } t._onChange(s), n._onChange(o), Object.defineProperties(this, { position: { configurable: !0, enumerable: !0, value: e }, rotation: { configurable: !0, enumerable: !0, value: t }, quaternion: { configurable: !0, enumerable: !0, value: n }, scale: { configurable: !0, enumerable: !0, value: r }, modelViewMatrix: { value: new yt }, normalMatrix: { value: new Ot } }), this.matrix = new yt, this.matrixWorld = new yt, this.matrixAutoUpdate = qt.DEFAULT_MATRIX_AUTO_UPDATE, this.matrixWorldNeedsUpdate = !1, this.matrixWorldAutoUpdate = qt.DEFAULT_MATRIX_WORLD_AUTO_UPDATE, this.layers = new jc, this.visible = !0, this.castShadow = !1, this.receiveShadow = !1, this.frustumCulled = !0, this.renderOrder = 0, this.animations = [], this.userData = {} } onBeforeRender() { } onAfterRender() { } applyMatrix4(e) { this.matrixAutoUpdate && this.updateMatrix(), this.matrix.premultiply(e), this.matrix.decompose(this.position, this.quaternion, this.scale) } applyQuaternion(e) { return this.quaternion.premultiply(e), this } setRotationFromAxisAngle(e, t) { this.quaternion.setFromAxisAngle(e, t) } setRotationFromEuler(e) { this.quaternion.setFromEuler(e, !0) } setRotationFromMatrix(e) { this.quaternion.setFromRotationMatrix(e) } setRotationFromQuaternion(e) { this.quaternion.copy(e) } rotateOnAxis(e, t) { return Vu.setFromAxisAngle(e, t), this.quaternion.multiply(Vu), this } rotateOnWorldAxis(e, t) { return Vu.setFromAxisAngle(e, t), this.quaternion.premultiply(Vu), this } rotateX(e) { return this.rotateOnAxis(iP, e) } rotateY(e) { return this.rotateOnAxis(rP, e) } rotateZ(e) { return this.rotateOnAxis(sP, e) } translateOnAxis(e, t) { return nP.copy(e).applyQuaternion(this.quaternion), this.position.add(nP.multiplyScalar(t)), this } translateX(e) { return this.translateOnAxis(iP, e) } translateY(e) { return this.translateOnAxis(rP, e) } translateZ(e) { return this.translateOnAxis(sP, e) } localToWorld(e) { return this.updateWorldMatrix(!0, !1), e.applyMatrix4(this.matrixWorld) } worldToLocal(e) { return this.updateWorldMatrix(!0, !1), e.applyMatrix4(oa.copy(this.matrixWorld).invert()) } lookAt(e, t, n) { e.isVector3 ? Yg.copy(e) : Yg.set(e, t, n); const r = this.parent; this.updateWorldMatrix(!0, !1), dd.setFromMatrixPosition(this.matrixWorld), this.isCamera || this.isLight ? oa.lookAt(dd, Yg, this.up) : oa.lookAt(Yg, dd, this.up), this.quaternion.setFromRotationMatrix(oa), r && (oa.extractRotation(r.matrixWorld), Vu.setFromRotationMatrix(oa), this.quaternion.premultiply(Vu.invert())) } add(e) { if (arguments.length > 1) { for (let t = 0; t < arguments.length; t++)this.add(arguments[t]); return this } return e === this ? (console.error("THREE.Object3D.add: object can't be added as a child of itself.", e), this) : (e && e.isObject3D ? (e.parent !== null && e.parent.remove(e), e.parent = this, this.children.push(e), e.dispatchEvent(HW)) : console.error("THREE.Object3D.add: object not an instance of THREE.Object3D.", e), this) } remove(e) { if (arguments.length > 1) { for (let n = 0; n < arguments.length; n++)this.remove(arguments[n]); return this } const t = this.children.indexOf(e); return t !== -1 && (e.parent = null, this.children.splice(t, 1), e.dispatchEvent(oP)), this } removeFromParent() { const e = this.parent; return e !== null && e.remove(this), this } clear() { for (let e = 0; e < this.children.length; e++) { const t = this.children[e]; t.parent = null, t.dispatchEvent(oP) } return this.children.length = 0, this } attach(e) { return this.updateWorldMatrix(!0, !1), oa.copy(this.matrixWorld).invert(), e.parent !== null && (e.parent.updateWorldMatrix(!0, !1), oa.multiply(e.parent.matrixWorld)), e.applyMatrix4(oa), this.add(e), e.updateWorldMatrix(!1, !0), this } getObjectById(e) { return this.getObjectByProperty("id", e) } getObjectByName(e) { return this.getObjectByProperty("name", e) } getObjectByProperty(e, t) { if (this[e] === t) return this; for (let n = 0, r = this.children.length; n < r; n++) { const o = this.children[n].getObjectByProperty(e, t); if (o !== void 0) return o } } getObjectsByProperty(e, t) { let n = []; this[e] === t && n.push(this); for (let r = 0, s = this.children.length; r < s; r++) { const o = this.children[r].getObjectsByProperty(e, t); o.length > 0 && (n = n.concat(o)) } return n } getWorldPosition(e) { return this.updateWorldMatrix(!0, !1), e.setFromMatrixPosition(this.matrixWorld) } getWorldQuaternion(e) { return this.updateWorldMatrix(!0, !1), this.matrixWorld.decompose(dd, e, UW), e } getWorldScale(e) { return this.updateWorldMatrix(!0, !1), this.matrixWorld.decompose(dd, zW, e), e } getWorldDirection(e) { this.updateWorldMatrix(!0, !1); const t = this.matrixWorld.elements; return e.set(t[8], t[9], t[10]).normalize() } raycast() { } traverse(e) { e(this); const t = this.children; for (let n = 0, r = t.length; n < r; n++)t[n].traverse(e) } traverseVisible(e) { if (this.visible === !1) return; e(this); const t = this.children; for (let n = 0, r = t.length; n < r; n++)t[n].traverseVisible(e) } traverseAncestors(e) { const t = this.parent; t !== null && (e(t), t.traverseAncestors(e)) } updateMatrix() { this.matrix.compose(this.position, this.quaternion, this.scale), this.matrixWorldNeedsUpdate = !0 } updateMatrixWorld(e) { this.matrixAutoUpdate && this.updateMatrix(), (this.matrixWorldNeedsUpdate || e) && (this.parent === null ? this.matrixWorld.copy(this.matrix) : this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix), this.matrixWorldNeedsUpdate = !1, e = !0); const t = this.children; for (let n = 0, r = t.length; n < r; n++) { const s = t[n]; (s.matrixWorldAutoUpdate === !0 || e === !0) && s.updateMatrixWorld(e) } } updateWorldMatrix(e, t) { const n = this.parent; if (e === !0 && n !== null && n.matrixWorldAutoUpdate === !0 && n.updateWorldMatrix(!0, !1), this.matrixAutoUpdate && this.updateMatrix(), this.parent === null ? this.matrixWorld.copy(this.matrix) : this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix), t === !0) { const r = this.children; for (let s = 0, o = r.length; s < o; s++) { const a = r[s]; a.matrixWorldAutoUpdate === !0 && a.updateWorldMatrix(!1, !0) } } } toJSON(e) { const t = e === void 0 || typeof e == "string", n = {}; t && (e = { geometries: {}, materials: {}, textures: {}, images: {}, shapes: {}, skeletons: {}, animations: {}, nodes: {} }, n.metadata = { version: 4.6, type: "Object", generator: "Object3D.toJSON" }); const r = {}; r.uuid = this.uuid, r.type = this.type, this.name !== "" && (r.name = this.name), this.castShadow === !0 && (r.castShadow = !0), this.receiveShadow === !0 && (r.receiveShadow = !0), this.visible === !1 && (r.visible = !1), this.frustumCulled === !1 && (r.frustumCulled = !1), this.renderOrder !== 0 && (r.renderOrder = this.renderOrder), Object.keys(this.userData).length > 0 && (r.userData = this.userData), r.layers = this.layers.mask, r.matrix = this.matrix.toArray(), r.up = this.up.toArray(), this.matrixAutoUpdate === !1 && (r.matrixAutoUpdate = !1), this.isInstancedMesh && (r.type = "InstancedMesh", r.count = this.count, r.instanceMatrix = this.instanceMatrix.toJSON(), this.instanceColor !== null && (r.instanceColor = this.instanceColor.toJSON())); function s(a, l) { return a[l.uuid] === void 0 && (a[l.uuid] = l.toJSON(e)), l.uuid } if (this.isScene) this.background && (this.background.isColor ? r.background = this.background.toJSON() : this.background.isTexture && (r.background = this.background.toJSON(e).uuid)), this.environment && this.environment.isTexture && this.environment.isRenderTargetTexture !== !0 && (r.environment = this.environment.toJSON(e).uuid); else if (this.isMesh || this.isLine || this.isPoints) { r.geometry = s(e.geometries, this.geometry); const a = this.geometry.parameters; if (a !== void 0 && a.shapes !== void 0) { const l = a.shapes; if (Array.isArray(l)) for (let c = 0, f = l.length; c < f; c++) { const d = l[c]; s(e.shapes, d) } else s(e.shapes, l) } } if (this.isSkinnedMesh && (r.bindMode = this.bindMode, r.bindMatrix = this.bindMatrix.toArray(), this.skeleton !== void 0 && (s(e.skeletons, this.skeleton), r.skeleton = this.skeleton.uuid)), this.material !== void 0) if (Array.isArray(this.material)) { const a = []; for (let l = 0, c = this.material.length; l < c; l++)a.push(s(e.materials, this.material[l])); r.material = a } else r.material = s(e.materials, this.material); if (this.children.length > 0) { r.children = []; for (let a = 0; a < this.children.length; a++)r.children.push(this.children[a].toJSON(e).object) } if (this.animations.length > 0) { r.animations = []; for (let a = 0; a < this.animations.length; a++) { const l = this.animations[a]; r.animations.push(s(e.animations, l)) } } if (t) { const a = o(e.geometries), l = o(e.materials), c = o(e.textures), f = o(e.images), d = o(e.shapes), p = o(e.skeletons), m = o(e.animations), y = o(e.nodes); a.length > 0 && (n.geometries = a), l.length > 0 && (n.materials = l), c.length > 0 && (n.textures = c), f.length > 0 && (n.images = f), d.length > 0 && (n.shapes = d), p.length > 0 && (n.skeletons = p), m.length > 0 && (n.animations = m), y.length > 0 && (n.nodes = y) } return n.object = r, n; function o(a) { const l = []; for (const c in a) { const f = a[c]; delete f.metadata, l.push(f) } return l } } clone(e) { return new this.constructor().copy(this, e) } copy(e, t = !0) { if (this.name = e.name, this.up.copy(e.up), this.position.copy(e.position), this.rotation.order = e.rotation.order, this.quaternion.copy(e.quaternion), this.scale.copy(e.scale), this.matrix.copy(e.matrix), this.matrixWorld.copy(e.matrixWorld), this.matrixAutoUpdate = e.matrixAutoUpdate, this.matrixWorldNeedsUpdate = e.matrixWorldNeedsUpdate, this.matrixWorldAutoUpdate = e.matrixWorldAutoUpdate, this.layers.mask = e.layers.mask, this.visible = e.visible, this.castShadow = e.castShadow, this.receiveShadow = e.receiveShadow, this.frustumCulled = e.frustumCulled, this.renderOrder = e.renderOrder, this.animations = e.animations.slice(), this.userData = JSON.parse(JSON.stringify(e.userData)), t === !0) for (let n = 0; n < e.children.length; n++) { const r = e.children[n]; this.add(r.clone()) } return this } } qt.DEFAULT_UP = new k(0, 1, 0); qt.DEFAULT_MATRIX_AUTO_UPDATE = !0; qt.DEFAULT_MATRIX_WORLD_AUTO_UPDATE = !0; const Ks = new k, aa = new k, DA = new k, la = new k, Wu = new k, Xu = new k, aP = new k, OA = new k, FA = new k, kA = new k; let jg = !1; class br { constructor(e = new k, t = new k, n = new k) { this.a = e, this.b = t, this.c = n } static getNormal(e, t, n, r) { r.subVectors(n, t), Ks.subVectors(e, t), r.cross(Ks); const s = r.lengthSq(); return s > 0 ? r.multiplyScalar(1 / Math.sqrt(s)) : r.set(0, 0, 0) } static getBarycoord(e, t, n, r, s) { Ks.subVectors(r, t), aa.subVectors(n, t), DA.subVectors(e, t); const o = Ks.dot(Ks), a = Ks.dot(aa), l = Ks.dot(DA), c = aa.dot(aa), f = aa.dot(DA), d = o * c - a * a; if (d === 0) return s.set(-2, -1, -1); const p = 1 / d, m = (c * l - a * f) * p, y = (o * f - a * l) * p; return s.set(1 - m - y, y, m) } static containsPoint(e, t, n, r) { return this.getBarycoord(e, t, n, r, la), la.x >= 0 && la.y >= 0 && la.x + la.y <= 1 } static getUV(e, t, n, r, s, o, a, l) { return jg === !1 && (console.warn("THREE.Triangle.getUV() has been renamed to THREE.Triangle.getInterpolation()."), jg = !0), this.getInterpolation(e, t, n, r, s, o, a, l) } static getInterpolation(e, t, n, r, s, o, a, l) { return this.getBarycoord(e, t, n, r, la), l.setScalar(0), l.addScaledVector(s, la.x), l.addScaledVector(o, la.y), l.addScaledVector(a, la.z), l } static isFrontFacing(e, t, n, r) { return Ks.subVectors(n, t), aa.subVectors(e, t), Ks.cross(aa).dot(r) < 0 } set(e, t, n) { return this.a.copy(e), this.b.copy(t), this.c.copy(n), this } setFromPointsAndIndices(e, t, n, r) { return this.a.copy(e[t]), this.b.copy(e[n]), this.c.copy(e[r]), this } setFromAttributeAndIndices(e, t, n, r) { return this.a.fromBufferAttribute(e, t), this.b.fromBufferAttribute(e, n), this.c.fromBufferAttribute(e, r), this } clone() { return new this.constructor().copy(this) } copy(e) { return this.a.copy(e.a), this.b.copy(e.b), this.c.copy(e.c), this } getArea() { return Ks.subVectors(this.c, this.b), aa.subVectors(this.a, this.b), Ks.cross(aa).length() * .5 } getMidpoint(e) { return e.addVectors(this.a, this.b).add(this.c).multiplyScalar(1 / 3) } getNormal(e) { return br.getNormal(this.a, this.b, this.c, e) } getPlane(e) { return e.setFromCoplanarPoints(this.a, this.b, this.c) } getBarycoord(e, t) { return br.getBarycoord(e, this.a, this.b, this.c, t) } getUV(e, t, n, r, s) { return jg === !1 && (console.warn("THREE.Triangle.getUV() has been renamed to THREE.Triangle.getInterpolation()."), jg = !0), br.getInterpolation(e, this.a, this.b, this.c, t, n, r, s) } getInterpolation(e, t, n, r, s) { return br.getInterpolation(e, this.a, this.b, this.c, t, n, r, s) } containsPoint(e) { return br.containsPoint(e, this.a, this.b, this.c) } isFrontFacing(e) { return br.isFrontFacing(this.a, this.b, this.c, e) } intersectsBox(e) { return e.intersectsTriangle(this) } closestPointToPoint(e, t) { const n = this.a, r = this.b, s = this.c; let o, a; Wu.subVectors(r, n), Xu.subVectors(s, n), OA.subVectors(e, n); const l = Wu.dot(OA), c = Xu.dot(OA); if (l <= 0 && c <= 0) return t.copy(n); FA.subVectors(e, r); const f = Wu.dot(FA), d = Xu.dot(FA); if (f >= 0 && d <= f) return t.copy(r); const p = l * d - f * c; if (p <= 0 && l >= 0 && f <= 0) return o = l / (l - f), t.copy(n).addScaledVector(Wu, o); kA.subVectors(e, s); const m = Wu.dot(kA), y = Xu.dot(kA); if (y >= 0 && m <= y) return t.copy(s); const _ = m * c - l * y; if (_ <= 0 && c >= 0 && y <= 0) return a = c / (c - y), t.copy(n).addScaledVector(Xu, a); const x = f * y - m * d; if (x <= 0 && d - f >= 0 && m - y >= 0) return aP.subVectors(s, r), a = (d - f) / (d - f + (m - y)), t.copy(r).addScaledVector(aP, a); const g = 1 / (x + _ + p); return o = _ * g, a = p * g, t.copy(n).addScaledVector(Wu, o).addScaledVector(Xu, a) } equals(e) { return e.a.equals(this.a) && e.b.equals(this.b) && e.c.equals(this.c) } } let GW = 0; class oi extends Ko { constructor() { super(), this.isMaterial = !0, Object.defineProperty(this, "id", { value: GW++ }), this.uuid = ss(), this.name = "", this.type = "Material", this.blending = Jc, this.side = Jo, this.vertexColors = !1, this.opacity = 1, this.transparent = !1, this.alphaHash = !1, this.blendSrc = aE, this.blendDst = lE, this.blendEquation = Sc, this.blendSrcAlpha = null, this.blendDstAlpha = null, this.blendEquationAlpha = null, this.depthFunc = nv, this.depthTest = !0, this.depthWrite = !0, this.stencilWriteMask = 255, this.stencilFunc = fF, this.stencilRef = 0, this.stencilFuncMask = 255, this.stencilFail = uy, this.stencilZFail = uy, this.stencilZPass = uy, this.stencilWrite = !1, this.clippingPlanes = null, this.clipIntersection = !1, this.clipShadows = !1, this.shadowSide = null, this.colorWrite = !0, this.precision = null, this.polygonOffset = !1, this.polygonOffsetFactor = 0, this.polygonOffsetUnits = 0, this.dithering = !1, this.alphaToCoverage = !1, this.premultipliedAlpha = !1, this.forceSinglePass = !1, this.visible = !0, this.toneMapped = !0, this.userData = {}, this.version = 0, this._alphaTest = 0 } get alphaTest() { return this._alphaTest } set alphaTest(e) { this._alphaTest > 0 != e > 0 && this.version++, this._alphaTest = e } onBuild() { } onBeforeRender() { } onBeforeCompile() { } customProgramCacheKey() { return this.onBeforeCompile.toString() } setValues(e) { if (e !== void 0) for (const t in e) { const n = e[t]; if (n === void 0) { console.warn(`THREE.Material: parameter '${t}' has value of undefined.`); continue } const r = this[t]; if (r === void 0) { console.warn(`THREE.Material: '${t}' is not a property of THREE.${this.type}.`); continue } r && r.isColor ? r.set(n) : r && r.isVector3 && n && n.isVector3 ? r.copy(n) : this[t] = n } } toJSON(e) { const t = e === void 0 || typeof e == "string"; t && (e = { textures: {}, images: {} }); const n = { metadata: { version: 4.6, type: "Material", generator: "Material.toJSON" } }; n.uuid = this.uuid, n.type = this.type, this.name !== "" && (n.name = this.name), this.color && this.color.isColor && (n.color = this.color.getHex()), this.roughness !== void 0 && (n.roughness = this.roughness), this.metalness !== void 0 && (n.metalness = this.metalness), this.sheen !== void 0 && (n.sheen = this.sheen), this.sheenColor && this.sheenColor.isColor && (n.sheenColor = this.sheenColor.getHex()), this.sheenRoughness !== void 0 && (n.sheenRoughness = this.sheenRoughness), this.emissive && this.emissive.isColor && (n.emissive = this.emissive.getHex()), this.emissiveIntensity && this.emissiveIntensity !== 1 && (n.emissiveIntensity = this.emissiveIntensity), this.specular && this.specular.isColor && (n.specular = this.specular.getHex()), this.specularIntensity !== void 0 && (n.specularIntensity = this.specularIntensity), this.specularColor && this.specularColor.isColor && (n.specularColor = this.specularColor.getHex()), this.shininess !== void 0 && (n.shininess = this.shininess), this.clearcoat !== void 0 && (n.clearcoat = this.clearcoat), this.clearcoatRoughness !== void 0 && (n.clearcoatRoughness = this.clearcoatRoughness), this.clearcoatMap && this.clearcoatMap.isTexture && (n.clearcoatMap = this.clearcoatMap.toJSON(e).uuid), this.clearcoatRoughnessMap && this.clearcoatRoughnessMap.isTexture && (n.clearcoatRoughnessMap = this.clearcoatRoughnessMap.toJSON(e).uuid), this.clearcoatNormalMap && this.clearcoatNormalMap.isTexture && (n.clearcoatNormalMap = this.clearcoatNormalMap.toJSON(e).uuid, n.clearcoatNormalScale = this.clearcoatNormalScale.toArray()), this.iridescence !== void 0 && (n.iridescence = this.iridescence), this.iridescenceIOR !== void 0 && (n.iridescenceIOR = this.iridescenceIOR), this.iridescenceThicknessRange !== void 0 && (n.iridescenceThicknessRange = this.iridescenceThicknessRange), this.iridescenceMap && this.iridescenceMap.isTexture && (n.iridescenceMap = this.iridescenceMap.toJSON(e).uuid), this.iridescenceThicknessMap && this.iridescenceThicknessMap.isTexture && (n.iridescenceThicknessMap = this.iridescenceThicknessMap.toJSON(e).uuid), this.anisotropy !== void 0 && (n.anisotropy = this.anisotropy), this.anisotropyRotation !== void 0 && (n.anisotropyRotation = this.anisotropyRotation), this.anisotropyMap && this.anisotropyMap.isTexture && (n.anisotropyMap = this.anisotropyMap.toJSON(e).uuid), this.map && this.map.isTexture && (n.map = this.map.toJSON(e).uuid), this.matcap && this.matcap.isTexture && (n.matcap = this.matcap.toJSON(e).uuid), this.alphaMap && this.alphaMap.isTexture && (n.alphaMap = this.alphaMap.toJSON(e).uuid), this.lightMap && this.lightMap.isTexture && (n.lightMap = this.lightMap.toJSON(e).uuid, n.lightMapIntensity = this.lightMapIntensity), this.aoMap && this.aoMap.isTexture && (n.aoMap = this.aoMap.toJSON(e).uuid, n.aoMapIntensity = this.aoMapIntensity), this.bumpMap && this.bumpMap.isTexture && (n.bumpMap = this.bumpMap.toJSON(e).uuid, n.bumpScale = this.bumpScale), this.normalMap && this.normalMap.isTexture && (n.normalMap = this.normalMap.toJSON(e).uuid, n.normalMapType = this.normalMapType, n.normalScale = this.normalScale.toArray()), this.displacementMap && this.displacementMap.isTexture && (n.displacementMap = this.displacementMap.toJSON(e).uuid, n.displacementScale = this.displacementScale, n.displacementBias = this.displacementBias), this.roughnessMap && this.roughnessMap.isTexture && (n.roughnessMap = this.roughnessMap.toJSON(e).uuid), this.metalnessMap && this.metalnessMap.isTexture && (n.metalnessMap = this.metalnessMap.toJSON(e).uuid), this.emissiveMap && this.emissiveMap.isTexture && (n.emissiveMap = this.emissiveMap.toJSON(e).uuid), this.specularMap && this.specularMap.isTexture && (n.specularMap = this.specularMap.toJSON(e).uuid), this.specularIntensityMap && this.specularIntensityMap.isTexture && (n.specularIntensityMap = this.specularIntensityMap.toJSON(e).uuid), this.specularColorMap && this.specularColorMap.isTexture && (n.specularColorMap = this.specularColorMap.toJSON(e).uuid), this.envMap && this.envMap.isTexture && (n.envMap = this.envMap.toJSON(e).uuid, this.combine !== void 0 && (n.combine = this.combine)), this.envMapIntensity !== void 0 && (n.envMapIntensity = this.envMapIntensity), this.reflectivity !== void 0 && (n.reflectivity = this.reflectivity), this.refractionRatio !== void 0 && (n.refractionRatio = this.refractionRatio), this.gradientMap && this.gradientMap.isTexture && (n.gradientMap = this.gradientMap.toJSON(e).uuid), this.transmission !== void 0 && (n.transmission = this.transmission), this.transmissionMap && this.transmissionMap.isTexture && (n.transmissionMap = this.transmissionMap.toJSON(e).uuid), this.thickness !== void 0 && (n.thickness = this.thickness), this.thicknessMap && this.thicknessMap.isTexture && (n.thicknessMap = this.thicknessMap.toJSON(e).uuid), this.attenuationDistance !== void 0 && this.attenuationDistance !== 1 / 0 && (n.attenuationDistance = this.attenuationDistance), this.attenuationColor !== void 0 && (n.attenuationColor = this.attenuationColor.getHex()), this.size !== void 0 && (n.size = this.size), this.shadowSide !== null && (n.shadowSide = this.shadowSide), this.sizeAttenuation !== void 0 && (n.sizeAttenuation = this.sizeAttenuation), this.blending !== Jc && (n.blending = this.blending), this.side !== Jo && (n.side = this.side), this.vertexColors && (n.vertexColors = !0), this.opacity < 1 && (n.opacity = this.opacity), this.transparent === !0 && (n.transparent = this.transparent), n.depthFunc = this.depthFunc, n.depthTest = this.depthTest, n.depthWrite = this.depthWrite, n.colorWrite = this.colorWrite, n.stencilWrite = this.stencilWrite, n.stencilWriteMask = this.stencilWriteMask, n.stencilFunc = this.stencilFunc, n.stencilRef = this.stencilRef, n.stencilFuncMask = this.stencilFuncMask, n.stencilFail = this.stencilFail, n.stencilZFail = this.stencilZFail, n.stencilZPass = this.stencilZPass, this.rotation !== void 0 && this.rotation !== 0 && (n.rotation = this.rotation), this.polygonOffset === !0 && (n.polygonOffset = !0), this.polygonOffsetFactor !== 0 && (n.polygonOffsetFactor = this.polygonOffsetFactor), this.polygonOffsetUnits !== 0 && (n.polygonOffsetUnits = this.polygonOffsetUnits), this.linewidth !== void 0 && this.linewidth !== 1 && (n.linewidth = this.linewidth), this.dashSize !== void 0 && (n.dashSize = this.dashSize), this.gapSize !== void 0 && (n.gapSize = this.gapSize), this.scale !== void 0 && (n.scale = this.scale), this.dithering === !0 && (n.dithering = !0), this.alphaTest > 0 && (n.alphaTest = this.alphaTest), this.alphaHash === !0 && (n.alphaHash = this.alphaHash), this.alphaToCoverage === !0 && (n.alphaToCoverage = this.alphaToCoverage), this.premultipliedAlpha === !0 && (n.premultipliedAlpha = this.premultipliedAlpha), this.forceSinglePass === !0 && (n.forceSinglePass = this.forceSinglePass), this.wireframe === !0 && (n.wireframe = this.wireframe), this.wireframeLinewidth > 1 && (n.wireframeLinewidth = this.wireframeLinewidth), this.wireframeLinecap !== "round" && (n.wireframeLinecap = this.wireframeLinecap), this.wireframeLinejoin !== "round" && (n.wireframeLinejoin = this.wireframeLinejoin), this.flatShading === !0 && (n.flatShading = this.flatShading), this.visible === !1 && (n.visible = !1), this.toneMapped === !1 && (n.toneMapped = !1), this.fog === !1 && (n.fog = !1), Object.keys(this.userData).length > 0 && (n.userData = this.userData); function r(s) { const o = []; for (const a in s) { const l = s[a]; delete l.metadata, o.push(l) } return o } if (t) { const s = r(e.textures), o = r(e.images); s.length > 0 && (n.textures = s), o.length > 0 && (n.images = o) } return n } clone() { return new this.constructor().copy(this) } copy(e) { this.name = e.name, this.blending = e.blending, this.side = e.side, this.vertexColors = e.vertexColors, this.opacity = e.opacity, this.transparent = e.transparent, this.blendSrc = e.blendSrc, this.blendDst = e.blendDst, this.blendEquation = e.blendEquation, this.blendSrcAlpha = e.blendSrcAlpha, this.blendDstAlpha = e.blendDstAlpha, this.blendEquationAlpha = e.blendEquationAlpha, this.depthFunc = e.depthFunc, this.depthTest = e.depthTest, this.depthWrite = e.depthWrite, this.stencilWriteMask = e.stencilWriteMask, this.stencilFunc = e.stencilFunc, this.stencilRef = e.stencilRef, this.stencilFuncMask = e.stencilFuncMask, this.stencilFail = e.stencilFail, this.stencilZFail = e.stencilZFail, this.stencilZPass = e.stencilZPass, this.stencilWrite = e.stencilWrite; const t = e.clippingPlanes; let n = null; if (t !== null) { const r = t.length; n = new Array(r); for (let s = 0; s !== r; ++s)n[s] = t[s].clone() } return this.clippingPlanes = n, this.clipIntersection = e.clipIntersection, this.clipShadows = e.clipShadows, this.shadowSide = e.shadowSide, this.colorWrite = e.colorWrite, this.precision = e.precision, this.polygonOffset = e.polygonOffset, this.polygonOffsetFactor = e.polygonOffsetFactor, this.polygonOffsetUnits = e.polygonOffsetUnits, this.dithering = e.dithering, this.alphaTest = e.alphaTest, this.alphaHash = e.alphaHash, this.alphaToCoverage = e.alphaToCoverage, this.premultipliedAlpha = e.premultipliedAlpha, this.forceSinglePass = e.forceSinglePass, this.visible = e.visible, this.toneMapped = e.toneMapped, this.userData = JSON.parse(JSON.stringify(e.userData)), this } dispose() { this.dispatchEvent({ type: "dispose" }) } set needsUpdate(e) { e === !0 && this.version++ } } const SF = { aliceblue: 15792383, antiquewhite: 16444375, aqua: 65535, aquamarine: 8388564, azure: 15794175, beige: 16119260, bisque: 16770244, black: 0, blanchedalmond: 16772045, blue: 255, blueviolet: 9055202, brown: 10824234, burlywood: 14596231, cadetblue: 6266528, chartreuse: 8388352, chocolate: 13789470, coral: 16744272, cornflowerblue: 6591981, cornsilk: 16775388, crimson: 14423100, cyan: 65535, darkblue: 139, darkcyan: 35723, darkgoldenrod: 12092939, darkgray: 11119017, darkgreen: 25600, darkgrey: 11119017, darkkhaki: 12433259, darkmagenta: 9109643, darkolivegreen: 5597999, darkorange: 16747520, darkorchid: 10040012, darkred: 9109504, darksalmon: 15308410, darkseagreen: 9419919, darkslateblue: 4734347, darkslategray: 3100495, darkslategrey: 3100495, darkturquoise: 52945, darkviolet: 9699539, deeppink: 16716947, deepskyblue: 49151, dimgray: 6908265, dimgrey: 6908265, dodgerblue: 2003199, firebrick: 11674146, floralwhite: 16775920, forestgreen: 2263842, fuchsia: 16711935, gainsboro: 14474460, ghostwhite: 16316671, gold: 16766720, goldenrod: 14329120, gray: 8421504, green: 32768, greenyellow: 11403055, grey: 8421504, honeydew: 15794160, hotpink: 16738740, indianred: 13458524, indigo: 4915330, ivory: 16777200, khaki: 15787660, lavender: 15132410, lavenderblush: 16773365, lawngreen: 8190976, lemonchiffon: 16775885, lightblue: 11393254, lightcoral: 15761536, lightcyan: 14745599, lightgoldenrodyellow: 16448210, lightgray: 13882323, lightgreen: 9498256, lightgrey: 13882323, lightpink: 16758465, lightsalmon: 16752762, lightseagreen: 2142890, lightskyblue: 8900346, lightslategray: 7833753, lightslategrey: 7833753, lightsteelblue: 11584734, lightyellow: 16777184, lime: 65280, limegreen: 3329330, linen: 16445670, magenta: 16711935, maroon: 8388608, mediumaquamarine: 6737322, mediumblue: 205, mediumorchid: 12211667, mediumpurple: 9662683, mediumseagreen: 3978097, mediumslateblue: 8087790, mediumspringgreen: 64154, mediumturquoise: 4772300, mediumvioletred: 13047173, midnightblue: 1644912, mintcream: 16121850, mistyrose: 16770273, moccasin: 16770229, navajowhite: 16768685, navy: 128, oldlace: 16643558, olive: 8421376, olivedrab: 7048739, orange: 16753920, orangered: 16729344, orchid: 14315734, palegoldenrod: 15657130, palegreen: 10025880, paleturquoise: 11529966, palevioletred: 14381203, papayawhip: 16773077, peachpuff: 16767673, peru: 13468991, pink: 16761035, plum: 14524637, powderblue: 11591910, purple: 8388736, rebeccapurple: 6697881, red: 16711680, rosybrown: 12357519, royalblue: 4286945, saddlebrown: 9127187, salmon: 16416882, sandybrown: 16032864, seagreen: 3050327, seashell: 16774638, sienna: 10506797, silver: 12632256, skyblue: 8900331, slateblue: 6970061, slategray: 7372944, slategrey: 7372944, snow: 16775930, springgreen: 65407, steelblue: 4620980, tan: 13808780, teal: 32896, thistle: 14204888, tomato: 16737095, turquoise: 4251856, violet: 15631086, wheat: 16113331, white: 16777215, whitesmoke: 16119285, yellow: 16776960, yellowgreen: 10145074 }, qs = { h: 0, s: 0, l: 0 }, Kg = { h: 0, s: 0, l: 0 }; function NA(i, e, t) { return t < 0 && (t += 1), t > 1 && (t -= 1), t < 1 / 6 ? i + (e - i) * 6 * t : t < 1 / 2 ? e : t < 2 / 3 ? i + (e - i) * 6 * (2 / 3 - t) : i } class We { constructor(e, t, n) { return this.isColor = !0, this.r = 1, this.g = 1, this.b = 1, this.set(e, t, n) } set(e, t, n) { if (t === void 0 && n === void 0) { const r = e; r && r.isColor ? this.copy(r) : typeof r == "number" ? this.setHex(r) : typeof r == "string" && this.setStyle(r) } else this.setRGB(e, t, n); return this } setScalar(e) { return this.r = e, this.g = e, this.b = e, this } setHex(e, t = bt) { return e = Math.floor(e), this.r = (e >> 16 & 255) / 255, this.g = (e >> 8 & 255) / 255, this.b = (e & 255) / 255, As.toWorkingColorSpace(this, t), this } setRGB(e, t, n, r = As.workingColorSpace) { return this.r = e, this.g = t, this.b = n, As.toWorkingColorSpace(this, r), this } setHSL(e, t, n, r = As.workingColorSpace) { if (e = xE(e, 1), t = Gn(t, 0, 1), n = Gn(n, 0, 1), t === 0) this.r = this.g = this.b = n; else { const s = n <= .5 ? n * (1 + t) : n + t - n * t, o = 2 * n - s; this.r = NA(o, s, e + 1 / 3), this.g = NA(o, s, e), this.b = NA(o, s, e - 1 / 3) } return As.toWorkingColorSpace(this, r), this } setStyle(e, t = bt) { function n(s) { s !== void 0 && parseFloat(s) < 1 && console.warn("THREE.Color: Alpha component of " + e + " will be ignored.") } let r; if (r = /^(\w+)\(([^\)]*)\)/.exec(e)) { let s; const o = r[1], a = r[2]; switch (o) { case "rgb": case "rgba": if (s = /^\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(a)) return n(s[4]), this.setRGB(Math.min(255, parseInt(s[1], 10)) / 255, Math.min(255, parseInt(s[2], 10)) / 255, Math.min(255, parseInt(s[3], 10)) / 255, t); if (s = /^\s*(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(a)) return n(s[4]), this.setRGB(Math.min(100, parseInt(s[1], 10)) / 100, Math.min(100, parseInt(s[2], 10)) / 100, Math.min(100, parseInt(s[3], 10)) / 100, t); break; case "hsl": case "hsla": if (s = /^\s*(\d*\.?\d+)\s*,\s*(\d*\.?\d+)\%\s*,\s*(\d*\.?\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(a)) return n(s[4]), this.setHSL(parseFloat(s[1]) / 360, parseFloat(s[2]) / 100, parseFloat(s[3]) / 100, t); break; default: console.warn("THREE.Color: Unknown color model " + e) } } else if (r = /^\#([A-Fa-f\d]+)$/.exec(e)) { const s = r[1], o = s.length; if (o === 3) return this.setRGB(parseInt(s.charAt(0), 16) / 15, parseInt(s.charAt(1), 16) / 15, parseInt(s.charAt(2), 16) / 15, t); if (o === 6) return this.setHex(parseInt(s, 16), t); console.warn("THREE.Color: Invalid hex color " + e) } else if (e && e.length > 0) return this.setColorName(e, t); return this } setColorName(e, t = bt) { const n = SF[e.toLowerCase()]; return n !== void 0 ? this.setHex(n, t) : console.warn("THREE.Color: Unknown color " + e), this } clone() { return new this.constructor(this.r, this.g, this.b) } copy(e) { return this.r = e.r, this.g = e.g, this.b = e.b, this } copySRGBToLinear(e) { return this.r = jf(e.r), this.g = jf(e.g), this.b = jf(e.b), this } copyLinearToSRGB(e) { return this.r = CA(e.r), this.g = CA(e.g), this.b = CA(e.b), this } convertSRGBToLinear() { return this.copySRGBToLinear(this), this } convertLinearToSRGB() { return this.copyLinearToSRGB(this), this } getHex(e = bt) { return As.fromWorkingColorSpace(Yi.copy(this), e), Math.round(Gn(Yi.r * 255, 0, 255)) * 65536 + Math.round(Gn(Yi.g * 255, 0, 255)) * 256 + Math.round(Gn(Yi.b * 255, 0, 255)) } getHexString(e = bt) { return ("000000" + this.getHex(e).toString(16)).slice(-6) } getHSL(e, t = As.workingColorSpace) { As.fromWorkingColorSpace(Yi.copy(this), t); const n = Yi.r, r = Yi.g, s = Yi.b, o = Math.max(n, r, s), a = Math.min(n, r, s); let l, c; const f = (a + o) / 2; if (a === o) l = 0, c = 0; else { const d = o - a; switch (c = f <= .5 ? d / (o + a) : d / (2 - o - a), o) { case n: l = (r - s) / d + (r < s ? 6 : 0); break; case r: l = (s - n) / d + 2; break; case s: l = (n - r) / d + 4; break }l /= 6 } return e.h = l, e.s = c, e.l = f, e } getRGB(e, t = As.workingColorSpace) { return As.fromWorkingColorSpace(Yi.copy(this), t), e.r = Yi.r, e.g = Yi.g, e.b = Yi.b, e } getStyle(e = bt) { As.fromWorkingColorSpace(Yi.copy(this), e); const t = Yi.r, n = Yi.g, r = Yi.b; return e !== bt ? `color(${e} ${t.toFixed(3)} ${n.toFixed(3)} ${r.toFixed(3)})` : `rgb(${Math.round(t * 255)},${Math.round(n * 255)},${Math.round(r * 255)})` } offsetHSL(e, t, n) { return this.getHSL(qs), qs.h += e, qs.s += t, qs.l += n, this.setHSL(qs.h, qs.s, qs.l), this } add(e) { return this.r += e.r, this.g += e.g, this.b += e.b, this } addColors(e, t) { return this.r = e.r + t.r, this.g = e.g + t.g, this.b = e.b + t.b, this } addScalar(e) { return this.r += e, this.g += e, this.b += e, this } sub(e) { return this.r = Math.max(0, this.r - e.r), this.g = Math.max(0, this.g - e.g), this.b = Math.max(0, this.b - e.b), this } multiply(e) { return this.r *= e.r, this.g *= e.g, this.b *= e.b, this } multiplyScalar(e) { return this.r *= e, this.g *= e, this.b *= e, this } lerp(e, t) { return this.r += (e.r - this.r) * t, this.g += (e.g - this.g) * t, this.b += (e.b - this.b) * t, this } lerpColors(e, t, n) { return this.r = e.r + (t.r - e.r) * n, this.g = e.g + (t.g - e.g) * n, this.b = e.b + (t.b - e.b) * n, this } lerpHSL(e, t) { this.getHSL(qs), e.getHSL(Kg); const n = sp(qs.h, Kg.h, t), r = sp(qs.s, Kg.s, t), s = sp(qs.l, Kg.l, t); return this.setHSL(n, r, s), this } setFromVector3(e) { return this.r = e.x, this.g = e.y, this.b = e.z, this } applyMatrix3(e) { const t = this.r, n = this.g, r = this.b, s = e.elements; return this.r = s[0] * t + s[3] * n + s[6] * r, this.g = s[1] * t + s[4] * n + s[7] * r, this.b = s[2] * t + s[5] * n + s[8] * r, this } equals(e) { return e.r === this.r && e.g === this.g && e.b === this.b } fromArray(e, t = 0) { return this.r = e[t], this.g = e[t + 1], this.b = e[t + 2], this } toArray(e = [], t = 0) { return e[t] = this.r, e[t + 1] = this.g, e[t + 2] = this.b, e } fromBufferAttribute(e, t) { return this.r = e.getX(t), this.g = e.getY(t), this.b = e.getZ(t), this } toJSON() { return this.getHex() } *[Symbol.iterator]() { yield this.r, yield this.g, yield this.b } } const Yi = new We; We.NAMES = SF; class ts extends oi { constructor(e) { super(), this.isMeshBasicMaterial = !0, this.type = "MeshBasicMaterial", this.color = new We(16777215), this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.specularMap = null, this.alphaMap = null, this.envMap = null, this.combine = sm, this.reflectivity = 1, this.refractionRatio = .98, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.fog = !0, this.setValues(e) } copy(e) { return super.copy(e), this.color.copy(e.color), this.map = e.map, this.lightMap = e.lightMap, this.lightMapIntensity = e.lightMapIntensity, this.aoMap = e.aoMap, this.aoMapIntensity = e.aoMapIntensity, this.specularMap = e.specularMap, this.alphaMap = e.alphaMap, this.envMap = e.envMap, this.combine = e.combine, this.reflectivity = e.reflectivity, this.refractionRatio = e.refractionRatio, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.wireframeLinecap = e.wireframeLinecap, this.wireframeLinejoin = e.wireframeLinejoin, this.fog = e.fog, this } } const ma = VW(); function VW() { const i = new ArrayBuffer(4), e = new Float32Array(i), t = new Uint32Array(i), n = new Uint32Array(512), r = new Uint32Array(512); for (let l = 0; l < 256; ++l) { const c = l - 127; c < -27 ? (n[l] = 0, n[l | 256] = 32768, r[l] = 24, r[l | 256] = 24) : c < -14 ? (n[l] = 1024 >> -c - 14, n[l | 256] = 1024 >> -c - 14 | 32768, r[l] = -c - 1, r[l | 256] = -c - 1) : c <= 15 ? (n[l] = c + 15 << 10, n[l | 256] = c + 15 << 10 | 32768, r[l] = 13, r[l | 256] = 13) : c < 128 ? (n[l] = 31744, n[l | 256] = 64512, r[l] = 24, r[l | 256] = 24) : (n[l] = 31744, n[l | 256] = 64512, r[l] = 13, r[l | 256] = 13) } const s = new Uint32Array(2048), o = new Uint32Array(64), a = new Uint32Array(64); for (let l = 1; l < 1024; ++l) { let c = l << 13, f = 0; for (; !(c & 8388608);)c <<= 1, f -= 8388608; c &= -8388609, f += 947912704, s[l] = c | f } for (let l = 1024; l < 2048; ++l)s[l] = 939524096 + (l - 1024 << 13); for (let l = 1; l < 31; ++l)o[l] = l << 23; o[31] = 1199570944, o[32] = 2147483648; for (let l = 33; l < 63; ++l)o[l] = 2147483648 + (l - 32 << 23); o[63] = 3347054592; for (let l = 1; l < 64; ++l)l !== 32 && (a[l] = 1024); return { floatView: e, uint32View: t, baseTable: n, shiftTable: r, mantissaTable: s, exponentTable: o, offsetTable: a } } function Er(i) { Math.abs(i) > 65504 && console.warn("THREE.DataUtils.toHalfFloat(): Value out of range."), i = Gn(i, -65504, 65504), ma.floatView[0] = i; const e = ma.uint32View[0], t = e >> 23 & 511; return ma.baseTable[t] + ((e & 8388607) >> ma.shiftTable[t]) } function Ld(i) { const e = i >> 10; return ma.uint32View[0] = ma.mantissaTable[ma.offsetTable[e] + (i & 1023)] + ma.exponentTable[e], ma.floatView[0] } const WW = { toHalfFloat: Er, fromHalfFloat: Ld }, ti = new k, qg = new _e; class rn { constructor(e, t, n = !1) { if (Array.isArray(e)) throw new TypeError("THREE.BufferAttribute: array should be a Typed Array."); this.isBufferAttribute = !0, this.name = "", this.array = e, this.itemSize = t, this.count = e !== void 0 ? e.length / t : 0, this.normalized = n, this.usage = zp, this.updateRange = { offset: 0, count: -1 }, this.gpuType = Do, this.version = 0 } onUploadCallback() { } set needsUpdate(e) { e === !0 && this.version++ } setUsage(e) { return this.usage = e, this } copy(e) { return this.name = e.name, this.array = new e.array.constructor(e.array), this.itemSize = e.itemSize, this.count = e.count, this.normalized = e.normalized, this.usage = e.usage, this.gpuType = e.gpuType, this } copyAt(e, t, n) { e *= this.itemSize, n *= t.itemSize; for (let r = 0, s = this.itemSize; r < s; r++)this.array[e + r] = t.array[n + r]; return this } copyArray(e) { return this.array.set(e), this } applyMatrix3(e) { if (this.itemSize === 2) for (let t = 0, n = this.count; t < n; t++)qg.fromBufferAttribute(this, t), qg.applyMatrix3(e), this.setXY(t, qg.x, qg.y); else if (this.itemSize === 3) for (let t = 0, n = this.count; t < n; t++)ti.fromBufferAttribute(this, t), ti.applyMatrix3(e), this.setXYZ(t, ti.x, ti.y, ti.z); return this } applyMatrix4(e) { for (let t = 0, n = this.count; t < n; t++)ti.fromBufferAttribute(this, t), ti.applyMatrix4(e), this.setXYZ(t, ti.x, ti.y, ti.z); return this } applyNormalMatrix(e) { for (let t = 0, n = this.count; t < n; t++)ti.fromBufferAttribute(this, t), ti.applyNormalMatrix(e), this.setXYZ(t, ti.x, ti.y, ti.z); return this } transformDirection(e) { for (let t = 0, n = this.count; t < n; t++)ti.fromBufferAttribute(this, t), ti.transformDirection(e), this.setXYZ(t, ti.x, ti.y, ti.z); return this } set(e, t = 0) { return this.array.set(e, t), this } getComponent(e, t) { let n = this.array[e * this.itemSize + t]; return this.normalized && (n = Ir(n, this.array)), n } setComponent(e, t, n) { return this.normalized && (n = It(n, this.array)), this.array[e * this.itemSize + t] = n, this } getX(e) { let t = this.array[e * this.itemSize]; return this.normalized && (t = Ir(t, this.array)), t } setX(e, t) { return this.normalized && (t = It(t, this.array)), this.array[e * this.itemSize] = t, this } getY(e) { let t = this.array[e * this.itemSize + 1]; return this.normalized && (t = Ir(t, this.array)), t } setY(e, t) { return this.normalized && (t = It(t, this.array)), this.array[e * this.itemSize + 1] = t, this } getZ(e) { let t = this.array[e * this.itemSize + 2]; return this.normalized && (t = Ir(t, this.array)), t } setZ(e, t) { return this.normalized && (t = It(t, this.array)), this.array[e * this.itemSize + 2] = t, this } getW(e) { let t = this.array[e * this.itemSize + 3]; return this.normalized && (t = Ir(t, this.array)), t } setW(e, t) { return this.normalized && (t = It(t, this.array)), this.array[e * this.itemSize + 3] = t, this } setXY(e, t, n) { return e *= this.itemSize, this.normalized && (t = It(t, this.array), n = It(n, this.array)), this.array[e + 0] = t, this.array[e + 1] = n, this } setXYZ(e, t, n, r) { return e *= this.itemSize, this.normalized && (t = It(t, this.array), n = It(n, this.array), r = It(r, this.array)), this.array[e + 0] = t, this.array[e + 1] = n, this.array[e + 2] = r, this } setXYZW(e, t, n, r, s) { return e *= this.itemSize, this.normalized && (t = It(t, this.array), n = It(n, this.array), r = It(r, this.array), s = It(s, this.array)), this.array[e + 0] = t, this.array[e + 1] = n, this.array[e + 2] = r, this.array[e + 3] = s, this } onUpload(e) { return this.onUploadCallback = e, this } clone() { return new this.constructor(this.array, this.itemSize).copy(this) } toJSON() { const e = { itemSize: this.itemSize, type: this.array.constructor.name, array: Array.from(this.array), normalized: this.normalized }; return this.name !== "" && (e.name = this.name), this.usage !== zp && (e.usage = this.usage), (this.updateRange.offset !== 0 || this.updateRange.count !== -1) && (e.updateRange = this.updateRange), e } } class XW extends rn { constructor(e, t, n) { super(new Int8Array(e), t, n) } } class JW extends rn { constructor(e, t, n) { super(new Uint8Array(e), t, n) } } class YW extends rn { constructor(e, t, n) { super(new Uint8ClampedArray(e), t, n) } } class jW extends rn { constructor(e, t, n) { super(new Int16Array(e), t, n) } } class wE extends rn { constructor(e, t, n) { super(new Uint16Array(e), t, n) } } class KW extends rn { constructor(e, t, n) { super(new Int32Array(e), t, n) } } class SE extends rn { constructor(e, t, n) { super(new Uint32Array(e), t, n) } } class qW extends rn { constructor(e, t, n) { super(new Uint16Array(e), t, n), this.isFloat16BufferAttribute = !0 } getX(e) { let t = Ld(this.array[e * this.itemSize]); return this.normalized && (t = Ir(t, this.array)), t } setX(e, t) { return this.normalized && (t = It(t, this.array)), this.array[e * this.itemSize] = Er(t), this } getY(e) { let t = Ld(this.array[e * this.itemSize + 1]); return this.normalized && (t = Ir(t, this.array)), t } setY(e, t) { return this.normalized && (t = It(t, this.array)), this.array[e * this.itemSize + 1] = Er(t), this } getZ(e) { let t = Ld(this.array[e * this.itemSize + 2]); return this.normalized && (t = Ir(t, this.array)), t } setZ(e, t) { return this.normalized && (t = It(t, this.array)), this.array[e * this.itemSize + 2] = Er(t), this } getW(e) { let t = Ld(this.array[e * this.itemSize + 3]); return this.normalized && (t = Ir(t, this.array)), t } setW(e, t) { return this.normalized && (t = It(t, this.array)), this.array[e * this.itemSize + 3] = Er(t), this } setXY(e, t, n) { return e *= this.itemSize, this.normalized && (t = It(t, this.array), n = It(n, this.array)), this.array[e + 0] = Er(t), this.array[e + 1] = Er(n), this } setXYZ(e, t, n, r) { return e *= this.itemSize, this.normalized && (t = It(t, this.array), n = It(n, this.array), r = It(r, this.array)), this.array[e + 0] = Er(t), this.array[e + 1] = Er(n), this.array[e + 2] = Er(r), this } setXYZW(e, t, n, r, s) { return e *= this.itemSize, this.normalized && (t = It(t, this.array), n = It(n, this.array), r = It(r, this.array), s = It(s, this.array)), this.array[e + 0] = Er(t), this.array[e + 1] = Er(n), this.array[e + 2] = Er(r), this.array[e + 3] = Er(s), this } } class rt extends rn { constructor(e, t, n) { super(new Float32Array(e), t, n) } } class QW extends rn { constructor(e, t, n) { super(new Float64Array(e), t, n) } } let ZW = 0; const xs = new yt, UA = new qt, Ju = new k, Xr = new yo, pd = new yo, xi = new k; class Rt extends Ko { constructor() { super(), this.isBufferGeometry = !0, Object.defineProperty(this, "id", { value: ZW++ }), this.uuid = ss(), this.name = "", this.type = "BufferGeometry", this.index = null, this.attributes = {}, this.morphAttributes = {}, this.morphTargetsRelative = !1, this.groups = [], this.boundingBox = null, this.boundingSphere = null, this.drawRange = { start: 0, count: 1 / 0 }, this.userData = {} } getIndex() { return this.index } setIndex(e) { return Array.isArray(e) ? this.index = new (MF(e) ? SE : wE)(e, 1) : this.index = e, this } getAttribute(e) { return this.attributes[e] } setAttribute(e, t) { return this.attributes[e] = t, this } deleteAttribute(e) { return delete this.attributes[e], this } hasAttribute(e) { return this.attributes[e] !== void 0 } addGroup(e, t, n = 0) { this.groups.push({ start: e, count: t, materialIndex: n }) } clearGroups() { this.groups = [] } setDrawRange(e, t) { this.drawRange.start = e, this.drawRange.count = t } applyMatrix4(e) { const t = this.attributes.position; t !== void 0 && (t.applyMatrix4(e), t.needsUpdate = !0); const n = this.attributes.normal; if (n !== void 0) { const s = new Ot().getNormalMatrix(e); n.applyNormalMatrix(s), n.needsUpdate = !0 } const r = this.attributes.tangent; return r !== void 0 && (r.transformDirection(e), r.needsUpdate = !0), this.boundingBox !== null && this.computeBoundingBox(), this.boundingSphere !== null && this.computeBoundingSphere(), this } applyQuaternion(e) { return xs.makeRotationFromQuaternion(e), this.applyMatrix4(xs), this } rotateX(e) { return xs.makeRotationX(e), this.applyMatrix4(xs), this } rotateY(e) { return xs.makeRotationY(e), this.applyMatrix4(xs), this } rotateZ(e) { return xs.makeRotationZ(e), this.applyMatrix4(xs), this } translate(e, t, n) { return xs.makeTranslation(e, t, n), this.applyMatrix4(xs), this } scale(e, t, n) { return xs.makeScale(e, t, n), this.applyMatrix4(xs), this } lookAt(e) { return UA.lookAt(e), UA.updateMatrix(), this.applyMatrix4(UA.matrix), this } center() { return this.computeBoundingBox(), this.boundingBox.getCenter(Ju).negate(), this.translate(Ju.x, Ju.y, Ju.z), this } setFromPoints(e) { const t = []; for (let n = 0, r = e.length; n < r; n++) { const s = e[n]; t.push(s.x, s.y, s.z || 0) } return this.setAttribute("position", new rt(t, 3)), this } computeBoundingBox() { this.boundingBox === null && (this.boundingBox = new yo); const e = this.attributes.position, t = this.morphAttributes.position; if (e && e.isGLBufferAttribute) { console.error('THREE.BufferGeometry.computeBoundingBox(): GLBufferAttribute requires a manual bounding box. Alternatively set "mesh.frustumCulled" to "false".', this), this.boundingBox.set(new k(-1 / 0, -1 / 0, -1 / 0), new k(1 / 0, 1 / 0, 1 / 0)); return } if (e !== void 0) { if (this.boundingBox.setFromBufferAttribute(e), t) for (let n = 0, r = t.length; n < r; n++) { const s = t[n]; Xr.setFromBufferAttribute(s), this.morphTargetsRelative ? (xi.addVectors(this.boundingBox.min, Xr.min), this.boundingBox.expandByPoint(xi), xi.addVectors(this.boundingBox.max, Xr.max), this.boundingBox.expandByPoint(xi)) : (this.boundingBox.expandByPoint(Xr.min), this.boundingBox.expandByPoint(Xr.max)) } } else this.boundingBox.makeEmpty(); (isNaN(this.boundingBox.min.x) || isNaN(this.boundingBox.min.y) || isNaN(this.boundingBox.min.z)) && console.error('THREE.BufferGeometry.computeBoundingBox(): Computed min/max have NaN values. The "position" attribute is likely to have NaN values.', this) } computeBoundingSphere() { this.boundingSphere === null && (this.boundingSphere = new Gs); const e = this.attributes.position, t = this.morphAttributes.position; if (e && e.isGLBufferAttribute) { console.error('THREE.BufferGeometry.computeBoundingSphere(): GLBufferAttribute requires a manual bounding sphere. Alternatively set "mesh.frustumCulled" to "false".', this), this.boundingSphere.set(new k, 1 / 0); return } if (e) { const n = this.boundingSphere.center; if (Xr.setFromBufferAttribute(e), t) for (let s = 0, o = t.length; s < o; s++) { const a = t[s]; pd.setFromBufferAttribute(a), this.morphTargetsRelative ? (xi.addVectors(Xr.min, pd.min), Xr.expandByPoint(xi), xi.addVectors(Xr.max, pd.max), Xr.expandByPoint(xi)) : (Xr.expandByPoint(pd.min), Xr.expandByPoint(pd.max)) } Xr.getCenter(n); let r = 0; for (let s = 0, o = e.count; s < o; s++)xi.fromBufferAttribute(e, s), r = Math.max(r, n.distanceToSquared(xi)); if (t) for (let s = 0, o = t.length; s < o; s++) { const a = t[s], l = this.morphTargetsRelative; for (let c = 0, f = a.count; c < f; c++)xi.fromBufferAttribute(a, c), l && (Ju.fromBufferAttribute(e, c), xi.add(Ju)), r = Math.max(r, n.distanceToSquared(xi)) } this.boundingSphere.radius = Math.sqrt(r), isNaN(this.boundingSphere.radius) && console.error('THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.', this) } } computeTangents() { const e = this.index, t = this.attributes; if (e === null || t.position === void 0 || t.normal === void 0 || t.uv === void 0) { console.error("THREE.BufferGeometry: .computeTangents() failed. Missing required attributes (index, position, normal or uv)"); return } const n = e.array, r = t.position.array, s = t.normal.array, o = t.uv.array, a = r.length / 3; this.hasAttribute("tangent") === !1 && this.setAttribute("tangent", new rn(new Float32Array(4 * a), 4)); const l = this.getAttribute("tangent").array, c = [], f = []; for (let I = 0; I < a; I++)c[I] = new k, f[I] = new k; const d = new k, p = new k, m = new k, y = new _e, _ = new _e, x = new _e, g = new k, A = new k; function M(I, N, V) { d.fromArray(r, I * 3), p.fromArray(r, N * 3), m.fromArray(r, V * 3), y.fromArray(o, I * 2), _.fromArray(o, N * 2), x.fromArray(o, V * 2), p.sub(d), m.sub(d), _.sub(y), x.sub(y); const J = 1 / (_.x * x.y - x.x * _.y); isFinite(J) && (g.copy(p).multiplyScalar(x.y).addScaledVector(m, -_.y).multiplyScalar(J), A.copy(m).multiplyScalar(_.x).addScaledVector(p, -x.x).multiplyScalar(J), c[I].add(g), c[N].add(g), c[V].add(g), f[I].add(A), f[N].add(A), f[V].add(A)) } let S = this.groups; S.length === 0 && (S = [{ start: 0, count: n.length }]); for (let I = 0, N = S.length; I < N; ++I) { const V = S[I], J = V.start, j = V.count; for (let q = J, ne = J + j; q < ne; q += 3)M(n[q + 0], n[q + 1], n[q + 2]) } const C = new k, T = new k, R = new k, B = new k; function b(I) { R.fromArray(s, I * 3), B.copy(R); const N = c[I]; C.copy(N), C.sub(R.multiplyScalar(R.dot(N))).normalize(), T.crossVectors(B, N); const J = T.dot(f[I]) < 0 ? -1 : 1; l[I * 4] = C.x, l[I * 4 + 1] = C.y, l[I * 4 + 2] = C.z, l[I * 4 + 3] = J } for (let I = 0, N = S.length; I < N; ++I) { const V = S[I], J = V.start, j = V.count; for (let q = J, ne = J + j; q < ne; q += 3)b(n[q + 0]), b(n[q + 1]), b(n[q + 2]) } } computeVertexNormals() { const e = this.index, t = this.getAttribute("position"); if (t !== void 0) { let n = this.getAttribute("normal"); if (n === void 0) n = new rn(new Float32Array(t.count * 3), 3), this.setAttribute("normal", n); else for (let p = 0, m = n.count; p < m; p++)n.setXYZ(p, 0, 0, 0); const r = new k, s = new k, o = new k, a = new k, l = new k, c = new k, f = new k, d = new k; if (e) for (let p = 0, m = e.count; p < m; p += 3) { const y = e.getX(p + 0), _ = e.getX(p + 1), x = e.getX(p + 2); r.fromBufferAttribute(t, y), s.fromBufferAttribute(t, _), o.fromBufferAttribute(t, x), f.subVectors(o, s), d.subVectors(r, s), f.cross(d), a.fromBufferAttribute(n, y), l.fromBufferAttribute(n, _), c.fromBufferAttribute(n, x), a.add(f), l.add(f), c.add(f), n.setXYZ(y, a.x, a.y, a.z), n.setXYZ(_, l.x, l.y, l.z), n.setXYZ(x, c.x, c.y, c.z) } else for (let p = 0, m = t.count; p < m; p += 3)r.fromBufferAttribute(t, p + 0), s.fromBufferAttribute(t, p + 1), o.fromBufferAttribute(t, p + 2), f.subVectors(o, s), d.subVectors(r, s), f.cross(d), n.setXYZ(p + 0, f.x, f.y, f.z), n.setXYZ(p + 1, f.x, f.y, f.z), n.setXYZ(p + 2, f.x, f.y, f.z); this.normalizeNormals(), n.needsUpdate = !0 } } normalizeNormals() { const e = this.attributes.normal; for (let t = 0, n = e.count; t < n; t++)xi.fromBufferAttribute(e, t), xi.normalize(), e.setXYZ(t, xi.x, xi.y, xi.z) } toNonIndexed() { function e(a, l) { const c = a.array, f = a.itemSize, d = a.normalized, p = new c.constructor(l.length * f); let m = 0, y = 0; for (let _ = 0, x = l.length; _ < x; _++) { a.isInterleavedBufferAttribute ? m = l[_] * a.data.stride + a.offset : m = l[_] * f; for (let g = 0; g < f; g++)p[y++] = c[m++] } return new rn(p, f, d) } if (this.index === null) return console.warn("THREE.BufferGeometry.toNonIndexed(): BufferGeometry is already non-indexed."), this; const t = new Rt, n = this.index.array, r = this.attributes; for (const a in r) { const l = r[a], c = e(l, n); t.setAttribute(a, c) } const s = this.morphAttributes; for (const a in s) { const l = [], c = s[a]; for (let f = 0, d = c.length; f < d; f++) { const p = c[f], m = e(p, n); l.push(m) } t.morphAttributes[a] = l } t.morphTargetsRelative = this.morphTargetsRelative; const o = this.groups; for (let a = 0, l = o.length; a < l; a++) { const c = o[a]; t.addGroup(c.start, c.count, c.materialIndex) } return t } toJSON() { const e = { metadata: { version: 4.6, type: "BufferGeometry", generator: "BufferGeometry.toJSON" } }; if (e.uuid = this.uuid, e.type = this.type, this.name !== "" && (e.name = this.name), Object.keys(this.userData).length > 0 && (e.userData = this.userData), this.parameters !== void 0) { const l = this.parameters; for (const c in l) l[c] !== void 0 && (e[c] = l[c]); return e } e.data = { attributes: {} }; const t = this.index; t !== null && (e.data.index = { type: t.array.constructor.name, array: Array.prototype.slice.call(t.array) }); const n = this.attributes; for (const l in n) { const c = n[l]; e.data.attributes[l] = c.toJSON(e.data) } const r = {}; let s = !1; for (const l in this.morphAttributes) { const c = this.morphAttributes[l], f = []; for (let d = 0, p = c.length; d < p; d++) { const m = c[d]; f.push(m.toJSON(e.data)) } f.length > 0 && (r[l] = f, s = !0) } s && (e.data.morphAttributes = r, e.data.morphTargetsRelative = this.morphTargetsRelative); const o = this.groups; o.length > 0 && (e.data.groups = JSON.parse(JSON.stringify(o))); const a = this.boundingSphere; return a !== null && (e.data.boundingSphere = { center: a.center.toArray(), radius: a.radius }), e } clone() { return new this.constructor().copy(this) } copy(e) { this.index = null, this.attributes = {}, this.morphAttributes = {}, this.groups = [], this.boundingBox = null, this.boundingSphere = null; const t = {}; this.name = e.name; const n = e.index; n !== null && this.setIndex(n.clone(t)); const r = e.attributes; for (const c in r) { const f = r[c]; this.setAttribute(c, f.clone(t)) } const s = e.morphAttributes; for (const c in s) { const f = [], d = s[c]; for (let p = 0, m = d.length; p < m; p++)f.push(d[p].clone(t)); this.morphAttributes[c] = f } this.morphTargetsRelative = e.morphTargetsRelative; const o = e.groups; for (let c = 0, f = o.length; c < f; c++) { const d = o[c]; this.addGroup(d.start, d.count, d.materialIndex) } const a = e.boundingBox; a !== null && (this.boundingBox = a.clone()); const l = e.boundingSphere; return l !== null && (this.boundingSphere = l.clone()), this.drawRange.start = e.drawRange.start, this.drawRange.count = e.drawRange.count, this.userData = e.userData, this } dispose() { this.dispatchEvent({ type: "dispose" }) } } const lP = new yt, lc = new Ph, Qg = new Gs, cP = new k, Yu = new k, ju = new k, Ku = new k, zA = new k, Zg = new k, $g = new _e, e0 = new _e, t0 = new _e, uP = new k, fP = new k, hP = new k, n0 = new k, i0 = new k; class Ei extends qt { constructor(e = new Rt, t = new ts) { super(), this.isMesh = !0, this.type = "Mesh", this.geometry = e, this.material = t, this.updateMorphTargets() } copy(e, t) { return super.copy(e, t), e.morphTargetInfluences !== void 0 && (this.morphTargetInfluences = e.morphTargetInfluences.slice()), e.morphTargetDictionary !== void 0 && (this.morphTargetDictionary = Object.assign({}, e.morphTargetDictionary)), this.material = e.material, this.geometry = e.geometry, this } updateMorphTargets() { const t = this.geometry.morphAttributes, n = Object.keys(t); if (n.length > 0) { const r = t[n[0]]; if (r !== void 0) { this.morphTargetInfluences = [], this.morphTargetDictionary = {}; for (let s = 0, o = r.length; s < o; s++) { const a = r[s].name || String(s); this.morphTargetInfluences.push(0), this.morphTargetDictionary[a] = s } } } } getVertexPosition(e, t) { const n = this.geometry, r = n.attributes.position, s = n.morphAttributes.position, o = n.morphTargetsRelative; t.fromBufferAttribute(r, e); const a = this.morphTargetInfluences; if (s && a) { Zg.set(0, 0, 0); for (let l = 0, c = s.length; l < c; l++) { const f = a[l], d = s[l]; f !== 0 && (zA.fromBufferAttribute(d, e), o ? Zg.addScaledVector(zA, f) : Zg.addScaledVector(zA.sub(t), f)) } t.add(Zg) } return t } raycast(e, t) { const n = this.geometry, r = this.material, s = this.matrixWorld; r !== void 0 && (n.boundingSphere === null && n.computeBoundingSphere(), Qg.copy(n.boundingSphere), Qg.applyMatrix4(s), lc.copy(e.ray).recast(e.near), !(Qg.containsPoint(lc.origin) === !1 && (lc.intersectSphere(Qg, cP) === null || lc.origin.distanceToSquared(cP) > (e.far - e.near) ** 2)) && (lP.copy(s).invert(), lc.copy(e.ray).applyMatrix4(lP), !(n.boundingBox !== null && lc.intersectsBox(n.boundingBox) === !1) && this._computeIntersections(e, t, lc))) } _computeIntersections(e, t, n) { let r; const s = this.geometry, o = this.material, a = s.index, l = s.attributes.position, c = s.attributes.uv, f = s.attributes.uv1, d = s.attributes.normal, p = s.groups, m = s.drawRange; if (a !== null) if (Array.isArray(o)) for (let y = 0, _ = p.length; y < _; y++) { const x = p[y], g = o[x.materialIndex], A = Math.max(x.start, m.start), M = Math.min(a.count, Math.min(x.start + x.count, m.start + m.count)); for (let S = A, C = M; S < C; S += 3) { const T = a.getX(S), R = a.getX(S + 1), B = a.getX(S + 2); r = r0(this, g, e, n, c, f, d, T, R, B), r && (r.faceIndex = Math.floor(S / 3), r.face.materialIndex = x.materialIndex, t.push(r)) } } else { const y = Math.max(0, m.start), _ = Math.min(a.count, m.start + m.count); for (let x = y, g = _; x < g; x += 3) { const A = a.getX(x), M = a.getX(x + 1), S = a.getX(x + 2); r = r0(this, o, e, n, c, f, d, A, M, S), r && (r.faceIndex = Math.floor(x / 3), t.push(r)) } } else if (l !== void 0) if (Array.isArray(o)) for (let y = 0, _ = p.length; y < _; y++) { const x = p[y], g = o[x.materialIndex], A = Math.max(x.start, m.start), M = Math.min(l.count, Math.min(x.start + x.count, m.start + m.count)); for (let S = A, C = M; S < C; S += 3) { const T = S, R = S + 1, B = S + 2; r = r0(this, g, e, n, c, f, d, T, R, B), r && (r.faceIndex = Math.floor(S / 3), r.face.materialIndex = x.materialIndex, t.push(r)) } } else { const y = Math.max(0, m.start), _ = Math.min(l.count, m.start + m.count); for (let x = y, g = _; x < g; x += 3) { const A = x, M = x + 1, S = x + 2; r = r0(this, o, e, n, c, f, d, A, M, S), r && (r.faceIndex = Math.floor(x / 3), t.push(r)) } } } } function $W(i, e, t, n, r, s, o, a) { let l; if (e.side === _r ? l = n.intersectTriangle(o, s, r, !0, a) : l = n.intersectTriangle(r, s, o, e.side === Jo, a), l === null) return null; i0.copy(a), i0.applyMatrix4(i.matrixWorld); const c = t.ray.origin.distanceTo(i0); return c < t.near || c > t.far ? null : { distance: c, point: i0.clone(), object: i } } function r0(i, e, t, n, r, s, o, a, l, c) { i.getVertexPosition(a, Yu), i.getVertexPosition(l, ju), i.getVertexPosition(c, Ku); const f = $W(i, e, t, n, Yu, ju, Ku, n0); if (f) { r && ($g.fromBufferAttribute(r, a), e0.fromBufferAttribute(r, l), t0.fromBufferAttribute(r, c), f.uv = br.getInterpolation(n0, Yu, ju, Ku, $g, e0, t0, new _e)), s && ($g.fromBufferAttribute(s, a), e0.fromBufferAttribute(s, l), t0.fromBufferAttribute(s, c), f.uv1 = br.getInterpolation(n0, Yu, ju, Ku, $g, e0, t0, new _e), f.uv2 = f.uv1), o && (uP.fromBufferAttribute(o, a), fP.fromBufferAttribute(o, l), hP.fromBufferAttribute(o, c), f.normal = br.getInterpolation(n0, Yu, ju, Ku, uP, fP, hP, new k), f.normal.dot(n.direction) > 0 && f.normal.multiplyScalar(-1)); const d = { a, b: l, c, normal: new k, materialIndex: 0 }; br.getNormal(Yu, ju, Ku, d.normal), f.face = d } return f } class pu extends Rt { constructor(e = 1, t = 1, n = 1, r = 1, s = 1, o = 1) { super(), this.type = "BoxGeometry", this.parameters = { width: e, height: t, depth: n, widthSegments: r, heightSegments: s, depthSegments: o }; const a = this; r = Math.floor(r), s = Math.floor(s), o = Math.floor(o); const l = [], c = [], f = [], d = []; let p = 0, m = 0; y("z", "y", "x", -1, -1, n, t, e, o, s, 0), y("z", "y", "x", 1, -1, n, t, -e, o, s, 1), y("x", "z", "y", 1, 1, e, n, t, r, o, 2), y("x", "z", "y", 1, -1, e, n, -t, r, o, 3), y("x", "y", "z", 1, -1, e, t, n, r, s, 4), y("x", "y", "z", -1, -1, e, t, -n, r, s, 5), this.setIndex(l), this.setAttribute("position", new rt(c, 3)), this.setAttribute("normal", new rt(f, 3)), this.setAttribute("uv", new rt(d, 2)); function y(_, x, g, A, M, S, C, T, R, B, b) { const I = S / R, N = C / B, V = S / 2, J = C / 2, j = T / 2, q = R + 1, ne = B + 1; let Q = 0, F = 0; const Y = new k; for (let L = 0; L < ne; L++) { const G = L * N - J; for (let K = 0; K < q; K++) { const ye = K * I - V; Y[_] = ye * A, Y[x] = G * M, Y[g] = j, c.push(Y.x, Y.y, Y.z), Y[_] = 0, Y[x] = 0, Y[g] = T > 0 ? 1 : -1, f.push(Y.x, Y.y, Y.z), d.push(K / R), d.push(1 - L / B), Q += 1 } } for (let L = 0; L < B; L++)for (let G = 0; G < R; G++) { const K = p + G + q * L, ye = p + G + q * (L + 1), ge = p + (G + 1) + q * (L + 1), xe = p + (G + 1) + q * L; l.push(K, ye, xe), l.push(ye, ge, xe), F += 6 } a.addGroup(m, F, b), m += F, p += Q } } copy(e) { return super.copy(e), this.parameters = Object.assign({}, e.parameters), this } static fromJSON(e) { return new pu(e.width, e.height, e.depth, e.widthSegments, e.heightSegments, e.depthSegments) } } function _h(i) { const e = {}; for (const t in i) { e[t] = {}; for (const n in i[t]) { const r = i[t][n]; r && (r.isColor || r.isMatrix3 || r.isMatrix4 || r.isVector2 || r.isVector3 || r.isVector4 || r.isTexture || r.isQuaternion) ? r.isRenderTargetTexture ? (console.warn("UniformsUtils: Textures of render targets cannot be cloned via cloneUniforms() or mergeUniforms()."), e[t][n] = null) : e[t][n] = r.clone() : Array.isArray(r) ? e[t][n] = r.slice() : e[t][n] = r } } return e } function ur(i) { const e = {}; for (let t = 0; t < i.length; t++) { const n = _h(i[t]); for (const r in n) e[r] = n[r] } return e } function e6(i) { const e = []; for (let t = 0; t < i.length; t++)e.push(i[t].clone()); return e } function EF(i) { return i.getRenderTarget() === null ? i.outputColorSpace : po } const CF = { clone: _h, merge: ur }; var t6 = `void main() {
	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
}`, n6 = `void main() {
	gl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );
}`; class jo extends oi { constructor(e) { super(), this.isShaderMaterial = !0, this.type = "ShaderMaterial", this.defines = {}, this.uniforms = {}, this.uniformsGroups = [], this.vertexShader = t6, this.fragmentShader = n6, this.linewidth = 1, this.wireframe = !1, this.wireframeLinewidth = 1, this.fog = !1, this.lights = !1, this.clipping = !1, this.forceSinglePass = !0, this.extensions = { derivatives: !1, fragDepth: !1, drawBuffers: !1, shaderTextureLOD: !1 }, this.defaultAttributeValues = { color: [1, 1, 1], uv: [0, 0], uv1: [0, 0] }, this.index0AttributeName = void 0, this.uniformsNeedUpdate = !1, this.glslVersion = null, e !== void 0 && this.setValues(e) } copy(e) { return super.copy(e), this.fragmentShader = e.fragmentShader, this.vertexShader = e.vertexShader, this.uniforms = _h(e.uniforms), this.uniformsGroups = e6(e.uniformsGroups), this.defines = Object.assign({}, e.defines), this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.fog = e.fog, this.lights = e.lights, this.clipping = e.clipping, this.extensions = Object.assign({}, e.extensions), this.glslVersion = e.glslVersion, this } toJSON(e) { const t = super.toJSON(e); t.glslVersion = this.glslVersion, t.uniforms = {}; for (const r in this.uniforms) { const o = this.uniforms[r].value; o && o.isTexture ? t.uniforms[r] = { type: "t", value: o.toJSON(e).uuid } : o && o.isColor ? t.uniforms[r] = { type: "c", value: o.getHex() } : o && o.isVector2 ? t.uniforms[r] = { type: "v2", value: o.toArray() } : o && o.isVector3 ? t.uniforms[r] = { type: "v3", value: o.toArray() } : o && o.isVector4 ? t.uniforms[r] = { type: "v4", value: o.toArray() } : o && o.isMatrix3 ? t.uniforms[r] = { type: "m3", value: o.toArray() } : o && o.isMatrix4 ? t.uniforms[r] = { type: "m4", value: o.toArray() } : t.uniforms[r] = { value: o } } Object.keys(this.defines).length > 0 && (t.defines = this.defines), t.vertexShader = this.vertexShader, t.fragmentShader = this.fragmentShader, t.lights = this.lights, t.clipping = this.clipping; const n = {}; for (const r in this.extensions) this.extensions[r] === !0 && (n[r] = !0); return Object.keys(n).length > 0 && (t.extensions = n), t } } class am extends qt { constructor() { super(), this.isCamera = !0, this.type = "Camera", this.matrixWorldInverse = new yt, this.projectionMatrix = new yt, this.projectionMatrixInverse = new yt, this.coordinateSystem = Oo } copy(e, t) { return super.copy(e, t), this.matrixWorldInverse.copy(e.matrixWorldInverse), this.projectionMatrix.copy(e.projectionMatrix), this.projectionMatrixInverse.copy(e.projectionMatrixInverse), this.coordinateSystem = e.coordinateSystem, this } getWorldDirection(e) { this.updateWorldMatrix(!0, !1); const t = this.matrixWorld.elements; return e.set(-t[8], -t[9], -t[10]).normalize() } updateMatrixWorld(e) { super.updateMatrixWorld(e), this.matrixWorldInverse.copy(this.matrixWorld).invert() } updateWorldMatrix(e, t) { super.updateWorldMatrix(e, t), this.matrixWorldInverse.copy(this.matrixWorld).invert() } clone() { return new this.constructor().copy(this) } } class Vn extends am { constructor(e = 50, t = 1, n = .1, r = 2e3) { super(), this.isPerspectiveCamera = !0, this.type = "PerspectiveCamera", this.fov = e, this.zoom = 1, this.near = n, this.far = r, this.focus = 10, this.aspect = t, this.view = null, this.filmGauge = 35, this.filmOffset = 0, this.updateProjectionMatrix() } copy(e, t) { return super.copy(e, t), this.fov = e.fov, this.zoom = e.zoom, this.near = e.near, this.far = e.far, this.focus = e.focus, this.aspect = e.aspect, this.view = e.view === null ? null : Object.assign({}, e.view), this.filmGauge = e.filmGauge, this.filmOffset = e.filmOffset, this } setFocalLength(e) { const t = .5 * this.getFilmHeight() / e; this.fov = vh * 2 * Math.atan(t), this.updateProjectionMatrix() } getFocalLength() { const e = Math.tan(Yc * .5 * this.fov); return .5 * this.getFilmHeight() / e } getEffectiveFOV() { return vh * 2 * Math.atan(Math.tan(Yc * .5 * this.fov) / this.zoom) } getFilmWidth() { return this.filmGauge * Math.min(this.aspect, 1) } getFilmHeight() { return this.filmGauge / Math.max(this.aspect, 1) } setViewOffset(e, t, n, r, s, o) { this.aspect = e / t, this.view === null && (this.view = { enabled: !0, fullWidth: 1, fullHeight: 1, offsetX: 0, offsetY: 0, width: 1, height: 1 }), this.view.enabled = !0, this.view.fullWidth = e, this.view.fullHeight = t, this.view.offsetX = n, this.view.offsetY = r, this.view.width = s, this.view.height = o, this.updateProjectionMatrix() } clearViewOffset() { this.view !== null && (this.view.enabled = !1), this.updateProjectionMatrix() } updateProjectionMatrix() { const e = this.near; let t = e * Math.tan(Yc * .5 * this.fov) / this.zoom, n = 2 * t, r = this.aspect * n, s = -.5 * r; const o = this.view; if (this.view !== null && this.view.enabled) { const l = o.fullWidth, c = o.fullHeight; s += o.offsetX * r / l, t -= o.offsetY * n / c, r *= o.width / l, n *= o.height / c } const a = this.filmOffset; a !== 0 && (s += e * a / this.getFilmWidth()), this.projectionMatrix.makePerspective(s, s + r, t, t - n, e, this.far, this.coordinateSystem), this.projectionMatrixInverse.copy(this.projectionMatrix).invert() } toJSON(e) { const t = super.toJSON(e); return t.object.fov = this.fov, t.object.zoom = this.zoom, t.object.near = this.near, t.object.far = this.far, t.object.focus = this.focus, t.object.aspect = this.aspect, this.view !== null && (t.object.view = Object.assign({}, this.view)), t.object.filmGauge = this.filmGauge, t.object.filmOffset = this.filmOffset, t } } const qu = -90, Qu = 1; class TF extends qt { constructor(e, t, n) { super(), this.type = "CubeCamera", this.renderTarget = n, this.coordinateSystem = null; const r = new Vn(qu, Qu, e, t); r.layers = this.layers, this.add(r); const s = new Vn(qu, Qu, e, t); s.layers = this.layers, this.add(s); const o = new Vn(qu, Qu, e, t); o.layers = this.layers, this.add(o); const a = new Vn(qu, Qu, e, t); a.layers = this.layers, this.add(a); const l = new Vn(qu, Qu, e, t); l.layers = this.layers, this.add(l); const c = new Vn(qu, Qu, e, t); c.layers = this.layers, this.add(c) } updateCoordinateSystem() { const e = this.coordinateSystem, t = this.children.concat(), [n, r, s, o, a, l] = t; for (const c of t) this.remove(c); if (e === Oo) n.up.set(0, 1, 0), n.lookAt(1, 0, 0), r.up.set(0, 1, 0), r.lookAt(-1, 0, 0), s.up.set(0, 0, -1), s.lookAt(0, 1, 0), o.up.set(0, 0, 1), o.lookAt(0, -1, 0), a.up.set(0, 1, 0), a.lookAt(0, 0, 1), l.up.set(0, 1, 0), l.lookAt(0, 0, -1); else if (e === Hp) n.up.set(0, -1, 0), n.lookAt(-1, 0, 0), r.up.set(0, -1, 0), r.lookAt(1, 0, 0), s.up.set(0, 0, 1), s.lookAt(0, 1, 0), o.up.set(0, 0, -1), o.lookAt(0, -1, 0), a.up.set(0, -1, 0), a.lookAt(0, 0, 1), l.up.set(0, -1, 0), l.lookAt(0, 0, -1); else throw new Error("THREE.CubeCamera.updateCoordinateSystem(): Invalid coordinate system: " + e); for (const c of t) this.add(c), c.updateMatrixWorld() } update(e, t) { this.parent === null && this.updateMatrixWorld(); const n = this.renderTarget; this.coordinateSystem !== e.coordinateSystem && (this.coordinateSystem = e.coordinateSystem, this.updateCoordinateSystem()); const [r, s, o, a, l, c] = this.children, f = e.getRenderTarget(), d = e.xr.enabled; e.xr.enabled = !1; const p = n.texture.generateMipmaps; n.texture.generateMipmaps = !1, e.setRenderTarget(n, 0), e.render(t, r), e.setRenderTarget(n, 1), e.render(t, s), e.setRenderTarget(n, 2), e.render(t, o), e.setRenderTarget(n, 3), e.render(t, a), e.setRenderTarget(n, 4), e.render(t, l), n.texture.generateMipmaps = p, e.setRenderTarget(n, 5), e.render(t, c), e.setRenderTarget(f), e.xr.enabled = d, n.texture.needsPMREMUpdate = !0 } } class lm extends wn { constructor(e, t, n, r, s, o, a, l, c, f) { e = e !== void 0 ? e : [], t = t !== void 0 ? t : Da, super(e, t, n, r, s, o, a, l, c, f), this.isCubeTexture = !0, this.flipY = !1 } get images() { return this.image } set images(e) { this.image = e } } class bF extends mo {
	constructor(e = 1, t = {}) { super(e, e, t), this.isWebGLCubeRenderTarget = !0; const n = { width: e, height: e, depth: 1 }, r = [n, n, n, n, n, n]; t.encoding !== void 0 && (op("THREE.WebGLCubeRenderTarget: option.encoding has been replaced by option.colorSpace."), t.colorSpace = t.encoding === Pl ? bt : Il), this.texture = new lm(r, t.mapping, t.wrapS, t.wrapT, t.magFilter, t.minFilter, t.format, t.type, t.anisotropy, t.colorSpace), this.texture.isRenderTargetTexture = !0, this.texture.generateMipmaps = t.generateMipmaps !== void 0 ? t.generateMipmaps : !1, this.texture.minFilter = t.minFilter !== void 0 ? t.minFilter : Pn } fromEquirectangularTexture(e, t) {
		this.texture.type = t.type, this.texture.colorSpace = t.colorSpace, this.texture.generateMipmaps = t.generateMipmaps, this.texture.minFilter = t.minFilter, this.texture.magFilter = t.magFilter; const n = {
			uniforms: { tEquirect: { value: null } }, vertexShader: `

				varying vec3 vWorldDirection;

				vec3 transformDirection( in vec3 dir, in mat4 matrix ) {

					return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );

				}

				void main() {

					vWorldDirection = transformDirection( position, modelMatrix );

					#include <begin_vertex>
					#include <project_vertex>

				}
			`, fragmentShader: `

				uniform sampler2D tEquirect;

				varying vec3 vWorldDirection;

				#include <common>

				void main() {

					vec3 direction = normalize( vWorldDirection );

					vec2 sampleUV = equirectUv( direction );

					gl_FragColor = texture2D( tEquirect, sampleUV );

				}
			`}, r = new pu(5, 5, 5), s = new jo({ name: "CubemapFromEquirect", uniforms: _h(n.uniforms), vertexShader: n.vertexShader, fragmentShader: n.fragmentShader, side: _r, blending: Ea }); s.uniforms.tEquirect.value = t; const o = new Ei(r, s), a = t.minFilter; return t.minFilter === Yo && (t.minFilter = Pn), new TF(1, 10, this).update(e, o), t.minFilter = a, o.geometry.dispose(), o.material.dispose(), this
	} clear(e, t, n, r) { const s = e.getRenderTarget(); for (let o = 0; o < 6; o++)e.setRenderTarget(this, o), e.clear(t, n, r); e.setRenderTarget(s) }
} const HA = new k, i6 = new k, r6 = new Ot; class il { constructor(e = new k(1, 0, 0), t = 0) { this.isPlane = !0, this.normal = e, this.constant = t } set(e, t) { return this.normal.copy(e), this.constant = t, this } setComponents(e, t, n, r) { return this.normal.set(e, t, n), this.constant = r, this } setFromNormalAndCoplanarPoint(e, t) { return this.normal.copy(e), this.constant = -t.dot(this.normal), this } setFromCoplanarPoints(e, t, n) { const r = HA.subVectors(n, t).cross(i6.subVectors(e, t)).normalize(); return this.setFromNormalAndCoplanarPoint(r, e), this } copy(e) { return this.normal.copy(e.normal), this.constant = e.constant, this } normalize() { const e = 1 / this.normal.length(); return this.normal.multiplyScalar(e), this.constant *= e, this } negate() { return this.constant *= -1, this.normal.negate(), this } distanceToPoint(e) { return this.normal.dot(e) + this.constant } distanceToSphere(e) { return this.distanceToPoint(e.center) - e.radius } projectPoint(e, t) { return t.copy(e).addScaledVector(this.normal, -this.distanceToPoint(e)) } intersectLine(e, t) { const n = e.delta(HA), r = this.normal.dot(n); if (r === 0) return this.distanceToPoint(e.start) === 0 ? t.copy(e.start) : null; const s = -(e.start.dot(this.normal) + this.constant) / r; return s < 0 || s > 1 ? null : t.copy(e.start).addScaledVector(n, s) } intersectsLine(e) { const t = this.distanceToPoint(e.start), n = this.distanceToPoint(e.end); return t < 0 && n > 0 || n < 0 && t > 0 } intersectsBox(e) { return e.intersectsPlane(this) } intersectsSphere(e) { return e.intersectsPlane(this) } coplanarPoint(e) { return e.copy(this.normal).multiplyScalar(-this.constant) } applyMatrix4(e, t) { const n = t || r6.getNormalMatrix(e), r = this.coplanarPoint(HA).applyMatrix4(e), s = this.normal.applyMatrix3(n).normalize(); return this.constant = -r.dot(s), this } translate(e) { return this.constant -= e.dot(this.normal), this } equals(e) { return e.normal.equals(this.normal) && e.constant === this.constant } clone() { return new this.constructor().copy(this) } } const cc = new Gs, s0 = new k; class zv { constructor(e = new il, t = new il, n = new il, r = new il, s = new il, o = new il) { this.planes = [e, t, n, r, s, o] } set(e, t, n, r, s, o) { const a = this.planes; return a[0].copy(e), a[1].copy(t), a[2].copy(n), a[3].copy(r), a[4].copy(s), a[5].copy(o), this } copy(e) { const t = this.planes; for (let n = 0; n < 6; n++)t[n].copy(e.planes[n]); return this } setFromProjectionMatrix(e, t = Oo) { const n = this.planes, r = e.elements, s = r[0], o = r[1], a = r[2], l = r[3], c = r[4], f = r[5], d = r[6], p = r[7], m = r[8], y = r[9], _ = r[10], x = r[11], g = r[12], A = r[13], M = r[14], S = r[15]; if (n[0].setComponents(l - s, p - c, x - m, S - g).normalize(), n[1].setComponents(l + s, p + c, x + m, S + g).normalize(), n[2].setComponents(l + o, p + f, x + y, S + A).normalize(), n[3].setComponents(l - o, p - f, x - y, S - A).normalize(), n[4].setComponents(l - a, p - d, x - _, S - M).normalize(), t === Oo) n[5].setComponents(l + a, p + d, x + _, S + M).normalize(); else if (t === Hp) n[5].setComponents(a, d, _, M).normalize(); else throw new Error("THREE.Frustum.setFromProjectionMatrix(): Invalid coordinate system: " + t); return this } intersectsObject(e) { if (e.boundingSphere !== void 0) e.boundingSphere === null && e.computeBoundingSphere(), cc.copy(e.boundingSphere).applyMatrix4(e.matrixWorld); else { const t = e.geometry; t.boundingSphere === null && t.computeBoundingSphere(), cc.copy(t.boundingSphere).applyMatrix4(e.matrixWorld) } return this.intersectsSphere(cc) } intersectsSprite(e) { return cc.center.set(0, 0, 0), cc.radius = .7071067811865476, cc.applyMatrix4(e.matrixWorld), this.intersectsSphere(cc) } intersectsSphere(e) { const t = this.planes, n = e.center, r = -e.radius; for (let s = 0; s < 6; s++)if (t[s].distanceToPoint(n) < r) return !1; return !0 } intersectsBox(e) { const t = this.planes; for (let n = 0; n < 6; n++) { const r = t[n]; if (s0.x = r.normal.x > 0 ? e.max.x : e.min.x, s0.y = r.normal.y > 0 ? e.max.y : e.min.y, s0.z = r.normal.z > 0 ? e.max.z : e.min.z, r.distanceToPoint(s0) < 0) return !1 } return !0 } containsPoint(e) { const t = this.planes; for (let n = 0; n < 6; n++)if (t[n].distanceToPoint(e) < 0) return !1; return !0 } clone() { return new this.constructor().copy(this) } } function RF() { let i = null, e = !1, t = null, n = null; function r(s, o) { t(s, o), n = i.requestAnimationFrame(r) } return { start: function () { e !== !0 && t !== null && (n = i.requestAnimationFrame(r), e = !0) }, stop: function () { i.cancelAnimationFrame(n), e = !1 }, setAnimationLoop: function (s) { t = s }, setContext: function (s) { i = s } } } function s6(i, e) { const t = e.isWebGL2, n = new WeakMap; function r(c, f) { const d = c.array, p = c.usage, m = i.createBuffer(); i.bindBuffer(f, m), i.bufferData(f, d, p), c.onUploadCallback(); let y; if (d instanceof Float32Array) y = i.FLOAT; else if (d instanceof Uint16Array) if (c.isFloat16BufferAttribute) if (t) y = i.HALF_FLOAT; else throw new Error("THREE.WebGLAttributes: Usage of Float16BufferAttribute requires WebGL2."); else y = i.UNSIGNED_SHORT; else if (d instanceof Int16Array) y = i.SHORT; else if (d instanceof Uint32Array) y = i.UNSIGNED_INT; else if (d instanceof Int32Array) y = i.INT; else if (d instanceof Int8Array) y = i.BYTE; else if (d instanceof Uint8Array) y = i.UNSIGNED_BYTE; else if (d instanceof Uint8ClampedArray) y = i.UNSIGNED_BYTE; else throw new Error("THREE.WebGLAttributes: Unsupported buffer data format: " + d); return { buffer: m, type: y, bytesPerElement: d.BYTES_PER_ELEMENT, version: c.version } } function s(c, f, d) { const p = f.array, m = f.updateRange; i.bindBuffer(d, c), m.count === -1 ? i.bufferSubData(d, 0, p) : (t ? i.bufferSubData(d, m.offset * p.BYTES_PER_ELEMENT, p, m.offset, m.count) : i.bufferSubData(d, m.offset * p.BYTES_PER_ELEMENT, p.subarray(m.offset, m.offset + m.count)), m.count = -1), f.onUploadCallback() } function o(c) { return c.isInterleavedBufferAttribute && (c = c.data), n.get(c) } function a(c) { c.isInterleavedBufferAttribute && (c = c.data); const f = n.get(c); f && (i.deleteBuffer(f.buffer), n.delete(c)) } function l(c, f) { if (c.isGLBufferAttribute) { const p = n.get(c); (!p || p.version < c.version) && n.set(c, { buffer: c.buffer, type: c.type, bytesPerElement: c.elementSize, version: c.version }); return } c.isInterleavedBufferAttribute && (c = c.data); const d = n.get(c); d === void 0 ? n.set(c, r(c, f)) : d.version < c.version && (s(d.buffer, c, f), d.version = c.version) } return { get: o, remove: a, update: l } } class cm extends Rt { constructor(e = 1, t = 1, n = 1, r = 1) { super(), this.type = "PlaneGeometry", this.parameters = { width: e, height: t, widthSegments: n, heightSegments: r }; const s = e / 2, o = t / 2, a = Math.floor(n), l = Math.floor(r), c = a + 1, f = l + 1, d = e / a, p = t / l, m = [], y = [], _ = [], x = []; for (let g = 0; g < f; g++) { const A = g * p - o; for (let M = 0; M < c; M++) { const S = M * d - s; y.push(S, -A, 0), _.push(0, 0, 1), x.push(M / a), x.push(1 - g / l) } } for (let g = 0; g < l; g++)for (let A = 0; A < a; A++) { const M = A + c * g, S = A + c * (g + 1), C = A + 1 + c * (g + 1), T = A + 1 + c * g; m.push(M, S, T), m.push(S, C, T) } this.setIndex(m), this.setAttribute("position", new rt(y, 3)), this.setAttribute("normal", new rt(_, 3)), this.setAttribute("uv", new rt(x, 2)) } copy(e) { return super.copy(e), this.parameters = Object.assign({}, e.parameters), this } static fromJSON(e) { return new cm(e.width, e.height, e.widthSegments, e.heightSegments) } } var o6 = `#ifdef USE_ALPHAHASH
	if ( diffuseColor.a < getAlphaHashThreshold( vPosition ) ) discard;
#endif`, a6 = `#ifdef USE_ALPHAHASH
	const float ALPHA_HASH_SCALE = 0.05;
	float hash2D( vec2 value ) {
		return fract( 1.0e4 * sin( 17.0 * value.x + 0.1 * value.y ) * ( 0.1 + abs( sin( 13.0 * value.y + value.x ) ) ) );
	}
	float hash3D( vec3 value ) {
		return hash2D( vec2( hash2D( value.xy ), value.z ) );
	}
	float getAlphaHashThreshold( vec3 position ) {
		float maxDeriv = max(
			length( dFdx( position.xyz ) ),
			length( dFdy( position.xyz ) )
		);
		float pixScale = 1.0 / ( ALPHA_HASH_SCALE * maxDeriv );
		vec2 pixScales = vec2(
			exp2( floor( log2( pixScale ) ) ),
			exp2( ceil( log2( pixScale ) ) )
		);
		vec2 alpha = vec2(
			hash3D( floor( pixScales.x * position.xyz ) ),
			hash3D( floor( pixScales.y * position.xyz ) )
		);
		float lerpFactor = fract( log2( pixScale ) );
		float x = ( 1.0 - lerpFactor ) * alpha.x + lerpFactor * alpha.y;
		float a = min( lerpFactor, 1.0 - lerpFactor );
		vec3 cases = vec3(
			x * x / ( 2.0 * a * ( 1.0 - a ) ),
			( x - 0.5 * a ) / ( 1.0 - a ),
			1.0 - ( ( 1.0 - x ) * ( 1.0 - x ) / ( 2.0 * a * ( 1.0 - a ) ) )
		);
		float threshold = ( x < ( 1.0 - a ) )
			? ( ( x < a ) ? cases.x : cases.y )
			: cases.z;
		return clamp( threshold , 1.0e-6, 1.0 );
	}
#endif`, l6 = `#ifdef USE_ALPHAMAP
	diffuseColor.a *= texture2D( alphaMap, vAlphaMapUv ).g;
#endif`, c6 = `#ifdef USE_ALPHAMAP
	uniform sampler2D alphaMap;
#endif`, u6 = `#ifdef USE_ALPHATEST
	if ( diffuseColor.a < alphaTest ) discard;
#endif`, f6 = `#ifdef USE_ALPHATEST
	uniform float alphaTest;
#endif`, h6 = `#ifdef USE_AOMAP
	float ambientOcclusion = ( texture2D( aoMap, vAoMapUv ).r - 1.0 ) * aoMapIntensity + 1.0;
	reflectedLight.indirectDiffuse *= ambientOcclusion;
	#if defined( USE_ENVMAP ) && defined( STANDARD )
		float dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );
		reflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.roughness );
	#endif
#endif`, d6 = `#ifdef USE_AOMAP
	uniform sampler2D aoMap;
	uniform float aoMapIntensity;
#endif`, p6 = `vec3 transformed = vec3( position );
#ifdef USE_ALPHAHASH
	vPosition = vec3( position );
#endif`, m6 = `vec3 objectNormal = vec3( normal );
#ifdef USE_TANGENT
	vec3 objectTangent = vec3( tangent.xyz );
#endif`, g6 = `float G_BlinnPhong_Implicit( ) {
	return 0.25;
}
float D_BlinnPhong( const in float shininess, const in float dotNH ) {
	return RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );
}
vec3 BRDF_BlinnPhong( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float shininess ) {
	vec3 halfDir = normalize( lightDir + viewDir );
	float dotNH = saturate( dot( normal, halfDir ) );
	float dotVH = saturate( dot( viewDir, halfDir ) );
	vec3 F = F_Schlick( specularColor, 1.0, dotVH );
	float G = G_BlinnPhong_Implicit( );
	float D = D_BlinnPhong( shininess, dotNH );
	return F * ( G * D );
} // validated`, y6 = `#ifdef USE_IRIDESCENCE
	const mat3 XYZ_TO_REC709 = mat3(
		 3.2404542, -0.9692660,  0.0556434,
		-1.5371385,  1.8760108, -0.2040259,
		-0.4985314,  0.0415560,  1.0572252
	);
	vec3 Fresnel0ToIor( vec3 fresnel0 ) {
		vec3 sqrtF0 = sqrt( fresnel0 );
		return ( vec3( 1.0 ) + sqrtF0 ) / ( vec3( 1.0 ) - sqrtF0 );
	}
	vec3 IorToFresnel0( vec3 transmittedIor, float incidentIor ) {
		return pow2( ( transmittedIor - vec3( incidentIor ) ) / ( transmittedIor + vec3( incidentIor ) ) );
	}
	float IorToFresnel0( float transmittedIor, float incidentIor ) {
		return pow2( ( transmittedIor - incidentIor ) / ( transmittedIor + incidentIor ));
	}
	vec3 evalSensitivity( float OPD, vec3 shift ) {
		float phase = 2.0 * PI * OPD * 1.0e-9;
		vec3 val = vec3( 5.4856e-13, 4.4201e-13, 5.2481e-13 );
		vec3 pos = vec3( 1.6810e+06, 1.7953e+06, 2.2084e+06 );
		vec3 var = vec3( 4.3278e+09, 9.3046e+09, 6.6121e+09 );
		vec3 xyz = val * sqrt( 2.0 * PI * var ) * cos( pos * phase + shift ) * exp( - pow2( phase ) * var );
		xyz.x += 9.7470e-14 * sqrt( 2.0 * PI * 4.5282e+09 ) * cos( 2.2399e+06 * phase + shift[ 0 ] ) * exp( - 4.5282e+09 * pow2( phase ) );
		xyz /= 1.0685e-7;
		vec3 rgb = XYZ_TO_REC709 * xyz;
		return rgb;
	}
	vec3 evalIridescence( float outsideIOR, float eta2, float cosTheta1, float thinFilmThickness, vec3 baseF0 ) {
		vec3 I;
		float iridescenceIOR = mix( outsideIOR, eta2, smoothstep( 0.0, 0.03, thinFilmThickness ) );
		float sinTheta2Sq = pow2( outsideIOR / iridescenceIOR ) * ( 1.0 - pow2( cosTheta1 ) );
		float cosTheta2Sq = 1.0 - sinTheta2Sq;
		if ( cosTheta2Sq < 0.0 ) {
			return vec3( 1.0 );
		}
		float cosTheta2 = sqrt( cosTheta2Sq );
		float R0 = IorToFresnel0( iridescenceIOR, outsideIOR );
		float R12 = F_Schlick( R0, 1.0, cosTheta1 );
		float T121 = 1.0 - R12;
		float phi12 = 0.0;
		if ( iridescenceIOR < outsideIOR ) phi12 = PI;
		float phi21 = PI - phi12;
		vec3 baseIOR = Fresnel0ToIor( clamp( baseF0, 0.0, 0.9999 ) );		vec3 R1 = IorToFresnel0( baseIOR, iridescenceIOR );
		vec3 R23 = F_Schlick( R1, 1.0, cosTheta2 );
		vec3 phi23 = vec3( 0.0 );
		if ( baseIOR[ 0 ] < iridescenceIOR ) phi23[ 0 ] = PI;
		if ( baseIOR[ 1 ] < iridescenceIOR ) phi23[ 1 ] = PI;
		if ( baseIOR[ 2 ] < iridescenceIOR ) phi23[ 2 ] = PI;
		float OPD = 2.0 * iridescenceIOR * thinFilmThickness * cosTheta2;
		vec3 phi = vec3( phi21 ) + phi23;
		vec3 R123 = clamp( R12 * R23, 1e-5, 0.9999 );
		vec3 r123 = sqrt( R123 );
		vec3 Rs = pow2( T121 ) * R23 / ( vec3( 1.0 ) - R123 );
		vec3 C0 = R12 + Rs;
		I = C0;
		vec3 Cm = Rs - T121;
		for ( int m = 1; m <= 2; ++ m ) {
			Cm *= r123;
			vec3 Sm = 2.0 * evalSensitivity( float( m ) * OPD, float( m ) * phi );
			I += Cm * Sm;
		}
		return max( I, vec3( 0.0 ) );
	}
#endif`, v6 = `#ifdef USE_BUMPMAP
	uniform sampler2D bumpMap;
	uniform float bumpScale;
	vec2 dHdxy_fwd() {
		vec2 dSTdx = dFdx( vBumpMapUv );
		vec2 dSTdy = dFdy( vBumpMapUv );
		float Hll = bumpScale * texture2D( bumpMap, vBumpMapUv ).x;
		float dBx = bumpScale * texture2D( bumpMap, vBumpMapUv + dSTdx ).x - Hll;
		float dBy = bumpScale * texture2D( bumpMap, vBumpMapUv + dSTdy ).x - Hll;
		return vec2( dBx, dBy );
	}
	vec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy, float faceDirection ) {
		vec3 vSigmaX = dFdx( surf_pos.xyz );
		vec3 vSigmaY = dFdy( surf_pos.xyz );
		vec3 vN = surf_norm;
		vec3 R1 = cross( vSigmaY, vN );
		vec3 R2 = cross( vN, vSigmaX );
		float fDet = dot( vSigmaX, R1 ) * faceDirection;
		vec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );
		return normalize( abs( fDet ) * surf_norm - vGrad );
	}
#endif`, _6 = `#if NUM_CLIPPING_PLANES > 0
	vec4 plane;
	#pragma unroll_loop_start
	for ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {
		plane = clippingPlanes[ i ];
		if ( dot( vClipPosition, plane.xyz ) > plane.w ) discard;
	}
	#pragma unroll_loop_end
	#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES
		bool clipped = true;
		#pragma unroll_loop_start
		for ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {
			plane = clippingPlanes[ i ];
			clipped = ( dot( vClipPosition, plane.xyz ) > plane.w ) && clipped;
		}
		#pragma unroll_loop_end
		if ( clipped ) discard;
	#endif
#endif`, x6 = `#if NUM_CLIPPING_PLANES > 0
	varying vec3 vClipPosition;
	uniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];
#endif`, A6 = `#if NUM_CLIPPING_PLANES > 0
	varying vec3 vClipPosition;
#endif`, M6 = `#if NUM_CLIPPING_PLANES > 0
	vClipPosition = - mvPosition.xyz;
#endif`, w6 = `#if defined( USE_COLOR_ALPHA )
	diffuseColor *= vColor;
#elif defined( USE_COLOR )
	diffuseColor.rgb *= vColor;
#endif`, S6 = `#if defined( USE_COLOR_ALPHA )
	varying vec4 vColor;
#elif defined( USE_COLOR )
	varying vec3 vColor;
#endif`, E6 = `#if defined( USE_COLOR_ALPHA )
	varying vec4 vColor;
#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )
	varying vec3 vColor;
#endif`, C6 = `#if defined( USE_COLOR_ALPHA )
	vColor = vec4( 1.0 );
#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )
	vColor = vec3( 1.0 );
#endif
#ifdef USE_COLOR
	vColor *= color;
#endif
#ifdef USE_INSTANCING_COLOR
	vColor.xyz *= instanceColor.xyz;
#endif`, T6 = `#define PI 3.141592653589793
#define PI2 6.283185307179586
#define PI_HALF 1.5707963267948966
#define RECIPROCAL_PI 0.3183098861837907
#define RECIPROCAL_PI2 0.15915494309189535
#define EPSILON 1e-6
#ifndef saturate
#define saturate( a ) clamp( a, 0.0, 1.0 )
#endif
#define whiteComplement( a ) ( 1.0 - saturate( a ) )
float pow2( const in float x ) { return x*x; }
vec3 pow2( const in vec3 x ) { return x*x; }
float pow3( const in float x ) { return x*x*x; }
float pow4( const in float x ) { float x2 = x*x; return x2*x2; }
float max3( const in vec3 v ) { return max( max( v.x, v.y ), v.z ); }
float average( const in vec3 v ) { return dot( v, vec3( 0.3333333 ) ); }
highp float rand( const in vec2 uv ) {
	const highp float a = 12.9898, b = 78.233, c = 43758.5453;
	highp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );
	return fract( sin( sn ) * c );
}
#ifdef HIGH_PRECISION
	float precisionSafeLength( vec3 v ) { return length( v ); }
#else
	float precisionSafeLength( vec3 v ) {
		float maxComponent = max3( abs( v ) );
		return length( v / maxComponent ) * maxComponent;
	}
#endif
struct IncidentLight {
	vec3 color;
	vec3 direction;
	bool visible;
};
struct ReflectedLight {
	vec3 directDiffuse;
	vec3 directSpecular;
	vec3 indirectDiffuse;
	vec3 indirectSpecular;
};
struct GeometricContext {
	vec3 position;
	vec3 normal;
	vec3 viewDir;
#ifdef USE_CLEARCOAT
	vec3 clearcoatNormal;
#endif
};
#ifdef USE_ALPHAHASH
	varying vec3 vPosition;
#endif
vec3 transformDirection( in vec3 dir, in mat4 matrix ) {
	return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );
}
vec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {
	return normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );
}
mat3 transposeMat3( const in mat3 m ) {
	mat3 tmp;
	tmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );
	tmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );
	tmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );
	return tmp;
}
float luminance( const in vec3 rgb ) {
	const vec3 weights = vec3( 0.2126729, 0.7151522, 0.0721750 );
	return dot( weights, rgb );
}
bool isPerspectiveMatrix( mat4 m ) {
	return m[ 2 ][ 3 ] == - 1.0;
}
vec2 equirectUv( in vec3 dir ) {
	float u = atan( dir.z, dir.x ) * RECIPROCAL_PI2 + 0.5;
	float v = asin( clamp( dir.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;
	return vec2( u, v );
}
vec3 BRDF_Lambert( const in vec3 diffuseColor ) {
	return RECIPROCAL_PI * diffuseColor;
}
vec3 F_Schlick( const in vec3 f0, const in float f90, const in float dotVH ) {
	float fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );
	return f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );
}
float F_Schlick( const in float f0, const in float f90, const in float dotVH ) {
	float fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );
	return f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );
} // validated`, b6 = `#ifdef ENVMAP_TYPE_CUBE_UV
	#define cubeUV_minMipLevel 4.0
	#define cubeUV_minTileSize 16.0
	float getFace( vec3 direction ) {
		vec3 absDirection = abs( direction );
		float face = - 1.0;
		if ( absDirection.x > absDirection.z ) {
			if ( absDirection.x > absDirection.y )
				face = direction.x > 0.0 ? 0.0 : 3.0;
			else
				face = direction.y > 0.0 ? 1.0 : 4.0;
		} else {
			if ( absDirection.z > absDirection.y )
				face = direction.z > 0.0 ? 2.0 : 5.0;
			else
				face = direction.y > 0.0 ? 1.0 : 4.0;
		}
		return face;
	}
	vec2 getUV( vec3 direction, float face ) {
		vec2 uv;
		if ( face == 0.0 ) {
			uv = vec2( direction.z, direction.y ) / abs( direction.x );
		} else if ( face == 1.0 ) {
			uv = vec2( - direction.x, - direction.z ) / abs( direction.y );
		} else if ( face == 2.0 ) {
			uv = vec2( - direction.x, direction.y ) / abs( direction.z );
		} else if ( face == 3.0 ) {
			uv = vec2( - direction.z, direction.y ) / abs( direction.x );
		} else if ( face == 4.0 ) {
			uv = vec2( - direction.x, direction.z ) / abs( direction.y );
		} else {
			uv = vec2( direction.x, direction.y ) / abs( direction.z );
		}
		return 0.5 * ( uv + 1.0 );
	}
	vec3 bilinearCubeUV( sampler2D envMap, vec3 direction, float mipInt ) {
		float face = getFace( direction );
		float filterInt = max( cubeUV_minMipLevel - mipInt, 0.0 );
		mipInt = max( mipInt, cubeUV_minMipLevel );
		float faceSize = exp2( mipInt );
		highp vec2 uv = getUV( direction, face ) * ( faceSize - 2.0 ) + 1.0;
		if ( face > 2.0 ) {
			uv.y += faceSize;
			face -= 3.0;
		}
		uv.x += face * faceSize;
		uv.x += filterInt * 3.0 * cubeUV_minTileSize;
		uv.y += 4.0 * ( exp2( CUBEUV_MAX_MIP ) - faceSize );
		uv.x *= CUBEUV_TEXEL_WIDTH;
		uv.y *= CUBEUV_TEXEL_HEIGHT;
		#ifdef texture2DGradEXT
			return texture2DGradEXT( envMap, uv, vec2( 0.0 ), vec2( 0.0 ) ).rgb;
		#else
			return texture2D( envMap, uv ).rgb;
		#endif
	}
	#define cubeUV_r0 1.0
	#define cubeUV_v0 0.339
	#define cubeUV_m0 - 2.0
	#define cubeUV_r1 0.8
	#define cubeUV_v1 0.276
	#define cubeUV_m1 - 1.0
	#define cubeUV_r4 0.4
	#define cubeUV_v4 0.046
	#define cubeUV_m4 2.0
	#define cubeUV_r5 0.305
	#define cubeUV_v5 0.016
	#define cubeUV_m5 3.0
	#define cubeUV_r6 0.21
	#define cubeUV_v6 0.0038
	#define cubeUV_m6 4.0
	float roughnessToMip( float roughness ) {
		float mip = 0.0;
		if ( roughness >= cubeUV_r1 ) {
			mip = ( cubeUV_r0 - roughness ) * ( cubeUV_m1 - cubeUV_m0 ) / ( cubeUV_r0 - cubeUV_r1 ) + cubeUV_m0;
		} else if ( roughness >= cubeUV_r4 ) {
			mip = ( cubeUV_r1 - roughness ) * ( cubeUV_m4 - cubeUV_m1 ) / ( cubeUV_r1 - cubeUV_r4 ) + cubeUV_m1;
		} else if ( roughness >= cubeUV_r5 ) {
			mip = ( cubeUV_r4 - roughness ) * ( cubeUV_m5 - cubeUV_m4 ) / ( cubeUV_r4 - cubeUV_r5 ) + cubeUV_m4;
		} else if ( roughness >= cubeUV_r6 ) {
			mip = ( cubeUV_r5 - roughness ) * ( cubeUV_m6 - cubeUV_m5 ) / ( cubeUV_r5 - cubeUV_r6 ) + cubeUV_m5;
		} else {
			mip = - 2.0 * log2( 1.16 * roughness );		}
		return mip;
	}
	vec4 textureCubeUV( sampler2D envMap, vec3 sampleDir, float roughness ) {
		float mip = clamp( roughnessToMip( roughness ), cubeUV_m0, CUBEUV_MAX_MIP );
		float mipF = fract( mip );
		float mipInt = floor( mip );
		vec3 color0 = bilinearCubeUV( envMap, sampleDir, mipInt );
		if ( mipF == 0.0 ) {
			return vec4( color0, 1.0 );
		} else {
			vec3 color1 = bilinearCubeUV( envMap, sampleDir, mipInt + 1.0 );
			return vec4( mix( color0, color1, mipF ), 1.0 );
		}
	}
#endif`, R6 = `vec3 transformedNormal = objectNormal;
#ifdef USE_INSTANCING
	mat3 m = mat3( instanceMatrix );
	transformedNormal /= vec3( dot( m[ 0 ], m[ 0 ] ), dot( m[ 1 ], m[ 1 ] ), dot( m[ 2 ], m[ 2 ] ) );
	transformedNormal = m * transformedNormal;
#endif
transformedNormal = normalMatrix * transformedNormal;
#ifdef FLIP_SIDED
	transformedNormal = - transformedNormal;
#endif
#ifdef USE_TANGENT
	vec3 transformedTangent = ( modelViewMatrix * vec4( objectTangent, 0.0 ) ).xyz;
	#ifdef FLIP_SIDED
		transformedTangent = - transformedTangent;
	#endif
#endif`, P6 = `#ifdef USE_DISPLACEMENTMAP
	uniform sampler2D displacementMap;
	uniform float displacementScale;
	uniform float displacementBias;
#endif`, I6 = `#ifdef USE_DISPLACEMENTMAP
	transformed += normalize( objectNormal ) * ( texture2D( displacementMap, vDisplacementMapUv ).x * displacementScale + displacementBias );
#endif`, B6 = `#ifdef USE_EMISSIVEMAP
	vec4 emissiveColor = texture2D( emissiveMap, vEmissiveMapUv );
	totalEmissiveRadiance *= emissiveColor.rgb;
#endif`, L6 = `#ifdef USE_EMISSIVEMAP
	uniform sampler2D emissiveMap;
#endif`, D6 = "gl_FragColor = linearToOutputTexel( gl_FragColor );", O6 = `vec4 LinearToLinear( in vec4 value ) {
	return value;
}
vec4 LinearTosRGB( in vec4 value ) {
	return vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );
}`, F6 = `#ifdef USE_ENVMAP
	#ifdef ENV_WORLDPOS
		vec3 cameraToFrag;
		if ( isOrthographic ) {
			cameraToFrag = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );
		} else {
			cameraToFrag = normalize( vWorldPosition - cameraPosition );
		}
		vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
		#ifdef ENVMAP_MODE_REFLECTION
			vec3 reflectVec = reflect( cameraToFrag, worldNormal );
		#else
			vec3 reflectVec = refract( cameraToFrag, worldNormal, refractionRatio );
		#endif
	#else
		vec3 reflectVec = vReflect;
	#endif
	#ifdef ENVMAP_TYPE_CUBE
		vec4 envColor = textureCube( envMap, vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );
	#else
		vec4 envColor = vec4( 0.0 );
	#endif
	#ifdef ENVMAP_BLENDING_MULTIPLY
		outgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );
	#elif defined( ENVMAP_BLENDING_MIX )
		outgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );
	#elif defined( ENVMAP_BLENDING_ADD )
		outgoingLight += envColor.xyz * specularStrength * reflectivity;
	#endif
#endif`, k6 = `#ifdef USE_ENVMAP
	uniform float envMapIntensity;
	uniform float flipEnvMap;
	#ifdef ENVMAP_TYPE_CUBE
		uniform samplerCube envMap;
	#else
		uniform sampler2D envMap;
	#endif
	
#endif`, N6 = `#ifdef USE_ENVMAP
	uniform float reflectivity;
	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( LAMBERT )
		#define ENV_WORLDPOS
	#endif
	#ifdef ENV_WORLDPOS
		varying vec3 vWorldPosition;
		uniform float refractionRatio;
	#else
		varying vec3 vReflect;
	#endif
#endif`, U6 = `#ifdef USE_ENVMAP
	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( LAMBERT )
		#define ENV_WORLDPOS
	#endif
	#ifdef ENV_WORLDPOS
		
		varying vec3 vWorldPosition;
	#else
		varying vec3 vReflect;
		uniform float refractionRatio;
	#endif
#endif`, z6 = `#ifdef USE_ENVMAP
	#ifdef ENV_WORLDPOS
		vWorldPosition = worldPosition.xyz;
	#else
		vec3 cameraToVertex;
		if ( isOrthographic ) {
			cameraToVertex = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );
		} else {
			cameraToVertex = normalize( worldPosition.xyz - cameraPosition );
		}
		vec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );
		#ifdef ENVMAP_MODE_REFLECTION
			vReflect = reflect( cameraToVertex, worldNormal );
		#else
			vReflect = refract( cameraToVertex, worldNormal, refractionRatio );
		#endif
	#endif
#endif`, H6 = `#ifdef USE_FOG
	vFogDepth = - mvPosition.z;
#endif`, G6 = `#ifdef USE_FOG
	varying float vFogDepth;
#endif`, V6 = `#ifdef USE_FOG
	#ifdef FOG_EXP2
		float fogFactor = 1.0 - exp( - fogDensity * fogDensity * vFogDepth * vFogDepth );
	#else
		float fogFactor = smoothstep( fogNear, fogFar, vFogDepth );
	#endif
	gl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );
#endif`, W6 = `#ifdef USE_FOG
	uniform vec3 fogColor;
	varying float vFogDepth;
	#ifdef FOG_EXP2
		uniform float fogDensity;
	#else
		uniform float fogNear;
		uniform float fogFar;
	#endif
#endif`, X6 = `#ifdef USE_GRADIENTMAP
	uniform sampler2D gradientMap;
#endif
vec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {
	float dotNL = dot( normal, lightDirection );
	vec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );
	#ifdef USE_GRADIENTMAP
		return vec3( texture2D( gradientMap, coord ).r );
	#else
		vec2 fw = fwidth( coord ) * 0.5;
		return mix( vec3( 0.7 ), vec3( 1.0 ), smoothstep( 0.7 - fw.x, 0.7 + fw.x, coord.x ) );
	#endif
}`, J6 = `#ifdef USE_LIGHTMAP
	vec4 lightMapTexel = texture2D( lightMap, vLightMapUv );
	vec3 lightMapIrradiance = lightMapTexel.rgb * lightMapIntensity;
	reflectedLight.indirectDiffuse += lightMapIrradiance;
#endif`, Y6 = `#ifdef USE_LIGHTMAP
	uniform sampler2D lightMap;
	uniform float lightMapIntensity;
#endif`, j6 = `LambertMaterial material;
material.diffuseColor = diffuseColor.rgb;
material.specularStrength = specularStrength;`, K6 = `varying vec3 vViewPosition;
struct LambertMaterial {
	vec3 diffuseColor;
	float specularStrength;
};
void RE_Direct_Lambert( const in IncidentLight directLight, const in GeometricContext geometry, const in LambertMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometry.normal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Lambert( const in vec3 irradiance, const in GeometricContext geometry, const in LambertMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_Lambert
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Lambert`, q6 = `uniform bool receiveShadow;
uniform vec3 ambientLightColor;
uniform vec3 lightProbe[ 9 ];
vec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {
	float x = normal.x, y = normal.y, z = normal.z;
	vec3 result = shCoefficients[ 0 ] * 0.886227;
	result += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;
	result += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;
	result += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;
	result += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;
	result += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;
	result += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );
	result += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;
	result += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );
	return result;
}
vec3 getLightProbeIrradiance( const in vec3 lightProbe[ 9 ], const in vec3 normal ) {
	vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
	vec3 irradiance = shGetIrradianceAt( worldNormal, lightProbe );
	return irradiance;
}
vec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {
	vec3 irradiance = ambientLightColor;
	return irradiance;
}
float getDistanceAttenuation( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {
	#if defined ( LEGACY_LIGHTS )
		if ( cutoffDistance > 0.0 && decayExponent > 0.0 ) {
			return pow( saturate( - lightDistance / cutoffDistance + 1.0 ), decayExponent );
		}
		return 1.0;
	#else
		float distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );
		if ( cutoffDistance > 0.0 ) {
			distanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );
		}
		return distanceFalloff;
	#endif
}
float getSpotAttenuation( const in float coneCosine, const in float penumbraCosine, const in float angleCosine ) {
	return smoothstep( coneCosine, penumbraCosine, angleCosine );
}
#if NUM_DIR_LIGHTS > 0
	struct DirectionalLight {
		vec3 direction;
		vec3 color;
	};
	uniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];
	void getDirectionalLightInfo( const in DirectionalLight directionalLight, const in GeometricContext geometry, out IncidentLight light ) {
		light.color = directionalLight.color;
		light.direction = directionalLight.direction;
		light.visible = true;
	}
#endif
#if NUM_POINT_LIGHTS > 0
	struct PointLight {
		vec3 position;
		vec3 color;
		float distance;
		float decay;
	};
	uniform PointLight pointLights[ NUM_POINT_LIGHTS ];
	void getPointLightInfo( const in PointLight pointLight, const in GeometricContext geometry, out IncidentLight light ) {
		vec3 lVector = pointLight.position - geometry.position;
		light.direction = normalize( lVector );
		float lightDistance = length( lVector );
		light.color = pointLight.color;
		light.color *= getDistanceAttenuation( lightDistance, pointLight.distance, pointLight.decay );
		light.visible = ( light.color != vec3( 0.0 ) );
	}
#endif
#if NUM_SPOT_LIGHTS > 0
	struct SpotLight {
		vec3 position;
		vec3 direction;
		vec3 color;
		float distance;
		float decay;
		float coneCos;
		float penumbraCos;
	};
	uniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];
	void getSpotLightInfo( const in SpotLight spotLight, const in GeometricContext geometry, out IncidentLight light ) {
		vec3 lVector = spotLight.position - geometry.position;
		light.direction = normalize( lVector );
		float angleCos = dot( light.direction, spotLight.direction );
		float spotAttenuation = getSpotAttenuation( spotLight.coneCos, spotLight.penumbraCos, angleCos );
		if ( spotAttenuation > 0.0 ) {
			float lightDistance = length( lVector );
			light.color = spotLight.color * spotAttenuation;
			light.color *= getDistanceAttenuation( lightDistance, spotLight.distance, spotLight.decay );
			light.visible = ( light.color != vec3( 0.0 ) );
		} else {
			light.color = vec3( 0.0 );
			light.visible = false;
		}
	}
#endif
#if NUM_RECT_AREA_LIGHTS > 0
	struct RectAreaLight {
		vec3 color;
		vec3 position;
		vec3 halfWidth;
		vec3 halfHeight;
	};
	uniform sampler2D ltc_1;	uniform sampler2D ltc_2;
	uniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];
#endif
#if NUM_HEMI_LIGHTS > 0
	struct HemisphereLight {
		vec3 direction;
		vec3 skyColor;
		vec3 groundColor;
	};
	uniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];
	vec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in vec3 normal ) {
		float dotNL = dot( normal, hemiLight.direction );
		float hemiDiffuseWeight = 0.5 * dotNL + 0.5;
		vec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );
		return irradiance;
	}
#endif`, Q6 = `#ifdef USE_ENVMAP
	vec3 getIBLIrradiance( const in vec3 normal ) {
		#ifdef ENVMAP_TYPE_CUBE_UV
			vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
			vec4 envMapColor = textureCubeUV( envMap, worldNormal, 1.0 );
			return PI * envMapColor.rgb * envMapIntensity;
		#else
			return vec3( 0.0 );
		#endif
	}
	vec3 getIBLRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness ) {
		#ifdef ENVMAP_TYPE_CUBE_UV
			vec3 reflectVec = reflect( - viewDir, normal );
			reflectVec = normalize( mix( reflectVec, normal, roughness * roughness) );
			reflectVec = inverseTransformDirection( reflectVec, viewMatrix );
			vec4 envMapColor = textureCubeUV( envMap, reflectVec, roughness );
			return envMapColor.rgb * envMapIntensity;
		#else
			return vec3( 0.0 );
		#endif
	}
	#ifdef USE_ANISOTROPY
		vec3 getIBLAnisotropyRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness, const in vec3 bitangent, const in float anisotropy ) {
			#ifdef ENVMAP_TYPE_CUBE_UV
				vec3 bentNormal = cross( bitangent, viewDir );
				bentNormal = normalize( cross( bentNormal, bitangent ) );
				bentNormal = normalize( mix( bentNormal, normal, pow2( pow2( 1.0 - anisotropy * ( 1.0 - roughness ) ) ) ) );
				return getIBLRadiance( viewDir, bentNormal, roughness );
			#else
				return vec3( 0.0 );
			#endif
		}
	#endif
#endif`, Z6 = `ToonMaterial material;
material.diffuseColor = diffuseColor.rgb;`, $6 = `varying vec3 vViewPosition;
struct ToonMaterial {
	vec3 diffuseColor;
};
void RE_Direct_Toon( const in IncidentLight directLight, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {
	vec3 irradiance = getGradientIrradiance( geometry.normal, directLight.direction ) * directLight.color;
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Toon( const in vec3 irradiance, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_Toon
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Toon`, eX = `BlinnPhongMaterial material;
material.diffuseColor = diffuseColor.rgb;
material.specularColor = specular;
material.specularShininess = shininess;
material.specularStrength = specularStrength;`, tX = `varying vec3 vViewPosition;
struct BlinnPhongMaterial {
	vec3 diffuseColor;
	vec3 specularColor;
	float specularShininess;
	float specularStrength;
};
void RE_Direct_BlinnPhong( const in IncidentLight directLight, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometry.normal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
	reflectedLight.directSpecular += irradiance * BRDF_BlinnPhong( directLight.direction, geometry.viewDir, geometry.normal, material.specularColor, material.specularShininess ) * material.specularStrength;
}
void RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_BlinnPhong
#define RE_IndirectDiffuse		RE_IndirectDiffuse_BlinnPhong`, nX = `PhysicalMaterial material;
material.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );
vec3 dxy = max( abs( dFdx( geometryNormal ) ), abs( dFdy( geometryNormal ) ) );
float geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );
material.roughness = max( roughnessFactor, 0.0525 );material.roughness += geometryRoughness;
material.roughness = min( material.roughness, 1.0 );
#ifdef IOR
	material.ior = ior;
	#ifdef USE_SPECULAR
		float specularIntensityFactor = specularIntensity;
		vec3 specularColorFactor = specularColor;
		#ifdef USE_SPECULAR_COLORMAP
			specularColorFactor *= texture2D( specularColorMap, vSpecularColorMapUv ).rgb;
		#endif
		#ifdef USE_SPECULAR_INTENSITYMAP
			specularIntensityFactor *= texture2D( specularIntensityMap, vSpecularIntensityMapUv ).a;
		#endif
		material.specularF90 = mix( specularIntensityFactor, 1.0, metalnessFactor );
	#else
		float specularIntensityFactor = 1.0;
		vec3 specularColorFactor = vec3( 1.0 );
		material.specularF90 = 1.0;
	#endif
	material.specularColor = mix( min( pow2( ( material.ior - 1.0 ) / ( material.ior + 1.0 ) ) * specularColorFactor, vec3( 1.0 ) ) * specularIntensityFactor, diffuseColor.rgb, metalnessFactor );
#else
	material.specularColor = mix( vec3( 0.04 ), diffuseColor.rgb, metalnessFactor );
	material.specularF90 = 1.0;
#endif
#ifdef USE_CLEARCOAT
	material.clearcoat = clearcoat;
	material.clearcoatRoughness = clearcoatRoughness;
	material.clearcoatF0 = vec3( 0.04 );
	material.clearcoatF90 = 1.0;
	#ifdef USE_CLEARCOATMAP
		material.clearcoat *= texture2D( clearcoatMap, vClearcoatMapUv ).x;
	#endif
	#ifdef USE_CLEARCOAT_ROUGHNESSMAP
		material.clearcoatRoughness *= texture2D( clearcoatRoughnessMap, vClearcoatRoughnessMapUv ).y;
	#endif
	material.clearcoat = saturate( material.clearcoat );	material.clearcoatRoughness = max( material.clearcoatRoughness, 0.0525 );
	material.clearcoatRoughness += geometryRoughness;
	material.clearcoatRoughness = min( material.clearcoatRoughness, 1.0 );
#endif
#ifdef USE_IRIDESCENCE
	material.iridescence = iridescence;
	material.iridescenceIOR = iridescenceIOR;
	#ifdef USE_IRIDESCENCEMAP
		material.iridescence *= texture2D( iridescenceMap, vIridescenceMapUv ).r;
	#endif
	#ifdef USE_IRIDESCENCE_THICKNESSMAP
		material.iridescenceThickness = (iridescenceThicknessMaximum - iridescenceThicknessMinimum) * texture2D( iridescenceThicknessMap, vIridescenceThicknessMapUv ).g + iridescenceThicknessMinimum;
	#else
		material.iridescenceThickness = iridescenceThicknessMaximum;
	#endif
#endif
#ifdef USE_SHEEN
	material.sheenColor = sheenColor;
	#ifdef USE_SHEEN_COLORMAP
		material.sheenColor *= texture2D( sheenColorMap, vSheenColorMapUv ).rgb;
	#endif
	material.sheenRoughness = clamp( sheenRoughness, 0.07, 1.0 );
	#ifdef USE_SHEEN_ROUGHNESSMAP
		material.sheenRoughness *= texture2D( sheenRoughnessMap, vSheenRoughnessMapUv ).a;
	#endif
#endif
#ifdef USE_ANISOTROPY
	#ifdef USE_ANISOTROPYMAP
		mat2 anisotropyMat = mat2( anisotropyVector.x, anisotropyVector.y, - anisotropyVector.y, anisotropyVector.x );
		vec3 anisotropyPolar = texture2D( anisotropyMap, vAnisotropyMapUv ).rgb;
		vec2 anisotropyV = anisotropyMat * normalize( 2.0 * anisotropyPolar.rg - vec2( 1.0 ) ) * anisotropyPolar.b;
	#else
		vec2 anisotropyV = anisotropyVector;
	#endif
	material.anisotropy = length( anisotropyV );
	anisotropyV /= material.anisotropy;
	material.anisotropy = saturate( material.anisotropy );
	material.alphaT = mix( pow2( material.roughness ), 1.0, pow2( material.anisotropy ) );
	material.anisotropyT = tbn[ 0 ] * anisotropyV.x - tbn[ 1 ] * anisotropyV.y;
	material.anisotropyB = tbn[ 1 ] * anisotropyV.x + tbn[ 0 ] * anisotropyV.y;
#endif`, iX = `struct PhysicalMaterial {
	vec3 diffuseColor;
	float roughness;
	vec3 specularColor;
	float specularF90;
	#ifdef USE_CLEARCOAT
		float clearcoat;
		float clearcoatRoughness;
		vec3 clearcoatF0;
		float clearcoatF90;
	#endif
	#ifdef USE_IRIDESCENCE
		float iridescence;
		float iridescenceIOR;
		float iridescenceThickness;
		vec3 iridescenceFresnel;
		vec3 iridescenceF0;
	#endif
	#ifdef USE_SHEEN
		vec3 sheenColor;
		float sheenRoughness;
	#endif
	#ifdef IOR
		float ior;
	#endif
	#ifdef USE_TRANSMISSION
		float transmission;
		float transmissionAlpha;
		float thickness;
		float attenuationDistance;
		vec3 attenuationColor;
	#endif
	#ifdef USE_ANISOTROPY
		float anisotropy;
		float alphaT;
		vec3 anisotropyT;
		vec3 anisotropyB;
	#endif
};
vec3 clearcoatSpecular = vec3( 0.0 );
vec3 sheenSpecular = vec3( 0.0 );
vec3 Schlick_to_F0( const in vec3 f, const in float f90, const in float dotVH ) {
    float x = clamp( 1.0 - dotVH, 0.0, 1.0 );
    float x2 = x * x;
    float x5 = clamp( x * x2 * x2, 0.0, 0.9999 );
    return ( f - vec3( f90 ) * x5 ) / ( 1.0 - x5 );
}
float V_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {
	float a2 = pow2( alpha );
	float gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );
	float gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );
	return 0.5 / max( gv + gl, EPSILON );
}
float D_GGX( const in float alpha, const in float dotNH ) {
	float a2 = pow2( alpha );
	float denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;
	return RECIPROCAL_PI * a2 / pow2( denom );
}
#ifdef USE_ANISOTROPY
	float V_GGX_SmithCorrelated_Anisotropic( const in float alphaT, const in float alphaB, const in float dotTV, const in float dotBV, const in float dotTL, const in float dotBL, const in float dotNV, const in float dotNL ) {
		float gv = dotNL * length( vec3( alphaT * dotTV, alphaB * dotBV, dotNV ) );
		float gl = dotNV * length( vec3( alphaT * dotTL, alphaB * dotBL, dotNL ) );
		float v = 0.5 / ( gv + gl );
		return saturate(v);
	}
	float D_GGX_Anisotropic( const in float alphaT, const in float alphaB, const in float dotNH, const in float dotTH, const in float dotBH ) {
		float a2 = alphaT * alphaB;
		highp vec3 v = vec3( alphaB * dotTH, alphaT * dotBH, a2 * dotNH );
		highp float v2 = dot( v, v );
		float w2 = a2 / v2;
		return RECIPROCAL_PI * a2 * pow2 ( w2 );
	}
#endif
#ifdef USE_CLEARCOAT
	vec3 BRDF_GGX_Clearcoat( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in PhysicalMaterial material) {
		vec3 f0 = material.clearcoatF0;
		float f90 = material.clearcoatF90;
		float roughness = material.clearcoatRoughness;
		float alpha = pow2( roughness );
		vec3 halfDir = normalize( lightDir + viewDir );
		float dotNL = saturate( dot( normal, lightDir ) );
		float dotNV = saturate( dot( normal, viewDir ) );
		float dotNH = saturate( dot( normal, halfDir ) );
		float dotVH = saturate( dot( viewDir, halfDir ) );
		vec3 F = F_Schlick( f0, f90, dotVH );
		float V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );
		float D = D_GGX( alpha, dotNH );
		return F * ( V * D );
	}
#endif
vec3 BRDF_GGX( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in PhysicalMaterial material ) {
	vec3 f0 = material.specularColor;
	float f90 = material.specularF90;
	float roughness = material.roughness;
	float alpha = pow2( roughness );
	vec3 halfDir = normalize( lightDir + viewDir );
	float dotNL = saturate( dot( normal, lightDir ) );
	float dotNV = saturate( dot( normal, viewDir ) );
	float dotNH = saturate( dot( normal, halfDir ) );
	float dotVH = saturate( dot( viewDir, halfDir ) );
	vec3 F = F_Schlick( f0, f90, dotVH );
	#ifdef USE_IRIDESCENCE
		F = mix( F, material.iridescenceFresnel, material.iridescence );
	#endif
	#ifdef USE_ANISOTROPY
		float dotTL = dot( material.anisotropyT, lightDir );
		float dotTV = dot( material.anisotropyT, viewDir );
		float dotTH = dot( material.anisotropyT, halfDir );
		float dotBL = dot( material.anisotropyB, lightDir );
		float dotBV = dot( material.anisotropyB, viewDir );
		float dotBH = dot( material.anisotropyB, halfDir );
		float V = V_GGX_SmithCorrelated_Anisotropic( material.alphaT, alpha, dotTV, dotBV, dotTL, dotBL, dotNV, dotNL );
		float D = D_GGX_Anisotropic( material.alphaT, alpha, dotNH, dotTH, dotBH );
	#else
		float V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );
		float D = D_GGX( alpha, dotNH );
	#endif
	return F * ( V * D );
}
vec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {
	const float LUT_SIZE = 64.0;
	const float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;
	const float LUT_BIAS = 0.5 / LUT_SIZE;
	float dotNV = saturate( dot( N, V ) );
	vec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );
	uv = uv * LUT_SCALE + LUT_BIAS;
	return uv;
}
float LTC_ClippedSphereFormFactor( const in vec3 f ) {
	float l = length( f );
	return max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );
}
vec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {
	float x = dot( v1, v2 );
	float y = abs( x );
	float a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;
	float b = 3.4175940 + ( 4.1616724 + y ) * y;
	float v = a / b;
	float theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;
	return cross( v1, v2 ) * theta_sintheta;
}
vec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {
	vec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];
	vec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];
	vec3 lightNormal = cross( v1, v2 );
	if( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );
	vec3 T1, T2;
	T1 = normalize( V - N * dot( V, N ) );
	T2 = - cross( N, T1 );
	mat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );
	vec3 coords[ 4 ];
	coords[ 0 ] = mat * ( rectCoords[ 0 ] - P );
	coords[ 1 ] = mat * ( rectCoords[ 1 ] - P );
	coords[ 2 ] = mat * ( rectCoords[ 2 ] - P );
	coords[ 3 ] = mat * ( rectCoords[ 3 ] - P );
	coords[ 0 ] = normalize( coords[ 0 ] );
	coords[ 1 ] = normalize( coords[ 1 ] );
	coords[ 2 ] = normalize( coords[ 2 ] );
	coords[ 3 ] = normalize( coords[ 3 ] );
	vec3 vectorFormFactor = vec3( 0.0 );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );
	float result = LTC_ClippedSphereFormFactor( vectorFormFactor );
	return vec3( result );
}
#if defined( USE_SHEEN )
float D_Charlie( float roughness, float dotNH ) {
	float alpha = pow2( roughness );
	float invAlpha = 1.0 / alpha;
	float cos2h = dotNH * dotNH;
	float sin2h = max( 1.0 - cos2h, 0.0078125 );
	return ( 2.0 + invAlpha ) * pow( sin2h, invAlpha * 0.5 ) / ( 2.0 * PI );
}
float V_Neubelt( float dotNV, float dotNL ) {
	return saturate( 1.0 / ( 4.0 * ( dotNL + dotNV - dotNL * dotNV ) ) );
}
vec3 BRDF_Sheen( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, vec3 sheenColor, const in float sheenRoughness ) {
	vec3 halfDir = normalize( lightDir + viewDir );
	float dotNL = saturate( dot( normal, lightDir ) );
	float dotNV = saturate( dot( normal, viewDir ) );
	float dotNH = saturate( dot( normal, halfDir ) );
	float D = D_Charlie( sheenRoughness, dotNH );
	float V = V_Neubelt( dotNV, dotNL );
	return sheenColor * ( D * V );
}
#endif
float IBLSheenBRDF( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {
	float dotNV = saturate( dot( normal, viewDir ) );
	float r2 = roughness * roughness;
	float a = roughness < 0.25 ? -339.2 * r2 + 161.4 * roughness - 25.9 : -8.48 * r2 + 14.3 * roughness - 9.95;
	float b = roughness < 0.25 ? 44.0 * r2 - 23.7 * roughness + 3.26 : 1.97 * r2 - 3.27 * roughness + 0.72;
	float DG = exp( a * dotNV + b ) + ( roughness < 0.25 ? 0.0 : 0.1 * ( roughness - 0.25 ) );
	return saturate( DG * RECIPROCAL_PI );
}
vec2 DFGApprox( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {
	float dotNV = saturate( dot( normal, viewDir ) );
	const vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );
	const vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );
	vec4 r = roughness * c0 + c1;
	float a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;
	vec2 fab = vec2( - 1.04, 1.04 ) * a004 + r.zw;
	return fab;
}
vec3 EnvironmentBRDF( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness ) {
	vec2 fab = DFGApprox( normal, viewDir, roughness );
	return specularColor * fab.x + specularF90 * fab.y;
}
#ifdef USE_IRIDESCENCE
void computeMultiscatteringIridescence( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float iridescence, const in vec3 iridescenceF0, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {
#else
void computeMultiscattering( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {
#endif
	vec2 fab = DFGApprox( normal, viewDir, roughness );
	#ifdef USE_IRIDESCENCE
		vec3 Fr = mix( specularColor, iridescenceF0, iridescence );
	#else
		vec3 Fr = specularColor;
	#endif
	vec3 FssEss = Fr * fab.x + specularF90 * fab.y;
	float Ess = fab.x + fab.y;
	float Ems = 1.0 - Ess;
	vec3 Favg = Fr + ( 1.0 - Fr ) * 0.047619;	vec3 Fms = FssEss * Favg / ( 1.0 - Ems * Favg );
	singleScatter += FssEss;
	multiScatter += Fms * Ems;
}
#if NUM_RECT_AREA_LIGHTS > 0
	void RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
		vec3 normal = geometry.normal;
		vec3 viewDir = geometry.viewDir;
		vec3 position = geometry.position;
		vec3 lightPos = rectAreaLight.position;
		vec3 halfWidth = rectAreaLight.halfWidth;
		vec3 halfHeight = rectAreaLight.halfHeight;
		vec3 lightColor = rectAreaLight.color;
		float roughness = material.roughness;
		vec3 rectCoords[ 4 ];
		rectCoords[ 0 ] = lightPos + halfWidth - halfHeight;		rectCoords[ 1 ] = lightPos - halfWidth - halfHeight;
		rectCoords[ 2 ] = lightPos - halfWidth + halfHeight;
		rectCoords[ 3 ] = lightPos + halfWidth + halfHeight;
		vec2 uv = LTC_Uv( normal, viewDir, roughness );
		vec4 t1 = texture2D( ltc_1, uv );
		vec4 t2 = texture2D( ltc_2, uv );
		mat3 mInv = mat3(
			vec3( t1.x, 0, t1.y ),
			vec3(    0, 1,    0 ),
			vec3( t1.z, 0, t1.w )
		);
		vec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );
		reflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );
		reflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );
	}
#endif
void RE_Direct_Physical( const in IncidentLight directLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometry.normal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	#ifdef USE_CLEARCOAT
		float dotNLcc = saturate( dot( geometry.clearcoatNormal, directLight.direction ) );
		vec3 ccIrradiance = dotNLcc * directLight.color;
		clearcoatSpecular += ccIrradiance * BRDF_GGX_Clearcoat( directLight.direction, geometry.viewDir, geometry.clearcoatNormal, material );
	#endif
	#ifdef USE_SHEEN
		sheenSpecular += irradiance * BRDF_Sheen( directLight.direction, geometry.viewDir, geometry.normal, material.sheenColor, material.sheenRoughness );
	#endif
	reflectedLight.directSpecular += irradiance * BRDF_GGX( directLight.direction, geometry.viewDir, geometry.normal, material );
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 irradiance, const in vec3 clearcoatRadiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight) {
	#ifdef USE_CLEARCOAT
		clearcoatSpecular += clearcoatRadiance * EnvironmentBRDF( geometry.clearcoatNormal, geometry.viewDir, material.clearcoatF0, material.clearcoatF90, material.clearcoatRoughness );
	#endif
	#ifdef USE_SHEEN
		sheenSpecular += irradiance * material.sheenColor * IBLSheenBRDF( geometry.normal, geometry.viewDir, material.sheenRoughness );
	#endif
	vec3 singleScattering = vec3( 0.0 );
	vec3 multiScattering = vec3( 0.0 );
	vec3 cosineWeightedIrradiance = irradiance * RECIPROCAL_PI;
	#ifdef USE_IRIDESCENCE
		computeMultiscatteringIridescence( geometry.normal, geometry.viewDir, material.specularColor, material.specularF90, material.iridescence, material.iridescenceFresnel, material.roughness, singleScattering, multiScattering );
	#else
		computeMultiscattering( geometry.normal, geometry.viewDir, material.specularColor, material.specularF90, material.roughness, singleScattering, multiScattering );
	#endif
	vec3 totalScattering = singleScattering + multiScattering;
	vec3 diffuse = material.diffuseColor * ( 1.0 - max( max( totalScattering.r, totalScattering.g ), totalScattering.b ) );
	reflectedLight.indirectSpecular += radiance * singleScattering;
	reflectedLight.indirectSpecular += multiScattering * cosineWeightedIrradiance;
	reflectedLight.indirectDiffuse += diffuse * cosineWeightedIrradiance;
}
#define RE_Direct				RE_Direct_Physical
#define RE_Direct_RectArea		RE_Direct_RectArea_Physical
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Physical
#define RE_IndirectSpecular		RE_IndirectSpecular_Physical
float computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {
	return saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );
}`, rX = `
GeometricContext geometry;
geometry.position = - vViewPosition;
geometry.normal = normal;
geometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );
#ifdef USE_CLEARCOAT
	geometry.clearcoatNormal = clearcoatNormal;
#endif
#ifdef USE_IRIDESCENCE
	float dotNVi = saturate( dot( normal, geometry.viewDir ) );
	if ( material.iridescenceThickness == 0.0 ) {
		material.iridescence = 0.0;
	} else {
		material.iridescence = saturate( material.iridescence );
	}
	if ( material.iridescence > 0.0 ) {
		material.iridescenceFresnel = evalIridescence( 1.0, material.iridescenceIOR, dotNVi, material.iridescenceThickness, material.specularColor );
		material.iridescenceF0 = Schlick_to_F0( material.iridescenceFresnel, 1.0, dotNVi );
	}
#endif
IncidentLight directLight;
#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )
	PointLight pointLight;
	#if defined( USE_SHADOWMAP ) && NUM_POINT_LIGHT_SHADOWS > 0
	PointLightShadow pointLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {
		pointLight = pointLights[ i ];
		getPointLightInfo( pointLight, geometry, directLight );
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_POINT_LIGHT_SHADOWS )
		pointLightShadow = pointLightShadows[ i ];
		directLight.color *= ( directLight.visible && receiveShadow ) ? getPointShadow( pointShadowMap[ i ], pointLightShadow.shadowMapSize, pointLightShadow.shadowBias, pointLightShadow.shadowRadius, vPointShadowCoord[ i ], pointLightShadow.shadowCameraNear, pointLightShadow.shadowCameraFar ) : 1.0;
		#endif
		RE_Direct( directLight, geometry, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )
	SpotLight spotLight;
	vec4 spotColor;
	vec3 spotLightCoord;
	bool inSpotLightMap;
	#if defined( USE_SHADOWMAP ) && NUM_SPOT_LIGHT_SHADOWS > 0
	SpotLightShadow spotLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {
		spotLight = spotLights[ i ];
		getSpotLightInfo( spotLight, geometry, directLight );
		#if ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS )
		#define SPOT_LIGHT_MAP_INDEX UNROLLED_LOOP_INDEX
		#elif ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )
		#define SPOT_LIGHT_MAP_INDEX NUM_SPOT_LIGHT_MAPS
		#else
		#define SPOT_LIGHT_MAP_INDEX ( UNROLLED_LOOP_INDEX - NUM_SPOT_LIGHT_SHADOWS + NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS )
		#endif
		#if ( SPOT_LIGHT_MAP_INDEX < NUM_SPOT_LIGHT_MAPS )
			spotLightCoord = vSpotLightCoord[ i ].xyz / vSpotLightCoord[ i ].w;
			inSpotLightMap = all( lessThan( abs( spotLightCoord * 2. - 1. ), vec3( 1.0 ) ) );
			spotColor = texture2D( spotLightMap[ SPOT_LIGHT_MAP_INDEX ], spotLightCoord.xy );
			directLight.color = inSpotLightMap ? directLight.color * spotColor.rgb : directLight.color;
		#endif
		#undef SPOT_LIGHT_MAP_INDEX
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )
		spotLightShadow = spotLightShadows[ i ];
		directLight.color *= ( directLight.visible && receiveShadow ) ? getShadow( spotShadowMap[ i ], spotLightShadow.shadowMapSize, spotLightShadow.shadowBias, spotLightShadow.shadowRadius, vSpotLightCoord[ i ] ) : 1.0;
		#endif
		RE_Direct( directLight, geometry, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )
	DirectionalLight directionalLight;
	#if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0
	DirectionalLightShadow directionalLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {
		directionalLight = directionalLights[ i ];
		getDirectionalLightInfo( directionalLight, geometry, directLight );
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )
		directionalLightShadow = directionalLightShadows[ i ];
		directLight.color *= ( directLight.visible && receiveShadow ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;
		#endif
		RE_Direct( directLight, geometry, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )
	RectAreaLight rectAreaLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {
		rectAreaLight = rectAreaLights[ i ];
		RE_Direct_RectArea( rectAreaLight, geometry, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if defined( RE_IndirectDiffuse )
	vec3 iblIrradiance = vec3( 0.0 );
	vec3 irradiance = getAmbientLightIrradiance( ambientLightColor );
	irradiance += getLightProbeIrradiance( lightProbe, geometry.normal );
	#if ( NUM_HEMI_LIGHTS > 0 )
		#pragma unroll_loop_start
		for ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {
			irradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry.normal );
		}
		#pragma unroll_loop_end
	#endif
#endif
#if defined( RE_IndirectSpecular )
	vec3 radiance = vec3( 0.0 );
	vec3 clearcoatRadiance = vec3( 0.0 );
#endif`, sX = `#if defined( RE_IndirectDiffuse )
	#ifdef USE_LIGHTMAP
		vec4 lightMapTexel = texture2D( lightMap, vLightMapUv );
		vec3 lightMapIrradiance = lightMapTexel.rgb * lightMapIntensity;
		irradiance += lightMapIrradiance;
	#endif
	#if defined( USE_ENVMAP ) && defined( STANDARD ) && defined( ENVMAP_TYPE_CUBE_UV )
		iblIrradiance += getIBLIrradiance( geometry.normal );
	#endif
#endif
#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )
	#ifdef USE_ANISOTROPY
		radiance += getIBLAnisotropyRadiance( geometry.viewDir, geometry.normal, material.roughness, material.anisotropyB, material.anisotropy );
	#else
		radiance += getIBLRadiance( geometry.viewDir, geometry.normal, material.roughness );
	#endif
	#ifdef USE_CLEARCOAT
		clearcoatRadiance += getIBLRadiance( geometry.viewDir, geometry.clearcoatNormal, material.clearcoatRoughness );
	#endif
#endif`, oX = `#if defined( RE_IndirectDiffuse )
	RE_IndirectDiffuse( irradiance, geometry, material, reflectedLight );
#endif
#if defined( RE_IndirectSpecular )
	RE_IndirectSpecular( radiance, iblIrradiance, clearcoatRadiance, geometry, material, reflectedLight );
#endif`, aX = `#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )
	gl_FragDepthEXT = vIsPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;
#endif`, lX = `#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )
	uniform float logDepthBufFC;
	varying float vFragDepth;
	varying float vIsPerspective;
#endif`, cX = `#ifdef USE_LOGDEPTHBUF
	#ifdef USE_LOGDEPTHBUF_EXT
		varying float vFragDepth;
		varying float vIsPerspective;
	#else
		uniform float logDepthBufFC;
	#endif
#endif`, uX = `#ifdef USE_LOGDEPTHBUF
	#ifdef USE_LOGDEPTHBUF_EXT
		vFragDepth = 1.0 + gl_Position.w;
		vIsPerspective = float( isPerspectiveMatrix( projectionMatrix ) );
	#else
		if ( isPerspectiveMatrix( projectionMatrix ) ) {
			gl_Position.z = log2( max( EPSILON, gl_Position.w + 1.0 ) ) * logDepthBufFC - 1.0;
			gl_Position.z *= gl_Position.w;
		}
	#endif
#endif`, fX = `#ifdef USE_MAP
	diffuseColor *= texture2D( map, vMapUv );
#endif`, hX = `#ifdef USE_MAP
	uniform sampler2D map;
#endif`, dX = `#if defined( USE_MAP ) || defined( USE_ALPHAMAP )
	#if defined( USE_POINTS_UV )
		vec2 uv = vUv;
	#else
		vec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;
	#endif
#endif
#ifdef USE_MAP
	diffuseColor *= texture2D( map, uv );
#endif
#ifdef USE_ALPHAMAP
	diffuseColor.a *= texture2D( alphaMap, uv ).g;
#endif`, pX = `#if defined( USE_POINTS_UV )
	varying vec2 vUv;
#else
	#if defined( USE_MAP ) || defined( USE_ALPHAMAP )
		uniform mat3 uvTransform;
	#endif
#endif
#ifdef USE_MAP
	uniform sampler2D map;
#endif
#ifdef USE_ALPHAMAP
	uniform sampler2D alphaMap;
#endif`, mX = `float metalnessFactor = metalness;
#ifdef USE_METALNESSMAP
	vec4 texelMetalness = texture2D( metalnessMap, vMetalnessMapUv );
	metalnessFactor *= texelMetalness.b;
#endif`, gX = `#ifdef USE_METALNESSMAP
	uniform sampler2D metalnessMap;
#endif`, yX = `#if defined( USE_MORPHCOLORS ) && defined( MORPHTARGETS_TEXTURE )
	vColor *= morphTargetBaseInfluence;
	for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
		#if defined( USE_COLOR_ALPHA )
			if ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ) * morphTargetInfluences[ i ];
		#elif defined( USE_COLOR )
			if ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ).rgb * morphTargetInfluences[ i ];
		#endif
	}
#endif`, vX = `#ifdef USE_MORPHNORMALS
	objectNormal *= morphTargetBaseInfluence;
	#ifdef MORPHTARGETS_TEXTURE
		for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
			if ( morphTargetInfluences[ i ] != 0.0 ) objectNormal += getMorph( gl_VertexID, i, 1 ).xyz * morphTargetInfluences[ i ];
		}
	#else
		objectNormal += morphNormal0 * morphTargetInfluences[ 0 ];
		objectNormal += morphNormal1 * morphTargetInfluences[ 1 ];
		objectNormal += morphNormal2 * morphTargetInfluences[ 2 ];
		objectNormal += morphNormal3 * morphTargetInfluences[ 3 ];
	#endif
#endif`, _X = `#ifdef USE_MORPHTARGETS
	uniform float morphTargetBaseInfluence;
	#ifdef MORPHTARGETS_TEXTURE
		uniform float morphTargetInfluences[ MORPHTARGETS_COUNT ];
		uniform sampler2DArray morphTargetsTexture;
		uniform ivec2 morphTargetsTextureSize;
		vec4 getMorph( const in int vertexIndex, const in int morphTargetIndex, const in int offset ) {
			int texelIndex = vertexIndex * MORPHTARGETS_TEXTURE_STRIDE + offset;
			int y = texelIndex / morphTargetsTextureSize.x;
			int x = texelIndex - y * morphTargetsTextureSize.x;
			ivec3 morphUV = ivec3( x, y, morphTargetIndex );
			return texelFetch( morphTargetsTexture, morphUV, 0 );
		}
	#else
		#ifndef USE_MORPHNORMALS
			uniform float morphTargetInfluences[ 8 ];
		#else
			uniform float morphTargetInfluences[ 4 ];
		#endif
	#endif
#endif`, xX = `#ifdef USE_MORPHTARGETS
	transformed *= morphTargetBaseInfluence;
	#ifdef MORPHTARGETS_TEXTURE
		for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
			if ( morphTargetInfluences[ i ] != 0.0 ) transformed += getMorph( gl_VertexID, i, 0 ).xyz * morphTargetInfluences[ i ];
		}
	#else
		transformed += morphTarget0 * morphTargetInfluences[ 0 ];
		transformed += morphTarget1 * morphTargetInfluences[ 1 ];
		transformed += morphTarget2 * morphTargetInfluences[ 2 ];
		transformed += morphTarget3 * morphTargetInfluences[ 3 ];
		#ifndef USE_MORPHNORMALS
			transformed += morphTarget4 * morphTargetInfluences[ 4 ];
			transformed += morphTarget5 * morphTargetInfluences[ 5 ];
			transformed += morphTarget6 * morphTargetInfluences[ 6 ];
			transformed += morphTarget7 * morphTargetInfluences[ 7 ];
		#endif
	#endif
#endif`, AX = `float faceDirection = gl_FrontFacing ? 1.0 : - 1.0;
#ifdef FLAT_SHADED
	vec3 fdx = dFdx( vViewPosition );
	vec3 fdy = dFdy( vViewPosition );
	vec3 normal = normalize( cross( fdx, fdy ) );
#else
	vec3 normal = normalize( vNormal );
	#ifdef DOUBLE_SIDED
		normal *= faceDirection;
	#endif
#endif
#if defined( USE_NORMALMAP_TANGENTSPACE ) || defined( USE_CLEARCOAT_NORMALMAP ) || defined( USE_ANISOTROPY )
	#ifdef USE_TANGENT
		mat3 tbn = mat3( normalize( vTangent ), normalize( vBitangent ), normal );
	#else
		mat3 tbn = getTangentFrame( - vViewPosition, normal,
		#if defined( USE_NORMALMAP )
			vNormalMapUv
		#elif defined( USE_CLEARCOAT_NORMALMAP )
			vClearcoatNormalMapUv
		#else
			vUv
		#endif
		);
	#endif
	#if defined( DOUBLE_SIDED ) && ! defined( FLAT_SHADED )
		tbn[0] *= faceDirection;
		tbn[1] *= faceDirection;
	#endif
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	#ifdef USE_TANGENT
		mat3 tbn2 = mat3( normalize( vTangent ), normalize( vBitangent ), normal );
	#else
		mat3 tbn2 = getTangentFrame( - vViewPosition, normal, vClearcoatNormalMapUv );
	#endif
	#if defined( DOUBLE_SIDED ) && ! defined( FLAT_SHADED )
		tbn2[0] *= faceDirection;
		tbn2[1] *= faceDirection;
	#endif
#endif
vec3 geometryNormal = normal;`, MX = `#ifdef USE_NORMALMAP_OBJECTSPACE
	normal = texture2D( normalMap, vNormalMapUv ).xyz * 2.0 - 1.0;
	#ifdef FLIP_SIDED
		normal = - normal;
	#endif
	#ifdef DOUBLE_SIDED
		normal = normal * faceDirection;
	#endif
	normal = normalize( normalMatrix * normal );
#elif defined( USE_NORMALMAP_TANGENTSPACE )
	vec3 mapN = texture2D( normalMap, vNormalMapUv ).xyz * 2.0 - 1.0;
	mapN.xy *= normalScale;
	normal = normalize( tbn * mapN );
#elif defined( USE_BUMPMAP )
	normal = perturbNormalArb( - vViewPosition, normal, dHdxy_fwd(), faceDirection );
#endif`, wX = `#ifndef FLAT_SHADED
	varying vec3 vNormal;
	#ifdef USE_TANGENT
		varying vec3 vTangent;
		varying vec3 vBitangent;
	#endif
#endif`, SX = `#ifndef FLAT_SHADED
	varying vec3 vNormal;
	#ifdef USE_TANGENT
		varying vec3 vTangent;
		varying vec3 vBitangent;
	#endif
#endif`, EX = `#ifndef FLAT_SHADED
	vNormal = normalize( transformedNormal );
	#ifdef USE_TANGENT
		vTangent = normalize( transformedTangent );
		vBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );
	#endif
#endif`, CX = `#ifdef USE_NORMALMAP
	uniform sampler2D normalMap;
	uniform vec2 normalScale;
#endif
#ifdef USE_NORMALMAP_OBJECTSPACE
	uniform mat3 normalMatrix;
#endif
#if ! defined ( USE_TANGENT ) && ( defined ( USE_NORMALMAP_TANGENTSPACE ) || defined ( USE_CLEARCOAT_NORMALMAP ) || defined( USE_ANISOTROPY ) )
	mat3 getTangentFrame( vec3 eye_pos, vec3 surf_norm, vec2 uv ) {
		vec3 q0 = dFdx( eye_pos.xyz );
		vec3 q1 = dFdy( eye_pos.xyz );
		vec2 st0 = dFdx( uv.st );
		vec2 st1 = dFdy( uv.st );
		vec3 N = surf_norm;
		vec3 q1perp = cross( q1, N );
		vec3 q0perp = cross( N, q0 );
		vec3 T = q1perp * st0.x + q0perp * st1.x;
		vec3 B = q1perp * st0.y + q0perp * st1.y;
		float det = max( dot( T, T ), dot( B, B ) );
		float scale = ( det == 0.0 ) ? 0.0 : inversesqrt( det );
		return mat3( T * scale, B * scale, N );
	}
#endif`, TX = `#ifdef USE_CLEARCOAT
	vec3 clearcoatNormal = geometryNormal;
#endif`, bX = `#ifdef USE_CLEARCOAT_NORMALMAP
	vec3 clearcoatMapN = texture2D( clearcoatNormalMap, vClearcoatNormalMapUv ).xyz * 2.0 - 1.0;
	clearcoatMapN.xy *= clearcoatNormalScale;
	clearcoatNormal = normalize( tbn2 * clearcoatMapN );
#endif`, RX = `#ifdef USE_CLEARCOATMAP
	uniform sampler2D clearcoatMap;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	uniform sampler2D clearcoatNormalMap;
	uniform vec2 clearcoatNormalScale;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	uniform sampler2D clearcoatRoughnessMap;
#endif`, PX = `#ifdef USE_IRIDESCENCEMAP
	uniform sampler2D iridescenceMap;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
	uniform sampler2D iridescenceThicknessMap;
#endif`, IX = `#ifdef OPAQUE
diffuseColor.a = 1.0;
#endif
#ifdef USE_TRANSMISSION
diffuseColor.a *= material.transmissionAlpha;
#endif
gl_FragColor = vec4( outgoingLight, diffuseColor.a );`, BX = `vec3 packNormalToRGB( const in vec3 normal ) {
	return normalize( normal ) * 0.5 + 0.5;
}
vec3 unpackRGBToNormal( const in vec3 rgb ) {
	return 2.0 * rgb.xyz - 1.0;
}
const float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;
const vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256., 256. );
const vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );
const float ShiftRight8 = 1. / 256.;
vec4 packDepthToRGBA( const in float v ) {
	vec4 r = vec4( fract( v * PackFactors ), v );
	r.yzw -= r.xyz * ShiftRight8;	return r * PackUpscale;
}
float unpackRGBAToDepth( const in vec4 v ) {
	return dot( v, UnpackFactors );
}
vec2 packDepthToRG( in highp float v ) {
	return packDepthToRGBA( v ).yx;
}
float unpackRGToDepth( const in highp vec2 v ) {
	return unpackRGBAToDepth( vec4( v.xy, 0.0, 0.0 ) );
}
vec4 pack2HalfToRGBA( vec2 v ) {
	vec4 r = vec4( v.x, fract( v.x * 255.0 ), v.y, fract( v.y * 255.0 ) );
	return vec4( r.x - r.y / 255.0, r.y, r.z - r.w / 255.0, r.w );
}
vec2 unpackRGBATo2Half( vec4 v ) {
	return vec2( v.x + ( v.y / 255.0 ), v.z + ( v.w / 255.0 ) );
}
float viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {
	return ( viewZ + near ) / ( near - far );
}
float orthographicDepthToViewZ( const in float depth, const in float near, const in float far ) {
	return depth * ( near - far ) - near;
}
float viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {
	return ( ( near + viewZ ) * far ) / ( ( far - near ) * viewZ );
}
float perspectiveDepthToViewZ( const in float depth, const in float near, const in float far ) {
	return ( near * far ) / ( ( far - near ) * depth - far );
}`, LX = `#ifdef PREMULTIPLIED_ALPHA
	gl_FragColor.rgb *= gl_FragColor.a;
#endif`, DX = `vec4 mvPosition = vec4( transformed, 1.0 );
#ifdef USE_INSTANCING
	mvPosition = instanceMatrix * mvPosition;
#endif
mvPosition = modelViewMatrix * mvPosition;
gl_Position = projectionMatrix * mvPosition;`, OX = `#ifdef DITHERING
	gl_FragColor.rgb = dithering( gl_FragColor.rgb );
#endif`, FX = `#ifdef DITHERING
	vec3 dithering( vec3 color ) {
		float grid_position = rand( gl_FragCoord.xy );
		vec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );
		dither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );
		return color + dither_shift_RGB;
	}
#endif`, kX = `float roughnessFactor = roughness;
#ifdef USE_ROUGHNESSMAP
	vec4 texelRoughness = texture2D( roughnessMap, vRoughnessMapUv );
	roughnessFactor *= texelRoughness.g;
#endif`, NX = `#ifdef USE_ROUGHNESSMAP
	uniform sampler2D roughnessMap;
#endif`, UX = `#if NUM_SPOT_LIGHT_COORDS > 0
	varying vec4 vSpotLightCoord[ NUM_SPOT_LIGHT_COORDS ];
#endif
#if NUM_SPOT_LIGHT_MAPS > 0
	uniform sampler2D spotLightMap[ NUM_SPOT_LIGHT_MAPS ];
#endif
#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
		uniform sampler2D directionalShadowMap[ NUM_DIR_LIGHT_SHADOWS ];
		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];
		struct DirectionalLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
		uniform sampler2D spotShadowMap[ NUM_SPOT_LIGHT_SHADOWS ];
		struct SpotLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
		uniform sampler2D pointShadowMap[ NUM_POINT_LIGHT_SHADOWS ];
		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];
		struct PointLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
			float shadowCameraNear;
			float shadowCameraFar;
		};
		uniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];
	#endif
	float texture2DCompare( sampler2D depths, vec2 uv, float compare ) {
		return step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );
	}
	vec2 texture2DDistribution( sampler2D shadow, vec2 uv ) {
		return unpackRGBATo2Half( texture2D( shadow, uv ) );
	}
	float VSMShadow (sampler2D shadow, vec2 uv, float compare ){
		float occlusion = 1.0;
		vec2 distribution = texture2DDistribution( shadow, uv );
		float hard_shadow = step( compare , distribution.x );
		if (hard_shadow != 1.0 ) {
			float distance = compare - distribution.x ;
			float variance = max( 0.00000, distribution.y * distribution.y );
			float softness_probability = variance / (variance + distance * distance );			softness_probability = clamp( ( softness_probability - 0.3 ) / ( 0.95 - 0.3 ), 0.0, 1.0 );			occlusion = clamp( max( hard_shadow, softness_probability ), 0.0, 1.0 );
		}
		return occlusion;
	}
	float getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {
		float shadow = 1.0;
		shadowCoord.xyz /= shadowCoord.w;
		shadowCoord.z += shadowBias;
		bool inFrustum = shadowCoord.x >= 0.0 && shadowCoord.x <= 1.0 && shadowCoord.y >= 0.0 && shadowCoord.y <= 1.0;
		bool frustumTest = inFrustum && shadowCoord.z <= 1.0;
		if ( frustumTest ) {
		#if defined( SHADOWMAP_TYPE_PCF )
			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;
			float dx0 = - texelSize.x * shadowRadius;
			float dy0 = - texelSize.y * shadowRadius;
			float dx1 = + texelSize.x * shadowRadius;
			float dy1 = + texelSize.y * shadowRadius;
			float dx2 = dx0 / 2.0;
			float dy2 = dy0 / 2.0;
			float dx3 = dx1 / 2.0;
			float dy3 = dy1 / 2.0;
			shadow = (
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )
			) * ( 1.0 / 17.0 );
		#elif defined( SHADOWMAP_TYPE_PCF_SOFT )
			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;
			float dx = texelSize.x;
			float dy = texelSize.y;
			vec2 uv = shadowCoord.xy;
			vec2 f = fract( uv * shadowMapSize + 0.5 );
			uv -= f * texelSize;
			shadow = (
				texture2DCompare( shadowMap, uv, shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + vec2( dx, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + vec2( 0.0, dy ), shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + texelSize, shadowCoord.z ) +
				mix( texture2DCompare( shadowMap, uv + vec2( -dx, 0.0 ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 0.0 ), shadowCoord.z ),
					 f.x ) +
				mix( texture2DCompare( shadowMap, uv + vec2( -dx, dy ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, dy ), shadowCoord.z ),
					 f.x ) +
				mix( texture2DCompare( shadowMap, uv + vec2( 0.0, -dy ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( 0.0, 2.0 * dy ), shadowCoord.z ),
					 f.y ) +
				mix( texture2DCompare( shadowMap, uv + vec2( dx, -dy ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( dx, 2.0 * dy ), shadowCoord.z ),
					 f.y ) +
				mix( mix( texture2DCompare( shadowMap, uv + vec2( -dx, -dy ), shadowCoord.z ),
						  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, -dy ), shadowCoord.z ),
						  f.x ),
					 mix( texture2DCompare( shadowMap, uv + vec2( -dx, 2.0 * dy ), shadowCoord.z ),
						  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 2.0 * dy ), shadowCoord.z ),
						  f.x ),
					 f.y )
			) * ( 1.0 / 9.0 );
		#elif defined( SHADOWMAP_TYPE_VSM )
			shadow = VSMShadow( shadowMap, shadowCoord.xy, shadowCoord.z );
		#else
			shadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );
		#endif
		}
		return shadow;
	}
	vec2 cubeToUV( vec3 v, float texelSizeY ) {
		vec3 absV = abs( v );
		float scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );
		absV *= scaleToCube;
		v *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );
		vec2 planar = v.xy;
		float almostATexel = 1.5 * texelSizeY;
		float almostOne = 1.0 - almostATexel;
		if ( absV.z >= almostOne ) {
			if ( v.z > 0.0 )
				planar.x = 4.0 - v.x;
		} else if ( absV.x >= almostOne ) {
			float signX = sign( v.x );
			planar.x = v.z * signX + 2.0 * signX;
		} else if ( absV.y >= almostOne ) {
			float signY = sign( v.y );
			planar.x = v.x + 2.0 * signY + 2.0;
			planar.y = v.z * signY - 2.0;
		}
		return vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );
	}
	float getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {
		vec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );
		vec3 lightToPosition = shadowCoord.xyz;
		float dp = ( length( lightToPosition ) - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear );		dp += shadowBias;
		vec3 bd3D = normalize( lightToPosition );
		#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT ) || defined( SHADOWMAP_TYPE_VSM )
			vec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;
			return (
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )
			) * ( 1.0 / 9.0 );
		#else
			return texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );
		#endif
	}
#endif`, zX = `#if NUM_SPOT_LIGHT_COORDS > 0
	uniform mat4 spotLightMatrix[ NUM_SPOT_LIGHT_COORDS ];
	varying vec4 vSpotLightCoord[ NUM_SPOT_LIGHT_COORDS ];
#endif
#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
		uniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHT_SHADOWS ];
		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];
		struct DirectionalLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
		struct SpotLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
		uniform mat4 pointShadowMatrix[ NUM_POINT_LIGHT_SHADOWS ];
		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];
		struct PointLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
			float shadowCameraNear;
			float shadowCameraFar;
		};
		uniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];
	#endif
#endif`, HX = `#if ( defined( USE_SHADOWMAP ) && ( NUM_DIR_LIGHT_SHADOWS > 0 || NUM_POINT_LIGHT_SHADOWS > 0 ) ) || ( NUM_SPOT_LIGHT_COORDS > 0 )
	vec3 shadowWorldNormal = inverseTransformDirection( transformedNormal, viewMatrix );
	vec4 shadowWorldPosition;
#endif
#if defined( USE_SHADOWMAP )
	#if NUM_DIR_LIGHT_SHADOWS > 0
		#pragma unroll_loop_start
		for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {
			shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * directionalLightShadows[ i ].shadowNormalBias, 0 );
			vDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * shadowWorldPosition;
		}
		#pragma unroll_loop_end
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
		#pragma unroll_loop_start
		for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {
			shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * pointLightShadows[ i ].shadowNormalBias, 0 );
			vPointShadowCoord[ i ] = pointShadowMatrix[ i ] * shadowWorldPosition;
		}
		#pragma unroll_loop_end
	#endif
#endif
#if NUM_SPOT_LIGHT_COORDS > 0
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHT_COORDS; i ++ ) {
		shadowWorldPosition = worldPosition;
		#if ( defined( USE_SHADOWMAP ) && UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )
			shadowWorldPosition.xyz += shadowWorldNormal * spotLightShadows[ i ].shadowNormalBias;
		#endif
		vSpotLightCoord[ i ] = spotLightMatrix[ i ] * shadowWorldPosition;
	}
	#pragma unroll_loop_end
#endif`, GX = `float getShadowMask() {
	float shadow = 1.0;
	#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
	DirectionalLightShadow directionalLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {
		directionalLight = directionalLightShadows[ i ];
		shadow *= receiveShadow ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
	SpotLightShadow spotLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {
		spotLight = spotLightShadows[ i ];
		shadow *= receiveShadow ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotLightCoord[ i ] ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
	PointLightShadow pointLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {
		pointLight = pointLightShadows[ i ];
		shadow *= receiveShadow ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#endif
	return shadow;
}`, VX = `#ifdef USE_SKINNING
	mat4 boneMatX = getBoneMatrix( skinIndex.x );
	mat4 boneMatY = getBoneMatrix( skinIndex.y );
	mat4 boneMatZ = getBoneMatrix( skinIndex.z );
	mat4 boneMatW = getBoneMatrix( skinIndex.w );
#endif`, WX = `#ifdef USE_SKINNING
	uniform mat4 bindMatrix;
	uniform mat4 bindMatrixInverse;
	uniform highp sampler2D boneTexture;
	uniform int boneTextureSize;
	mat4 getBoneMatrix( const in float i ) {
		float j = i * 4.0;
		float x = mod( j, float( boneTextureSize ) );
		float y = floor( j / float( boneTextureSize ) );
		float dx = 1.0 / float( boneTextureSize );
		float dy = 1.0 / float( boneTextureSize );
		y = dy * ( y + 0.5 );
		vec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );
		vec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );
		vec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );
		vec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );
		mat4 bone = mat4( v1, v2, v3, v4 );
		return bone;
	}
#endif`, XX = `#ifdef USE_SKINNING
	vec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );
	vec4 skinned = vec4( 0.0 );
	skinned += boneMatX * skinVertex * skinWeight.x;
	skinned += boneMatY * skinVertex * skinWeight.y;
	skinned += boneMatZ * skinVertex * skinWeight.z;
	skinned += boneMatW * skinVertex * skinWeight.w;
	transformed = ( bindMatrixInverse * skinned ).xyz;
#endif`, JX = `#ifdef USE_SKINNING
	mat4 skinMatrix = mat4( 0.0 );
	skinMatrix += skinWeight.x * boneMatX;
	skinMatrix += skinWeight.y * boneMatY;
	skinMatrix += skinWeight.z * boneMatZ;
	skinMatrix += skinWeight.w * boneMatW;
	skinMatrix = bindMatrixInverse * skinMatrix * bindMatrix;
	objectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;
	#ifdef USE_TANGENT
		objectTangent = vec4( skinMatrix * vec4( objectTangent, 0.0 ) ).xyz;
	#endif
#endif`, YX = `float specularStrength;
#ifdef USE_SPECULARMAP
	vec4 texelSpecular = texture2D( specularMap, vSpecularMapUv );
	specularStrength = texelSpecular.r;
#else
	specularStrength = 1.0;
#endif`, jX = `#ifdef USE_SPECULARMAP
	uniform sampler2D specularMap;
#endif`, KX = `#if defined( TONE_MAPPING )
	gl_FragColor.rgb = toneMapping( gl_FragColor.rgb );
#endif`, qX = `#ifndef saturate
#define saturate( a ) clamp( a, 0.0, 1.0 )
#endif
uniform float toneMappingExposure;
vec3 LinearToneMapping( vec3 color ) {
	return saturate( toneMappingExposure * color );
}
vec3 ReinhardToneMapping( vec3 color ) {
	color *= toneMappingExposure;
	return saturate( color / ( vec3( 1.0 ) + color ) );
}
vec3 OptimizedCineonToneMapping( vec3 color ) {
	color *= toneMappingExposure;
	color = max( vec3( 0.0 ), color - 0.004 );
	return pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );
}
vec3 RRTAndODTFit( vec3 v ) {
	vec3 a = v * ( v + 0.0245786 ) - 0.000090537;
	vec3 b = v * ( 0.983729 * v + 0.4329510 ) + 0.238081;
	return a / b;
}
vec3 ACESFilmicToneMapping( vec3 color ) {
	const mat3 ACESInputMat = mat3(
		vec3( 0.59719, 0.07600, 0.02840 ),		vec3( 0.35458, 0.90834, 0.13383 ),
		vec3( 0.04823, 0.01566, 0.83777 )
	);
	const mat3 ACESOutputMat = mat3(
		vec3(  1.60475, -0.10208, -0.00327 ),		vec3( -0.53108,  1.10813, -0.07276 ),
		vec3( -0.07367, -0.00605,  1.07602 )
	);
	color *= toneMappingExposure / 0.6;
	color = ACESInputMat * color;
	color = RRTAndODTFit( color );
	color = ACESOutputMat * color;
	return saturate( color );
}
vec3 CustomToneMapping( vec3 color ) { return color; }`, QX = `#ifdef USE_TRANSMISSION
	material.transmission = transmission;
	material.transmissionAlpha = 1.0;
	material.thickness = thickness;
	material.attenuationDistance = attenuationDistance;
	material.attenuationColor = attenuationColor;
	#ifdef USE_TRANSMISSIONMAP
		material.transmission *= texture2D( transmissionMap, vTransmissionMapUv ).r;
	#endif
	#ifdef USE_THICKNESSMAP
		material.thickness *= texture2D( thicknessMap, vThicknessMapUv ).g;
	#endif
	vec3 pos = vWorldPosition;
	vec3 v = normalize( cameraPosition - pos );
	vec3 n = inverseTransformDirection( normal, viewMatrix );
	vec4 transmitted = getIBLVolumeRefraction(
		n, v, material.roughness, material.diffuseColor, material.specularColor, material.specularF90,
		pos, modelMatrix, viewMatrix, projectionMatrix, material.ior, material.thickness,
		material.attenuationColor, material.attenuationDistance );
	material.transmissionAlpha = mix( material.transmissionAlpha, transmitted.a, material.transmission );
	totalDiffuse = mix( totalDiffuse, transmitted.rgb, material.transmission );
#endif`, ZX = `#ifdef USE_TRANSMISSION
	uniform float transmission;
	uniform float thickness;
	uniform float attenuationDistance;
	uniform vec3 attenuationColor;
	#ifdef USE_TRANSMISSIONMAP
		uniform sampler2D transmissionMap;
	#endif
	#ifdef USE_THICKNESSMAP
		uniform sampler2D thicknessMap;
	#endif
	uniform vec2 transmissionSamplerSize;
	uniform sampler2D transmissionSamplerMap;
	uniform mat4 modelMatrix;
	uniform mat4 projectionMatrix;
	varying vec3 vWorldPosition;
	float w0( float a ) {
		return ( 1.0 / 6.0 ) * ( a * ( a * ( - a + 3.0 ) - 3.0 ) + 1.0 );
	}
	float w1( float a ) {
		return ( 1.0 / 6.0 ) * ( a *  a * ( 3.0 * a - 6.0 ) + 4.0 );
	}
	float w2( float a ){
		return ( 1.0 / 6.0 ) * ( a * ( a * ( - 3.0 * a + 3.0 ) + 3.0 ) + 1.0 );
	}
	float w3( float a ) {
		return ( 1.0 / 6.0 ) * ( a * a * a );
	}
	float g0( float a ) {
		return w0( a ) + w1( a );
	}
	float g1( float a ) {
		return w2( a ) + w3( a );
	}
	float h0( float a ) {
		return - 1.0 + w1( a ) / ( w0( a ) + w1( a ) );
	}
	float h1( float a ) {
		return 1.0 + w3( a ) / ( w2( a ) + w3( a ) );
	}
	vec4 bicubic( sampler2D tex, vec2 uv, vec4 texelSize, float lod ) {
		uv = uv * texelSize.zw + 0.5;
		vec2 iuv = floor( uv );
		vec2 fuv = fract( uv );
		float g0x = g0( fuv.x );
		float g1x = g1( fuv.x );
		float h0x = h0( fuv.x );
		float h1x = h1( fuv.x );
		float h0y = h0( fuv.y );
		float h1y = h1( fuv.y );
		vec2 p0 = ( vec2( iuv.x + h0x, iuv.y + h0y ) - 0.5 ) * texelSize.xy;
		vec2 p1 = ( vec2( iuv.x + h1x, iuv.y + h0y ) - 0.5 ) * texelSize.xy;
		vec2 p2 = ( vec2( iuv.x + h0x, iuv.y + h1y ) - 0.5 ) * texelSize.xy;
		vec2 p3 = ( vec2( iuv.x + h1x, iuv.y + h1y ) - 0.5 ) * texelSize.xy;
		return g0( fuv.y ) * ( g0x * textureLod( tex, p0, lod ) + g1x * textureLod( tex, p1, lod ) ) +
			g1( fuv.y ) * ( g0x * textureLod( tex, p2, lod ) + g1x * textureLod( tex, p3, lod ) );
	}
	vec4 textureBicubic( sampler2D sampler, vec2 uv, float lod ) {
		vec2 fLodSize = vec2( textureSize( sampler, int( lod ) ) );
		vec2 cLodSize = vec2( textureSize( sampler, int( lod + 1.0 ) ) );
		vec2 fLodSizeInv = 1.0 / fLodSize;
		vec2 cLodSizeInv = 1.0 / cLodSize;
		vec4 fSample = bicubic( sampler, uv, vec4( fLodSizeInv, fLodSize ), floor( lod ) );
		vec4 cSample = bicubic( sampler, uv, vec4( cLodSizeInv, cLodSize ), ceil( lod ) );
		return mix( fSample, cSample, fract( lod ) );
	}
	vec3 getVolumeTransmissionRay( const in vec3 n, const in vec3 v, const in float thickness, const in float ior, const in mat4 modelMatrix ) {
		vec3 refractionVector = refract( - v, normalize( n ), 1.0 / ior );
		vec3 modelScale;
		modelScale.x = length( vec3( modelMatrix[ 0 ].xyz ) );
		modelScale.y = length( vec3( modelMatrix[ 1 ].xyz ) );
		modelScale.z = length( vec3( modelMatrix[ 2 ].xyz ) );
		return normalize( refractionVector ) * thickness * modelScale;
	}
	float applyIorToRoughness( const in float roughness, const in float ior ) {
		return roughness * clamp( ior * 2.0 - 2.0, 0.0, 1.0 );
	}
	vec4 getTransmissionSample( const in vec2 fragCoord, const in float roughness, const in float ior ) {
		float lod = log2( transmissionSamplerSize.x ) * applyIorToRoughness( roughness, ior );
		return textureBicubic( transmissionSamplerMap, fragCoord.xy, lod );
	}
	vec3 volumeAttenuation( const in float transmissionDistance, const in vec3 attenuationColor, const in float attenuationDistance ) {
		if ( isinf( attenuationDistance ) ) {
			return vec3( 1.0 );
		} else {
			vec3 attenuationCoefficient = -log( attenuationColor ) / attenuationDistance;
			vec3 transmittance = exp( - attenuationCoefficient * transmissionDistance );			return transmittance;
		}
	}
	vec4 getIBLVolumeRefraction( const in vec3 n, const in vec3 v, const in float roughness, const in vec3 diffuseColor,
		const in vec3 specularColor, const in float specularF90, const in vec3 position, const in mat4 modelMatrix,
		const in mat4 viewMatrix, const in mat4 projMatrix, const in float ior, const in float thickness,
		const in vec3 attenuationColor, const in float attenuationDistance ) {
		vec3 transmissionRay = getVolumeTransmissionRay( n, v, thickness, ior, modelMatrix );
		vec3 refractedRayExit = position + transmissionRay;
		vec4 ndcPos = projMatrix * viewMatrix * vec4( refractedRayExit, 1.0 );
		vec2 refractionCoords = ndcPos.xy / ndcPos.w;
		refractionCoords += 1.0;
		refractionCoords /= 2.0;
		vec4 transmittedLight = getTransmissionSample( refractionCoords, roughness, ior );
		vec3 transmittance = diffuseColor * volumeAttenuation( length( transmissionRay ), attenuationColor, attenuationDistance );
		vec3 attenuatedColor = transmittance * transmittedLight.rgb;
		vec3 F = EnvironmentBRDF( n, v, specularColor, specularF90, roughness );
		float transmittanceFactor = ( transmittance.r + transmittance.g + transmittance.b ) / 3.0;
		return vec4( ( 1.0 - F ) * attenuatedColor, 1.0 - ( 1.0 - transmittedLight.a ) * transmittanceFactor );
	}
#endif`, $X = `#if defined( USE_UV ) || defined( USE_ANISOTROPY )
	varying vec2 vUv;
#endif
#ifdef USE_MAP
	varying vec2 vMapUv;
#endif
#ifdef USE_ALPHAMAP
	varying vec2 vAlphaMapUv;
#endif
#ifdef USE_LIGHTMAP
	varying vec2 vLightMapUv;
#endif
#ifdef USE_AOMAP
	varying vec2 vAoMapUv;
#endif
#ifdef USE_BUMPMAP
	varying vec2 vBumpMapUv;
#endif
#ifdef USE_NORMALMAP
	varying vec2 vNormalMapUv;
#endif
#ifdef USE_EMISSIVEMAP
	varying vec2 vEmissiveMapUv;
#endif
#ifdef USE_METALNESSMAP
	varying vec2 vMetalnessMapUv;
#endif
#ifdef USE_ROUGHNESSMAP
	varying vec2 vRoughnessMapUv;
#endif
#ifdef USE_ANISOTROPYMAP
	varying vec2 vAnisotropyMapUv;
#endif
#ifdef USE_CLEARCOATMAP
	varying vec2 vClearcoatMapUv;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	varying vec2 vClearcoatNormalMapUv;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	varying vec2 vClearcoatRoughnessMapUv;
#endif
#ifdef USE_IRIDESCENCEMAP
	varying vec2 vIridescenceMapUv;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
	varying vec2 vIridescenceThicknessMapUv;
#endif
#ifdef USE_SHEEN_COLORMAP
	varying vec2 vSheenColorMapUv;
#endif
#ifdef USE_SHEEN_ROUGHNESSMAP
	varying vec2 vSheenRoughnessMapUv;
#endif
#ifdef USE_SPECULARMAP
	varying vec2 vSpecularMapUv;
#endif
#ifdef USE_SPECULAR_COLORMAP
	varying vec2 vSpecularColorMapUv;
#endif
#ifdef USE_SPECULAR_INTENSITYMAP
	varying vec2 vSpecularIntensityMapUv;
#endif
#ifdef USE_TRANSMISSIONMAP
	uniform mat3 transmissionMapTransform;
	varying vec2 vTransmissionMapUv;
#endif
#ifdef USE_THICKNESSMAP
	uniform mat3 thicknessMapTransform;
	varying vec2 vThicknessMapUv;
#endif`, eJ = `#if defined( USE_UV ) || defined( USE_ANISOTROPY )
	varying vec2 vUv;
#endif
#ifdef USE_MAP
	uniform mat3 mapTransform;
	varying vec2 vMapUv;
#endif
#ifdef USE_ALPHAMAP
	uniform mat3 alphaMapTransform;
	varying vec2 vAlphaMapUv;
#endif
#ifdef USE_LIGHTMAP
	uniform mat3 lightMapTransform;
	varying vec2 vLightMapUv;
#endif
#ifdef USE_AOMAP
	uniform mat3 aoMapTransform;
	varying vec2 vAoMapUv;
#endif
#ifdef USE_BUMPMAP
	uniform mat3 bumpMapTransform;
	varying vec2 vBumpMapUv;
#endif
#ifdef USE_NORMALMAP
	uniform mat3 normalMapTransform;
	varying vec2 vNormalMapUv;
#endif
#ifdef USE_DISPLACEMENTMAP
	uniform mat3 displacementMapTransform;
	varying vec2 vDisplacementMapUv;
#endif
#ifdef USE_EMISSIVEMAP
	uniform mat3 emissiveMapTransform;
	varying vec2 vEmissiveMapUv;
#endif
#ifdef USE_METALNESSMAP
	uniform mat3 metalnessMapTransform;
	varying vec2 vMetalnessMapUv;
#endif
#ifdef USE_ROUGHNESSMAP
	uniform mat3 roughnessMapTransform;
	varying vec2 vRoughnessMapUv;
#endif
#ifdef USE_ANISOTROPYMAP
	uniform mat3 anisotropyMapTransform;
	varying vec2 vAnisotropyMapUv;
#endif
#ifdef USE_CLEARCOATMAP
	uniform mat3 clearcoatMapTransform;
	varying vec2 vClearcoatMapUv;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	uniform mat3 clearcoatNormalMapTransform;
	varying vec2 vClearcoatNormalMapUv;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	uniform mat3 clearcoatRoughnessMapTransform;
	varying vec2 vClearcoatRoughnessMapUv;
#endif
#ifdef USE_SHEEN_COLORMAP
	uniform mat3 sheenColorMapTransform;
	varying vec2 vSheenColorMapUv;
#endif
#ifdef USE_SHEEN_ROUGHNESSMAP
	uniform mat3 sheenRoughnessMapTransform;
	varying vec2 vSheenRoughnessMapUv;
#endif
#ifdef USE_IRIDESCENCEMAP
	uniform mat3 iridescenceMapTransform;
	varying vec2 vIridescenceMapUv;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
	uniform mat3 iridescenceThicknessMapTransform;
	varying vec2 vIridescenceThicknessMapUv;
#endif
#ifdef USE_SPECULARMAP
	uniform mat3 specularMapTransform;
	varying vec2 vSpecularMapUv;
#endif
#ifdef USE_SPECULAR_COLORMAP
	uniform mat3 specularColorMapTransform;
	varying vec2 vSpecularColorMapUv;
#endif
#ifdef USE_SPECULAR_INTENSITYMAP
	uniform mat3 specularIntensityMapTransform;
	varying vec2 vSpecularIntensityMapUv;
#endif
#ifdef USE_TRANSMISSIONMAP
	uniform mat3 transmissionMapTransform;
	varying vec2 vTransmissionMapUv;
#endif
#ifdef USE_THICKNESSMAP
	uniform mat3 thicknessMapTransform;
	varying vec2 vThicknessMapUv;
#endif`, tJ = `#if defined( USE_UV ) || defined( USE_ANISOTROPY )
	vUv = vec3( uv, 1 ).xy;
#endif
#ifdef USE_MAP
	vMapUv = ( mapTransform * vec3( MAP_UV, 1 ) ).xy;
#endif
#ifdef USE_ALPHAMAP
	vAlphaMapUv = ( alphaMapTransform * vec3( ALPHAMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_LIGHTMAP
	vLightMapUv = ( lightMapTransform * vec3( LIGHTMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_AOMAP
	vAoMapUv = ( aoMapTransform * vec3( AOMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_BUMPMAP
	vBumpMapUv = ( bumpMapTransform * vec3( BUMPMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_NORMALMAP
	vNormalMapUv = ( normalMapTransform * vec3( NORMALMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_DISPLACEMENTMAP
	vDisplacementMapUv = ( displacementMapTransform * vec3( DISPLACEMENTMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_EMISSIVEMAP
	vEmissiveMapUv = ( emissiveMapTransform * vec3( EMISSIVEMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_METALNESSMAP
	vMetalnessMapUv = ( metalnessMapTransform * vec3( METALNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_ROUGHNESSMAP
	vRoughnessMapUv = ( roughnessMapTransform * vec3( ROUGHNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_ANISOTROPYMAP
	vAnisotropyMapUv = ( anisotropyMapTransform * vec3( ANISOTROPYMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_CLEARCOATMAP
	vClearcoatMapUv = ( clearcoatMapTransform * vec3( CLEARCOATMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	vClearcoatNormalMapUv = ( clearcoatNormalMapTransform * vec3( CLEARCOAT_NORMALMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	vClearcoatRoughnessMapUv = ( clearcoatRoughnessMapTransform * vec3( CLEARCOAT_ROUGHNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_IRIDESCENCEMAP
	vIridescenceMapUv = ( iridescenceMapTransform * vec3( IRIDESCENCEMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
	vIridescenceThicknessMapUv = ( iridescenceThicknessMapTransform * vec3( IRIDESCENCE_THICKNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SHEEN_COLORMAP
	vSheenColorMapUv = ( sheenColorMapTransform * vec3( SHEEN_COLORMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SHEEN_ROUGHNESSMAP
	vSheenRoughnessMapUv = ( sheenRoughnessMapTransform * vec3( SHEEN_ROUGHNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SPECULARMAP
	vSpecularMapUv = ( specularMapTransform * vec3( SPECULARMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SPECULAR_COLORMAP
	vSpecularColorMapUv = ( specularColorMapTransform * vec3( SPECULAR_COLORMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SPECULAR_INTENSITYMAP
	vSpecularIntensityMapUv = ( specularIntensityMapTransform * vec3( SPECULAR_INTENSITYMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_TRANSMISSIONMAP
	vTransmissionMapUv = ( transmissionMapTransform * vec3( TRANSMISSIONMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_THICKNESSMAP
	vThicknessMapUv = ( thicknessMapTransform * vec3( THICKNESSMAP_UV, 1 ) ).xy;
#endif`, nJ = `#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP ) || defined ( USE_TRANSMISSION ) || NUM_SPOT_LIGHT_COORDS > 0
	vec4 worldPosition = vec4( transformed, 1.0 );
	#ifdef USE_INSTANCING
		worldPosition = instanceMatrix * worldPosition;
	#endif
	worldPosition = modelMatrix * worldPosition;
#endif`; const iJ = `varying vec2 vUv;
uniform mat3 uvTransform;
void main() {
	vUv = ( uvTransform * vec3( uv, 1 ) ).xy;
	gl_Position = vec4( position.xy, 1.0, 1.0 );
}`, rJ = `uniform sampler2D t2D;
uniform float backgroundIntensity;
varying vec2 vUv;
void main() {
	vec4 texColor = texture2D( t2D, vUv );
	texColor.rgb *= backgroundIntensity;
	gl_FragColor = texColor;
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
}`, sJ = `varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
	gl_Position.z = gl_Position.w;
}`, oJ = `#ifdef ENVMAP_TYPE_CUBE
	uniform samplerCube envMap;
#elif defined( ENVMAP_TYPE_CUBE_UV )
	uniform sampler2D envMap;
#endif
uniform float flipEnvMap;
uniform float backgroundBlurriness;
uniform float backgroundIntensity;
varying vec3 vWorldDirection;
#include <cube_uv_reflection_fragment>
void main() {
	#ifdef ENVMAP_TYPE_CUBE
		vec4 texColor = textureCube( envMap, vec3( flipEnvMap * vWorldDirection.x, vWorldDirection.yz ) );
	#elif defined( ENVMAP_TYPE_CUBE_UV )
		vec4 texColor = textureCubeUV( envMap, vWorldDirection, backgroundBlurriness );
	#else
		vec4 texColor = vec4( 0.0, 0.0, 0.0, 1.0 );
	#endif
	texColor.rgb *= backgroundIntensity;
	gl_FragColor = texColor;
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
}`, aJ = `varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
	gl_Position.z = gl_Position.w;
}`, lJ = `uniform samplerCube tCube;
uniform float tFlip;
uniform float opacity;
varying vec3 vWorldDirection;
void main() {
	vec4 texColor = textureCube( tCube, vec3( tFlip * vWorldDirection.x, vWorldDirection.yz ) );
	gl_FragColor = texColor;
	gl_FragColor.a *= opacity;
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
}`, cJ = `#include <common>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
varying vec2 vHighPrecisionZW;
void main() {
	#include <uv_vertex>
	#include <skinbase_vertex>
	#ifdef USE_DISPLACEMENTMAP
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vHighPrecisionZW = gl_Position.zw;
}`, uJ = `#if DEPTH_PACKING == 3200
	uniform float opacity;
#endif
#include <common>
#include <packing>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
varying vec2 vHighPrecisionZW;
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( 1.0 );
	#if DEPTH_PACKING == 3200
		diffuseColor.a = opacity;
	#endif
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <logdepthbuf_fragment>
	float fragCoordZ = 0.5 * vHighPrecisionZW[0] / vHighPrecisionZW[1] + 0.5;
	#if DEPTH_PACKING == 3200
		gl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), opacity );
	#elif DEPTH_PACKING == 3201
		gl_FragColor = packDepthToRGBA( fragCoordZ );
	#endif
}`, fJ = `#define DISTANCE
varying vec3 vWorldPosition;
#include <common>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <skinbase_vertex>
	#ifdef USE_DISPLACEMENTMAP
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <worldpos_vertex>
	#include <clipping_planes_vertex>
	vWorldPosition = worldPosition.xyz;
}`, hJ = `#define DISTANCE
uniform vec3 referencePosition;
uniform float nearDistance;
uniform float farDistance;
varying vec3 vWorldPosition;
#include <common>
#include <packing>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <clipping_planes_pars_fragment>
void main () {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( 1.0 );
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	float dist = length( vWorldPosition - referencePosition );
	dist = ( dist - nearDistance ) / ( farDistance - nearDistance );
	dist = saturate( dist );
	gl_FragColor = packDepthToRGBA( dist );
}`, dJ = `varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
}`, pJ = `uniform sampler2D tEquirect;
varying vec3 vWorldDirection;
#include <common>
void main() {
	vec3 direction = normalize( vWorldDirection );
	vec2 sampleUV = equirectUv( direction );
	gl_FragColor = texture2D( tEquirect, sampleUV );
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
}`, mJ = `uniform float scale;
attribute float lineDistance;
varying float vLineDistance;
#include <common>
#include <uv_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	vLineDistance = scale * lineDistance;
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
}`, gJ = `uniform vec3 diffuse;
uniform float opacity;
uniform float dashSize;
uniform float totalSize;
varying float vLineDistance;
#include <common>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	if ( mod( vLineDistance, totalSize ) > dashSize ) {
		discard;
	}
	vec3 outgoingLight = vec3( 0.0 );
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	outgoingLight = diffuseColor.rgb;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
}`, yJ = `#include <common>
#include <uv_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#if defined ( USE_ENVMAP ) || defined ( USE_SKINNING )
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinbase_vertex>
		#include <skinnormal_vertex>
		#include <defaultnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <fog_vertex>
}`, vJ = `uniform vec3 diffuse;
uniform float opacity;
#ifndef FLAT_SHADED
	varying vec3 vNormal;
#endif
#include <common>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <fog_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <specularmap_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	#ifdef USE_LIGHTMAP
		vec4 lightMapTexel = texture2D( lightMap, vLightMapUv );
		reflectedLight.indirectDiffuse += lightMapTexel.rgb * lightMapIntensity * RECIPROCAL_PI;
	#else
		reflectedLight.indirectDiffuse += vec3( 1.0 );
	#endif
	#include <aomap_fragment>
	reflectedLight.indirectDiffuse *= diffuseColor.rgb;
	vec3 outgoingLight = reflectedLight.indirectDiffuse;
	#include <envmap_fragment>
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`, _J = `#define LAMBERT
varying vec3 vViewPosition;
#include <common>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`, xJ = `#define LAMBERT
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float opacity;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_lambert_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <specularmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_lambert_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;
	#include <envmap_fragment>
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`, AJ = `#define MATCAP
varying vec3 vViewPosition;
#include <common>
#include <uv_pars_vertex>
#include <color_pars_vertex>
#include <displacementmap_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
	vViewPosition = - mvPosition.xyz;
}`, MJ = `#define MATCAP
uniform vec3 diffuse;
uniform float opacity;
uniform sampler2D matcap;
varying vec3 vViewPosition;
#include <common>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <fog_pars_fragment>
#include <normal_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	vec3 viewDir = normalize( vViewPosition );
	vec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );
	vec3 y = cross( viewDir, x );
	vec2 uv = vec2( dot( x, normal ), dot( y, normal ) ) * 0.495 + 0.5;
	#ifdef USE_MATCAP
		vec4 matcapColor = texture2D( matcap, uv );
	#else
		vec4 matcapColor = vec4( vec3( mix( 0.2, 0.8, uv.y ) ), 1.0 );
	#endif
	vec3 outgoingLight = diffuseColor.rgb * matcapColor.rgb;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`, wJ = `#define NORMAL
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )
	varying vec3 vViewPosition;
#endif
#include <common>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )
	vViewPosition = - mvPosition.xyz;
#endif
}`, SJ = `#define NORMAL
uniform float opacity;
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )
	varying vec3 vViewPosition;
#endif
#include <packing>
#include <uv_pars_fragment>
#include <normal_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	#include <logdepthbuf_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	gl_FragColor = vec4( packNormalToRGB( normal ), opacity );
	#ifdef OPAQUE
		gl_FragColor.a = 1.0;
	#endif
}`, EJ = `#define PHONG
varying vec3 vViewPosition;
#include <common>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`, CJ = `#define PHONG
uniform vec3 diffuse;
uniform vec3 emissive;
uniform vec3 specular;
uniform float shininess;
uniform float opacity;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_phong_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <specularmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_phong_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;
	#include <envmap_fragment>
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`, TJ = `#define STANDARD
varying vec3 vViewPosition;
#ifdef USE_TRANSMISSION
	varying vec3 vWorldPosition;
#endif
#include <common>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
#ifdef USE_TRANSMISSION
	vWorldPosition = worldPosition.xyz;
#endif
}`, bJ = `#define STANDARD
#ifdef PHYSICAL
	#define IOR
	#define USE_SPECULAR
#endif
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float roughness;
uniform float metalness;
uniform float opacity;
#ifdef IOR
	uniform float ior;
#endif
#ifdef USE_SPECULAR
	uniform float specularIntensity;
	uniform vec3 specularColor;
	#ifdef USE_SPECULAR_COLORMAP
		uniform sampler2D specularColorMap;
	#endif
	#ifdef USE_SPECULAR_INTENSITYMAP
		uniform sampler2D specularIntensityMap;
	#endif
#endif
#ifdef USE_CLEARCOAT
	uniform float clearcoat;
	uniform float clearcoatRoughness;
#endif
#ifdef USE_IRIDESCENCE
	uniform float iridescence;
	uniform float iridescenceIOR;
	uniform float iridescenceThicknessMinimum;
	uniform float iridescenceThicknessMaximum;
#endif
#ifdef USE_SHEEN
	uniform vec3 sheenColor;
	uniform float sheenRoughness;
	#ifdef USE_SHEEN_COLORMAP
		uniform sampler2D sheenColorMap;
	#endif
	#ifdef USE_SHEEN_ROUGHNESSMAP
		uniform sampler2D sheenRoughnessMap;
	#endif
#endif
#ifdef USE_ANISOTROPY
	uniform vec2 anisotropyVector;
	#ifdef USE_ANISOTROPYMAP
		uniform sampler2D anisotropyMap;
	#endif
#endif
varying vec3 vViewPosition;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <iridescence_fragment>
#include <cube_uv_reflection_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_physical_pars_fragment>
#include <fog_pars_fragment>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_physical_pars_fragment>
#include <transmission_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <clearcoat_pars_fragment>
#include <iridescence_pars_fragment>
#include <roughnessmap_pars_fragment>
#include <metalnessmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <roughnessmap_fragment>
	#include <metalnessmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <clearcoat_normal_fragment_begin>
	#include <clearcoat_normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_physical_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 totalDiffuse = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse;
	vec3 totalSpecular = reflectedLight.directSpecular + reflectedLight.indirectSpecular;
	#include <transmission_fragment>
	vec3 outgoingLight = totalDiffuse + totalSpecular + totalEmissiveRadiance;
	#ifdef USE_SHEEN
		float sheenEnergyComp = 1.0 - 0.157 * max3( material.sheenColor );
		outgoingLight = outgoingLight * sheenEnergyComp + sheenSpecular;
	#endif
	#ifdef USE_CLEARCOAT
		float dotNVcc = saturate( dot( geometry.clearcoatNormal, geometry.viewDir ) );
		vec3 Fcc = F_Schlick( material.clearcoatF0, material.clearcoatF90, dotNVcc );
		outgoingLight = outgoingLight * ( 1.0 - material.clearcoat * Fcc ) + clearcoatSpecular * material.clearcoat;
	#endif
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`, RJ = `#define TOON
varying vec3 vViewPosition;
#include <common>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`, PJ = `#define TOON
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float opacity;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <gradientmap_pars_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_toon_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_toon_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`, IJ = `uniform float size;
uniform float scale;
#include <common>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
#ifdef USE_POINTS_UV
	varying vec2 vUv;
	uniform mat3 uvTransform;
#endif
void main() {
	#ifdef USE_POINTS_UV
		vUv = ( uvTransform * vec3( uv, 1 ) ).xy;
	#endif
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <project_vertex>
	gl_PointSize = size;
	#ifdef USE_SIZEATTENUATION
		bool isPerspective = isPerspectiveMatrix( projectionMatrix );
		if ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );
	#endif
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <worldpos_vertex>
	#include <fog_vertex>
}`, BJ = `uniform vec3 diffuse;
uniform float opacity;
#include <common>
#include <color_pars_fragment>
#include <map_particle_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec3 outgoingLight = vec3( 0.0 );
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <map_particle_fragment>
	#include <color_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	outgoingLight = diffuseColor.rgb;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
}`, LJ = `#include <common>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <shadowmap_pars_vertex>
void main() {
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`, DJ = `uniform vec3 color;
uniform float opacity;
#include <common>
#include <packing>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <logdepthbuf_pars_fragment>
#include <shadowmap_pars_fragment>
#include <shadowmask_pars_fragment>
void main() {
	#include <logdepthbuf_fragment>
	gl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
}`, OJ = `uniform float rotation;
uniform vec2 center;
#include <common>
#include <uv_pars_vertex>
#include <fog_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	vec4 mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );
	vec2 scale;
	scale.x = length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );
	scale.y = length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );
	#ifndef USE_SIZEATTENUATION
		bool isPerspective = isPerspectiveMatrix( projectionMatrix );
		if ( isPerspective ) scale *= - mvPosition.z;
	#endif
	vec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;
	vec2 rotatedPosition;
	rotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;
	rotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;
	mvPosition.xy += rotatedPosition;
	gl_Position = projectionMatrix * mvPosition;
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
}`, FJ = `uniform vec3 diffuse;
uniform float opacity;
#include <common>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec3 outgoingLight = vec3( 0.0 );
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	outgoingLight = diffuseColor.rgb;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
}`, Pt = { alphahash_fragment: o6, alphahash_pars_fragment: a6, alphamap_fragment: l6, alphamap_pars_fragment: c6, alphatest_fragment: u6, alphatest_pars_fragment: f6, aomap_fragment: h6, aomap_pars_fragment: d6, begin_vertex: p6, beginnormal_vertex: m6, bsdfs: g6, iridescence_fragment: y6, bumpmap_pars_fragment: v6, clipping_planes_fragment: _6, clipping_planes_pars_fragment: x6, clipping_planes_pars_vertex: A6, clipping_planes_vertex: M6, color_fragment: w6, color_pars_fragment: S6, color_pars_vertex: E6, color_vertex: C6, common: T6, cube_uv_reflection_fragment: b6, defaultnormal_vertex: R6, displacementmap_pars_vertex: P6, displacementmap_vertex: I6, emissivemap_fragment: B6, emissivemap_pars_fragment: L6, colorspace_fragment: D6, colorspace_pars_fragment: O6, envmap_fragment: F6, envmap_common_pars_fragment: k6, envmap_pars_fragment: N6, envmap_pars_vertex: U6, envmap_physical_pars_fragment: Q6, envmap_vertex: z6, fog_vertex: H6, fog_pars_vertex: G6, fog_fragment: V6, fog_pars_fragment: W6, gradientmap_pars_fragment: X6, lightmap_fragment: J6, lightmap_pars_fragment: Y6, lights_lambert_fragment: j6, lights_lambert_pars_fragment: K6, lights_pars_begin: q6, lights_toon_fragment: Z6, lights_toon_pars_fragment: $6, lights_phong_fragment: eX, lights_phong_pars_fragment: tX, lights_physical_fragment: nX, lights_physical_pars_fragment: iX, lights_fragment_begin: rX, lights_fragment_maps: sX, lights_fragment_end: oX, logdepthbuf_fragment: aX, logdepthbuf_pars_fragment: lX, logdepthbuf_pars_vertex: cX, logdepthbuf_vertex: uX, map_fragment: fX, map_pars_fragment: hX, map_particle_fragment: dX, map_particle_pars_fragment: pX, metalnessmap_fragment: mX, metalnessmap_pars_fragment: gX, morphcolor_vertex: yX, morphnormal_vertex: vX, morphtarget_pars_vertex: _X, morphtarget_vertex: xX, normal_fragment_begin: AX, normal_fragment_maps: MX, normal_pars_fragment: wX, normal_pars_vertex: SX, normal_vertex: EX, normalmap_pars_fragment: CX, clearcoat_normal_fragment_begin: TX, clearcoat_normal_fragment_maps: bX, clearcoat_pars_fragment: RX, iridescence_pars_fragment: PX, opaque_fragment: IX, packing: BX, premultiplied_alpha_fragment: LX, project_vertex: DX, dithering_fragment: OX, dithering_pars_fragment: FX, roughnessmap_fragment: kX, roughnessmap_pars_fragment: NX, shadowmap_pars_fragment: UX, shadowmap_pars_vertex: zX, shadowmap_vertex: HX, shadowmask_pars_fragment: GX, skinbase_vertex: VX, skinning_pars_vertex: WX, skinning_vertex: XX, skinnormal_vertex: JX, specularmap_fragment: YX, specularmap_pars_fragment: jX, tonemapping_fragment: KX, tonemapping_pars_fragment: qX, transmission_fragment: QX, transmission_pars_fragment: ZX, uv_pars_fragment: $X, uv_pars_vertex: eJ, uv_vertex: tJ, worldpos_vertex: nJ, background_vert: iJ, background_frag: rJ, backgroundCube_vert: sJ, backgroundCube_frag: oJ, cube_vert: aJ, cube_frag: lJ, depth_vert: cJ, depth_frag: uJ, distanceRGBA_vert: fJ, distanceRGBA_frag: hJ, equirect_vert: dJ, equirect_frag: pJ, linedashed_vert: mJ, linedashed_frag: gJ, meshbasic_vert: yJ, meshbasic_frag: vJ, meshlambert_vert: _J, meshlambert_frag: xJ, meshmatcap_vert: AJ, meshmatcap_frag: MJ, meshnormal_vert: wJ, meshnormal_frag: SJ, meshphong_vert: EJ, meshphong_frag: CJ, meshphysical_vert: TJ, meshphysical_frag: bJ, meshtoon_vert: RJ, meshtoon_frag: PJ, points_vert: IJ, points_frag: BJ, shadow_vert: LJ, shadow_frag: DJ, sprite_vert: OJ, sprite_frag: FJ }, He = { common: { diffuse: { value: new We(16777215) }, opacity: { value: 1 }, map: { value: null }, mapTransform: { value: new Ot }, alphaMap: { value: null }, alphaMapTransform: { value: new Ot }, alphaTest: { value: 0 } }, specularmap: { specularMap: { value: null }, specularMapTransform: { value: new Ot } }, envmap: { envMap: { value: null }, flipEnvMap: { value: -1 }, reflectivity: { value: 1 }, ior: { value: 1.5 }, refractionRatio: { value: .98 } }, aomap: { aoMap: { value: null }, aoMapIntensity: { value: 1 }, aoMapTransform: { value: new Ot } }, lightmap: { lightMap: { value: null }, lightMapIntensity: { value: 1 }, lightMapTransform: { value: new Ot } }, bumpmap: { bumpMap: { value: null }, bumpMapTransform: { value: new Ot }, bumpScale: { value: 1 } }, normalmap: { normalMap: { value: null }, normalMapTransform: { value: new Ot }, normalScale: { value: new _e(1, 1) } }, displacementmap: { displacementMap: { value: null }, displacementMapTransform: { value: new Ot }, displacementScale: { value: 1 }, displacementBias: { value: 0 } }, emissivemap: { emissiveMap: { value: null }, emissiveMapTransform: { value: new Ot } }, metalnessmap: { metalnessMap: { value: null }, metalnessMapTransform: { value: new Ot } }, roughnessmap: { roughnessMap: { value: null }, roughnessMapTransform: { value: new Ot } }, gradientmap: { gradientMap: { value: null } }, fog: { fogDensity: { value: 25e-5 }, fogNear: { value: 1 }, fogFar: { value: 2e3 }, fogColor: { value: new We(16777215) } }, lights: { ambientLightColor: { value: [] }, lightProbe: { value: [] }, directionalLights: { value: [], properties: { direction: {}, color: {} } }, directionalLightShadows: { value: [], properties: { shadowBias: {}, shadowNormalBias: {}, shadowRadius: {}, shadowMapSize: {} } }, directionalShadowMap: { value: [] }, directionalShadowMatrix: { value: [] }, spotLights: { value: [], properties: { color: {}, position: {}, direction: {}, distance: {}, coneCos: {}, penumbraCos: {}, decay: {} } }, spotLightShadows: { value: [], properties: { shadowBias: {}, shadowNormalBias: {}, shadowRadius: {}, shadowMapSize: {} } }, spotLightMap: { value: [] }, spotShadowMap: { value: [] }, spotLightMatrix: { value: [] }, pointLights: { value: [], properties: { color: {}, position: {}, decay: {}, distance: {} } }, pointLightShadows: { value: [], properties: { shadowBias: {}, shadowNormalBias: {}, shadowRadius: {}, shadowMapSize: {}, shadowCameraNear: {}, shadowCameraFar: {} } }, pointShadowMap: { value: [] }, pointShadowMatrix: { value: [] }, hemisphereLights: { value: [], properties: { direction: {}, skyColor: {}, groundColor: {} } }, rectAreaLights: { value: [], properties: { color: {}, position: {}, width: {}, height: {} } }, ltc_1: { value: null }, ltc_2: { value: null } }, points: { diffuse: { value: new We(16777215) }, opacity: { value: 1 }, size: { value: 1 }, scale: { value: 1 }, map: { value: null }, alphaMap: { value: null }, alphaMapTransform: { value: new Ot }, alphaTest: { value: 0 }, uvTransform: { value: new Ot } }, sprite: { diffuse: { value: new We(16777215) }, opacity: { value: 1 }, center: { value: new _e(.5, .5) }, rotation: { value: 0 }, map: { value: null }, mapTransform: { value: new Ot }, alphaMap: { value: null }, alphaMapTransform: { value: new Ot }, alphaTest: { value: 0 } } }, io = { basic: { uniforms: ur([He.common, He.specularmap, He.envmap, He.aomap, He.lightmap, He.fog]), vertexShader: Pt.meshbasic_vert, fragmentShader: Pt.meshbasic_frag }, lambert: { uniforms: ur([He.common, He.specularmap, He.envmap, He.aomap, He.lightmap, He.emissivemap, He.bumpmap, He.normalmap, He.displacementmap, He.fog, He.lights, { emissive: { value: new We(0) } }]), vertexShader: Pt.meshlambert_vert, fragmentShader: Pt.meshlambert_frag }, phong: { uniforms: ur([He.common, He.specularmap, He.envmap, He.aomap, He.lightmap, He.emissivemap, He.bumpmap, He.normalmap, He.displacementmap, He.fog, He.lights, { emissive: { value: new We(0) }, specular: { value: new We(1118481) }, shininess: { value: 30 } }]), vertexShader: Pt.meshphong_vert, fragmentShader: Pt.meshphong_frag }, standard: { uniforms: ur([He.common, He.envmap, He.aomap, He.lightmap, He.emissivemap, He.bumpmap, He.normalmap, He.displacementmap, He.roughnessmap, He.metalnessmap, He.fog, He.lights, { emissive: { value: new We(0) }, roughness: { value: 1 }, metalness: { value: 0 }, envMapIntensity: { value: 1 } }]), vertexShader: Pt.meshphysical_vert, fragmentShader: Pt.meshphysical_frag }, toon: { uniforms: ur([He.common, He.aomap, He.lightmap, He.emissivemap, He.bumpmap, He.normalmap, He.displacementmap, He.gradientmap, He.fog, He.lights, { emissive: { value: new We(0) } }]), vertexShader: Pt.meshtoon_vert, fragmentShader: Pt.meshtoon_frag }, matcap: { uniforms: ur([He.common, He.bumpmap, He.normalmap, He.displacementmap, He.fog, { matcap: { value: null } }]), vertexShader: Pt.meshmatcap_vert, fragmentShader: Pt.meshmatcap_frag }, points: { uniforms: ur([He.points, He.fog]), vertexShader: Pt.points_vert, fragmentShader: Pt.points_frag }, dashed: { uniforms: ur([He.common, He.fog, { scale: { value: 1 }, dashSize: { value: 1 }, totalSize: { value: 2 } }]), vertexShader: Pt.linedashed_vert, fragmentShader: Pt.linedashed_frag }, depth: { uniforms: ur([He.common, He.displacementmap]), vertexShader: Pt.depth_vert, fragmentShader: Pt.depth_frag }, normal: { uniforms: ur([He.common, He.bumpmap, He.normalmap, He.displacementmap, { opacity: { value: 1 } }]), vertexShader: Pt.meshnormal_vert, fragmentShader: Pt.meshnormal_frag }, sprite: { uniforms: ur([He.sprite, He.fog]), vertexShader: Pt.sprite_vert, fragmentShader: Pt.sprite_frag }, background: { uniforms: { uvTransform: { value: new Ot }, t2D: { value: null }, backgroundIntensity: { value: 1 } }, vertexShader: Pt.background_vert, fragmentShader: Pt.background_frag }, backgroundCube: { uniforms: { envMap: { value: null }, flipEnvMap: { value: -1 }, backgroundBlurriness: { value: 0 }, backgroundIntensity: { value: 1 } }, vertexShader: Pt.backgroundCube_vert, fragmentShader: Pt.backgroundCube_frag }, cube: { uniforms: { tCube: { value: null }, tFlip: { value: -1 }, opacity: { value: 1 } }, vertexShader: Pt.cube_vert, fragmentShader: Pt.cube_frag }, equirect: { uniforms: { tEquirect: { value: null } }, vertexShader: Pt.equirect_vert, fragmentShader: Pt.equirect_frag }, distanceRGBA: { uniforms: ur([He.common, He.displacementmap, { referencePosition: { value: new k }, nearDistance: { value: 1 }, farDistance: { value: 1e3 } }]), vertexShader: Pt.distanceRGBA_vert, fragmentShader: Pt.distanceRGBA_frag }, shadow: { uniforms: ur([He.lights, He.fog, { color: { value: new We(0) }, opacity: { value: 1 } }]), vertexShader: Pt.shadow_vert, fragmentShader: Pt.shadow_frag } }; io.physical = { uniforms: ur([io.standard.uniforms, { clearcoat: { value: 0 }, clearcoatMap: { value: null }, clearcoatMapTransform: { value: new Ot }, clearcoatNormalMap: { value: null }, clearcoatNormalMapTransform: { value: new Ot }, clearcoatNormalScale: { value: new _e(1, 1) }, clearcoatRoughness: { value: 0 }, clearcoatRoughnessMap: { value: null }, clearcoatRoughnessMapTransform: { value: new Ot }, iridescence: { value: 0 }, iridescenceMap: { value: null }, iridescenceMapTransform: { value: new Ot }, iridescenceIOR: { value: 1.3 }, iridescenceThicknessMinimum: { value: 100 }, iridescenceThicknessMaximum: { value: 400 }, iridescenceThicknessMap: { value: null }, iridescenceThicknessMapTransform: { value: new Ot }, sheen: { value: 0 }, sheenColor: { value: new We(0) }, sheenColorMap: { value: null }, sheenColorMapTransform: { value: new Ot }, sheenRoughness: { value: 1 }, sheenRoughnessMap: { value: null }, sheenRoughnessMapTransform: { value: new Ot }, transmission: { value: 0 }, transmissionMap: { value: null }, transmissionMapTransform: { value: new Ot }, transmissionSamplerSize: { value: new _e }, transmissionSamplerMap: { value: null }, thickness: { value: 0 }, thicknessMap: { value: null }, thicknessMapTransform: { value: new Ot }, attenuationDistance: { value: 0 }, attenuationColor: { value: new We(0) }, specularColor: { value: new We(1, 1, 1) }, specularColorMap: { value: null }, specularColorMapTransform: { value: new Ot }, specularIntensity: { value: 1 }, specularIntensityMap: { value: null }, specularIntensityMapTransform: { value: new Ot }, anisotropyVector: { value: new _e }, anisotropyMap: { value: null }, anisotropyMapTransform: { value: new Ot } }]), vertexShader: Pt.meshphysical_vert, fragmentShader: Pt.meshphysical_frag }; const o0 = { r: 0, b: 0, g: 0 }; function kJ(i, e, t, n, r, s, o) { const a = new We(0); let l = s === !0 ? 0 : 1, c, f, d = null, p = 0, m = null; function y(x, g) { let A = !1, M = g.isScene === !0 ? g.background : null; switch (M && M.isTexture && (M = (g.backgroundBlurriness > 0 ? t : e).get(M)), M === null ? _(a, l) : M && M.isColor && (_(M, 1), A = !0), i.xr.getEnvironmentBlendMode()) { case "opaque": A = !0; break; case "additive": n.buffers.color.setClear(0, 0, 0, 1, o), A = !0; break; case "alpha-blend": n.buffers.color.setClear(0, 0, 0, 0, o), A = !0; break }(i.autoClear || A) && i.clear(i.autoClearColor, i.autoClearDepth, i.autoClearStencil), M && (M.isCubeTexture || M.mapping === Rh) ? (f === void 0 && (f = new Ei(new pu(1, 1, 1), new jo({ name: "BackgroundCubeMaterial", uniforms: _h(io.backgroundCube.uniforms), vertexShader: io.backgroundCube.vertexShader, fragmentShader: io.backgroundCube.fragmentShader, side: _r, depthTest: !1, depthWrite: !1, fog: !1 })), f.geometry.deleteAttribute("normal"), f.geometry.deleteAttribute("uv"), f.onBeforeRender = function (T, R, B) { this.matrixWorld.copyPosition(B.matrixWorld) }, Object.defineProperty(f.material, "envMap", { get: function () { return this.uniforms.envMap.value } }), r.update(f)), f.material.uniforms.envMap.value = M, f.material.uniforms.flipEnvMap.value = M.isCubeTexture && M.isRenderTargetTexture === !1 ? -1 : 1, f.material.uniforms.backgroundBlurriness.value = g.backgroundBlurriness, f.material.uniforms.backgroundIntensity.value = g.backgroundIntensity, f.material.toneMapped = M.colorSpace !== bt, (d !== M || p !== M.version || m !== i.toneMapping) && (f.material.needsUpdate = !0, d = M, p = M.version, m = i.toneMapping), f.layers.enableAll(), x.unshift(f, f.geometry, f.material, 0, 0, null)) : M && M.isTexture && (c === void 0 && (c = new Ei(new cm(2, 2), new jo({ name: "BackgroundMaterial", uniforms: _h(io.background.uniforms), vertexShader: io.background.vertexShader, fragmentShader: io.background.fragmentShader, side: Jo, depthTest: !1, depthWrite: !1, fog: !1 })), c.geometry.deleteAttribute("normal"), Object.defineProperty(c.material, "map", { get: function () { return this.uniforms.t2D.value } }), r.update(c)), c.material.uniforms.t2D.value = M, c.material.uniforms.backgroundIntensity.value = g.backgroundIntensity, c.material.toneMapped = M.colorSpace !== bt, M.matrixAutoUpdate === !0 && M.updateMatrix(), c.material.uniforms.uvTransform.value.copy(M.matrix), (d !== M || p !== M.version || m !== i.toneMapping) && (c.material.needsUpdate = !0, d = M, p = M.version, m = i.toneMapping), c.layers.enableAll(), x.unshift(c, c.geometry, c.material, 0, 0, null)) } function _(x, g) { x.getRGB(o0, EF(i)), n.buffers.color.setClear(o0.r, o0.g, o0.b, g, o) } return { getClearColor: function () { return a }, setClearColor: function (x, g = 1) { a.set(x), l = g, _(a, l) }, getClearAlpha: function () { return l }, setClearAlpha: function (x) { l = x, _(a, l) }, render: y } } function NJ(i, e, t, n) { const r = i.getParameter(i.MAX_VERTEX_ATTRIBS), s = n.isWebGL2 ? null : e.get("OES_vertex_array_object"), o = n.isWebGL2 || s !== null, a = {}, l = x(null); let c = l, f = !1; function d(j, q, ne, Q, F) { let Y = !1; if (o) { const L = _(Q, ne, q); c !== L && (c = L, m(c.object)), Y = g(j, Q, ne, F), Y && A(j, Q, ne, F) } else { const L = q.wireframe === !0; (c.geometry !== Q.id || c.program !== ne.id || c.wireframe !== L) && (c.geometry = Q.id, c.program = ne.id, c.wireframe = L, Y = !0) } F !== null && t.update(F, i.ELEMENT_ARRAY_BUFFER), (Y || f) && (f = !1, B(j, q, ne, Q), F !== null && i.bindBuffer(i.ELEMENT_ARRAY_BUFFER, t.get(F).buffer)) } function p() { return n.isWebGL2 ? i.createVertexArray() : s.createVertexArrayOES() } function m(j) { return n.isWebGL2 ? i.bindVertexArray(j) : s.bindVertexArrayOES(j) } function y(j) { return n.isWebGL2 ? i.deleteVertexArray(j) : s.deleteVertexArrayOES(j) } function _(j, q, ne) { const Q = ne.wireframe === !0; let F = a[j.id]; F === void 0 && (F = {}, a[j.id] = F); let Y = F[q.id]; Y === void 0 && (Y = {}, F[q.id] = Y); let L = Y[Q]; return L === void 0 && (L = x(p()), Y[Q] = L), L } function x(j) { const q = [], ne = [], Q = []; for (let F = 0; F < r; F++)q[F] = 0, ne[F] = 0, Q[F] = 0; return { geometry: null, program: null, wireframe: !1, newAttributes: q, enabledAttributes: ne, attributeDivisors: Q, object: j, attributes: {}, index: null } } function g(j, q, ne, Q) { const F = c.attributes, Y = q.attributes; let L = 0; const G = ne.getAttributes(); for (const K in G) if (G[K].location >= 0) { const ge = F[K]; let xe = Y[K]; if (xe === void 0 && (K === "instanceMatrix" && j.instanceMatrix && (xe = j.instanceMatrix), K === "instanceColor" && j.instanceColor && (xe = j.instanceColor)), ge === void 0 || ge.attribute !== xe || xe && ge.data !== xe.data) return !0; L++ } return c.attributesNum !== L || c.index !== Q } function A(j, q, ne, Q) { const F = {}, Y = q.attributes; let L = 0; const G = ne.getAttributes(); for (const K in G) if (G[K].location >= 0) { let ge = Y[K]; ge === void 0 && (K === "instanceMatrix" && j.instanceMatrix && (ge = j.instanceMatrix), K === "instanceColor" && j.instanceColor && (ge = j.instanceColor)); const xe = {}; xe.attribute = ge, ge && ge.data && (xe.data = ge.data), F[K] = xe, L++ } c.attributes = F, c.attributesNum = L, c.index = Q } function M() { const j = c.newAttributes; for (let q = 0, ne = j.length; q < ne; q++)j[q] = 0 } function S(j) { C(j, 0) } function C(j, q) { const ne = c.newAttributes, Q = c.enabledAttributes, F = c.attributeDivisors; ne[j] = 1, Q[j] === 0 && (i.enableVertexAttribArray(j), Q[j] = 1), F[j] !== q && ((n.isWebGL2 ? i : e.get("ANGLE_instanced_arrays"))[n.isWebGL2 ? "vertexAttribDivisor" : "vertexAttribDivisorANGLE"](j, q), F[j] = q) } function T() { const j = c.newAttributes, q = c.enabledAttributes; for (let ne = 0, Q = q.length; ne < Q; ne++)q[ne] !== j[ne] && (i.disableVertexAttribArray(ne), q[ne] = 0) } function R(j, q, ne, Q, F, Y, L) { L === !0 ? i.vertexAttribIPointer(j, q, ne, F, Y) : i.vertexAttribPointer(j, q, ne, Q, F, Y) } function B(j, q, ne, Q) { if (n.isWebGL2 === !1 && (j.isInstancedMesh || Q.isInstancedBufferGeometry) && e.get("ANGLE_instanced_arrays") === null) return; M(); const F = Q.attributes, Y = ne.getAttributes(), L = q.defaultAttributeValues; for (const G in Y) { const K = Y[G]; if (K.location >= 0) { let ye = F[G]; if (ye === void 0 && (G === "instanceMatrix" && j.instanceMatrix && (ye = j.instanceMatrix), G === "instanceColor" && j.instanceColor && (ye = j.instanceColor)), ye !== void 0) { const ge = ye.normalized, xe = ye.itemSize, Be = t.get(ye); if (Be === void 0) continue; const Ie = Be.buffer, Je = Be.type, ut = Be.bytesPerElement, Bt = n.isWebGL2 === !0 && (Je === i.INT || Je === i.UNSIGNED_INT || ye.gpuType === uE); if (ye.isInterleavedBufferAttribute) { const Ge = ye.data, H = Ge.stride, pe = ye.offset; if (Ge.isInstancedInterleavedBuffer) { for (let fe = 0; fe < K.locationSize; fe++)C(K.location + fe, Ge.meshPerAttribute); j.isInstancedMesh !== !0 && Q._maxInstanceCount === void 0 && (Q._maxInstanceCount = Ge.meshPerAttribute * Ge.count) } else for (let fe = 0; fe < K.locationSize; fe++)S(K.location + fe); i.bindBuffer(i.ARRAY_BUFFER, Ie); for (let fe = 0; fe < K.locationSize; fe++)R(K.location + fe, xe / K.locationSize, Je, ge, H * ut, (pe + xe / K.locationSize * fe) * ut, Bt) } else { if (ye.isInstancedBufferAttribute) { for (let Ge = 0; Ge < K.locationSize; Ge++)C(K.location + Ge, ye.meshPerAttribute); j.isInstancedMesh !== !0 && Q._maxInstanceCount === void 0 && (Q._maxInstanceCount = ye.meshPerAttribute * ye.count) } else for (let Ge = 0; Ge < K.locationSize; Ge++)S(K.location + Ge); i.bindBuffer(i.ARRAY_BUFFER, Ie); for (let Ge = 0; Ge < K.locationSize; Ge++)R(K.location + Ge, xe / K.locationSize, Je, ge, xe * ut, xe / K.locationSize * Ge * ut, Bt) } } else if (L !== void 0) { const ge = L[G]; if (ge !== void 0) switch (ge.length) { case 2: i.vertexAttrib2fv(K.location, ge); break; case 3: i.vertexAttrib3fv(K.location, ge); break; case 4: i.vertexAttrib4fv(K.location, ge); break; default: i.vertexAttrib1fv(K.location, ge) } } } } T() } function b() { V(); for (const j in a) { const q = a[j]; for (const ne in q) { const Q = q[ne]; for (const F in Q) y(Q[F].object), delete Q[F]; delete q[ne] } delete a[j] } } function I(j) { if (a[j.id] === void 0) return; const q = a[j.id]; for (const ne in q) { const Q = q[ne]; for (const F in Q) y(Q[F].object), delete Q[F]; delete q[ne] } delete a[j.id] } function N(j) { for (const q in a) { const ne = a[q]; if (ne[j.id] === void 0) continue; const Q = ne[j.id]; for (const F in Q) y(Q[F].object), delete Q[F]; delete ne[j.id] } } function V() { J(), f = !0, c !== l && (c = l, m(c.object)) } function J() { l.geometry = null, l.program = null, l.wireframe = !1 } return { setup: d, reset: V, resetDefaultState: J, dispose: b, releaseStatesOfGeometry: I, releaseStatesOfProgram: N, initAttributes: M, enableAttribute: S, disableUnusedAttributes: T } } function UJ(i, e, t, n) { const r = n.isWebGL2; let s; function o(c) { s = c } function a(c, f) { i.drawArrays(s, c, f), t.update(f, s, 1) } function l(c, f, d) { if (d === 0) return; let p, m; if (r) p = i, m = "drawArraysInstanced"; else if (p = e.get("ANGLE_instanced_arrays"), m = "drawArraysInstancedANGLE", p === null) { console.error("THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays."); return } p[m](s, c, f, d), t.update(f, s, d) } this.setMode = o, this.render = a, this.renderInstances = l } function zJ(i, e, t) { let n; function r() { if (n !== void 0) return n; if (e.has("EXT_texture_filter_anisotropic") === !0) { const R = e.get("EXT_texture_filter_anisotropic"); n = i.getParameter(R.MAX_TEXTURE_MAX_ANISOTROPY_EXT) } else n = 0; return n } function s(R) { if (R === "highp") { if (i.getShaderPrecisionFormat(i.VERTEX_SHADER, i.HIGH_FLOAT).precision > 0 && i.getShaderPrecisionFormat(i.FRAGMENT_SHADER, i.HIGH_FLOAT).precision > 0) return "highp"; R = "mediump" } return R === "mediump" && i.getShaderPrecisionFormat(i.VERTEX_SHADER, i.MEDIUM_FLOAT).precision > 0 && i.getShaderPrecisionFormat(i.FRAGMENT_SHADER, i.MEDIUM_FLOAT).precision > 0 ? "mediump" : "lowp" } const o = typeof WebGL2RenderingContext < "u" && i.constructor.name === "WebGL2RenderingContext"; let a = t.precision !== void 0 ? t.precision : "highp"; const l = s(a); l !== a && (console.warn("THREE.WebGLRenderer:", a, "not supported, using", l, "instead."), a = l); const c = o || e.has("WEBGL_draw_buffers"), f = t.logarithmicDepthBuffer === !0, d = i.getParameter(i.MAX_TEXTURE_IMAGE_UNITS), p = i.getParameter(i.MAX_VERTEX_TEXTURE_IMAGE_UNITS), m = i.getParameter(i.MAX_TEXTURE_SIZE), y = i.getParameter(i.MAX_CUBE_MAP_TEXTURE_SIZE), _ = i.getParameter(i.MAX_VERTEX_ATTRIBS), x = i.getParameter(i.MAX_VERTEX_UNIFORM_VECTORS), g = i.getParameter(i.MAX_VARYING_VECTORS), A = i.getParameter(i.MAX_FRAGMENT_UNIFORM_VECTORS), M = p > 0, S = o || e.has("OES_texture_float"), C = M && S, T = o ? i.getParameter(i.MAX_SAMPLES) : 0; return { isWebGL2: o, drawBuffers: c, getMaxAnisotropy: r, getMaxPrecision: s, precision: a, logarithmicDepthBuffer: f, maxTextures: d, maxVertexTextures: p, maxTextureSize: m, maxCubemapSize: y, maxAttributes: _, maxVertexUniforms: x, maxVaryings: g, maxFragmentUniforms: A, vertexTextures: M, floatFragmentTextures: S, floatVertexTextures: C, maxSamples: T } } function HJ(i) { const e = this; let t = null, n = 0, r = !1, s = !1; const o = new il, a = new Ot, l = { value: null, needsUpdate: !1 }; this.uniform = l, this.numPlanes = 0, this.numIntersection = 0, this.init = function (d, p) { const m = d.length !== 0 || p || n !== 0 || r; return r = p, n = d.length, m }, this.beginShadows = function () { s = !0, f(null) }, this.endShadows = function () { s = !1 }, this.setGlobalState = function (d, p) { t = f(d, p, 0) }, this.setState = function (d, p, m) { const y = d.clippingPlanes, _ = d.clipIntersection, x = d.clipShadows, g = i.get(d); if (!r || y === null || y.length === 0 || s && !x) s ? f(null) : c(); else { const A = s ? 0 : n, M = A * 4; let S = g.clippingState || null; l.value = S, S = f(y, p, M, m); for (let C = 0; C !== M; ++C)S[C] = t[C]; g.clippingState = S, this.numIntersection = _ ? this.numPlanes : 0, this.numPlanes += A } }; function c() { l.value !== t && (l.value = t, l.needsUpdate = n > 0), e.numPlanes = n, e.numIntersection = 0 } function f(d, p, m, y) { const _ = d !== null ? d.length : 0; let x = null; if (_ !== 0) { if (x = l.value, y !== !0 || x === null) { const g = m + _ * 4, A = p.matrixWorldInverse; a.getNormalMatrix(A), (x === null || x.length < g) && (x = new Float32Array(g)); for (let M = 0, S = m; M !== _; ++M, S += 4)o.copy(d[M]).applyMatrix4(A, a), o.normal.toArray(x, S), x[S + 3] = o.constant } l.value = x, l.needsUpdate = !0 } return e.numPlanes = _, e.numIntersection = 0, x } } function GJ(i) { let e = new WeakMap; function t(o, a) { return a === Fp ? o.mapping = Da : a === kp && (o.mapping = Nl), o } function n(o) { if (o && o.isTexture && o.isRenderTargetTexture === !1) { const a = o.mapping; if (a === Fp || a === kp) if (e.has(o)) { const l = e.get(o).texture; return t(l, o.mapping) } else { const l = o.image; if (l && l.height > 0) { const c = new bF(l.height / 2); return c.fromEquirectangularTexture(i, o), e.set(o, c), o.addEventListener("dispose", r), t(c.texture, o.mapping) } else return null } } return o } function r(o) { const a = o.target; a.removeEventListener("dispose", r); const l = e.get(a); l !== void 0 && (e.delete(a), l.dispose()) } function s() { e = new WeakMap } return { get: n, dispose: s } } class Ca extends am { constructor(e = -1, t = 1, n = 1, r = -1, s = .1, o = 2e3) { super(), this.isOrthographicCamera = !0, this.type = "OrthographicCamera", this.zoom = 1, this.view = null, this.left = e, this.right = t, this.top = n, this.bottom = r, this.near = s, this.far = o, this.updateProjectionMatrix() } copy(e, t) { return super.copy(e, t), this.left = e.left, this.right = e.right, this.top = e.top, this.bottom = e.bottom, this.near = e.near, this.far = e.far, this.zoom = e.zoom, this.view = e.view === null ? null : Object.assign({}, e.view), this } setViewOffset(e, t, n, r, s, o) { this.view === null && (this.view = { enabled: !0, fullWidth: 1, fullHeight: 1, offsetX: 0, offsetY: 0, width: 1, height: 1 }), this.view.enabled = !0, this.view.fullWidth = e, this.view.fullHeight = t, this.view.offsetX = n, this.view.offsetY = r, this.view.width = s, this.view.height = o, this.updateProjectionMatrix() } clearViewOffset() { this.view !== null && (this.view.enabled = !1), this.updateProjectionMatrix() } updateProjectionMatrix() { const e = (this.right - this.left) / (2 * this.zoom), t = (this.top - this.bottom) / (2 * this.zoom), n = (this.right + this.left) / 2, r = (this.top + this.bottom) / 2; let s = n - e, o = n + e, a = r + t, l = r - t; if (this.view !== null && this.view.enabled) { const c = (this.right - this.left) / this.view.fullWidth / this.zoom, f = (this.top - this.bottom) / this.view.fullHeight / this.zoom; s += c * this.view.offsetX, o = s + c * this.view.width, a -= f * this.view.offsetY, l = a - f * this.view.height } this.projectionMatrix.makeOrthographic(s, o, a, l, this.near, this.far, this.coordinateSystem), this.projectionMatrixInverse.copy(this.projectionMatrix).invert() } toJSON(e) { const t = super.toJSON(e); return t.object.zoom = this.zoom, t.object.left = this.left, t.object.right = this.right, t.object.top = this.top, t.object.bottom = this.bottom, t.object.near = this.near, t.object.far = this.far, this.view !== null && (t.object.view = Object.assign({}, this.view)), t } } const If = 4, dP = [.125, .215, .35, .446, .526, .582], Ec = 20, GA = new Ca, pP = new We; let VA = null; const wc = (1 + Math.sqrt(5)) / 2, Zu = 1 / wc, mP = [new k(1, 1, 1), new k(-1, 1, 1), new k(1, 1, -1), new k(-1, 1, -1), new k(0, wc, Zu), new k(0, wc, -Zu), new k(Zu, 0, wc), new k(-Zu, 0, wc), new k(wc, Zu, 0), new k(-wc, Zu, 0)]; class _S { constructor(e) { this._renderer = e, this._pingPongRenderTarget = null, this._lodMax = 0, this._cubeSize = 0, this._lodPlanes = [], this._sizeLods = [], this._sigmas = [], this._blurMaterial = null, this._cubemapMaterial = null, this._equirectMaterial = null, this._compileMaterial(this._blurMaterial) } fromScene(e, t = 0, n = .1, r = 100) { VA = this._renderer.getRenderTarget(), this._setSize(256); const s = this._allocateTargets(); return s.depthBuffer = !0, this._sceneToCubeUV(e, n, r, s), t > 0 && this._blur(s, 0, 0, t), this._applyPMREM(s), this._cleanup(s), s } fromEquirectangular(e, t = null) { return this._fromTexture(e, t) } fromCubemap(e, t = null) { return this._fromTexture(e, t) } compileCubemapShader() { this._cubemapMaterial === null && (this._cubemapMaterial = vP(), this._compileMaterial(this._cubemapMaterial)) } compileEquirectangularShader() { this._equirectMaterial === null && (this._equirectMaterial = yP(), this._compileMaterial(this._equirectMaterial)) } dispose() { this._dispose(), this._cubemapMaterial !== null && this._cubemapMaterial.dispose(), this._equirectMaterial !== null && this._equirectMaterial.dispose() } _setSize(e) { this._lodMax = Math.floor(Math.log2(e)), this._cubeSize = Math.pow(2, this._lodMax) } _dispose() { this._blurMaterial !== null && this._blurMaterial.dispose(), this._pingPongRenderTarget !== null && this._pingPongRenderTarget.dispose(); for (let e = 0; e < this._lodPlanes.length; e++)this._lodPlanes[e].dispose() } _cleanup(e) { this._renderer.setRenderTarget(VA), e.scissorTest = !1, a0(e, 0, 0, e.width, e.height) } _fromTexture(e, t) { e.mapping === Da || e.mapping === Nl ? this._setSize(e.image.length === 0 ? 16 : e.image[0].width || e.image[0].image.width) : this._setSize(e.image.width / 4), VA = this._renderer.getRenderTarget(); const n = t || this._allocateTargets(); return this._textureToCubeUV(e, n), this._applyPMREM(n), this._cleanup(n), n } _allocateTargets() { const e = 3 * Math.max(this._cubeSize, 112), t = 4 * this._cubeSize, n = { magFilter: Pn, minFilter: Pn, generateMipmaps: !1, type: gh, format: Pr, colorSpace: po, depthBuffer: !1 }, r = gP(e, t, n); if (this._pingPongRenderTarget === null || this._pingPongRenderTarget.width !== e || this._pingPongRenderTarget.height !== t) { this._pingPongRenderTarget !== null && this._dispose(), this._pingPongRenderTarget = gP(e, t, n); const { _lodMax: s } = this; ({ sizeLods: this._sizeLods, lodPlanes: this._lodPlanes, sigmas: this._sigmas } = VJ(s)), this._blurMaterial = WJ(s, e, t) } return r } _compileMaterial(e) { const t = new Ei(this._lodPlanes[0], e); this._renderer.compile(t, GA) } _sceneToCubeUV(e, t, n, r) { const a = new Vn(90, 1, t, n), l = [1, -1, 1, 1, 1, 1], c = [1, 1, 1, -1, -1, -1], f = this._renderer, d = f.autoClear, p = f.toneMapping; f.getClearColor(pP), f.toneMapping = Ho, f.autoClear = !1; const m = new ts({ name: "PMREM.Background", side: _r, depthWrite: !1, depthTest: !1 }), y = new Ei(new pu, m); let _ = !1; const x = e.background; x ? x.isColor && (m.color.copy(x), e.background = null, _ = !0) : (m.color.copy(pP), _ = !0); for (let g = 0; g < 6; g++) { const A = g % 3; A === 0 ? (a.up.set(0, l[g], 0), a.lookAt(c[g], 0, 0)) : A === 1 ? (a.up.set(0, 0, l[g]), a.lookAt(0, c[g], 0)) : (a.up.set(0, l[g], 0), a.lookAt(0, 0, c[g])); const M = this._cubeSize; a0(r, A * M, g > 2 ? M : 0, M, M), f.setRenderTarget(r), _ && f.render(y, a), f.render(e, a) } y.geometry.dispose(), y.material.dispose(), f.toneMapping = p, f.autoClear = d, e.background = x } _textureToCubeUV(e, t) { const n = this._renderer, r = e.mapping === Da || e.mapping === Nl; r ? (this._cubemapMaterial === null && (this._cubemapMaterial = vP()), this._cubemapMaterial.uniforms.flipEnvMap.value = e.isRenderTargetTexture === !1 ? -1 : 1) : this._equirectMaterial === null && (this._equirectMaterial = yP()); const s = r ? this._cubemapMaterial : this._equirectMaterial, o = new Ei(this._lodPlanes[0], s), a = s.uniforms; a.envMap.value = e; const l = this._cubeSize; a0(t, 0, 0, 3 * l, 2 * l), n.setRenderTarget(t), n.render(o, GA) } _applyPMREM(e) { const t = this._renderer, n = t.autoClear; t.autoClear = !1; for (let r = 1; r < this._lodPlanes.length; r++) { const s = Math.sqrt(this._sigmas[r] * this._sigmas[r] - this._sigmas[r - 1] * this._sigmas[r - 1]), o = mP[(r - 1) % mP.length]; this._blur(e, r - 1, r, s, o) } t.autoClear = n } _blur(e, t, n, r, s) { const o = this._pingPongRenderTarget; this._halfBlur(e, o, t, n, r, "latitudinal", s), this._halfBlur(o, e, n, n, r, "longitudinal", s) } _halfBlur(e, t, n, r, s, o, a) { const l = this._renderer, c = this._blurMaterial; o !== "latitudinal" && o !== "longitudinal" && console.error("blur direction must be either latitudinal or longitudinal!"); const f = 3, d = new Ei(this._lodPlanes[r], c), p = c.uniforms, m = this._sizeLods[n] - 1, y = isFinite(s) ? Math.PI / (2 * m) : 2 * Math.PI / (2 * Ec - 1), _ = s / y, x = isFinite(s) ? 1 + Math.floor(f * _) : Ec; x > Ec && console.warn(`sigmaRadians, ${s}, is too large and will clip, as it requested ${x} samples when the maximum is set to ${Ec}`); const g = []; let A = 0; for (let R = 0; R < Ec; ++R) { const B = R / _, b = Math.exp(-B * B / 2); g.push(b), R === 0 ? A += b : R < x && (A += 2 * b) } for (let R = 0; R < g.length; R++)g[R] = g[R] / A; p.envMap.value = e.texture, p.samples.value = x, p.weights.value = g, p.latitudinal.value = o === "latitudinal", a && (p.poleAxis.value = a); const { _lodMax: M } = this; p.dTheta.value = y, p.mipInt.value = M - n; const S = this._sizeLods[r], C = 3 * S * (r > M - If ? r - M + If : 0), T = 4 * (this._cubeSize - S); a0(t, C, T, 3 * S, 2 * S), l.setRenderTarget(t), l.render(d, GA) } } function VJ(i) { const e = [], t = [], n = []; let r = i; const s = i - If + 1 + dP.length; for (let o = 0; o < s; o++) { const a = Math.pow(2, r); t.push(a); let l = 1 / a; o > i - If ? l = dP[o - i + If - 1] : o === 0 && (l = 0), n.push(l); const c = 1 / (a - 2), f = -c, d = 1 + c, p = [f, f, d, f, d, d, f, f, d, d, f, d], m = 6, y = 6, _ = 3, x = 2, g = 1, A = new Float32Array(_ * y * m), M = new Float32Array(x * y * m), S = new Float32Array(g * y * m); for (let T = 0; T < m; T++) { const R = T % 3 * 2 / 3 - 1, B = T > 2 ? 0 : -1, b = [R, B, 0, R + 2 / 3, B, 0, R + 2 / 3, B + 1, 0, R, B, 0, R + 2 / 3, B + 1, 0, R, B + 1, 0]; A.set(b, _ * y * T), M.set(p, x * y * T); const I = [T, T, T, T, T, T]; S.set(I, g * y * T) } const C = new Rt; C.setAttribute("position", new rn(A, _)), C.setAttribute("uv", new rn(M, x)), C.setAttribute("faceIndex", new rn(S, g)), e.push(C), r > If && r-- } return { lodPlanes: e, sizeLods: t, sigmas: n } } function gP(i, e, t) { const n = new mo(i, e, t); return n.texture.mapping = Rh, n.texture.name = "PMREM.cubeUv", n.scissorTest = !0, n } function a0(i, e, t, n, r) { i.viewport.set(e, t, n, r), i.scissor.set(e, t, n, r) } function WJ(i, e, t) {
	const n = new Float32Array(Ec), r = new k(0, 1, 0); return new jo({
		name: "SphericalGaussianBlur", defines: { n: Ec, CUBEUV_TEXEL_WIDTH: 1 / e, CUBEUV_TEXEL_HEIGHT: 1 / t, CUBEUV_MAX_MIP: `${i}.0` }, uniforms: { envMap: { value: null }, samples: { value: 1 }, weights: { value: n }, latitudinal: { value: !1 }, dTheta: { value: 0 }, mipInt: { value: 0 }, poleAxis: { value: r } }, vertexShader: EE(), fragmentShader: `

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform sampler2D envMap;
			uniform int samples;
			uniform float weights[ n ];
			uniform bool latitudinal;
			uniform float dTheta;
			uniform float mipInt;
			uniform vec3 poleAxis;

			#define ENVMAP_TYPE_CUBE_UV
			#include <cube_uv_reflection_fragment>

			vec3 getSample( float theta, vec3 axis ) {

				float cosTheta = cos( theta );
				// Rodrigues' axis-angle rotation
				vec3 sampleDirection = vOutputDirection * cosTheta
					+ cross( axis, vOutputDirection ) * sin( theta )
					+ axis * dot( axis, vOutputDirection ) * ( 1.0 - cosTheta );

				return bilinearCubeUV( envMap, sampleDirection, mipInt );

			}

			void main() {

				vec3 axis = latitudinal ? poleAxis : cross( poleAxis, vOutputDirection );

				if ( all( equal( axis, vec3( 0.0 ) ) ) ) {

					axis = vec3( vOutputDirection.z, 0.0, - vOutputDirection.x );

				}

				axis = normalize( axis );

				gl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );
				gl_FragColor.rgb += weights[ 0 ] * getSample( 0.0, axis );

				for ( int i = 1; i < n; i++ ) {

					if ( i >= samples ) {

						break;

					}

					float theta = dTheta * float( i );
					gl_FragColor.rgb += weights[ i ] * getSample( -1.0 * theta, axis );
					gl_FragColor.rgb += weights[ i ] * getSample( theta, axis );

				}

			}
		`, blending: Ea, depthTest: !1, depthWrite: !1
	})
} function yP() {
	return new jo({
		name: "EquirectangularToCubeUV", uniforms: { envMap: { value: null } }, vertexShader: EE(), fragmentShader: `

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform sampler2D envMap;

			#include <common>

			void main() {

				vec3 outputDirection = normalize( vOutputDirection );
				vec2 uv = equirectUv( outputDirection );

				gl_FragColor = vec4( texture2D ( envMap, uv ).rgb, 1.0 );

			}
		`, blending: Ea, depthTest: !1, depthWrite: !1
	})
} function vP() {
	return new jo({
		name: "CubemapToCubeUV", uniforms: { envMap: { value: null }, flipEnvMap: { value: -1 } }, vertexShader: EE(), fragmentShader: `

			precision mediump float;
			precision mediump int;

			uniform float flipEnvMap;

			varying vec3 vOutputDirection;

			uniform samplerCube envMap;

			void main() {

				gl_FragColor = textureCube( envMap, vec3( flipEnvMap * vOutputDirection.x, vOutputDirection.yz ) );

			}
		`, blending: Ea, depthTest: !1, depthWrite: !1
	})
} function EE() {
	return `

		precision mediump float;
		precision mediump int;

		attribute float faceIndex;

		varying vec3 vOutputDirection;

		// RH coordinate system; PMREM face-indexing convention
		vec3 getDirection( vec2 uv, float face ) {

			uv = 2.0 * uv - 1.0;

			vec3 direction = vec3( uv, 1.0 );

			if ( face == 0.0 ) {

				direction = direction.zyx; // ( 1, v, u ) pos x

			} else if ( face == 1.0 ) {

				direction = direction.xzy;
				direction.xz *= -1.0; // ( -u, 1, -v ) pos y

			} else if ( face == 2.0 ) {

				direction.x *= -1.0; // ( -u, v, 1 ) pos z

			} else if ( face == 3.0 ) {

				direction = direction.zyx;
				direction.xz *= -1.0; // ( -1, v, -u ) neg x

			} else if ( face == 4.0 ) {

				direction = direction.xzy;
				direction.xy *= -1.0; // ( -u, -1, v ) neg y

			} else if ( face == 5.0 ) {

				direction.z *= -1.0; // ( u, v, -1 ) neg z

			}

			return direction;

		}

		void main() {

			vOutputDirection = getDirection( uv, faceIndex );
			gl_Position = vec4( position, 1.0 );

		}
	`} function XJ(i) { let e = new WeakMap, t = null; function n(a) { if (a && a.isTexture) { const l = a.mapping, c = l === Fp || l === kp, f = l === Da || l === Nl; if (c || f) if (a.isRenderTargetTexture && a.needsPMREMUpdate === !0) { a.needsPMREMUpdate = !1; let d = e.get(a); return t === null && (t = new _S(i)), d = c ? t.fromEquirectangular(a, d) : t.fromCubemap(a, d), e.set(a, d), d.texture } else { if (e.has(a)) return e.get(a).texture; { const d = a.image; if (c && d && d.height > 0 || f && d && r(d)) { t === null && (t = new _S(i)); const p = c ? t.fromEquirectangular(a) : t.fromCubemap(a); return e.set(a, p), a.addEventListener("dispose", s), p.texture } else return null } } } return a } function r(a) { let l = 0; const c = 6; for (let f = 0; f < c; f++)a[f] !== void 0 && l++; return l === c } function s(a) { const l = a.target; l.removeEventListener("dispose", s); const c = e.get(l); c !== void 0 && (e.delete(l), c.dispose()) } function o() { e = new WeakMap, t !== null && (t.dispose(), t = null) } return { get: n, dispose: o } } function JJ(i) { const e = {}; function t(n) { if (e[n] !== void 0) return e[n]; let r; switch (n) { case "WEBGL_depth_texture": r = i.getExtension("WEBGL_depth_texture") || i.getExtension("MOZ_WEBGL_depth_texture") || i.getExtension("WEBKIT_WEBGL_depth_texture"); break; case "EXT_texture_filter_anisotropic": r = i.getExtension("EXT_texture_filter_anisotropic") || i.getExtension("MOZ_EXT_texture_filter_anisotropic") || i.getExtension("WEBKIT_EXT_texture_filter_anisotropic"); break; case "WEBGL_compressed_texture_s3tc": r = i.getExtension("WEBGL_compressed_texture_s3tc") || i.getExtension("MOZ_WEBGL_compressed_texture_s3tc") || i.getExtension("WEBKIT_WEBGL_compressed_texture_s3tc"); break; case "WEBGL_compressed_texture_pvrtc": r = i.getExtension("WEBGL_compressed_texture_pvrtc") || i.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc"); break; default: r = i.getExtension(n) }return e[n] = r, r } return { has: function (n) { return t(n) !== null }, init: function (n) { n.isWebGL2 ? t("EXT_color_buffer_float") : (t("WEBGL_depth_texture"), t("OES_texture_float"), t("OES_texture_half_float"), t("OES_texture_half_float_linear"), t("OES_standard_derivatives"), t("OES_element_index_uint"), t("OES_vertex_array_object"), t("ANGLE_instanced_arrays")), t("OES_texture_float_linear"), t("EXT_color_buffer_half_float"), t("WEBGL_multisampled_render_to_texture") }, get: function (n) { const r = t(n); return r === null && console.warn("THREE.WebGLRenderer: " + n + " extension not supported."), r } } } function YJ(i, e, t, n) { const r = {}, s = new WeakMap; function o(d) { const p = d.target; p.index !== null && e.remove(p.index); for (const y in p.attributes) e.remove(p.attributes[y]); for (const y in p.morphAttributes) { const _ = p.morphAttributes[y]; for (let x = 0, g = _.length; x < g; x++)e.remove(_[x]) } p.removeEventListener("dispose", o), delete r[p.id]; const m = s.get(p); m && (e.remove(m), s.delete(p)), n.releaseStatesOfGeometry(p), p.isInstancedBufferGeometry === !0 && delete p._maxInstanceCount, t.memory.geometries-- } function a(d, p) { return r[p.id] === !0 || (p.addEventListener("dispose", o), r[p.id] = !0, t.memory.geometries++), p } function l(d) { const p = d.attributes; for (const y in p) e.update(p[y], i.ARRAY_BUFFER); const m = d.morphAttributes; for (const y in m) { const _ = m[y]; for (let x = 0, g = _.length; x < g; x++)e.update(_[x], i.ARRAY_BUFFER) } } function c(d) { const p = [], m = d.index, y = d.attributes.position; let _ = 0; if (m !== null) { const A = m.array; _ = m.version; for (let M = 0, S = A.length; M < S; M += 3) { const C = A[M + 0], T = A[M + 1], R = A[M + 2]; p.push(C, T, T, R, R, C) } } else if (y !== void 0) { const A = y.array; _ = y.version; for (let M = 0, S = A.length / 3 - 1; M < S; M += 3) { const C = M + 0, T = M + 1, R = M + 2; p.push(C, T, T, R, R, C) } } else return; const x = new (MF(p) ? SE : wE)(p, 1); x.version = _; const g = s.get(d); g && e.remove(g), s.set(d, x) } function f(d) { const p = s.get(d); if (p) { const m = d.index; m !== null && p.version < m.version && c(d) } else c(d); return s.get(d) } return { get: a, update: l, getWireframeAttribute: f } } function jJ(i, e, t, n) { const r = n.isWebGL2; let s; function o(p) { s = p } let a, l; function c(p) { a = p.type, l = p.bytesPerElement } function f(p, m) { i.drawElements(s, m, a, p * l), t.update(m, s, 1) } function d(p, m, y) { if (y === 0) return; let _, x; if (r) _ = i, x = "drawElementsInstanced"; else if (_ = e.get("ANGLE_instanced_arrays"), x = "drawElementsInstancedANGLE", _ === null) { console.error("THREE.WebGLIndexedBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays."); return } _[x](s, m, a, p * l, y), t.update(m, s, y) } this.setMode = o, this.setIndex = c, this.render = f, this.renderInstances = d } function KJ(i) { const e = { geometries: 0, textures: 0 }, t = { frame: 0, calls: 0, triangles: 0, points: 0, lines: 0 }; function n(s, o, a) { switch (t.calls++, o) { case i.TRIANGLES: t.triangles += a * (s / 3); break; case i.LINES: t.lines += a * (s / 2); break; case i.LINE_STRIP: t.lines += a * (s - 1); break; case i.LINE_LOOP: t.lines += a * s; break; case i.POINTS: t.points += a * s; break; default: console.error("THREE.WebGLInfo: Unknown draw mode:", o); break } } function r() { t.calls = 0, t.triangles = 0, t.points = 0, t.lines = 0 } return { memory: e, render: t, programs: null, autoReset: !0, reset: r, update: n } } function qJ(i, e) { return i[0] - e[0] } function QJ(i, e) { return Math.abs(e[1]) - Math.abs(i[1]) } function ZJ(i, e, t) { const n = {}, r = new Float32Array(8), s = new WeakMap, o = new on, a = []; for (let c = 0; c < 8; c++)a[c] = [c, 0]; function l(c, f, d) { const p = c.morphTargetInfluences; if (e.isWebGL2 === !0) { const y = f.morphAttributes.position || f.morphAttributes.normal || f.morphAttributes.color, _ = y !== void 0 ? y.length : 0; let x = s.get(f); if (x === void 0 || x.count !== _) { let q = function () { J.dispose(), s.delete(f), f.removeEventListener("dispose", q) }; var m = q; x !== void 0 && x.texture.dispose(); const M = f.morphAttributes.position !== void 0, S = f.morphAttributes.normal !== void 0, C = f.morphAttributes.color !== void 0, T = f.morphAttributes.position || [], R = f.morphAttributes.normal || [], B = f.morphAttributes.color || []; let b = 0; M === !0 && (b = 1), S === !0 && (b = 2), C === !0 && (b = 3); let I = f.attributes.position.count * b, N = 1; I > e.maxTextureSize && (N = Math.ceil(I / e.maxTextureSize), I = e.maxTextureSize); const V = new Float32Array(I * N * 4 * _), J = new Uv(V, I, N, _); J.type = Do, J.needsUpdate = !0; const j = b * 4; for (let ne = 0; ne < _; ne++) { const Q = T[ne], F = R[ne], Y = B[ne], L = I * N * 4 * ne; for (let G = 0; G < Q.count; G++) { const K = G * j; M === !0 && (o.fromBufferAttribute(Q, G), V[L + K + 0] = o.x, V[L + K + 1] = o.y, V[L + K + 2] = o.z, V[L + K + 3] = 0), S === !0 && (o.fromBufferAttribute(F, G), V[L + K + 4] = o.x, V[L + K + 5] = o.y, V[L + K + 6] = o.z, V[L + K + 7] = 0), C === !0 && (o.fromBufferAttribute(Y, G), V[L + K + 8] = o.x, V[L + K + 9] = o.y, V[L + K + 10] = o.z, V[L + K + 11] = Y.itemSize === 4 ? o.w : 1) } } x = { count: _, texture: J, size: new _e(I, N) }, s.set(f, x), f.addEventListener("dispose", q) } let g = 0; for (let M = 0; M < p.length; M++)g += p[M]; const A = f.morphTargetsRelative ? 1 : 1 - g; d.getUniforms().setValue(i, "morphTargetBaseInfluence", A), d.getUniforms().setValue(i, "morphTargetInfluences", p), d.getUniforms().setValue(i, "morphTargetsTexture", x.texture, t), d.getUniforms().setValue(i, "morphTargetsTextureSize", x.size) } else { const y = p === void 0 ? 0 : p.length; let _ = n[f.id]; if (_ === void 0 || _.length !== y) { _ = []; for (let S = 0; S < y; S++)_[S] = [S, 0]; n[f.id] = _ } for (let S = 0; S < y; S++) { const C = _[S]; C[0] = S, C[1] = p[S] } _.sort(QJ); for (let S = 0; S < 8; S++)S < y && _[S][1] ? (a[S][0] = _[S][0], a[S][1] = _[S][1]) : (a[S][0] = Number.MAX_SAFE_INTEGER, a[S][1] = 0); a.sort(qJ); const x = f.morphAttributes.position, g = f.morphAttributes.normal; let A = 0; for (let S = 0; S < 8; S++) { const C = a[S], T = C[0], R = C[1]; T !== Number.MAX_SAFE_INTEGER && R ? (x && f.getAttribute("morphTarget" + S) !== x[T] && f.setAttribute("morphTarget" + S, x[T]), g && f.getAttribute("morphNormal" + S) !== g[T] && f.setAttribute("morphNormal" + S, g[T]), r[S] = R, A += R) : (x && f.hasAttribute("morphTarget" + S) === !0 && f.deleteAttribute("morphTarget" + S), g && f.hasAttribute("morphNormal" + S) === !0 && f.deleteAttribute("morphNormal" + S), r[S] = 0) } const M = f.morphTargetsRelative ? 1 : 1 - A; d.getUniforms().setValue(i, "morphTargetBaseInfluence", M), d.getUniforms().setValue(i, "morphTargetInfluences", r) } } return { update: l } } function $J(i, e, t, n) { let r = new WeakMap; function s(l) { const c = n.render.frame, f = l.geometry, d = e.get(l, f); if (r.get(d) !== c && (e.update(d), r.set(d, c)), l.isInstancedMesh && (l.hasEventListener("dispose", a) === !1 && l.addEventListener("dispose", a), r.get(l) !== c && (t.update(l.instanceMatrix, i.ARRAY_BUFFER), l.instanceColor !== null && t.update(l.instanceColor, i.ARRAY_BUFFER), r.set(l, c))), l.isSkinnedMesh) { const p = l.skeleton; r.get(p) !== c && (p.update(), r.set(p, c)) } return d } function o() { r = new WeakMap } function a(l) { const c = l.target; c.removeEventListener("dispose", a), t.remove(c.instanceMatrix), c.instanceColor !== null && t.remove(c.instanceColor) } return { update: s, dispose: o } } const PF = new wn, IF = new Uv, BF = new ME, LF = new lm, _P = [], xP = [], AP = new Float32Array(16), MP = new Float32Array(9), wP = new Float32Array(4); function Ih(i, e, t) { const n = i[0]; if (n <= 0 || n > 0) return i; const r = e * t; let s = _P[r]; if (s === void 0 && (s = new Float32Array(r), _P[r] = s), e !== 0) { n.toArray(s, 0); for (let o = 1, a = 0; o !== e; ++o)a += t, i[o].toArray(s, a) } return s } function mi(i, e) { if (i.length !== e.length) return !1; for (let t = 0, n = i.length; t < n; t++)if (i[t] !== e[t]) return !1; return !0 } function gi(i, e) { for (let t = 0, n = e.length; t < n; t++)i[t] = e[t] } function Hv(i, e) { let t = xP[e]; t === void 0 && (t = new Int32Array(e), xP[e] = t); for (let n = 0; n !== e; ++n)t[n] = i.allocateTextureUnit(); return t } function eY(i, e) { const t = this.cache; t[0] !== e && (i.uniform1f(this.addr, e), t[0] = e) } function tY(i, e) { const t = this.cache; if (e.x !== void 0) (t[0] !== e.x || t[1] !== e.y) && (i.uniform2f(this.addr, e.x, e.y), t[0] = e.x, t[1] = e.y); else { if (mi(t, e)) return; i.uniform2fv(this.addr, e), gi(t, e) } } function nY(i, e) { const t = this.cache; if (e.x !== void 0) (t[0] !== e.x || t[1] !== e.y || t[2] !== e.z) && (i.uniform3f(this.addr, e.x, e.y, e.z), t[0] = e.x, t[1] = e.y, t[2] = e.z); else if (e.r !== void 0) (t[0] !== e.r || t[1] !== e.g || t[2] !== e.b) && (i.uniform3f(this.addr, e.r, e.g, e.b), t[0] = e.r, t[1] = e.g, t[2] = e.b); else { if (mi(t, e)) return; i.uniform3fv(this.addr, e), gi(t, e) } } function iY(i, e) { const t = this.cache; if (e.x !== void 0) (t[0] !== e.x || t[1] !== e.y || t[2] !== e.z || t[3] !== e.w) && (i.uniform4f(this.addr, e.x, e.y, e.z, e.w), t[0] = e.x, t[1] = e.y, t[2] = e.z, t[3] = e.w); else { if (mi(t, e)) return; i.uniform4fv(this.addr, e), gi(t, e) } } function rY(i, e) { const t = this.cache, n = e.elements; if (n === void 0) { if (mi(t, e)) return; i.uniformMatrix2fv(this.addr, !1, e), gi(t, e) } else { if (mi(t, n)) return; wP.set(n), i.uniformMatrix2fv(this.addr, !1, wP), gi(t, n) } } function sY(i, e) { const t = this.cache, n = e.elements; if (n === void 0) { if (mi(t, e)) return; i.uniformMatrix3fv(this.addr, !1, e), gi(t, e) } else { if (mi(t, n)) return; MP.set(n), i.uniformMatrix3fv(this.addr, !1, MP), gi(t, n) } } function oY(i, e) { const t = this.cache, n = e.elements; if (n === void 0) { if (mi(t, e)) return; i.uniformMatrix4fv(this.addr, !1, e), gi(t, e) } else { if (mi(t, n)) return; AP.set(n), i.uniformMatrix4fv(this.addr, !1, AP), gi(t, n) } } function aY(i, e) { const t = this.cache; t[0] !== e && (i.uniform1i(this.addr, e), t[0] = e) } function lY(i, e) { const t = this.cache; if (e.x !== void 0) (t[0] !== e.x || t[1] !== e.y) && (i.uniform2i(this.addr, e.x, e.y), t[0] = e.x, t[1] = e.y); else { if (mi(t, e)) return; i.uniform2iv(this.addr, e), gi(t, e) } } function cY(i, e) { const t = this.cache; if (e.x !== void 0) (t[0] !== e.x || t[1] !== e.y || t[2] !== e.z) && (i.uniform3i(this.addr, e.x, e.y, e.z), t[0] = e.x, t[1] = e.y, t[2] = e.z); else { if (mi(t, e)) return; i.uniform3iv(this.addr, e), gi(t, e) } } function uY(i, e) { const t = this.cache; if (e.x !== void 0) (t[0] !== e.x || t[1] !== e.y || t[2] !== e.z || t[3] !== e.w) && (i.uniform4i(this.addr, e.x, e.y, e.z, e.w), t[0] = e.x, t[1] = e.y, t[2] = e.z, t[3] = e.w); else { if (mi(t, e)) return; i.uniform4iv(this.addr, e), gi(t, e) } } function fY(i, e) { const t = this.cache; t[0] !== e && (i.uniform1ui(this.addr, e), t[0] = e) } function hY(i, e) { const t = this.cache; if (e.x !== void 0) (t[0] !== e.x || t[1] !== e.y) && (i.uniform2ui(this.addr, e.x, e.y), t[0] = e.x, t[1] = e.y); else { if (mi(t, e)) return; i.uniform2uiv(this.addr, e), gi(t, e) } } function dY(i, e) { const t = this.cache; if (e.x !== void 0) (t[0] !== e.x || t[1] !== e.y || t[2] !== e.z) && (i.uniform3ui(this.addr, e.x, e.y, e.z), t[0] = e.x, t[1] = e.y, t[2] = e.z); else { if (mi(t, e)) return; i.uniform3uiv(this.addr, e), gi(t, e) } } function pY(i, e) { const t = this.cache; if (e.x !== void 0) (t[0] !== e.x || t[1] !== e.y || t[2] !== e.z || t[3] !== e.w) && (i.uniform4ui(this.addr, e.x, e.y, e.z, e.w), t[0] = e.x, t[1] = e.y, t[2] = e.z, t[3] = e.w); else { if (mi(t, e)) return; i.uniform4uiv(this.addr, e), gi(t, e) } } function mY(i, e, t) { const n = this.cache, r = t.allocateTextureUnit(); n[0] !== r && (i.uniform1i(this.addr, r), n[0] = r), t.setTexture2D(e || PF, r) } function gY(i, e, t) { const n = this.cache, r = t.allocateTextureUnit(); n[0] !== r && (i.uniform1i(this.addr, r), n[0] = r), t.setTexture3D(e || BF, r) } function yY(i, e, t) { const n = this.cache, r = t.allocateTextureUnit(); n[0] !== r && (i.uniform1i(this.addr, r), n[0] = r), t.setTextureCube(e || LF, r) } function vY(i, e, t) { const n = this.cache, r = t.allocateTextureUnit(); n[0] !== r && (i.uniform1i(this.addr, r), n[0] = r), t.setTexture2DArray(e || IF, r) } function _Y(i) { switch (i) { case 5126: return eY; case 35664: return tY; case 35665: return nY; case 35666: return iY; case 35674: return rY; case 35675: return sY; case 35676: return oY; case 5124: case 35670: return aY; case 35667: case 35671: return lY; case 35668: case 35672: return cY; case 35669: case 35673: return uY; case 5125: return fY; case 36294: return hY; case 36295: return dY; case 36296: return pY; case 35678: case 36198: case 36298: case 36306: case 35682: return mY; case 35679: case 36299: case 36307: return gY; case 35680: case 36300: case 36308: case 36293: return yY; case 36289: case 36303: case 36311: case 36292: return vY } } function xY(i, e) { i.uniform1fv(this.addr, e) } function AY(i, e) { const t = Ih(e, this.size, 2); i.uniform2fv(this.addr, t) } function MY(i, e) { const t = Ih(e, this.size, 3); i.uniform3fv(this.addr, t) } function wY(i, e) { const t = Ih(e, this.size, 4); i.uniform4fv(this.addr, t) } function SY(i, e) { const t = Ih(e, this.size, 4); i.uniformMatrix2fv(this.addr, !1, t) } function EY(i, e) { const t = Ih(e, this.size, 9); i.uniformMatrix3fv(this.addr, !1, t) } function CY(i, e) { const t = Ih(e, this.size, 16); i.uniformMatrix4fv(this.addr, !1, t) } function TY(i, e) { i.uniform1iv(this.addr, e) } function bY(i, e) { i.uniform2iv(this.addr, e) } function RY(i, e) { i.uniform3iv(this.addr, e) } function PY(i, e) { i.uniform4iv(this.addr, e) } function IY(i, e) { i.uniform1uiv(this.addr, e) } function BY(i, e) { i.uniform2uiv(this.addr, e) } function LY(i, e) { i.uniform3uiv(this.addr, e) } function DY(i, e) { i.uniform4uiv(this.addr, e) } function OY(i, e, t) { const n = this.cache, r = e.length, s = Hv(t, r); mi(n, s) || (i.uniform1iv(this.addr, s), gi(n, s)); for (let o = 0; o !== r; ++o)t.setTexture2D(e[o] || PF, s[o]) } function FY(i, e, t) { const n = this.cache, r = e.length, s = Hv(t, r); mi(n, s) || (i.uniform1iv(this.addr, s), gi(n, s)); for (let o = 0; o !== r; ++o)t.setTexture3D(e[o] || BF, s[o]) } function kY(i, e, t) { const n = this.cache, r = e.length, s = Hv(t, r); mi(n, s) || (i.uniform1iv(this.addr, s), gi(n, s)); for (let o = 0; o !== r; ++o)t.setTextureCube(e[o] || LF, s[o]) } function NY(i, e, t) { const n = this.cache, r = e.length, s = Hv(t, r); mi(n, s) || (i.uniform1iv(this.addr, s), gi(n, s)); for (let o = 0; o !== r; ++o)t.setTexture2DArray(e[o] || IF, s[o]) } function UY(i) { switch (i) { case 5126: return xY; case 35664: return AY; case 35665: return MY; case 35666: return wY; case 35674: return SY; case 35675: return EY; case 35676: return CY; case 5124: case 35670: return TY; case 35667: case 35671: return bY; case 35668: case 35672: return RY; case 35669: case 35673: return PY; case 5125: return IY; case 36294: return BY; case 36295: return LY; case 36296: return DY; case 35678: case 36198: case 36298: case 36306: case 35682: return OY; case 35679: case 36299: case 36307: return FY; case 35680: case 36300: case 36308: case 36293: return kY; case 36289: case 36303: case 36311: case 36292: return NY } } class zY { constructor(e, t, n) { this.id = e, this.addr = n, this.cache = [], this.setValue = _Y(t.type) } } class HY { constructor(e, t, n) { this.id = e, this.addr = n, this.cache = [], this.size = t.size, this.setValue = UY(t.type) } } class GY { constructor(e) { this.id = e, this.seq = [], this.map = {} } setValue(e, t, n) { const r = this.seq; for (let s = 0, o = r.length; s !== o; ++s) { const a = r[s]; a.setValue(e, t[a.id], n) } } } const WA = /(\w+)(\])?(\[|\.)?/g; function SP(i, e) { i.seq.push(e), i.map[e.id] = e } function VY(i, e, t) { const n = i.name, r = n.length; for (WA.lastIndex = 0; ;) { const s = WA.exec(n), o = WA.lastIndex; let a = s[1]; const l = s[2] === "]", c = s[3]; if (l && (a = a | 0), c === void 0 || c === "[" && o + 2 === r) { SP(t, c === void 0 ? new zY(a, i, e) : new HY(a, i, e)); break } else { let d = t.map[a]; d === void 0 && (d = new GY(a), SP(t, d)), t = d } } } class fy { constructor(e, t) { this.seq = [], this.map = {}; const n = e.getProgramParameter(t, e.ACTIVE_UNIFORMS); for (let r = 0; r < n; ++r) { const s = e.getActiveUniform(t, r), o = e.getUniformLocation(t, s.name); VY(s, o, this) } } setValue(e, t, n, r) { const s = this.map[t]; s !== void 0 && s.setValue(e, n, r) } setOptional(e, t, n) { const r = t[n]; r !== void 0 && this.setValue(e, n, r) } static upload(e, t, n, r) { for (let s = 0, o = t.length; s !== o; ++s) { const a = t[s], l = n[a.id]; l.needsUpdate !== !1 && a.setValue(e, l.value, r) } } static seqWithValue(e, t) { const n = []; for (let r = 0, s = e.length; r !== s; ++r) { const o = e[r]; o.id in t && n.push(o) } return n } } function EP(i, e, t) { const n = i.createShader(e); return i.shaderSource(n, t), i.compileShader(n), n } let WY = 0; function XY(i, e) {
	const t = i.split(`
`), n = [], r = Math.max(e - 6, 0), s = Math.min(e + 6, t.length); for (let o = r; o < s; o++) { const a = o + 1; n.push(`${a === e ? ">" : " "} ${a}: ${t[o]}`) } return n.join(`
`)
} function JY(i) { switch (i) { case po: return ["Linear", "( value )"]; case bt: return ["sRGB", "( value )"]; default: return console.warn("THREE.WebGLProgram: Unsupported color space:", i), ["Linear", "( value )"] } } function CP(i, e, t) {
	const n = i.getShaderParameter(e, i.COMPILE_STATUS), r = i.getShaderInfoLog(e).trim(); if (n && r === "") return ""; const s = /ERROR: 0:(\d+)/.exec(r); if (s) {
		const o = parseInt(s[1]); return t.toUpperCase() + `

`+ r + `

`+ XY(i.getShaderSource(e), o)
	} else return r
} function YY(i, e) { const t = JY(e); return "vec4 " + i + "( vec4 value ) { return LinearTo" + t[0] + t[1] + "; }" } function jY(i, e) { let t; switch (e) { case XO: t = "Linear"; break; case JO: t = "Reinhard"; break; case YO: t = "OptimizedCineon"; break; case cE: t = "ACESFilmic"; break; case jO: t = "Custom"; break; default: console.warn("THREE.WebGLProgram: Unsupported toneMapping:", e), t = "Linear" }return "vec3 " + i + "( vec3 color ) { return " + t + "ToneMapping( color ); }" } function KY(i) {
	return [i.extensionDerivatives || i.envMapCubeUVHeight || i.bumpMap || i.normalMapTangentSpace || i.clearcoatNormalMap || i.flatShading || i.shaderID === "physical" ? "#extension GL_OES_standard_derivatives : enable" : "", (i.extensionFragDepth || i.logarithmicDepthBuffer) && i.rendererExtensionFragDepth ? "#extension GL_EXT_frag_depth : enable" : "", i.extensionDrawBuffers && i.rendererExtensionDrawBuffers ? "#extension GL_EXT_draw_buffers : require" : "", (i.extensionShaderTextureLOD || i.envMap || i.transmission) && i.rendererExtensionShaderTextureLod ? "#extension GL_EXT_shader_texture_lod : enable" : ""].filter(Dd).join(`
`)
} function qY(i) {
	const e = []; for (const t in i) { const n = i[t]; n !== !1 && e.push("#define " + t + " " + n) } return e.join(`
`)
} function QY(i, e) { const t = {}, n = i.getProgramParameter(e, i.ACTIVE_ATTRIBUTES); for (let r = 0; r < n; r++) { const s = i.getActiveAttrib(e, r), o = s.name; let a = 1; s.type === i.FLOAT_MAT2 && (a = 2), s.type === i.FLOAT_MAT3 && (a = 3), s.type === i.FLOAT_MAT4 && (a = 4), t[o] = { type: s.type, location: i.getAttribLocation(e, o), locationSize: a } } return t } function Dd(i) { return i !== "" } function TP(i, e) { const t = e.numSpotLightShadows + e.numSpotLightMaps - e.numSpotLightShadowsWithMaps; return i.replace(/NUM_DIR_LIGHTS/g, e.numDirLights).replace(/NUM_SPOT_LIGHTS/g, e.numSpotLights).replace(/NUM_SPOT_LIGHT_MAPS/g, e.numSpotLightMaps).replace(/NUM_SPOT_LIGHT_COORDS/g, t).replace(/NUM_RECT_AREA_LIGHTS/g, e.numRectAreaLights).replace(/NUM_POINT_LIGHTS/g, e.numPointLights).replace(/NUM_HEMI_LIGHTS/g, e.numHemiLights).replace(/NUM_DIR_LIGHT_SHADOWS/g, e.numDirLightShadows).replace(/NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS/g, e.numSpotLightShadowsWithMaps).replace(/NUM_SPOT_LIGHT_SHADOWS/g, e.numSpotLightShadows).replace(/NUM_POINT_LIGHT_SHADOWS/g, e.numPointLightShadows) } function bP(i, e) { return i.replace(/NUM_CLIPPING_PLANES/g, e.numClippingPlanes).replace(/UNION_CLIPPING_PLANES/g, e.numClippingPlanes - e.numClipIntersection) } const ZY = /^[ \t]*#include +<([\w\d./]+)>/gm; function xS(i) { return i.replace(ZY, ej) } const $Y = new Map([["encodings_fragment", "colorspace_fragment"], ["encodings_pars_fragment", "colorspace_pars_fragment"], ["output_fragment", "opaque_fragment"]]); function ej(i, e) { let t = Pt[e]; if (t === void 0) { const n = $Y.get(e); if (n !== void 0) t = Pt[n], console.warn('THREE.WebGLRenderer: Shader chunk "%s" has been deprecated. Use "%s" instead.', e, n); else throw new Error("Can not resolve #include <" + e + ">") } return xS(t) } const tj = /#pragma unroll_loop_start\s+for\s*\(\s*int\s+i\s*=\s*(\d+)\s*;\s*i\s*<\s*(\d+)\s*;\s*i\s*\+\+\s*\)\s*{([\s\S]+?)}\s+#pragma unroll_loop_end/g; function RP(i) { return i.replace(tj, nj) } function nj(i, e, t, n) { let r = ""; for (let s = parseInt(e); s < parseInt(t); s++)r += n.replace(/\[\s*i\s*\]/g, "[ " + s + " ]").replace(/UNROLLED_LOOP_INDEX/g, s); return r } function PP(i) {
	let e = "precision " + i.precision + ` float;
precision `+ i.precision + " int;"; return i.precision === "highp" ? e += `
#define HIGH_PRECISION`: i.precision === "mediump" ? e += `
#define MEDIUM_PRECISION`: i.precision === "lowp" && (e += `
#define LOW_PRECISION`), e
} function ij(i) { let e = "SHADOWMAP_TYPE_BASIC"; return i.shadowMapType === Dv ? e = "SHADOWMAP_TYPE_PCF" : i.shadowMapType === rp ? e = "SHADOWMAP_TYPE_PCF_SOFT" : i.shadowMapType === $s && (e = "SHADOWMAP_TYPE_VSM"), e } function rj(i) { let e = "ENVMAP_TYPE_CUBE"; if (i.envMap) switch (i.envMapMode) { case Da: case Nl: e = "ENVMAP_TYPE_CUBE"; break; case Rh: e = "ENVMAP_TYPE_CUBE_UV"; break }return e } function sj(i) { let e = "ENVMAP_MODE_REFLECTION"; if (i.envMap) switch (i.envMapMode) { case Nl: e = "ENVMAP_MODE_REFRACTION"; break }return e } function oj(i) { let e = "ENVMAP_BLENDING_NONE"; if (i.envMap) switch (i.combine) { case sm: e = "ENVMAP_BLENDING_MULTIPLY"; break; case VO: e = "ENVMAP_BLENDING_MIX"; break; case WO: e = "ENVMAP_BLENDING_ADD"; break }return e } function aj(i) { const e = i.envMapCubeUVHeight; if (e === null) return null; const t = Math.log2(e) - 2, n = 1 / e; return { texelWidth: 1 / (3 * Math.max(Math.pow(2, t), 7 * 16)), texelHeight: n, maxMip: t } } function lj(i, e, t, n) {
	const r = i.getContext(), s = t.defines; let o = t.vertexShader, a = t.fragmentShader; const l = ij(t), c = rj(t), f = sj(t), d = oj(t), p = aj(t), m = t.isWebGL2 ? "" : KY(t), y = qY(s), _ = r.createProgram(); let x, g, A = t.glslVersion ? "#version " + t.glslVersion + `
`: ""; t.isRawShaderMaterial ? (x = ["#define SHADER_TYPE " + t.shaderType, "#define SHADER_NAME " + t.shaderName, y].filter(Dd).join(`
`), x.length > 0 && (x += `
`), g = [m, "#define SHADER_TYPE " + t.shaderType, "#define SHADER_NAME " + t.shaderName, y].filter(Dd).join(`
`), g.length > 0 && (g += `
`)) : (x = [PP(t), "#define SHADER_TYPE " + t.shaderType, "#define SHADER_NAME " + t.shaderName, y, t.instancing ? "#define USE_INSTANCING" : "", t.instancingColor ? "#define USE_INSTANCING_COLOR" : "", t.useFog && t.fog ? "#define USE_FOG" : "", t.useFog && t.fogExp2 ? "#define FOG_EXP2" : "", t.map ? "#define USE_MAP" : "", t.envMap ? "#define USE_ENVMAP" : "", t.envMap ? "#define " + f : "", t.lightMap ? "#define USE_LIGHTMAP" : "", t.aoMap ? "#define USE_AOMAP" : "", t.bumpMap ? "#define USE_BUMPMAP" : "", t.normalMap ? "#define USE_NORMALMAP" : "", t.normalMapObjectSpace ? "#define USE_NORMALMAP_OBJECTSPACE" : "", t.normalMapTangentSpace ? "#define USE_NORMALMAP_TANGENTSPACE" : "", t.displacementMap ? "#define USE_DISPLACEMENTMAP" : "", t.emissiveMap ? "#define USE_EMISSIVEMAP" : "", t.anisotropyMap ? "#define USE_ANISOTROPYMAP" : "", t.clearcoatMap ? "#define USE_CLEARCOATMAP" : "", t.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "", t.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "", t.iridescenceMap ? "#define USE_IRIDESCENCEMAP" : "", t.iridescenceThicknessMap ? "#define USE_IRIDESCENCE_THICKNESSMAP" : "", t.specularMap ? "#define USE_SPECULARMAP" : "", t.specularColorMap ? "#define USE_SPECULAR_COLORMAP" : "", t.specularIntensityMap ? "#define USE_SPECULAR_INTENSITYMAP" : "", t.roughnessMap ? "#define USE_ROUGHNESSMAP" : "", t.metalnessMap ? "#define USE_METALNESSMAP" : "", t.alphaMap ? "#define USE_ALPHAMAP" : "", t.alphaHash ? "#define USE_ALPHAHASH" : "", t.transmission ? "#define USE_TRANSMISSION" : "", t.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "", t.thicknessMap ? "#define USE_THICKNESSMAP" : "", t.sheenColorMap ? "#define USE_SHEEN_COLORMAP" : "", t.sheenRoughnessMap ? "#define USE_SHEEN_ROUGHNESSMAP" : "", t.mapUv ? "#define MAP_UV " + t.mapUv : "", t.alphaMapUv ? "#define ALPHAMAP_UV " + t.alphaMapUv : "", t.lightMapUv ? "#define LIGHTMAP_UV " + t.lightMapUv : "", t.aoMapUv ? "#define AOMAP_UV " + t.aoMapUv : "", t.emissiveMapUv ? "#define EMISSIVEMAP_UV " + t.emissiveMapUv : "", t.bumpMapUv ? "#define BUMPMAP_UV " + t.bumpMapUv : "", t.normalMapUv ? "#define NORMALMAP_UV " + t.normalMapUv : "", t.displacementMapUv ? "#define DISPLACEMENTMAP_UV " + t.displacementMapUv : "", t.metalnessMapUv ? "#define METALNESSMAP_UV " + t.metalnessMapUv : "", t.roughnessMapUv ? "#define ROUGHNESSMAP_UV " + t.roughnessMapUv : "", t.anisotropyMapUv ? "#define ANISOTROPYMAP_UV " + t.anisotropyMapUv : "", t.clearcoatMapUv ? "#define CLEARCOATMAP_UV " + t.clearcoatMapUv : "", t.clearcoatNormalMapUv ? "#define CLEARCOAT_NORMALMAP_UV " + t.clearcoatNormalMapUv : "", t.clearcoatRoughnessMapUv ? "#define CLEARCOAT_ROUGHNESSMAP_UV " + t.clearcoatRoughnessMapUv : "", t.iridescenceMapUv ? "#define IRIDESCENCEMAP_UV " + t.iridescenceMapUv : "", t.iridescenceThicknessMapUv ? "#define IRIDESCENCE_THICKNESSMAP_UV " + t.iridescenceThicknessMapUv : "", t.sheenColorMapUv ? "#define SHEEN_COLORMAP_UV " + t.sheenColorMapUv : "", t.sheenRoughnessMapUv ? "#define SHEEN_ROUGHNESSMAP_UV " + t.sheenRoughnessMapUv : "", t.specularMapUv ? "#define SPECULARMAP_UV " + t.specularMapUv : "", t.specularColorMapUv ? "#define SPECULAR_COLORMAP_UV " + t.specularColorMapUv : "", t.specularIntensityMapUv ? "#define SPECULAR_INTENSITYMAP_UV " + t.specularIntensityMapUv : "", t.transmissionMapUv ? "#define TRANSMISSIONMAP_UV " + t.transmissionMapUv : "", t.thicknessMapUv ? "#define THICKNESSMAP_UV " + t.thicknessMapUv : "", t.vertexTangents && t.flatShading === !1 ? "#define USE_TANGENT" : "", t.vertexColors ? "#define USE_COLOR" : "", t.vertexAlphas ? "#define USE_COLOR_ALPHA" : "", t.vertexUv1s ? "#define USE_UV1" : "", t.vertexUv2s ? "#define USE_UV2" : "", t.vertexUv3s ? "#define USE_UV3" : "", t.pointsUvs ? "#define USE_POINTS_UV" : "", t.flatShading ? "#define FLAT_SHADED" : "", t.skinning ? "#define USE_SKINNING" : "", t.morphTargets ? "#define USE_MORPHTARGETS" : "", t.morphNormals && t.flatShading === !1 ? "#define USE_MORPHNORMALS" : "", t.morphColors && t.isWebGL2 ? "#define USE_MORPHCOLORS" : "", t.morphTargetsCount > 0 && t.isWebGL2 ? "#define MORPHTARGETS_TEXTURE" : "", t.morphTargetsCount > 0 && t.isWebGL2 ? "#define MORPHTARGETS_TEXTURE_STRIDE " + t.morphTextureStride : "", t.morphTargetsCount > 0 && t.isWebGL2 ? "#define MORPHTARGETS_COUNT " + t.morphTargetsCount : "", t.doubleSided ? "#define DOUBLE_SIDED" : "", t.flipSided ? "#define FLIP_SIDED" : "", t.shadowMapEnabled ? "#define USE_SHADOWMAP" : "", t.shadowMapEnabled ? "#define " + l : "", t.sizeAttenuation ? "#define USE_SIZEATTENUATION" : "", t.useLegacyLights ? "#define LEGACY_LIGHTS" : "", t.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "", t.logarithmicDepthBuffer && t.rendererExtensionFragDepth ? "#define USE_LOGDEPTHBUF_EXT" : "", "uniform mat4 modelMatrix;", "uniform mat4 modelViewMatrix;", "uniform mat4 projectionMatrix;", "uniform mat4 viewMatrix;", "uniform mat3 normalMatrix;", "uniform vec3 cameraPosition;", "uniform bool isOrthographic;", "#ifdef USE_INSTANCING", "	attribute mat4 instanceMatrix;", "#endif", "#ifdef USE_INSTANCING_COLOR", "	attribute vec3 instanceColor;", "#endif", "attribute vec3 position;", "attribute vec3 normal;", "attribute vec2 uv;", "#ifdef USE_UV1", "	attribute vec2 uv1;", "#endif", "#ifdef USE_UV2", "	attribute vec2 uv2;", "#endif", "#ifdef USE_UV3", "	attribute vec2 uv3;", "#endif", "#ifdef USE_TANGENT", "	attribute vec4 tangent;", "#endif", "#if defined( USE_COLOR_ALPHA )", "	attribute vec4 color;", "#elif defined( USE_COLOR )", "	attribute vec3 color;", "#endif", "#if ( defined( USE_MORPHTARGETS ) && ! defined( MORPHTARGETS_TEXTURE ) )", "	attribute vec3 morphTarget0;", "	attribute vec3 morphTarget1;", "	attribute vec3 morphTarget2;", "	attribute vec3 morphTarget3;", "	#ifdef USE_MORPHNORMALS", "		attribute vec3 morphNormal0;", "		attribute vec3 morphNormal1;", "		attribute vec3 morphNormal2;", "		attribute vec3 morphNormal3;", "	#else", "		attribute vec3 morphTarget4;", "		attribute vec3 morphTarget5;", "		attribute vec3 morphTarget6;", "		attribute vec3 morphTarget7;", "	#endif", "#endif", "#ifdef USE_SKINNING", "	attribute vec4 skinIndex;", "	attribute vec4 skinWeight;", "#endif", `
`].filter(Dd).join(`
`), g = [m, PP(t), "#define SHADER_TYPE " + t.shaderType, "#define SHADER_NAME " + t.shaderName, y, t.useFog && t.fog ? "#define USE_FOG" : "", t.useFog && t.fogExp2 ? "#define FOG_EXP2" : "", t.map ? "#define USE_MAP" : "", t.matcap ? "#define USE_MATCAP" : "", t.envMap ? "#define USE_ENVMAP" : "", t.envMap ? "#define " + c : "", t.envMap ? "#define " + f : "", t.envMap ? "#define " + d : "", p ? "#define CUBEUV_TEXEL_WIDTH " + p.texelWidth : "", p ? "#define CUBEUV_TEXEL_HEIGHT " + p.texelHeight : "", p ? "#define CUBEUV_MAX_MIP " + p.maxMip + ".0" : "", t.lightMap ? "#define USE_LIGHTMAP" : "", t.aoMap ? "#define USE_AOMAP" : "", t.bumpMap ? "#define USE_BUMPMAP" : "", t.normalMap ? "#define USE_NORMALMAP" : "", t.normalMapObjectSpace ? "#define USE_NORMALMAP_OBJECTSPACE" : "", t.normalMapTangentSpace ? "#define USE_NORMALMAP_TANGENTSPACE" : "", t.emissiveMap ? "#define USE_EMISSIVEMAP" : "", t.anisotropy ? "#define USE_ANISOTROPY" : "", t.anisotropyMap ? "#define USE_ANISOTROPYMAP" : "", t.clearcoat ? "#define USE_CLEARCOAT" : "", t.clearcoatMap ? "#define USE_CLEARCOATMAP" : "", t.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "", t.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "", t.iridescence ? "#define USE_IRIDESCENCE" : "", t.iridescenceMap ? "#define USE_IRIDESCENCEMAP" : "", t.iridescenceThicknessMap ? "#define USE_IRIDESCENCE_THICKNESSMAP" : "", t.specularMap ? "#define USE_SPECULARMAP" : "", t.specularColorMap ? "#define USE_SPECULAR_COLORMAP" : "", t.specularIntensityMap ? "#define USE_SPECULAR_INTENSITYMAP" : "", t.roughnessMap ? "#define USE_ROUGHNESSMAP" : "", t.metalnessMap ? "#define USE_METALNESSMAP" : "", t.alphaMap ? "#define USE_ALPHAMAP" : "", t.alphaTest ? "#define USE_ALPHATEST" : "", t.alphaHash ? "#define USE_ALPHAHASH" : "", t.sheen ? "#define USE_SHEEN" : "", t.sheenColorMap ? "#define USE_SHEEN_COLORMAP" : "", t.sheenRoughnessMap ? "#define USE_SHEEN_ROUGHNESSMAP" : "", t.transmission ? "#define USE_TRANSMISSION" : "", t.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "", t.thicknessMap ? "#define USE_THICKNESSMAP" : "", t.vertexTangents && t.flatShading === !1 ? "#define USE_TANGENT" : "", t.vertexColors || t.instancingColor ? "#define USE_COLOR" : "", t.vertexAlphas ? "#define USE_COLOR_ALPHA" : "", t.vertexUv1s ? "#define USE_UV1" : "", t.vertexUv2s ? "#define USE_UV2" : "", t.vertexUv3s ? "#define USE_UV3" : "", t.pointsUvs ? "#define USE_POINTS_UV" : "", t.gradientMap ? "#define USE_GRADIENTMAP" : "", t.flatShading ? "#define FLAT_SHADED" : "", t.doubleSided ? "#define DOUBLE_SIDED" : "", t.flipSided ? "#define FLIP_SIDED" : "", t.shadowMapEnabled ? "#define USE_SHADOWMAP" : "", t.shadowMapEnabled ? "#define " + l : "", t.premultipliedAlpha ? "#define PREMULTIPLIED_ALPHA" : "", t.useLegacyLights ? "#define LEGACY_LIGHTS" : "", t.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "", t.logarithmicDepthBuffer && t.rendererExtensionFragDepth ? "#define USE_LOGDEPTHBUF_EXT" : "", "uniform mat4 viewMatrix;", "uniform vec3 cameraPosition;", "uniform bool isOrthographic;", t.toneMapping !== Ho ? "#define TONE_MAPPING" : "", t.toneMapping !== Ho ? Pt.tonemapping_pars_fragment : "", t.toneMapping !== Ho ? jY("toneMapping", t.toneMapping) : "", t.dithering ? "#define DITHERING" : "", t.opaque ? "#define OPAQUE" : "", Pt.colorspace_pars_fragment, YY("linearToOutputTexel", t.outputColorSpace), t.useDepthPacking ? "#define DEPTH_PACKING " + t.depthPacking : "", `
`].filter(Dd).join(`
`)), o = xS(o), o = TP(o, t), o = bP(o, t), a = xS(a), a = TP(a, t), a = bP(a, t), o = RP(o), a = RP(a), t.isWebGL2 && t.isRawShaderMaterial !== !0 && (A = `#version 300 es
`, x = ["precision mediump sampler2DArray;", "#define attribute in", "#define varying out", "#define texture2D texture"].join(`
`) + `
`+ x, g = ["#define varying in", t.glslVersion === yS ? "" : "layout(location = 0) out highp vec4 pc_fragColor;", t.glslVersion === yS ? "" : "#define gl_FragColor pc_fragColor", "#define gl_FragDepthEXT gl_FragDepth", "#define texture2D texture", "#define textureCube texture", "#define texture2DProj textureProj", "#define texture2DLodEXT textureLod", "#define texture2DProjLodEXT textureProjLod", "#define textureCubeLodEXT textureLod", "#define texture2DGradEXT textureGrad", "#define texture2DProjGradEXT textureProjGrad", "#define textureCubeGradEXT textureGrad"].join(`
`) + `
`+ g); const M = A + x + o, S = A + g + a, C = EP(r, r.VERTEX_SHADER, M), T = EP(r, r.FRAGMENT_SHADER, S); if (r.attachShader(_, C), r.attachShader(_, T), t.index0AttributeName !== void 0 ? r.bindAttribLocation(_, 0, t.index0AttributeName) : t.morphTargets === !0 && r.bindAttribLocation(_, 0, "position"), r.linkProgram(_), i.debug.checkShaderErrors) {
		const b = r.getProgramInfoLog(_).trim(), I = r.getShaderInfoLog(C).trim(), N = r.getShaderInfoLog(T).trim(); let V = !0, J = !0; if (r.getProgramParameter(_, r.LINK_STATUS) === !1) if (V = !1, typeof i.debug.onShaderError == "function") i.debug.onShaderError(r, _, C, T); else {
			const j = CP(r, C, "vertex"), q = CP(r, T, "fragment"); console.error("THREE.WebGLProgram: Shader Error " + r.getError() + " - VALIDATE_STATUS " + r.getProgramParameter(_, r.VALIDATE_STATUS) + `

Program Info Log: `+ b + `
`+ j + `
`+ q)
		} else b !== "" ? console.warn("THREE.WebGLProgram: Program Info Log:", b) : (I === "" || N === "") && (J = !1); J && (this.diagnostics = { runnable: V, programLog: b, vertexShader: { log: I, prefix: x }, fragmentShader: { log: N, prefix: g } })
	} r.deleteShader(C), r.deleteShader(T); let R; this.getUniforms = function () { return R === void 0 && (R = new fy(r, _)), R }; let B; return this.getAttributes = function () { return B === void 0 && (B = QY(r, _)), B }, this.destroy = function () { n.releaseStatesOfProgram(this), r.deleteProgram(_), this.program = void 0 }, this.type = t.shaderType, this.name = t.shaderName, this.id = WY++, this.cacheKey = e, this.usedTimes = 1, this.program = _, this.vertexShader = C, this.fragmentShader = T, this
} let cj = 0; class uj { constructor() { this.shaderCache = new Map, this.materialCache = new Map } update(e) { const t = e.vertexShader, n = e.fragmentShader, r = this._getShaderStage(t), s = this._getShaderStage(n), o = this._getShaderCacheForMaterial(e); return o.has(r) === !1 && (o.add(r), r.usedTimes++), o.has(s) === !1 && (o.add(s), s.usedTimes++), this } remove(e) { const t = this.materialCache.get(e); for (const n of t) n.usedTimes--, n.usedTimes === 0 && this.shaderCache.delete(n.code); return this.materialCache.delete(e), this } getVertexShaderID(e) { return this._getShaderStage(e.vertexShader).id } getFragmentShaderID(e) { return this._getShaderStage(e.fragmentShader).id } dispose() { this.shaderCache.clear(), this.materialCache.clear() } _getShaderCacheForMaterial(e) { const t = this.materialCache; let n = t.get(e); return n === void 0 && (n = new Set, t.set(e, n)), n } _getShaderStage(e) { const t = this.shaderCache; let n = t.get(e); return n === void 0 && (n = new fj(e), t.set(e, n)), n } } class fj { constructor(e) { this.id = cj++, this.code = e, this.usedTimes = 0 } } function hj(i, e, t, n, r, s, o) { const a = new jc, l = new uj, c = [], f = r.isWebGL2, d = r.logarithmicDepthBuffer, p = r.vertexTextures; let m = r.precision; const y = { MeshDepthMaterial: "depth", MeshDistanceMaterial: "distanceRGBA", MeshNormalMaterial: "normal", MeshBasicMaterial: "basic", MeshLambertMaterial: "lambert", MeshPhongMaterial: "phong", MeshToonMaterial: "toon", MeshStandardMaterial: "physical", MeshPhysicalMaterial: "physical", MeshMatcapMaterial: "matcap", LineBasicMaterial: "basic", LineDashedMaterial: "dashed", PointsMaterial: "points", ShadowMaterial: "shadow", SpriteMaterial: "sprite" }; function _(b) { return b === 0 ? "uv" : `uv${b}` } function x(b, I, N, V, J) { const j = V.fog, q = J.geometry, ne = b.isMeshStandardMaterial ? V.environment : null, Q = (b.isMeshStandardMaterial ? t : e).get(b.envMap || ne), F = Q && Q.mapping === Rh ? Q.image.height : null, Y = y[b.type]; b.precision !== null && (m = r.getMaxPrecision(b.precision), m !== b.precision && console.warn("THREE.WebGLProgram.getParameters:", b.precision, "not supported, using", m, "instead.")); const L = q.morphAttributes.position || q.morphAttributes.normal || q.morphAttributes.color, G = L !== void 0 ? L.length : 0; let K = 0; q.morphAttributes.position !== void 0 && (K = 1), q.morphAttributes.normal !== void 0 && (K = 2), q.morphAttributes.color !== void 0 && (K = 3); let ye, ge, xe, Be; if (Y) { const Ne = io[Y]; ye = Ne.vertexShader, ge = Ne.fragmentShader } else ye = b.vertexShader, ge = b.fragmentShader, l.update(b), xe = l.getVertexShaderID(b), Be = l.getFragmentShaderID(b); const Ie = i.getRenderTarget(), Je = J.isInstancedMesh === !0, ut = !!b.map, Bt = !!b.matcap, Ge = !!Q, H = !!b.aoMap, pe = !!b.lightMap, fe = !!b.bumpMap, Ee = !!b.normalMap, ve = !!b.displacementMap, Z = !!b.emissiveMap, Fe = !!b.metalnessMap, Ve = !!b.roughnessMap, st = b.anisotropy > 0, ot = b.clearcoat > 0, Yt = b.iridescence > 0, U = b.sheen > 0, D = b.transmission > 0, re = st && !!b.anisotropyMap, Ae = ot && !!b.clearcoatMap, Me = ot && !!b.clearcoatNormalMap, Ce = ot && !!b.clearcoatRoughnessMap, qe = Yt && !!b.iridescenceMap, Te = Yt && !!b.iridescenceThicknessMap, oe = U && !!b.sheenColorMap, X = U && !!b.sheenRoughnessMap, he = !!b.specularMap, we = !!b.specularColorMap, be = !!b.specularIntensityMap, De = D && !!b.transmissionMap, lt = D && !!b.thicknessMap, vt = !!b.gradientMap, W = !!b.alphaMap, Oe = b.alphaTest > 0, se = !!b.alphaHash, Se = !!b.extensions, ke = !!q.attributes.uv1, St = !!q.attributes.uv2, Qt = !!q.attributes.uv3; let $t = Ho; return b.toneMapped && (Ie === null || Ie.isXRRenderTarget === !0) && ($t = i.toneMapping), { isWebGL2: f, shaderID: Y, shaderType: b.type, shaderName: b.name, vertexShader: ye, fragmentShader: ge, defines: b.defines, customVertexShaderID: xe, customFragmentShaderID: Be, isRawShaderMaterial: b.isRawShaderMaterial === !0, glslVersion: b.glslVersion, precision: m, instancing: Je, instancingColor: Je && J.instanceColor !== null, supportsVertexTextures: p, outputColorSpace: Ie === null ? i.outputColorSpace : Ie.isXRRenderTarget === !0 ? Ie.texture.colorSpace : po, map: ut, matcap: Bt, envMap: Ge, envMapMode: Ge && Q.mapping, envMapCubeUVHeight: F, aoMap: H, lightMap: pe, bumpMap: fe, normalMap: Ee, displacementMap: p && ve, emissiveMap: Z, normalMapObjectSpace: Ee && b.normalMapType === uF, normalMapTangentSpace: Ee && b.normalMapType === Jl, metalnessMap: Fe, roughnessMap: Ve, anisotropy: st, anisotropyMap: re, clearcoat: ot, clearcoatMap: Ae, clearcoatNormalMap: Me, clearcoatRoughnessMap: Ce, iridescence: Yt, iridescenceMap: qe, iridescenceThicknessMap: Te, sheen: U, sheenColorMap: oe, sheenRoughnessMap: X, specularMap: he, specularColorMap: we, specularIntensityMap: be, transmission: D, transmissionMap: De, thicknessMap: lt, gradientMap: vt, opaque: b.transparent === !1 && b.blending === Jc, alphaMap: W, alphaTest: Oe, alphaHash: se, combine: b.combine, mapUv: ut && _(b.map.channel), aoMapUv: H && _(b.aoMap.channel), lightMapUv: pe && _(b.lightMap.channel), bumpMapUv: fe && _(b.bumpMap.channel), normalMapUv: Ee && _(b.normalMap.channel), displacementMapUv: ve && _(b.displacementMap.channel), emissiveMapUv: Z && _(b.emissiveMap.channel), metalnessMapUv: Fe && _(b.metalnessMap.channel), roughnessMapUv: Ve && _(b.roughnessMap.channel), anisotropyMapUv: re && _(b.anisotropyMap.channel), clearcoatMapUv: Ae && _(b.clearcoatMap.channel), clearcoatNormalMapUv: Me && _(b.clearcoatNormalMap.channel), clearcoatRoughnessMapUv: Ce && _(b.clearcoatRoughnessMap.channel), iridescenceMapUv: qe && _(b.iridescenceMap.channel), iridescenceThicknessMapUv: Te && _(b.iridescenceThicknessMap.channel), sheenColorMapUv: oe && _(b.sheenColorMap.channel), sheenRoughnessMapUv: X && _(b.sheenRoughnessMap.channel), specularMapUv: he && _(b.specularMap.channel), specularColorMapUv: we && _(b.specularColorMap.channel), specularIntensityMapUv: be && _(b.specularIntensityMap.channel), transmissionMapUv: De && _(b.transmissionMap.channel), thicknessMapUv: lt && _(b.thicknessMap.channel), alphaMapUv: W && _(b.alphaMap.channel), vertexTangents: !!q.attributes.tangent && (Ee || st), vertexColors: b.vertexColors, vertexAlphas: b.vertexColors === !0 && !!q.attributes.color && q.attributes.color.itemSize === 4, vertexUv1s: ke, vertexUv2s: St, vertexUv3s: Qt, pointsUvs: J.isPoints === !0 && !!q.attributes.uv && (ut || W), fog: !!j, useFog: b.fog === !0, fogExp2: j && j.isFogExp2, flatShading: b.flatShading === !0, sizeAttenuation: b.sizeAttenuation === !0, logarithmicDepthBuffer: d, skinning: J.isSkinnedMesh === !0, morphTargets: q.morphAttributes.position !== void 0, morphNormals: q.morphAttributes.normal !== void 0, morphColors: q.morphAttributes.color !== void 0, morphTargetsCount: G, morphTextureStride: K, numDirLights: I.directional.length, numPointLights: I.point.length, numSpotLights: I.spot.length, numSpotLightMaps: I.spotLightMap.length, numRectAreaLights: I.rectArea.length, numHemiLights: I.hemi.length, numDirLightShadows: I.directionalShadowMap.length, numPointLightShadows: I.pointShadowMap.length, numSpotLightShadows: I.spotShadowMap.length, numSpotLightShadowsWithMaps: I.numSpotLightShadowsWithMaps, numClippingPlanes: o.numPlanes, numClipIntersection: o.numIntersection, dithering: b.dithering, shadowMapEnabled: i.shadowMap.enabled && N.length > 0, shadowMapType: i.shadowMap.type, toneMapping: $t, useLegacyLights: i._useLegacyLights, premultipliedAlpha: b.premultipliedAlpha, doubleSided: b.side === ro, flipSided: b.side === _r, useDepthPacking: b.depthPacking >= 0, depthPacking: b.depthPacking || 0, index0AttributeName: b.index0AttributeName, extensionDerivatives: Se && b.extensions.derivatives === !0, extensionFragDepth: Se && b.extensions.fragDepth === !0, extensionDrawBuffers: Se && b.extensions.drawBuffers === !0, extensionShaderTextureLOD: Se && b.extensions.shaderTextureLOD === !0, rendererExtensionFragDepth: f || n.has("EXT_frag_depth"), rendererExtensionDrawBuffers: f || n.has("WEBGL_draw_buffers"), rendererExtensionShaderTextureLod: f || n.has("EXT_shader_texture_lod"), customProgramCacheKey: b.customProgramCacheKey() } } function g(b) { const I = []; if (b.shaderID ? I.push(b.shaderID) : (I.push(b.customVertexShaderID), I.push(b.customFragmentShaderID)), b.defines !== void 0) for (const N in b.defines) I.push(N), I.push(b.defines[N]); return b.isRawShaderMaterial === !1 && (A(I, b), M(I, b), I.push(i.outputColorSpace)), I.push(b.customProgramCacheKey), I.join() } function A(b, I) { b.push(I.precision), b.push(I.outputColorSpace), b.push(I.envMapMode), b.push(I.envMapCubeUVHeight), b.push(I.mapUv), b.push(I.alphaMapUv), b.push(I.lightMapUv), b.push(I.aoMapUv), b.push(I.bumpMapUv), b.push(I.normalMapUv), b.push(I.displacementMapUv), b.push(I.emissiveMapUv), b.push(I.metalnessMapUv), b.push(I.roughnessMapUv), b.push(I.anisotropyMapUv), b.push(I.clearcoatMapUv), b.push(I.clearcoatNormalMapUv), b.push(I.clearcoatRoughnessMapUv), b.push(I.iridescenceMapUv), b.push(I.iridescenceThicknessMapUv), b.push(I.sheenColorMapUv), b.push(I.sheenRoughnessMapUv), b.push(I.specularMapUv), b.push(I.specularColorMapUv), b.push(I.specularIntensityMapUv), b.push(I.transmissionMapUv), b.push(I.thicknessMapUv), b.push(I.combine), b.push(I.fogExp2), b.push(I.sizeAttenuation), b.push(I.morphTargetsCount), b.push(I.morphAttributeCount), b.push(I.numDirLights), b.push(I.numPointLights), b.push(I.numSpotLights), b.push(I.numSpotLightMaps), b.push(I.numHemiLights), b.push(I.numRectAreaLights), b.push(I.numDirLightShadows), b.push(I.numPointLightShadows), b.push(I.numSpotLightShadows), b.push(I.numSpotLightShadowsWithMaps), b.push(I.shadowMapType), b.push(I.toneMapping), b.push(I.numClippingPlanes), b.push(I.numClipIntersection), b.push(I.depthPacking) } function M(b, I) { a.disableAll(), I.isWebGL2 && a.enable(0), I.supportsVertexTextures && a.enable(1), I.instancing && a.enable(2), I.instancingColor && a.enable(3), I.matcap && a.enable(4), I.envMap && a.enable(5), I.normalMapObjectSpace && a.enable(6), I.normalMapTangentSpace && a.enable(7), I.clearcoat && a.enable(8), I.iridescence && a.enable(9), I.alphaTest && a.enable(10), I.vertexColors && a.enable(11), I.vertexAlphas && a.enable(12), I.vertexUv1s && a.enable(13), I.vertexUv2s && a.enable(14), I.vertexUv3s && a.enable(15), I.vertexTangents && a.enable(16), I.anisotropy && a.enable(17), b.push(a.mask), a.disableAll(), I.fog && a.enable(0), I.useFog && a.enable(1), I.flatShading && a.enable(2), I.logarithmicDepthBuffer && a.enable(3), I.skinning && a.enable(4), I.morphTargets && a.enable(5), I.morphNormals && a.enable(6), I.morphColors && a.enable(7), I.premultipliedAlpha && a.enable(8), I.shadowMapEnabled && a.enable(9), I.useLegacyLights && a.enable(10), I.doubleSided && a.enable(11), I.flipSided && a.enable(12), I.useDepthPacking && a.enable(13), I.dithering && a.enable(14), I.transmission && a.enable(15), I.sheen && a.enable(16), I.opaque && a.enable(17), I.pointsUvs && a.enable(18), b.push(a.mask) } function S(b) { const I = y[b.type]; let N; if (I) { const V = io[I]; N = CF.clone(V.uniforms) } else N = b.uniforms; return N } function C(b, I) { let N; for (let V = 0, J = c.length; V < J; V++) { const j = c[V]; if (j.cacheKey === I) { N = j, ++N.usedTimes; break } } return N === void 0 && (N = new lj(i, I, b, s), c.push(N)), N } function T(b) { if (--b.usedTimes === 0) { const I = c.indexOf(b); c[I] = c[c.length - 1], c.pop(), b.destroy() } } function R(b) { l.remove(b) } function B() { l.dispose() } return { getParameters: x, getProgramCacheKey: g, getUniforms: S, acquireProgram: C, releaseProgram: T, releaseShaderCache: R, programs: c, dispose: B } } function dj() { let i = new WeakMap; function e(s) { let o = i.get(s); return o === void 0 && (o = {}, i.set(s, o)), o } function t(s) { i.delete(s) } function n(s, o, a) { i.get(s)[o] = a } function r() { i = new WeakMap } return { get: e, remove: t, update: n, dispose: r } } function pj(i, e) { return i.groupOrder !== e.groupOrder ? i.groupOrder - e.groupOrder : i.renderOrder !== e.renderOrder ? i.renderOrder - e.renderOrder : i.material.id !== e.material.id ? i.material.id - e.material.id : i.z !== e.z ? i.z - e.z : i.id - e.id } function IP(i, e) { return i.groupOrder !== e.groupOrder ? i.groupOrder - e.groupOrder : i.renderOrder !== e.renderOrder ? i.renderOrder - e.renderOrder : i.z !== e.z ? e.z - i.z : i.id - e.id } function BP() { const i = []; let e = 0; const t = [], n = [], r = []; function s() { e = 0, t.length = 0, n.length = 0, r.length = 0 } function o(d, p, m, y, _, x) { let g = i[e]; return g === void 0 ? (g = { id: d.id, object: d, geometry: p, material: m, groupOrder: y, renderOrder: d.renderOrder, z: _, group: x }, i[e] = g) : (g.id = d.id, g.object = d, g.geometry = p, g.material = m, g.groupOrder = y, g.renderOrder = d.renderOrder, g.z = _, g.group = x), e++, g } function a(d, p, m, y, _, x) { const g = o(d, p, m, y, _, x); m.transmission > 0 ? n.push(g) : m.transparent === !0 ? r.push(g) : t.push(g) } function l(d, p, m, y, _, x) { const g = o(d, p, m, y, _, x); m.transmission > 0 ? n.unshift(g) : m.transparent === !0 ? r.unshift(g) : t.unshift(g) } function c(d, p) { t.length > 1 && t.sort(d || pj), n.length > 1 && n.sort(p || IP), r.length > 1 && r.sort(p || IP) } function f() { for (let d = e, p = i.length; d < p; d++) { const m = i[d]; if (m.id === null) break; m.id = null, m.object = null, m.geometry = null, m.material = null, m.group = null } } return { opaque: t, transmissive: n, transparent: r, init: s, push: a, unshift: l, finish: f, sort: c } } function mj() { let i = new WeakMap; function e(n, r) { const s = i.get(n); let o; return s === void 0 ? (o = new BP, i.set(n, [o])) : r >= s.length ? (o = new BP, s.push(o)) : o = s[r], o } function t() { i = new WeakMap } return { get: e, dispose: t } } function gj() { const i = {}; return { get: function (e) { if (i[e.id] !== void 0) return i[e.id]; let t; switch (e.type) { case "DirectionalLight": t = { direction: new k, color: new We }; break; case "SpotLight": t = { position: new k, direction: new k, color: new We, distance: 0, coneCos: 0, penumbraCos: 0, decay: 0 }; break; case "PointLight": t = { position: new k, color: new We, distance: 0, decay: 0 }; break; case "HemisphereLight": t = { direction: new k, skyColor: new We, groundColor: new We }; break; case "RectAreaLight": t = { color: new We, position: new k, halfWidth: new k, halfHeight: new k }; break }return i[e.id] = t, t } } } function yj() { const i = {}; return { get: function (e) { if (i[e.id] !== void 0) return i[e.id]; let t; switch (e.type) { case "DirectionalLight": t = { shadowBias: 0, shadowNormalBias: 0, shadowRadius: 1, shadowMapSize: new _e }; break; case "SpotLight": t = { shadowBias: 0, shadowNormalBias: 0, shadowRadius: 1, shadowMapSize: new _e }; break; case "PointLight": t = { shadowBias: 0, shadowNormalBias: 0, shadowRadius: 1, shadowMapSize: new _e, shadowCameraNear: 1, shadowCameraFar: 1e3 }; break }return i[e.id] = t, t } } } let vj = 0; function _j(i, e) { return (e.castShadow ? 2 : 0) - (i.castShadow ? 2 : 0) + (e.map ? 1 : 0) - (i.map ? 1 : 0) } function xj(i, e) { const t = new gj, n = yj(), r = { version: 0, hash: { directionalLength: -1, pointLength: -1, spotLength: -1, rectAreaLength: -1, hemiLength: -1, numDirectionalShadows: -1, numPointShadows: -1, numSpotShadows: -1, numSpotMaps: -1 }, ambient: [0, 0, 0], probe: [], directional: [], directionalShadow: [], directionalShadowMap: [], directionalShadowMatrix: [], spot: [], spotLightMap: [], spotShadow: [], spotShadowMap: [], spotLightMatrix: [], rectArea: [], rectAreaLTC1: null, rectAreaLTC2: null, point: [], pointShadow: [], pointShadowMap: [], pointShadowMatrix: [], hemi: [], numSpotLightShadowsWithMaps: 0 }; for (let f = 0; f < 9; f++)r.probe.push(new k); const s = new k, o = new yt, a = new yt; function l(f, d) { let p = 0, m = 0, y = 0; for (let N = 0; N < 9; N++)r.probe[N].set(0, 0, 0); let _ = 0, x = 0, g = 0, A = 0, M = 0, S = 0, C = 0, T = 0, R = 0, B = 0; f.sort(_j); const b = d === !0 ? Math.PI : 1; for (let N = 0, V = f.length; N < V; N++) { const J = f[N], j = J.color, q = J.intensity, ne = J.distance, Q = J.shadow && J.shadow.map ? J.shadow.map.texture : null; if (J.isAmbientLight) p += j.r * q * b, m += j.g * q * b, y += j.b * q * b; else if (J.isLightProbe) for (let F = 0; F < 9; F++)r.probe[F].addScaledVector(J.sh.coefficients[F], q); else if (J.isDirectionalLight) { const F = t.get(J); if (F.color.copy(J.color).multiplyScalar(J.intensity * b), J.castShadow) { const Y = J.shadow, L = n.get(J); L.shadowBias = Y.bias, L.shadowNormalBias = Y.normalBias, L.shadowRadius = Y.radius, L.shadowMapSize = Y.mapSize, r.directionalShadow[_] = L, r.directionalShadowMap[_] = Q, r.directionalShadowMatrix[_] = J.shadow.matrix, S++ } r.directional[_] = F, _++ } else if (J.isSpotLight) { const F = t.get(J); F.position.setFromMatrixPosition(J.matrixWorld), F.color.copy(j).multiplyScalar(q * b), F.distance = ne, F.coneCos = Math.cos(J.angle), F.penumbraCos = Math.cos(J.angle * (1 - J.penumbra)), F.decay = J.decay, r.spot[g] = F; const Y = J.shadow; if (J.map && (r.spotLightMap[R] = J.map, R++, Y.updateMatrices(J), J.castShadow && B++), r.spotLightMatrix[g] = Y.matrix, J.castShadow) { const L = n.get(J); L.shadowBias = Y.bias, L.shadowNormalBias = Y.normalBias, L.shadowRadius = Y.radius, L.shadowMapSize = Y.mapSize, r.spotShadow[g] = L, r.spotShadowMap[g] = Q, T++ } g++ } else if (J.isRectAreaLight) { const F = t.get(J); F.color.copy(j).multiplyScalar(q), F.halfWidth.set(J.width * .5, 0, 0), F.halfHeight.set(0, J.height * .5, 0), r.rectArea[A] = F, A++ } else if (J.isPointLight) { const F = t.get(J); if (F.color.copy(J.color).multiplyScalar(J.intensity * b), F.distance = J.distance, F.decay = J.decay, J.castShadow) { const Y = J.shadow, L = n.get(J); L.shadowBias = Y.bias, L.shadowNormalBias = Y.normalBias, L.shadowRadius = Y.radius, L.shadowMapSize = Y.mapSize, L.shadowCameraNear = Y.camera.near, L.shadowCameraFar = Y.camera.far, r.pointShadow[x] = L, r.pointShadowMap[x] = Q, r.pointShadowMatrix[x] = J.shadow.matrix, C++ } r.point[x] = F, x++ } else if (J.isHemisphereLight) { const F = t.get(J); F.skyColor.copy(J.color).multiplyScalar(q * b), F.groundColor.copy(J.groundColor).multiplyScalar(q * b), r.hemi[M] = F, M++ } } A > 0 && (e.isWebGL2 || i.has("OES_texture_float_linear") === !0 ? (r.rectAreaLTC1 = He.LTC_FLOAT_1, r.rectAreaLTC2 = He.LTC_FLOAT_2) : i.has("OES_texture_half_float_linear") === !0 ? (r.rectAreaLTC1 = He.LTC_HALF_1, r.rectAreaLTC2 = He.LTC_HALF_2) : console.error("THREE.WebGLRenderer: Unable to use RectAreaLight. Missing WebGL extensions.")), r.ambient[0] = p, r.ambient[1] = m, r.ambient[2] = y; const I = r.hash; (I.directionalLength !== _ || I.pointLength !== x || I.spotLength !== g || I.rectAreaLength !== A || I.hemiLength !== M || I.numDirectionalShadows !== S || I.numPointShadows !== C || I.numSpotShadows !== T || I.numSpotMaps !== R) && (r.directional.length = _, r.spot.length = g, r.rectArea.length = A, r.point.length = x, r.hemi.length = M, r.directionalShadow.length = S, r.directionalShadowMap.length = S, r.pointShadow.length = C, r.pointShadowMap.length = C, r.spotShadow.length = T, r.spotShadowMap.length = T, r.directionalShadowMatrix.length = S, r.pointShadowMatrix.length = C, r.spotLightMatrix.length = T + R - B, r.spotLightMap.length = R, r.numSpotLightShadowsWithMaps = B, I.directionalLength = _, I.pointLength = x, I.spotLength = g, I.rectAreaLength = A, I.hemiLength = M, I.numDirectionalShadows = S, I.numPointShadows = C, I.numSpotShadows = T, I.numSpotMaps = R, r.version = vj++) } function c(f, d) { let p = 0, m = 0, y = 0, _ = 0, x = 0; const g = d.matrixWorldInverse; for (let A = 0, M = f.length; A < M; A++) { const S = f[A]; if (S.isDirectionalLight) { const C = r.directional[p]; C.direction.setFromMatrixPosition(S.matrixWorld), s.setFromMatrixPosition(S.target.matrixWorld), C.direction.sub(s), C.direction.transformDirection(g), p++ } else if (S.isSpotLight) { const C = r.spot[y]; C.position.setFromMatrixPosition(S.matrixWorld), C.position.applyMatrix4(g), C.direction.setFromMatrixPosition(S.matrixWorld), s.setFromMatrixPosition(S.target.matrixWorld), C.direction.sub(s), C.direction.transformDirection(g), y++ } else if (S.isRectAreaLight) { const C = r.rectArea[_]; C.position.setFromMatrixPosition(S.matrixWorld), C.position.applyMatrix4(g), a.identity(), o.copy(S.matrixWorld), o.premultiply(g), a.extractRotation(o), C.halfWidth.set(S.width * .5, 0, 0), C.halfHeight.set(0, S.height * .5, 0), C.halfWidth.applyMatrix4(a), C.halfHeight.applyMatrix4(a), _++ } else if (S.isPointLight) { const C = r.point[m]; C.position.setFromMatrixPosition(S.matrixWorld), C.position.applyMatrix4(g), m++ } else if (S.isHemisphereLight) { const C = r.hemi[x]; C.direction.setFromMatrixPosition(S.matrixWorld), C.direction.transformDirection(g), x++ } } } return { setup: l, setupView: c, state: r } } function LP(i, e) { const t = new xj(i, e), n = [], r = []; function s() { n.length = 0, r.length = 0 } function o(d) { n.push(d) } function a(d) { r.push(d) } function l(d) { t.setup(n, d) } function c(d) { t.setupView(n, d) } return { init: s, state: { lightsArray: n, shadowsArray: r, lights: t }, setupLights: l, setupLightsView: c, pushLight: o, pushShadow: a } } function Aj(i, e) { let t = new WeakMap; function n(s, o = 0) { const a = t.get(s); let l; return a === void 0 ? (l = new LP(i, e), t.set(s, [l])) : o >= a.length ? (l = new LP(i, e), a.push(l)) : l = a[o], l } function r() { t = new WeakMap } return { get: n, dispose: r } } class CE extends oi { constructor(e) { super(), this.isMeshDepthMaterial = !0, this.type = "MeshDepthMaterial", this.depthPacking = lF, this.map = null, this.alphaMap = null, this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.wireframe = !1, this.wireframeLinewidth = 1, this.setValues(e) } copy(e) { return super.copy(e), this.depthPacking = e.depthPacking, this.map = e.map, this.alphaMap = e.alphaMap, this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this } } class TE extends oi { constructor(e) { super(), this.isMeshDistanceMaterial = !0, this.type = "MeshDistanceMaterial", this.map = null, this.alphaMap = null, this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.setValues(e) } copy(e) { return super.copy(e), this.map = e.map, this.alphaMap = e.alphaMap, this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this } } const Mj = `void main() {
	gl_Position = vec4( position, 1.0 );
}`, wj = `uniform sampler2D shadow_pass;
uniform vec2 resolution;
uniform float radius;
#include <packing>
void main() {
	const float samples = float( VSM_SAMPLES );
	float mean = 0.0;
	float squared_mean = 0.0;
	float uvStride = samples <= 1.0 ? 0.0 : 2.0 / ( samples - 1.0 );
	float uvStart = samples <= 1.0 ? 0.0 : - 1.0;
	for ( float i = 0.0; i < samples; i ++ ) {
		float uvOffset = uvStart + i * uvStride;
		#ifdef HORIZONTAL_PASS
			vec2 distribution = unpackRGBATo2Half( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( uvOffset, 0.0 ) * radius ) / resolution ) );
			mean += distribution.x;
			squared_mean += distribution.y * distribution.y + distribution.x * distribution.x;
		#else
			float depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( 0.0, uvOffset ) * radius ) / resolution ) );
			mean += depth;
			squared_mean += depth * depth;
		#endif
	}
	mean = mean / samples;
	squared_mean = squared_mean / samples;
	float std_dev = sqrt( squared_mean - mean * mean );
	gl_FragColor = pack2HalfToRGBA( vec2( mean, std_dev ) );
}`; function Sj(i, e, t) { let n = new zv; const r = new _e, s = new _e, o = new on, a = new CE({ depthPacking: cF }), l = new TE, c = {}, f = t.maxTextureSize, d = { [Jo]: _r, [_r]: Jo, [ro]: ro }, p = new jo({ defines: { VSM_SAMPLES: 8 }, uniforms: { shadow_pass: { value: null }, resolution: { value: new _e }, radius: { value: 4 } }, vertexShader: Mj, fragmentShader: wj }), m = p.clone(); m.defines.HORIZONTAL_PASS = 1; const y = new Rt; y.setAttribute("position", new rn(new Float32Array([-1, -1, .5, 3, -1, .5, -1, 3, .5]), 3)); const _ = new Ei(y, p), x = this; this.enabled = !1, this.autoUpdate = !0, this.needsUpdate = !1, this.type = Dv; let g = this.type; this.render = function (C, T, R) { if (x.enabled === !1 || x.autoUpdate === !1 && x.needsUpdate === !1 || C.length === 0) return; const B = i.getRenderTarget(), b = i.getActiveCubeFace(), I = i.getActiveMipmapLevel(), N = i.state; N.setBlending(Ea), N.buffers.color.setClear(1, 1, 1, 1), N.buffers.depth.setTest(!0), N.setScissorTest(!1); const V = g !== $s && this.type === $s, J = g === $s && this.type !== $s; for (let j = 0, q = C.length; j < q; j++) { const ne = C[j], Q = ne.shadow; if (Q === void 0) { console.warn("THREE.WebGLShadowMap:", ne, "has no shadow."); continue } if (Q.autoUpdate === !1 && Q.needsUpdate === !1) continue; r.copy(Q.mapSize); const F = Q.getFrameExtents(); if (r.multiply(F), s.copy(Q.mapSize), (r.x > f || r.y > f) && (r.x > f && (s.x = Math.floor(f / F.x), r.x = s.x * F.x, Q.mapSize.x = s.x), r.y > f && (s.y = Math.floor(f / F.y), r.y = s.y * F.y, Q.mapSize.y = s.y)), Q.map === null || V === !0 || J === !0) { const L = this.type !== $s ? { minFilter: zn, magFilter: zn } : {}; Q.map !== null && Q.map.dispose(), Q.map = new mo(r.x, r.y, L), Q.map.texture.name = ne.name + ".shadowMap", Q.camera.updateProjectionMatrix() } i.setRenderTarget(Q.map), i.clear(); const Y = Q.getViewportCount(); for (let L = 0; L < Y; L++) { const G = Q.getViewport(L); o.set(s.x * G.x, s.y * G.y, s.x * G.z, s.y * G.w), N.viewport(o), Q.updateMatrices(ne, L), n = Q.getFrustum(), S(T, R, Q.camera, ne, this.type) } Q.isPointLightShadow !== !0 && this.type === $s && A(Q, R), Q.needsUpdate = !1 } g = this.type, x.needsUpdate = !1, i.setRenderTarget(B, b, I) }; function A(C, T) { const R = e.update(_); p.defines.VSM_SAMPLES !== C.blurSamples && (p.defines.VSM_SAMPLES = C.blurSamples, m.defines.VSM_SAMPLES = C.blurSamples, p.needsUpdate = !0, m.needsUpdate = !0), C.mapPass === null && (C.mapPass = new mo(r.x, r.y)), p.uniforms.shadow_pass.value = C.map.texture, p.uniforms.resolution.value = C.mapSize, p.uniforms.radius.value = C.radius, i.setRenderTarget(C.mapPass), i.clear(), i.renderBufferDirect(T, null, R, p, _, null), m.uniforms.shadow_pass.value = C.mapPass.texture, m.uniforms.resolution.value = C.mapSize, m.uniforms.radius.value = C.radius, i.setRenderTarget(C.map), i.clear(), i.renderBufferDirect(T, null, R, m, _, null) } function M(C, T, R, B) { let b = null; const I = R.isPointLight === !0 ? C.customDistanceMaterial : C.customDepthMaterial; if (I !== void 0) b = I; else if (b = R.isPointLight === !0 ? l : a, i.localClippingEnabled && T.clipShadows === !0 && Array.isArray(T.clippingPlanes) && T.clippingPlanes.length !== 0 || T.displacementMap && T.displacementScale !== 0 || T.alphaMap && T.alphaTest > 0 || T.map && T.alphaTest > 0) { const N = b.uuid, V = T.uuid; let J = c[N]; J === void 0 && (J = {}, c[N] = J); let j = J[V]; j === void 0 && (j = b.clone(), J[V] = j), b = j } if (b.visible = T.visible, b.wireframe = T.wireframe, B === $s ? b.side = T.shadowSide !== null ? T.shadowSide : T.side : b.side = T.shadowSide !== null ? T.shadowSide : d[T.side], b.alphaMap = T.alphaMap, b.alphaTest = T.alphaTest, b.map = T.map, b.clipShadows = T.clipShadows, b.clippingPlanes = T.clippingPlanes, b.clipIntersection = T.clipIntersection, b.displacementMap = T.displacementMap, b.displacementScale = T.displacementScale, b.displacementBias = T.displacementBias, b.wireframeLinewidth = T.wireframeLinewidth, b.linewidth = T.linewidth, R.isPointLight === !0 && b.isMeshDistanceMaterial === !0) { const N = i.properties.get(b); N.light = R } return b } function S(C, T, R, B, b) { if (C.visible === !1) return; if (C.layers.test(T.layers) && (C.isMesh || C.isLine || C.isPoints) && (C.castShadow || C.receiveShadow && b === $s) && (!C.frustumCulled || n.intersectsObject(C))) { C.modelViewMatrix.multiplyMatrices(R.matrixWorldInverse, C.matrixWorld); const V = e.update(C), J = C.material; if (Array.isArray(J)) { const j = V.groups; for (let q = 0, ne = j.length; q < ne; q++) { const Q = j[q], F = J[Q.materialIndex]; if (F && F.visible) { const Y = M(C, F, B, b); i.renderBufferDirect(R, null, V, Y, C, Q) } } } else if (J.visible) { const j = M(C, J, B, b); i.renderBufferDirect(R, null, V, j, C, null) } } const N = C.children; for (let V = 0, J = N.length; V < J; V++)S(N[V], T, R, B, b) } } function Ej(i, e, t) { const n = t.isWebGL2; function r() { let W = !1; const Oe = new on; let se = null; const Se = new on(0, 0, 0, 0); return { setMask: function (ke) { se !== ke && !W && (i.colorMask(ke, ke, ke, ke), se = ke) }, setLocked: function (ke) { W = ke }, setClear: function (ke, St, Qt, $t, ht) { ht === !0 && (ke *= $t, St *= $t, Qt *= $t), Oe.set(ke, St, Qt, $t), Se.equals(Oe) === !1 && (i.clearColor(ke, St, Qt, $t), Se.copy(Oe)) }, reset: function () { W = !1, se = null, Se.set(-1, 0, 0, 0) } } } function s() { let W = !1, Oe = null, se = null, Se = null; return { setTest: function (ke) { ke ? Ie(i.DEPTH_TEST) : Je(i.DEPTH_TEST) }, setMask: function (ke) { Oe !== ke && !W && (i.depthMask(ke), Oe = ke) }, setFunc: function (ke) { if (se !== ke) { switch (ke) { case FO: i.depthFunc(i.NEVER); break; case kO: i.depthFunc(i.ALWAYS); break; case NO: i.depthFunc(i.LESS); break; case nv: i.depthFunc(i.LEQUAL); break; case UO: i.depthFunc(i.EQUAL); break; case zO: i.depthFunc(i.GEQUAL); break; case HO: i.depthFunc(i.GREATER); break; case GO: i.depthFunc(i.NOTEQUAL); break; default: i.depthFunc(i.LEQUAL) }se = ke } }, setLocked: function (ke) { W = ke }, setClear: function (ke) { Se !== ke && (i.clearDepth(ke), Se = ke) }, reset: function () { W = !1, Oe = null, se = null, Se = null } } } function o() { let W = !1, Oe = null, se = null, Se = null, ke = null, St = null, Qt = null, $t = null, ht = null; return { setTest: function (Ne) { W || (Ne ? Ie(i.STENCIL_TEST) : Je(i.STENCIL_TEST)) }, setMask: function (Ne) { Oe !== Ne && !W && (i.stencilMask(Ne), Oe = Ne) }, setFunc: function (Ne, At, Lt) { (se !== Ne || Se !== At || ke !== Lt) && (i.stencilFunc(Ne, At, Lt), se = Ne, Se = At, ke = Lt) }, setOp: function (Ne, At, Lt) { (St !== Ne || Qt !== At || $t !== Lt) && (i.stencilOp(Ne, At, Lt), St = Ne, Qt = At, $t = Lt) }, setLocked: function (Ne) { W = Ne }, setClear: function (Ne) { ht !== Ne && (i.clearStencil(Ne), ht = Ne) }, reset: function () { W = !1, Oe = null, se = null, Se = null, ke = null, St = null, Qt = null, $t = null, ht = null } } } const a = new r, l = new s, c = new o, f = new WeakMap, d = new WeakMap; let p = {}, m = {}, y = new WeakMap, _ = [], x = null, g = !1, A = null, M = null, S = null, C = null, T = null, R = null, B = null, b = !1, I = null, N = null, V = null, J = null, j = null; const q = i.getParameter(i.MAX_COMBINED_TEXTURE_IMAGE_UNITS); let ne = !1, Q = 0; const F = i.getParameter(i.VERSION); F.indexOf("WebGL") !== -1 ? (Q = parseFloat(/^WebGL (\d)/.exec(F)[1]), ne = Q >= 1) : F.indexOf("OpenGL ES") !== -1 && (Q = parseFloat(/^OpenGL ES (\d)/.exec(F)[1]), ne = Q >= 2); let Y = null, L = {}; const G = i.getParameter(i.SCISSOR_BOX), K = i.getParameter(i.VIEWPORT), ye = new on().fromArray(G), ge = new on().fromArray(K); function xe(W, Oe, se, Se) { const ke = new Uint8Array(4), St = i.createTexture(); i.bindTexture(W, St), i.texParameteri(W, i.TEXTURE_MIN_FILTER, i.NEAREST), i.texParameteri(W, i.TEXTURE_MAG_FILTER, i.NEAREST); for (let Qt = 0; Qt < se; Qt++)n && (W === i.TEXTURE_3D || W === i.TEXTURE_2D_ARRAY) ? i.texImage3D(Oe, 0, i.RGBA, 1, 1, Se, 0, i.RGBA, i.UNSIGNED_BYTE, ke) : i.texImage2D(Oe + Qt, 0, i.RGBA, 1, 1, 0, i.RGBA, i.UNSIGNED_BYTE, ke); return St } const Be = {}; Be[i.TEXTURE_2D] = xe(i.TEXTURE_2D, i.TEXTURE_2D, 1), Be[i.TEXTURE_CUBE_MAP] = xe(i.TEXTURE_CUBE_MAP, i.TEXTURE_CUBE_MAP_POSITIVE_X, 6), n && (Be[i.TEXTURE_2D_ARRAY] = xe(i.TEXTURE_2D_ARRAY, i.TEXTURE_2D_ARRAY, 1, 1), Be[i.TEXTURE_3D] = xe(i.TEXTURE_3D, i.TEXTURE_3D, 1, 1)), a.setClear(0, 0, 0, 1), l.setClear(1), c.setClear(0), Ie(i.DEPTH_TEST), l.setFunc(nv), ve(!1), Z(Gw), Ie(i.CULL_FACE), fe(Ea); function Ie(W) { p[W] !== !0 && (i.enable(W), p[W] = !0) } function Je(W) { p[W] !== !1 && (i.disable(W), p[W] = !1) } function ut(W, Oe) { return m[W] !== Oe ? (i.bindFramebuffer(W, Oe), m[W] = Oe, n && (W === i.DRAW_FRAMEBUFFER && (m[i.FRAMEBUFFER] = Oe), W === i.FRAMEBUFFER && (m[i.DRAW_FRAMEBUFFER] = Oe)), !0) : !1 } function Bt(W, Oe) { let se = _, Se = !1; if (W) if (se = y.get(Oe), se === void 0 && (se = [], y.set(Oe, se)), W.isWebGLMultipleRenderTargets) { const ke = W.texture; if (se.length !== ke.length || se[0] !== i.COLOR_ATTACHMENT0) { for (let St = 0, Qt = ke.length; St < Qt; St++)se[St] = i.COLOR_ATTACHMENT0 + St; se.length = ke.length, Se = !0 } } else se[0] !== i.COLOR_ATTACHMENT0 && (se[0] = i.COLOR_ATTACHMENT0, Se = !0); else se[0] !== i.BACK && (se[0] = i.BACK, Se = !0); Se && (t.isWebGL2 ? i.drawBuffers(se) : e.get("WEBGL_draw_buffers").drawBuffersWEBGL(se)) } function Ge(W) { return x !== W ? (i.useProgram(W), x = W, !0) : !1 } const H = { [Sc]: i.FUNC_ADD, [EO]: i.FUNC_SUBTRACT, [CO]: i.FUNC_REVERSE_SUBTRACT }; if (n) H[Jw] = i.MIN, H[Yw] = i.MAX; else { const W = e.get("EXT_blend_minmax"); W !== null && (H[Jw] = W.MIN_EXT, H[Yw] = W.MAX_EXT) } const pe = { [TO]: i.ZERO, [bO]: i.ONE, [RO]: i.SRC_COLOR, [aE]: i.SRC_ALPHA, [OO]: i.SRC_ALPHA_SATURATE, [LO]: i.DST_COLOR, [IO]: i.DST_ALPHA, [PO]: i.ONE_MINUS_SRC_COLOR, [lE]: i.ONE_MINUS_SRC_ALPHA, [DO]: i.ONE_MINUS_DST_COLOR, [BO]: i.ONE_MINUS_DST_ALPHA }; function fe(W, Oe, se, Se, ke, St, Qt, $t) { if (W === Ea) { g === !0 && (Je(i.BLEND), g = !1); return } if (g === !1 && (Ie(i.BLEND), g = !0), W !== SO) { if (W !== A || $t !== b) { if ((M !== Sc || T !== Sc) && (i.blendEquation(i.FUNC_ADD), M = Sc, T = Sc), $t) switch (W) { case Jc: i.blendFuncSeparate(i.ONE, i.ONE_MINUS_SRC_ALPHA, i.ONE, i.ONE_MINUS_SRC_ALPHA); break; case Vw: i.blendFunc(i.ONE, i.ONE); break; case Ww: i.blendFuncSeparate(i.ZERO, i.ONE_MINUS_SRC_COLOR, i.ZERO, i.ONE); break; case Xw: i.blendFuncSeparate(i.ZERO, i.SRC_COLOR, i.ZERO, i.SRC_ALPHA); break; default: console.error("THREE.WebGLState: Invalid blending: ", W); break } else switch (W) { case Jc: i.blendFuncSeparate(i.SRC_ALPHA, i.ONE_MINUS_SRC_ALPHA, i.ONE, i.ONE_MINUS_SRC_ALPHA); break; case Vw: i.blendFunc(i.SRC_ALPHA, i.ONE); break; case Ww: i.blendFuncSeparate(i.ZERO, i.ONE_MINUS_SRC_COLOR, i.ZERO, i.ONE); break; case Xw: i.blendFunc(i.ZERO, i.SRC_COLOR); break; default: console.error("THREE.WebGLState: Invalid blending: ", W); break }S = null, C = null, R = null, B = null, A = W, b = $t } return } ke = ke || Oe, St = St || se, Qt = Qt || Se, (Oe !== M || ke !== T) && (i.blendEquationSeparate(H[Oe], H[ke]), M = Oe, T = ke), (se !== S || Se !== C || St !== R || Qt !== B) && (i.blendFuncSeparate(pe[se], pe[Se], pe[St], pe[Qt]), S = se, C = Se, R = St, B = Qt), A = W, b = !1 } function Ee(W, Oe) { W.side === ro ? Je(i.CULL_FACE) : Ie(i.CULL_FACE); let se = W.side === _r; Oe && (se = !se), ve(se), W.blending === Jc && W.transparent === !1 ? fe(Ea) : fe(W.blending, W.blendEquation, W.blendSrc, W.blendDst, W.blendEquationAlpha, W.blendSrcAlpha, W.blendDstAlpha, W.premultipliedAlpha), l.setFunc(W.depthFunc), l.setTest(W.depthTest), l.setMask(W.depthWrite), a.setMask(W.colorWrite); const Se = W.stencilWrite; c.setTest(Se), Se && (c.setMask(W.stencilWriteMask), c.setFunc(W.stencilFunc, W.stencilRef, W.stencilFuncMask), c.setOp(W.stencilFail, W.stencilZFail, W.stencilZPass)), Ve(W.polygonOffset, W.polygonOffsetFactor, W.polygonOffsetUnits), W.alphaToCoverage === !0 ? Ie(i.SAMPLE_ALPHA_TO_COVERAGE) : Je(i.SAMPLE_ALPHA_TO_COVERAGE) } function ve(W) { I !== W && (W ? i.frontFace(i.CW) : i.frontFace(i.CCW), I = W) } function Z(W) { W !== AO ? (Ie(i.CULL_FACE), W !== N && (W === Gw ? i.cullFace(i.BACK) : W === MO ? i.cullFace(i.FRONT) : i.cullFace(i.FRONT_AND_BACK))) : Je(i.CULL_FACE), N = W } function Fe(W) { W !== V && (ne && i.lineWidth(W), V = W) } function Ve(W, Oe, se) { W ? (Ie(i.POLYGON_OFFSET_FILL), (J !== Oe || j !== se) && (i.polygonOffset(Oe, se), J = Oe, j = se)) : Je(i.POLYGON_OFFSET_FILL) } function st(W) { W ? Ie(i.SCISSOR_TEST) : Je(i.SCISSOR_TEST) } function ot(W) { W === void 0 && (W = i.TEXTURE0 + q - 1), Y !== W && (i.activeTexture(W), Y = W) } function Yt(W, Oe, se) { se === void 0 && (Y === null ? se = i.TEXTURE0 + q - 1 : se = Y); let Se = L[se]; Se === void 0 && (Se = { type: void 0, texture: void 0 }, L[se] = Se), (Se.type !== W || Se.texture !== Oe) && (Y !== se && (i.activeTexture(se), Y = se), i.bindTexture(W, Oe || Be[W]), Se.type = W, Se.texture = Oe) } function U() { const W = L[Y]; W !== void 0 && W.type !== void 0 && (i.bindTexture(W.type, null), W.type = void 0, W.texture = void 0) } function D() { try { i.compressedTexImage2D.apply(i, arguments) } catch (W) { console.error("THREE.WebGLState:", W) } } function re() { try { i.compressedTexImage3D.apply(i, arguments) } catch (W) { console.error("THREE.WebGLState:", W) } } function Ae() { try { i.texSubImage2D.apply(i, arguments) } catch (W) { console.error("THREE.WebGLState:", W) } } function Me() { try { i.texSubImage3D.apply(i, arguments) } catch (W) { console.error("THREE.WebGLState:", W) } } function Ce() { try { i.compressedTexSubImage2D.apply(i, arguments) } catch (W) { console.error("THREE.WebGLState:", W) } } function qe() { try { i.compressedTexSubImage3D.apply(i, arguments) } catch (W) { console.error("THREE.WebGLState:", W) } } function Te() { try { i.texStorage2D.apply(i, arguments) } catch (W) { console.error("THREE.WebGLState:", W) } } function oe() { try { i.texStorage3D.apply(i, arguments) } catch (W) { console.error("THREE.WebGLState:", W) } } function X() { try { i.texImage2D.apply(i, arguments) } catch (W) { console.error("THREE.WebGLState:", W) } } function he() { try { i.texImage3D.apply(i, arguments) } catch (W) { console.error("THREE.WebGLState:", W) } } function we(W) { ye.equals(W) === !1 && (i.scissor(W.x, W.y, W.z, W.w), ye.copy(W)) } function be(W) { ge.equals(W) === !1 && (i.viewport(W.x, W.y, W.z, W.w), ge.copy(W)) } function De(W, Oe) { let se = d.get(Oe); se === void 0 && (se = new WeakMap, d.set(Oe, se)); let Se = se.get(W); Se === void 0 && (Se = i.getUniformBlockIndex(Oe, W.name), se.set(W, Se)) } function lt(W, Oe) { const Se = d.get(Oe).get(W); f.get(Oe) !== Se && (i.uniformBlockBinding(Oe, Se, W.__bindingPointIndex), f.set(Oe, Se)) } function vt() { i.disable(i.BLEND), i.disable(i.CULL_FACE), i.disable(i.DEPTH_TEST), i.disable(i.POLYGON_OFFSET_FILL), i.disable(i.SCISSOR_TEST), i.disable(i.STENCIL_TEST), i.disable(i.SAMPLE_ALPHA_TO_COVERAGE), i.blendEquation(i.FUNC_ADD), i.blendFunc(i.ONE, i.ZERO), i.blendFuncSeparate(i.ONE, i.ZERO, i.ONE, i.ZERO), i.colorMask(!0, !0, !0, !0), i.clearColor(0, 0, 0, 0), i.depthMask(!0), i.depthFunc(i.LESS), i.clearDepth(1), i.stencilMask(4294967295), i.stencilFunc(i.ALWAYS, 0, 4294967295), i.stencilOp(i.KEEP, i.KEEP, i.KEEP), i.clearStencil(0), i.cullFace(i.BACK), i.frontFace(i.CCW), i.polygonOffset(0, 0), i.activeTexture(i.TEXTURE0), i.bindFramebuffer(i.FRAMEBUFFER, null), n === !0 && (i.bindFramebuffer(i.DRAW_FRAMEBUFFER, null), i.bindFramebuffer(i.READ_FRAMEBUFFER, null)), i.useProgram(null), i.lineWidth(1), i.scissor(0, 0, i.canvas.width, i.canvas.height), i.viewport(0, 0, i.canvas.width, i.canvas.height), p = {}, Y = null, L = {}, m = {}, y = new WeakMap, _ = [], x = null, g = !1, A = null, M = null, S = null, C = null, T = null, R = null, B = null, b = !1, I = null, N = null, V = null, J = null, j = null, ye.set(0, 0, i.canvas.width, i.canvas.height), ge.set(0, 0, i.canvas.width, i.canvas.height), a.reset(), l.reset(), c.reset() } return { buffers: { color: a, depth: l, stencil: c }, enable: Ie, disable: Je, bindFramebuffer: ut, drawBuffers: Bt, useProgram: Ge, setBlending: fe, setMaterial: Ee, setFlipSided: ve, setCullFace: Z, setLineWidth: Fe, setPolygonOffset: Ve, setScissorTest: st, activeTexture: ot, bindTexture: Yt, unbindTexture: U, compressedTexImage2D: D, compressedTexImage3D: re, texImage2D: X, texImage3D: he, updateUBOMapping: De, uniformBlockBinding: lt, texStorage2D: Te, texStorage3D: oe, texSubImage2D: Ae, texSubImage3D: Me, compressedTexSubImage2D: Ce, compressedTexSubImage3D: qe, scissor: we, viewport: be, reset: vt } } function Cj(i, e, t, n, r, s, o) { const a = r.isWebGL2, l = r.maxTextures, c = r.maxCubemapSize, f = r.maxTextureSize, d = r.maxSamples, p = e.has("WEBGL_multisampled_render_to_texture") ? e.get("WEBGL_multisampled_render_to_texture") : null, m = typeof navigator > "u" ? !1 : /OculusBrowser/g.test(navigator.userAgent), y = new WeakMap; let _; const x = new WeakMap; let g = !1; try { g = typeof OffscreenCanvas < "u" && new OffscreenCanvas(1, 1).getContext("2d") !== null } catch { } function A(U, D) { return g ? new OffscreenCanvas(U, D) : Gp("canvas") } function M(U, D, re, Ae) { let Me = 1; if ((U.width > Ae || U.height > Ae) && (Me = Ae / Math.max(U.width, U.height)), Me < 1 || D === !0) if (typeof HTMLImageElement < "u" && U instanceof HTMLImageElement || typeof HTMLCanvasElement < "u" && U instanceof HTMLCanvasElement || typeof ImageBitmap < "u" && U instanceof ImageBitmap) { const Ce = D ? sv : Math.floor, qe = Ce(Me * U.width), Te = Ce(Me * U.height); _ === void 0 && (_ = A(qe, Te)); const oe = re ? A(qe, Te) : _; return oe.width = qe, oe.height = Te, oe.getContext("2d").drawImage(U, 0, 0, qe, Te), console.warn("THREE.WebGLRenderer: Texture has been resized from (" + U.width + "x" + U.height + ") to (" + qe + "x" + Te + ")."), oe } else return "data" in U && console.warn("THREE.WebGLRenderer: Image in DataTexture is too big (" + U.width + "x" + U.height + ")."), U; return U } function S(U) { return vS(U.width) && vS(U.height) } function C(U) { return a ? !1 : U.wrapS !== Di || U.wrapT !== Di || U.minFilter !== zn && U.minFilter !== Pn } function T(U, D) { return U.generateMipmaps && D && U.minFilter !== zn && U.minFilter !== Pn } function R(U) { i.generateMipmap(U) } function B(U, D, re, Ae, Me = !1) { if (a === !1) return D; if (U !== null) { if (i[U] !== void 0) return i[U]; console.warn("THREE.WebGLRenderer: Attempt to use non-existing WebGL internal format '" + U + "'") } let Ce = D; return D === i.RED && (re === i.FLOAT && (Ce = i.R32F), re === i.HALF_FLOAT && (Ce = i.R16F), re === i.UNSIGNED_BYTE && (Ce = i.R8)), D === i.RED_INTEGER && (re === i.UNSIGNED_BYTE && (Ce = i.R8UI), re === i.UNSIGNED_SHORT && (Ce = i.R16UI), re === i.UNSIGNED_INT && (Ce = i.R32UI), re === i.BYTE && (Ce = i.R8I), re === i.SHORT && (Ce = i.R16I), re === i.INT && (Ce = i.R32I)), D === i.RG && (re === i.FLOAT && (Ce = i.RG32F), re === i.HALF_FLOAT && (Ce = i.RG16F), re === i.UNSIGNED_BYTE && (Ce = i.RG8)), D === i.RGBA && (re === i.FLOAT && (Ce = i.RGBA32F), re === i.HALF_FLOAT && (Ce = i.RGBA16F), re === i.UNSIGNED_BYTE && (Ce = Ae === bt && Me === !1 ? i.SRGB8_ALPHA8 : i.RGBA8), re === i.UNSIGNED_SHORT_4_4_4_4 && (Ce = i.RGBA4), re === i.UNSIGNED_SHORT_5_5_5_1 && (Ce = i.RGB5_A1)), (Ce === i.R16F || Ce === i.R32F || Ce === i.RG16F || Ce === i.RG32F || Ce === i.RGBA16F || Ce === i.RGBA32F) && e.get("EXT_color_buffer_float"), Ce } function b(U, D, re) { return T(U, re) === !0 || U.isFramebufferTexture && U.minFilter !== zn && U.minFilter !== Pn ? Math.log2(Math.max(D.width, D.height)) + 1 : U.mipmaps !== void 0 && U.mipmaps.length > 0 ? U.mipmaps.length : U.isCompressedTexture && Array.isArray(U.image) ? D.mipmaps.length : 1 } function I(U) { return U === zn || U === Np || U === Yf ? i.NEAREST : i.LINEAR } function N(U) { const D = U.target; D.removeEventListener("dispose", N), J(D), D.isVideoTexture && y.delete(D) } function V(U) { const D = U.target; D.removeEventListener("dispose", V), q(D) } function J(U) { const D = n.get(U); if (D.__webglInit === void 0) return; const re = U.source, Ae = x.get(re); if (Ae) { const Me = Ae[D.__cacheKey]; Me.usedTimes--, Me.usedTimes === 0 && j(U), Object.keys(Ae).length === 0 && x.delete(re) } n.remove(U) } function j(U) { const D = n.get(U); i.deleteTexture(D.__webglTexture); const re = U.source, Ae = x.get(re); delete Ae[D.__cacheKey], o.memory.textures-- } function q(U) { const D = U.texture, re = n.get(U), Ae = n.get(D); if (Ae.__webglTexture !== void 0 && (i.deleteTexture(Ae.__webglTexture), o.memory.textures--), U.depthTexture && U.depthTexture.dispose(), U.isWebGLCubeRenderTarget) for (let Me = 0; Me < 6; Me++) { if (Array.isArray(re.__webglFramebuffer[Me])) for (let Ce = 0; Ce < re.__webglFramebuffer[Me].length; Ce++)i.deleteFramebuffer(re.__webglFramebuffer[Me][Ce]); else i.deleteFramebuffer(re.__webglFramebuffer[Me]); re.__webglDepthbuffer && i.deleteRenderbuffer(re.__webglDepthbuffer[Me]) } else { if (Array.isArray(re.__webglFramebuffer)) for (let Me = 0; Me < re.__webglFramebuffer.length; Me++)i.deleteFramebuffer(re.__webglFramebuffer[Me]); else i.deleteFramebuffer(re.__webglFramebuffer); if (re.__webglDepthbuffer && i.deleteRenderbuffer(re.__webglDepthbuffer), re.__webglMultisampledFramebuffer && i.deleteFramebuffer(re.__webglMultisampledFramebuffer), re.__webglColorRenderbuffer) for (let Me = 0; Me < re.__webglColorRenderbuffer.length; Me++)re.__webglColorRenderbuffer[Me] && i.deleteRenderbuffer(re.__webglColorRenderbuffer[Me]); re.__webglDepthRenderbuffer && i.deleteRenderbuffer(re.__webglDepthRenderbuffer) } if (U.isWebGLMultipleRenderTargets) for (let Me = 0, Ce = D.length; Me < Ce; Me++) { const qe = n.get(D[Me]); qe.__webglTexture && (i.deleteTexture(qe.__webglTexture), o.memory.textures--), n.remove(D[Me]) } n.remove(D), n.remove(U) } let ne = 0; function Q() { ne = 0 } function F() { const U = ne; return U >= l && console.warn("THREE.WebGLTextures: Trying to use " + U + " texture units while this GPU supports only " + l), ne += 1, U } function Y(U) { const D = []; return D.push(U.wrapS), D.push(U.wrapT), D.push(U.wrapR || 0), D.push(U.magFilter), D.push(U.minFilter), D.push(U.anisotropy), D.push(U.internalFormat), D.push(U.format), D.push(U.type), D.push(U.generateMipmaps), D.push(U.premultiplyAlpha), D.push(U.flipY), D.push(U.unpackAlignment), D.push(U.colorSpace), D.join() } function L(U, D) { const re = n.get(U); if (U.isVideoTexture && ot(U), U.isRenderTargetTexture === !1 && U.version > 0 && re.__version !== U.version) { const Ae = U.image; if (Ae === null) console.warn("THREE.WebGLRenderer: Texture marked for update but no image data found."); else if (Ae.complete === !1) console.warn("THREE.WebGLRenderer: Texture marked for update but image is incomplete"); else { ut(re, U, D); return } } t.bindTexture(i.TEXTURE_2D, re.__webglTexture, i.TEXTURE0 + D) } function G(U, D) { const re = n.get(U); if (U.version > 0 && re.__version !== U.version) { ut(re, U, D); return } t.bindTexture(i.TEXTURE_2D_ARRAY, re.__webglTexture, i.TEXTURE0 + D) } function K(U, D) { const re = n.get(U); if (U.version > 0 && re.__version !== U.version) { ut(re, U, D); return } t.bindTexture(i.TEXTURE_3D, re.__webglTexture, i.TEXTURE0 + D) } function ye(U, D) { const re = n.get(U); if (U.version > 0 && re.__version !== U.version) { Bt(re, U, D); return } t.bindTexture(i.TEXTURE_CUBE_MAP, re.__webglTexture, i.TEXTURE0 + D) } const ge = { [Ul]: i.REPEAT, [Di]: i.CLAMP_TO_EDGE, [mh]: i.MIRRORED_REPEAT }, xe = { [zn]: i.NEAREST, [Np]: i.NEAREST_MIPMAP_NEAREST, [Yf]: i.NEAREST_MIPMAP_LINEAR, [Pn]: i.LINEAR, [Fv]: i.LINEAR_MIPMAP_NEAREST, [Yo]: i.LINEAR_MIPMAP_LINEAR }, Be = { [hF]: i.NEVER, [_F]: i.ALWAYS, [dF]: i.LESS, [mF]: i.LEQUAL, [pF]: i.EQUAL, [vF]: i.GEQUAL, [gF]: i.GREATER, [yF]: i.NOTEQUAL }; function Ie(U, D, re) { if (re ? (i.texParameteri(U, i.TEXTURE_WRAP_S, ge[D.wrapS]), i.texParameteri(U, i.TEXTURE_WRAP_T, ge[D.wrapT]), (U === i.TEXTURE_3D || U === i.TEXTURE_2D_ARRAY) && i.texParameteri(U, i.TEXTURE_WRAP_R, ge[D.wrapR]), i.texParameteri(U, i.TEXTURE_MAG_FILTER, xe[D.magFilter]), i.texParameteri(U, i.TEXTURE_MIN_FILTER, xe[D.minFilter])) : (i.texParameteri(U, i.TEXTURE_WRAP_S, i.CLAMP_TO_EDGE), i.texParameteri(U, i.TEXTURE_WRAP_T, i.CLAMP_TO_EDGE), (U === i.TEXTURE_3D || U === i.TEXTURE_2D_ARRAY) && i.texParameteri(U, i.TEXTURE_WRAP_R, i.CLAMP_TO_EDGE), (D.wrapS !== Di || D.wrapT !== Di) && console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.wrapS and Texture.wrapT should be set to THREE.ClampToEdgeWrapping."), i.texParameteri(U, i.TEXTURE_MAG_FILTER, I(D.magFilter)), i.texParameteri(U, i.TEXTURE_MIN_FILTER, I(D.minFilter)), D.minFilter !== zn && D.minFilter !== Pn && console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.minFilter should be set to THREE.NearestFilter or THREE.LinearFilter.")), D.compareFunction && (i.texParameteri(U, i.TEXTURE_COMPARE_MODE, i.COMPARE_REF_TO_TEXTURE), i.texParameteri(U, i.TEXTURE_COMPARE_FUNC, Be[D.compareFunction])), e.has("EXT_texture_filter_anisotropic") === !0) { const Ae = e.get("EXT_texture_filter_anisotropic"); if (D.magFilter === zn || D.minFilter !== Yf && D.minFilter !== Yo || D.type === Do && e.has("OES_texture_float_linear") === !1 || a === !1 && D.type === gh && e.has("OES_texture_half_float_linear") === !1) return; (D.anisotropy > 1 || n.get(D).__currentAnisotropy) && (i.texParameterf(U, Ae.TEXTURE_MAX_ANISOTROPY_EXT, Math.min(D.anisotropy, r.getMaxAnisotropy())), n.get(D).__currentAnisotropy = D.anisotropy) } } function Je(U, D) { let re = !1; U.__webglInit === void 0 && (U.__webglInit = !0, D.addEventListener("dispose", N)); const Ae = D.source; let Me = x.get(Ae); Me === void 0 && (Me = {}, x.set(Ae, Me)); const Ce = Y(D); if (Ce !== U.__cacheKey) { Me[Ce] === void 0 && (Me[Ce] = { texture: i.createTexture(), usedTimes: 0 }, o.memory.textures++, re = !0), Me[Ce].usedTimes++; const qe = Me[U.__cacheKey]; qe !== void 0 && (Me[U.__cacheKey].usedTimes--, qe.usedTimes === 0 && j(D)), U.__cacheKey = Ce, U.__webglTexture = Me[Ce].texture } return re } function ut(U, D, re) { let Ae = i.TEXTURE_2D; (D.isDataArrayTexture || D.isCompressedArrayTexture) && (Ae = i.TEXTURE_2D_ARRAY), D.isData3DTexture && (Ae = i.TEXTURE_3D); const Me = Je(U, D), Ce = D.source; t.bindTexture(Ae, U.__webglTexture, i.TEXTURE0 + re); const qe = n.get(Ce); if (Ce.version !== qe.__version || Me === !0) { t.activeTexture(i.TEXTURE0 + re), i.pixelStorei(i.UNPACK_FLIP_Y_WEBGL, D.flipY), i.pixelStorei(i.UNPACK_PREMULTIPLY_ALPHA_WEBGL, D.premultiplyAlpha), i.pixelStorei(i.UNPACK_ALIGNMENT, D.unpackAlignment), i.pixelStorei(i.UNPACK_COLORSPACE_CONVERSION_WEBGL, i.NONE); const Te = C(D) && S(D.image) === !1; let oe = M(D.image, Te, !1, f); oe = Yt(D, oe); const X = S(oe) || a, he = s.convert(D.format, D.colorSpace); let we = s.convert(D.type), be = B(D.internalFormat, he, we, D.colorSpace); Ie(Ae, D, X); let De; const lt = D.mipmaps, vt = a && D.isVideoTexture !== !0, W = qe.__version === void 0 || Me === !0, Oe = b(D, oe, X); if (D.isDepthTexture) be = i.DEPTH_COMPONENT, a ? D.type === Do ? be = i.DEPTH_COMPONENT32F : D.type === Aa ? be = i.DEPTH_COMPONENT24 : D.type === bl ? be = i.DEPTH24_STENCIL8 : be = i.DEPTH_COMPONENT16 : D.type === Do && console.error("WebGLRenderer: Floating point depth texture requires WebGL2."), D.format === Rl && be === i.DEPTH_COMPONENT && D.type !== kv && D.type !== Aa && (console.warn("THREE.WebGLRenderer: Use UnsignedShortType or UnsignedIntType for DepthFormat DepthTexture."), D.type = Aa, we = s.convert(D.type)), D.format === au && be === i.DEPTH_COMPONENT && (be = i.DEPTH_STENCIL, D.type !== bl && (console.warn("THREE.WebGLRenderer: Use UnsignedInt248Type for DepthStencilFormat DepthTexture."), D.type = bl, we = s.convert(D.type))), W && (vt ? t.texStorage2D(i.TEXTURE_2D, 1, be, oe.width, oe.height) : t.texImage2D(i.TEXTURE_2D, 0, be, oe.width, oe.height, 0, he, we, null)); else if (D.isDataTexture) if (lt.length > 0 && X) { vt && W && t.texStorage2D(i.TEXTURE_2D, Oe, be, lt[0].width, lt[0].height); for (let se = 0, Se = lt.length; se < Se; se++)De = lt[se], vt ? t.texSubImage2D(i.TEXTURE_2D, se, 0, 0, De.width, De.height, he, we, De.data) : t.texImage2D(i.TEXTURE_2D, se, be, De.width, De.height, 0, he, we, De.data); D.generateMipmaps = !1 } else vt ? (W && t.texStorage2D(i.TEXTURE_2D, Oe, be, oe.width, oe.height), t.texSubImage2D(i.TEXTURE_2D, 0, 0, 0, oe.width, oe.height, he, we, oe.data)) : t.texImage2D(i.TEXTURE_2D, 0, be, oe.width, oe.height, 0, he, we, oe.data); else if (D.isCompressedTexture) if (D.isCompressedArrayTexture) { vt && W && t.texStorage3D(i.TEXTURE_2D_ARRAY, Oe, be, lt[0].width, lt[0].height, oe.depth); for (let se = 0, Se = lt.length; se < Se; se++)De = lt[se], D.format !== Pr ? he !== null ? vt ? t.compressedTexSubImage3D(i.TEXTURE_2D_ARRAY, se, 0, 0, 0, De.width, De.height, oe.depth, he, De.data, 0, 0) : t.compressedTexImage3D(i.TEXTURE_2D_ARRAY, se, be, De.width, De.height, oe.depth, 0, De.data, 0, 0) : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()") : vt ? t.texSubImage3D(i.TEXTURE_2D_ARRAY, se, 0, 0, 0, De.width, De.height, oe.depth, he, we, De.data) : t.texImage3D(i.TEXTURE_2D_ARRAY, se, be, De.width, De.height, oe.depth, 0, he, we, De.data) } else { vt && W && t.texStorage2D(i.TEXTURE_2D, Oe, be, lt[0].width, lt[0].height); for (let se = 0, Se = lt.length; se < Se; se++)De = lt[se], D.format !== Pr ? he !== null ? vt ? t.compressedTexSubImage2D(i.TEXTURE_2D, se, 0, 0, De.width, De.height, he, De.data) : t.compressedTexImage2D(i.TEXTURE_2D, se, be, De.width, De.height, 0, De.data) : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()") : vt ? t.texSubImage2D(i.TEXTURE_2D, se, 0, 0, De.width, De.height, he, we, De.data) : t.texImage2D(i.TEXTURE_2D, se, be, De.width, De.height, 0, he, we, De.data) } else if (D.isDataArrayTexture) vt ? (W && t.texStorage3D(i.TEXTURE_2D_ARRAY, Oe, be, oe.width, oe.height, oe.depth), t.texSubImage3D(i.TEXTURE_2D_ARRAY, 0, 0, 0, 0, oe.width, oe.height, oe.depth, he, we, oe.data)) : t.texImage3D(i.TEXTURE_2D_ARRAY, 0, be, oe.width, oe.height, oe.depth, 0, he, we, oe.data); else if (D.isData3DTexture) vt ? (W && t.texStorage3D(i.TEXTURE_3D, Oe, be, oe.width, oe.height, oe.depth), t.texSubImage3D(i.TEXTURE_3D, 0, 0, 0, 0, oe.width, oe.height, oe.depth, he, we, oe.data)) : t.texImage3D(i.TEXTURE_3D, 0, be, oe.width, oe.height, oe.depth, 0, he, we, oe.data); else if (D.isFramebufferTexture) { if (W) if (vt) t.texStorage2D(i.TEXTURE_2D, Oe, be, oe.width, oe.height); else { let se = oe.width, Se = oe.height; for (let ke = 0; ke < Oe; ke++)t.texImage2D(i.TEXTURE_2D, ke, be, se, Se, 0, he, we, null), se >>= 1, Se >>= 1 } } else if (lt.length > 0 && X) { vt && W && t.texStorage2D(i.TEXTURE_2D, Oe, be, lt[0].width, lt[0].height); for (let se = 0, Se = lt.length; se < Se; se++)De = lt[se], vt ? t.texSubImage2D(i.TEXTURE_2D, se, 0, 0, he, we, De) : t.texImage2D(i.TEXTURE_2D, se, be, he, we, De); D.generateMipmaps = !1 } else vt ? (W && t.texStorage2D(i.TEXTURE_2D, Oe, be, oe.width, oe.height), t.texSubImage2D(i.TEXTURE_2D, 0, 0, 0, he, we, oe)) : t.texImage2D(i.TEXTURE_2D, 0, be, he, we, oe); T(D, X) && R(Ae), qe.__version = Ce.version, D.onUpdate && D.onUpdate(D) } U.__version = D.version } function Bt(U, D, re) { if (D.image.length !== 6) return; const Ae = Je(U, D), Me = D.source; t.bindTexture(i.TEXTURE_CUBE_MAP, U.__webglTexture, i.TEXTURE0 + re); const Ce = n.get(Me); if (Me.version !== Ce.__version || Ae === !0) { t.activeTexture(i.TEXTURE0 + re), i.pixelStorei(i.UNPACK_FLIP_Y_WEBGL, D.flipY), i.pixelStorei(i.UNPACK_PREMULTIPLY_ALPHA_WEBGL, D.premultiplyAlpha), i.pixelStorei(i.UNPACK_ALIGNMENT, D.unpackAlignment), i.pixelStorei(i.UNPACK_COLORSPACE_CONVERSION_WEBGL, i.NONE); const qe = D.isCompressedTexture || D.image[0].isCompressedTexture, Te = D.image[0] && D.image[0].isDataTexture, oe = []; for (let se = 0; se < 6; se++)!qe && !Te ? oe[se] = M(D.image[se], !1, !0, c) : oe[se] = Te ? D.image[se].image : D.image[se], oe[se] = Yt(D, oe[se]); const X = oe[0], he = S(X) || a, we = s.convert(D.format, D.colorSpace), be = s.convert(D.type), De = B(D.internalFormat, we, be, D.colorSpace), lt = a && D.isVideoTexture !== !0, vt = Ce.__version === void 0 || Ae === !0; let W = b(D, X, he); Ie(i.TEXTURE_CUBE_MAP, D, he); let Oe; if (qe) { lt && vt && t.texStorage2D(i.TEXTURE_CUBE_MAP, W, De, X.width, X.height); for (let se = 0; se < 6; se++) { Oe = oe[se].mipmaps; for (let Se = 0; Se < Oe.length; Se++) { const ke = Oe[Se]; D.format !== Pr ? we !== null ? lt ? t.compressedTexSubImage2D(i.TEXTURE_CUBE_MAP_POSITIVE_X + se, Se, 0, 0, ke.width, ke.height, we, ke.data) : t.compressedTexImage2D(i.TEXTURE_CUBE_MAP_POSITIVE_X + se, Se, De, ke.width, ke.height, 0, ke.data) : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()") : lt ? t.texSubImage2D(i.TEXTURE_CUBE_MAP_POSITIVE_X + se, Se, 0, 0, ke.width, ke.height, we, be, ke.data) : t.texImage2D(i.TEXTURE_CUBE_MAP_POSITIVE_X + se, Se, De, ke.width, ke.height, 0, we, be, ke.data) } } } else { Oe = D.mipmaps, lt && vt && (Oe.length > 0 && W++, t.texStorage2D(i.TEXTURE_CUBE_MAP, W, De, oe[0].width, oe[0].height)); for (let se = 0; se < 6; se++)if (Te) { lt ? t.texSubImage2D(i.TEXTURE_CUBE_MAP_POSITIVE_X + se, 0, 0, 0, oe[se].width, oe[se].height, we, be, oe[se].data) : t.texImage2D(i.TEXTURE_CUBE_MAP_POSITIVE_X + se, 0, De, oe[se].width, oe[se].height, 0, we, be, oe[se].data); for (let Se = 0; Se < Oe.length; Se++) { const St = Oe[Se].image[se].image; lt ? t.texSubImage2D(i.TEXTURE_CUBE_MAP_POSITIVE_X + se, Se + 1, 0, 0, St.width, St.height, we, be, St.data) : t.texImage2D(i.TEXTURE_CUBE_MAP_POSITIVE_X + se, Se + 1, De, St.width, St.height, 0, we, be, St.data) } } else { lt ? t.texSubImage2D(i.TEXTURE_CUBE_MAP_POSITIVE_X + se, 0, 0, 0, we, be, oe[se]) : t.texImage2D(i.TEXTURE_CUBE_MAP_POSITIVE_X + se, 0, De, we, be, oe[se]); for (let Se = 0; Se < Oe.length; Se++) { const ke = Oe[Se]; lt ? t.texSubImage2D(i.TEXTURE_CUBE_MAP_POSITIVE_X + se, Se + 1, 0, 0, we, be, ke.image[se]) : t.texImage2D(i.TEXTURE_CUBE_MAP_POSITIVE_X + se, Se + 1, De, we, be, ke.image[se]) } } } T(D, he) && R(i.TEXTURE_CUBE_MAP), Ce.__version = Me.version, D.onUpdate && D.onUpdate(D) } U.__version = D.version } function Ge(U, D, re, Ae, Me, Ce) { const qe = s.convert(re.format, re.colorSpace), Te = s.convert(re.type), oe = B(re.internalFormat, qe, Te, re.colorSpace); if (!n.get(D).__hasExternalTextures) { const he = Math.max(1, D.width >> Ce), we = Math.max(1, D.height >> Ce); Me === i.TEXTURE_3D || Me === i.TEXTURE_2D_ARRAY ? t.texImage3D(Me, Ce, oe, he, we, D.depth, 0, qe, Te, null) : t.texImage2D(Me, Ce, oe, he, we, 0, qe, Te, null) } t.bindFramebuffer(i.FRAMEBUFFER, U), st(D) ? p.framebufferTexture2DMultisampleEXT(i.FRAMEBUFFER, Ae, Me, n.get(re).__webglTexture, 0, Ve(D)) : (Me === i.TEXTURE_2D || Me >= i.TEXTURE_CUBE_MAP_POSITIVE_X && Me <= i.TEXTURE_CUBE_MAP_NEGATIVE_Z) && i.framebufferTexture2D(i.FRAMEBUFFER, Ae, Me, n.get(re).__webglTexture, Ce), t.bindFramebuffer(i.FRAMEBUFFER, null) } function H(U, D, re) { if (i.bindRenderbuffer(i.RENDERBUFFER, U), D.depthBuffer && !D.stencilBuffer) { let Ae = i.DEPTH_COMPONENT16; if (re || st(D)) { const Me = D.depthTexture; Me && Me.isDepthTexture && (Me.type === Do ? Ae = i.DEPTH_COMPONENT32F : Me.type === Aa && (Ae = i.DEPTH_COMPONENT24)); const Ce = Ve(D); st(D) ? p.renderbufferStorageMultisampleEXT(i.RENDERBUFFER, Ce, Ae, D.width, D.height) : i.renderbufferStorageMultisample(i.RENDERBUFFER, Ce, Ae, D.width, D.height) } else i.renderbufferStorage(i.RENDERBUFFER, Ae, D.width, D.height); i.framebufferRenderbuffer(i.FRAMEBUFFER, i.DEPTH_ATTACHMENT, i.RENDERBUFFER, U) } else if (D.depthBuffer && D.stencilBuffer) { const Ae = Ve(D); re && st(D) === !1 ? i.renderbufferStorageMultisample(i.RENDERBUFFER, Ae, i.DEPTH24_STENCIL8, D.width, D.height) : st(D) ? p.renderbufferStorageMultisampleEXT(i.RENDERBUFFER, Ae, i.DEPTH24_STENCIL8, D.width, D.height) : i.renderbufferStorage(i.RENDERBUFFER, i.DEPTH_STENCIL, D.width, D.height), i.framebufferRenderbuffer(i.FRAMEBUFFER, i.DEPTH_STENCIL_ATTACHMENT, i.RENDERBUFFER, U) } else { const Ae = D.isWebGLMultipleRenderTargets === !0 ? D.texture : [D.texture]; for (let Me = 0; Me < Ae.length; Me++) { const Ce = Ae[Me], qe = s.convert(Ce.format, Ce.colorSpace), Te = s.convert(Ce.type), oe = B(Ce.internalFormat, qe, Te, Ce.colorSpace), X = Ve(D); re && st(D) === !1 ? i.renderbufferStorageMultisample(i.RENDERBUFFER, X, oe, D.width, D.height) : st(D) ? p.renderbufferStorageMultisampleEXT(i.RENDERBUFFER, X, oe, D.width, D.height) : i.renderbufferStorage(i.RENDERBUFFER, oe, D.width, D.height) } } i.bindRenderbuffer(i.RENDERBUFFER, null) } function pe(U, D) { if (D && D.isWebGLCubeRenderTarget) throw new Error("Depth Texture with cube render targets is not supported"); if (t.bindFramebuffer(i.FRAMEBUFFER, U), !(D.depthTexture && D.depthTexture.isDepthTexture)) throw new Error("renderTarget.depthTexture must be an instance of THREE.DepthTexture"); (!n.get(D.depthTexture).__webglTexture || D.depthTexture.image.width !== D.width || D.depthTexture.image.height !== D.height) && (D.depthTexture.image.width = D.width, D.depthTexture.image.height = D.height, D.depthTexture.needsUpdate = !0), L(D.depthTexture, 0); const Ae = n.get(D.depthTexture).__webglTexture, Me = Ve(D); if (D.depthTexture.format === Rl) st(D) ? p.framebufferTexture2DMultisampleEXT(i.FRAMEBUFFER, i.DEPTH_ATTACHMENT, i.TEXTURE_2D, Ae, 0, Me) : i.framebufferTexture2D(i.FRAMEBUFFER, i.DEPTH_ATTACHMENT, i.TEXTURE_2D, Ae, 0); else if (D.depthTexture.format === au) st(D) ? p.framebufferTexture2DMultisampleEXT(i.FRAMEBUFFER, i.DEPTH_STENCIL_ATTACHMENT, i.TEXTURE_2D, Ae, 0, Me) : i.framebufferTexture2D(i.FRAMEBUFFER, i.DEPTH_STENCIL_ATTACHMENT, i.TEXTURE_2D, Ae, 0); else throw new Error("Unknown depthTexture format") } function fe(U) { const D = n.get(U), re = U.isWebGLCubeRenderTarget === !0; if (U.depthTexture && !D.__autoAllocateDepthBuffer) { if (re) throw new Error("target.depthTexture not supported in Cube render targets"); pe(D.__webglFramebuffer, U) } else if (re) { D.__webglDepthbuffer = []; for (let Ae = 0; Ae < 6; Ae++)t.bindFramebuffer(i.FRAMEBUFFER, D.__webglFramebuffer[Ae]), D.__webglDepthbuffer[Ae] = i.createRenderbuffer(), H(D.__webglDepthbuffer[Ae], U, !1) } else t.bindFramebuffer(i.FRAMEBUFFER, D.__webglFramebuffer), D.__webglDepthbuffer = i.createRenderbuffer(), H(D.__webglDepthbuffer, U, !1); t.bindFramebuffer(i.FRAMEBUFFER, null) } function Ee(U, D, re) { const Ae = n.get(U); D !== void 0 && Ge(Ae.__webglFramebuffer, U, U.texture, i.COLOR_ATTACHMENT0, i.TEXTURE_2D, 0), re !== void 0 && fe(U) } function ve(U) { const D = U.texture, re = n.get(U), Ae = n.get(D); U.addEventListener("dispose", V), U.isWebGLMultipleRenderTargets !== !0 && (Ae.__webglTexture === void 0 && (Ae.__webglTexture = i.createTexture()), Ae.__version = D.version, o.memory.textures++); const Me = U.isWebGLCubeRenderTarget === !0, Ce = U.isWebGLMultipleRenderTargets === !0, qe = S(U) || a; if (Me) { re.__webglFramebuffer = []; for (let Te = 0; Te < 6; Te++)if (a && D.mipmaps && D.mipmaps.length > 0) { re.__webglFramebuffer[Te] = []; for (let oe = 0; oe < D.mipmaps.length; oe++)re.__webglFramebuffer[Te][oe] = i.createFramebuffer() } else re.__webglFramebuffer[Te] = i.createFramebuffer() } else { if (a && D.mipmaps && D.mipmaps.length > 0) { re.__webglFramebuffer = []; for (let Te = 0; Te < D.mipmaps.length; Te++)re.__webglFramebuffer[Te] = i.createFramebuffer() } else re.__webglFramebuffer = i.createFramebuffer(); if (Ce) if (r.drawBuffers) { const Te = U.texture; for (let oe = 0, X = Te.length; oe < X; oe++) { const he = n.get(Te[oe]); he.__webglTexture === void 0 && (he.__webglTexture = i.createTexture(), o.memory.textures++) } } else console.warn("THREE.WebGLRenderer: WebGLMultipleRenderTargets can only be used with WebGL2 or WEBGL_draw_buffers extension."); if (a && U.samples > 0 && st(U) === !1) { const Te = Ce ? D : [D]; re.__webglMultisampledFramebuffer = i.createFramebuffer(), re.__webglColorRenderbuffer = [], t.bindFramebuffer(i.FRAMEBUFFER, re.__webglMultisampledFramebuffer); for (let oe = 0; oe < Te.length; oe++) { const X = Te[oe]; re.__webglColorRenderbuffer[oe] = i.createRenderbuffer(), i.bindRenderbuffer(i.RENDERBUFFER, re.__webglColorRenderbuffer[oe]); const he = s.convert(X.format, X.colorSpace), we = s.convert(X.type), be = B(X.internalFormat, he, we, X.colorSpace, U.isXRRenderTarget === !0), De = Ve(U); i.renderbufferStorageMultisample(i.RENDERBUFFER, De, be, U.width, U.height), i.framebufferRenderbuffer(i.FRAMEBUFFER, i.COLOR_ATTACHMENT0 + oe, i.RENDERBUFFER, re.__webglColorRenderbuffer[oe]) } i.bindRenderbuffer(i.RENDERBUFFER, null), U.depthBuffer && (re.__webglDepthRenderbuffer = i.createRenderbuffer(), H(re.__webglDepthRenderbuffer, U, !0)), t.bindFramebuffer(i.FRAMEBUFFER, null) } } if (Me) { t.bindTexture(i.TEXTURE_CUBE_MAP, Ae.__webglTexture), Ie(i.TEXTURE_CUBE_MAP, D, qe); for (let Te = 0; Te < 6; Te++)if (a && D.mipmaps && D.mipmaps.length > 0) for (let oe = 0; oe < D.mipmaps.length; oe++)Ge(re.__webglFramebuffer[Te][oe], U, D, i.COLOR_ATTACHMENT0, i.TEXTURE_CUBE_MAP_POSITIVE_X + Te, oe); else Ge(re.__webglFramebuffer[Te], U, D, i.COLOR_ATTACHMENT0, i.TEXTURE_CUBE_MAP_POSITIVE_X + Te, 0); T(D, qe) && R(i.TEXTURE_CUBE_MAP), t.unbindTexture() } else if (Ce) { const Te = U.texture; for (let oe = 0, X = Te.length; oe < X; oe++) { const he = Te[oe], we = n.get(he); t.bindTexture(i.TEXTURE_2D, we.__webglTexture), Ie(i.TEXTURE_2D, he, qe), Ge(re.__webglFramebuffer, U, he, i.COLOR_ATTACHMENT0 + oe, i.TEXTURE_2D, 0), T(he, qe) && R(i.TEXTURE_2D) } t.unbindTexture() } else { let Te = i.TEXTURE_2D; if ((U.isWebGL3DRenderTarget || U.isWebGLArrayRenderTarget) && (a ? Te = U.isWebGL3DRenderTarget ? i.TEXTURE_3D : i.TEXTURE_2D_ARRAY : console.error("THREE.WebGLTextures: THREE.Data3DTexture and THREE.DataArrayTexture only supported with WebGL2.")), t.bindTexture(Te, Ae.__webglTexture), Ie(Te, D, qe), a && D.mipmaps && D.mipmaps.length > 0) for (let oe = 0; oe < D.mipmaps.length; oe++)Ge(re.__webglFramebuffer[oe], U, D, i.COLOR_ATTACHMENT0, Te, oe); else Ge(re.__webglFramebuffer, U, D, i.COLOR_ATTACHMENT0, Te, 0); T(D, qe) && R(Te), t.unbindTexture() } U.depthBuffer && fe(U) } function Z(U) { const D = S(U) || a, re = U.isWebGLMultipleRenderTargets === !0 ? U.texture : [U.texture]; for (let Ae = 0, Me = re.length; Ae < Me; Ae++) { const Ce = re[Ae]; if (T(Ce, D)) { const qe = U.isWebGLCubeRenderTarget ? i.TEXTURE_CUBE_MAP : i.TEXTURE_2D, Te = n.get(Ce).__webglTexture; t.bindTexture(qe, Te), R(qe), t.unbindTexture() } } } function Fe(U) { if (a && U.samples > 0 && st(U) === !1) { const D = U.isWebGLMultipleRenderTargets ? U.texture : [U.texture], re = U.width, Ae = U.height; let Me = i.COLOR_BUFFER_BIT; const Ce = [], qe = U.stencilBuffer ? i.DEPTH_STENCIL_ATTACHMENT : i.DEPTH_ATTACHMENT, Te = n.get(U), oe = U.isWebGLMultipleRenderTargets === !0; if (oe) for (let X = 0; X < D.length; X++)t.bindFramebuffer(i.FRAMEBUFFER, Te.__webglMultisampledFramebuffer), i.framebufferRenderbuffer(i.FRAMEBUFFER, i.COLOR_ATTACHMENT0 + X, i.RENDERBUFFER, null), t.bindFramebuffer(i.FRAMEBUFFER, Te.__webglFramebuffer), i.framebufferTexture2D(i.DRAW_FRAMEBUFFER, i.COLOR_ATTACHMENT0 + X, i.TEXTURE_2D, null, 0); t.bindFramebuffer(i.READ_FRAMEBUFFER, Te.__webglMultisampledFramebuffer), t.bindFramebuffer(i.DRAW_FRAMEBUFFER, Te.__webglFramebuffer); for (let X = 0; X < D.length; X++) { Ce.push(i.COLOR_ATTACHMENT0 + X), U.depthBuffer && Ce.push(qe); const he = Te.__ignoreDepthValues !== void 0 ? Te.__ignoreDepthValues : !1; if (he === !1 && (U.depthBuffer && (Me |= i.DEPTH_BUFFER_BIT), U.stencilBuffer && (Me |= i.STENCIL_BUFFER_BIT)), oe && i.framebufferRenderbuffer(i.READ_FRAMEBUFFER, i.COLOR_ATTACHMENT0, i.RENDERBUFFER, Te.__webglColorRenderbuffer[X]), he === !0 && (i.invalidateFramebuffer(i.READ_FRAMEBUFFER, [qe]), i.invalidateFramebuffer(i.DRAW_FRAMEBUFFER, [qe])), oe) { const we = n.get(D[X]).__webglTexture; i.framebufferTexture2D(i.DRAW_FRAMEBUFFER, i.COLOR_ATTACHMENT0, i.TEXTURE_2D, we, 0) } i.blitFramebuffer(0, 0, re, Ae, 0, 0, re, Ae, Me, i.NEAREST), m && i.invalidateFramebuffer(i.READ_FRAMEBUFFER, Ce) } if (t.bindFramebuffer(i.READ_FRAMEBUFFER, null), t.bindFramebuffer(i.DRAW_FRAMEBUFFER, null), oe) for (let X = 0; X < D.length; X++) { t.bindFramebuffer(i.FRAMEBUFFER, Te.__webglMultisampledFramebuffer), i.framebufferRenderbuffer(i.FRAMEBUFFER, i.COLOR_ATTACHMENT0 + X, i.RENDERBUFFER, Te.__webglColorRenderbuffer[X]); const he = n.get(D[X]).__webglTexture; t.bindFramebuffer(i.FRAMEBUFFER, Te.__webglFramebuffer), i.framebufferTexture2D(i.DRAW_FRAMEBUFFER, i.COLOR_ATTACHMENT0 + X, i.TEXTURE_2D, he, 0) } t.bindFramebuffer(i.DRAW_FRAMEBUFFER, Te.__webglMultisampledFramebuffer) } } function Ve(U) { return Math.min(d, U.samples) } function st(U) { const D = n.get(U); return a && U.samples > 0 && e.has("WEBGL_multisampled_render_to_texture") === !0 && D.__useRenderToTexture !== !1 } function ot(U) { const D = o.render.frame; y.get(U) !== D && (y.set(U, D), U.update()) } function Yt(U, D) { const re = U.colorSpace, Ae = U.format, Me = U.type; return U.isCompressedTexture === !0 || U.format === rv || re !== po && re !== Il && (re === bt ? a === !1 ? e.has("EXT_sRGB") === !0 && Ae === Pr ? (U.format = rv, U.minFilter = Pn, U.generateMipmaps = !1) : D = AE.sRGBToLinear(D) : (Ae !== Pr || Me !== Go) && console.warn("THREE.WebGLTextures: sRGB encoded textures have to use RGBAFormat and UnsignedByteType.") : console.error("THREE.WebGLTextures: Unsupported texture color space:", re)), D } this.allocateTextureUnit = F, this.resetTextureUnits = Q, this.setTexture2D = L, this.setTexture2DArray = G, this.setTexture3D = K, this.setTextureCube = ye, this.rebindTextures = Ee, this.setupRenderTarget = ve, this.updateRenderTargetMipmap = Z, this.updateMultisampleRenderTarget = Fe, this.setupDepthRenderbuffer = fe, this.setupFrameBufferTexture = Ge, this.useMultisampledRTT = st } function DF(i, e, t) { const n = t.isWebGL2; function r(s, o = Il) { let a; if (s === Go) return i.UNSIGNED_BYTE; if (s === fE) return i.UNSIGNED_SHORT_4_4_4_4; if (s === hE) return i.UNSIGNED_SHORT_5_5_5_1; if (s === KO) return i.BYTE; if (s === qO) return i.SHORT; if (s === kv) return i.UNSIGNED_SHORT; if (s === uE) return i.INT; if (s === Aa) return i.UNSIGNED_INT; if (s === Do) return i.FLOAT; if (s === gh) return n ? i.HALF_FLOAT : (a = e.get("OES_texture_half_float"), a !== null ? a.HALF_FLOAT_OES : null); if (s === QO) return i.ALPHA; if (s === Pr) return i.RGBA; if (s === ZO) return i.LUMINANCE; if (s === $O) return i.LUMINANCE_ALPHA; if (s === Rl) return i.DEPTH_COMPONENT; if (s === au) return i.DEPTH_STENCIL; if (s === rv) return a = e.get("EXT_sRGB"), a !== null ? a.SRGB_ALPHA_EXT : null; if (s === eF) return i.RED; if (s === dE) return i.RED_INTEGER; if (s === tF) return i.RG; if (s === pE) return i.RG_INTEGER; if (s === mE) return i.RGBA_INTEGER; if (s === ry || s === sy || s === oy || s === ay) if (o === bt) if (a = e.get("WEBGL_compressed_texture_s3tc_srgb"), a !== null) { if (s === ry) return a.COMPRESSED_SRGB_S3TC_DXT1_EXT; if (s === sy) return a.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT; if (s === oy) return a.COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT; if (s === ay) return a.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT } else return null; else if (a = e.get("WEBGL_compressed_texture_s3tc"), a !== null) { if (s === ry) return a.COMPRESSED_RGB_S3TC_DXT1_EXT; if (s === sy) return a.COMPRESSED_RGBA_S3TC_DXT1_EXT; if (s === oy) return a.COMPRESSED_RGBA_S3TC_DXT3_EXT; if (s === ay) return a.COMPRESSED_RGBA_S3TC_DXT5_EXT } else return null; if (s === jw || s === Kw || s === qw || s === Qw) if (a = e.get("WEBGL_compressed_texture_pvrtc"), a !== null) { if (s === jw) return a.COMPRESSED_RGB_PVRTC_4BPPV1_IMG; if (s === Kw) return a.COMPRESSED_RGB_PVRTC_2BPPV1_IMG; if (s === qw) return a.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG; if (s === Qw) return a.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG } else return null; if (s === nF) return a = e.get("WEBGL_compressed_texture_etc1"), a !== null ? a.COMPRESSED_RGB_ETC1_WEBGL : null; if (s === Zw || s === $w) if (a = e.get("WEBGL_compressed_texture_etc"), a !== null) { if (s === Zw) return o === bt ? a.COMPRESSED_SRGB8_ETC2 : a.COMPRESSED_RGB8_ETC2; if (s === $w) return o === bt ? a.COMPRESSED_SRGB8_ALPHA8_ETC2_EAC : a.COMPRESSED_RGBA8_ETC2_EAC } else return null; if (s === eS || s === tS || s === nS || s === iS || s === rS || s === sS || s === oS || s === aS || s === lS || s === cS || s === uS || s === fS || s === hS || s === dS) if (a = e.get("WEBGL_compressed_texture_astc"), a !== null) { if (s === eS) return o === bt ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR : a.COMPRESSED_RGBA_ASTC_4x4_KHR; if (s === tS) return o === bt ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR : a.COMPRESSED_RGBA_ASTC_5x4_KHR; if (s === nS) return o === bt ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR : a.COMPRESSED_RGBA_ASTC_5x5_KHR; if (s === iS) return o === bt ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR : a.COMPRESSED_RGBA_ASTC_6x5_KHR; if (s === rS) return o === bt ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR : a.COMPRESSED_RGBA_ASTC_6x6_KHR; if (s === sS) return o === bt ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR : a.COMPRESSED_RGBA_ASTC_8x5_KHR; if (s === oS) return o === bt ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR : a.COMPRESSED_RGBA_ASTC_8x6_KHR; if (s === aS) return o === bt ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR : a.COMPRESSED_RGBA_ASTC_8x8_KHR; if (s === lS) return o === bt ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR : a.COMPRESSED_RGBA_ASTC_10x5_KHR; if (s === cS) return o === bt ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR : a.COMPRESSED_RGBA_ASTC_10x6_KHR; if (s === uS) return o === bt ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR : a.COMPRESSED_RGBA_ASTC_10x8_KHR; if (s === fS) return o === bt ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR : a.COMPRESSED_RGBA_ASTC_10x10_KHR; if (s === hS) return o === bt ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR : a.COMPRESSED_RGBA_ASTC_12x10_KHR; if (s === dS) return o === bt ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR : a.COMPRESSED_RGBA_ASTC_12x12_KHR } else return null; if (s === ly) if (a = e.get("EXT_texture_compression_bptc"), a !== null) { if (s === ly) return o === bt ? a.COMPRESSED_SRGB_ALPHA_BPTC_UNORM_EXT : a.COMPRESSED_RGBA_BPTC_UNORM_EXT } else return null; if (s === iF || s === pS || s === mS || s === gS) if (a = e.get("EXT_texture_compression_rgtc"), a !== null) { if (s === ly) return a.COMPRESSED_RED_RGTC1_EXT; if (s === pS) return a.COMPRESSED_SIGNED_RED_RGTC1_EXT; if (s === mS) return a.COMPRESSED_RED_GREEN_RGTC2_EXT; if (s === gS) return a.COMPRESSED_SIGNED_RED_GREEN_RGTC2_EXT } else return null; return s === bl ? n ? i.UNSIGNED_INT_24_8 : (a = e.get("WEBGL_depth_texture"), a !== null ? a.UNSIGNED_INT_24_8_WEBGL : null) : i[s] !== void 0 ? i[s] : null } return { convert: r } } class OF extends Vn { constructor(e = []) { super(), this.isArrayCamera = !0, this.cameras = e } } class Ma extends qt { constructor() { super(), this.isGroup = !0, this.type = "Group" } } const Tj = { type: "move" }; class XA { constructor() { this._targetRay = null, this._grip = null, this._hand = null } getHandSpace() { return this._hand === null && (this._hand = new Ma, this._hand.matrixAutoUpdate = !1, this._hand.visible = !1, this._hand.joints = {}, this._hand.inputState = { pinching: !1 }), this._hand } getTargetRaySpace() { return this._targetRay === null && (this._targetRay = new Ma, this._targetRay.matrixAutoUpdate = !1, this._targetRay.visible = !1, this._targetRay.hasLinearVelocity = !1, this._targetRay.linearVelocity = new k, this._targetRay.hasAngularVelocity = !1, this._targetRay.angularVelocity = new k), this._targetRay } getGripSpace() { return this._grip === null && (this._grip = new Ma, this._grip.matrixAutoUpdate = !1, this._grip.visible = !1, this._grip.hasLinearVelocity = !1, this._grip.linearVelocity = new k, this._grip.hasAngularVelocity = !1, this._grip.angularVelocity = new k), this._grip } dispatchEvent(e) { return this._targetRay !== null && this._targetRay.dispatchEvent(e), this._grip !== null && this._grip.dispatchEvent(e), this._hand !== null && this._hand.dispatchEvent(e), this } connect(e) { if (e && e.hand) { const t = this._hand; if (t) for (const n of e.hand.values()) this._getHandJoint(t, n) } return this.dispatchEvent({ type: "connected", data: e }), this } disconnect(e) { return this.dispatchEvent({ type: "disconnected", data: e }), this._targetRay !== null && (this._targetRay.visible = !1), this._grip !== null && (this._grip.visible = !1), this._hand !== null && (this._hand.visible = !1), this } update(e, t, n) { let r = null, s = null, o = null; const a = this._targetRay, l = this._grip, c = this._hand; if (e && t.session.visibilityState !== "visible-blurred") { if (c && e.hand) { o = !0; for (const _ of e.hand.values()) { const x = t.getJointPose(_, n), g = this._getHandJoint(c, _); x !== null && (g.matrix.fromArray(x.transform.matrix), g.matrix.decompose(g.position, g.rotation, g.scale), g.matrixWorldNeedsUpdate = !0, g.jointRadius = x.radius), g.visible = x !== null } const f = c.joints["index-finger-tip"], d = c.joints["thumb-tip"], p = f.position.distanceTo(d.position), m = .02, y = .005; c.inputState.pinching && p > m + y ? (c.inputState.pinching = !1, this.dispatchEvent({ type: "pinchend", handedness: e.handedness, target: this })) : !c.inputState.pinching && p <= m - y && (c.inputState.pinching = !0, this.dispatchEvent({ type: "pinchstart", handedness: e.handedness, target: this })) } else l !== null && e.gripSpace && (s = t.getPose(e.gripSpace, n), s !== null && (l.matrix.fromArray(s.transform.matrix), l.matrix.decompose(l.position, l.rotation, l.scale), l.matrixWorldNeedsUpdate = !0, s.linearVelocity ? (l.hasLinearVelocity = !0, l.linearVelocity.copy(s.linearVelocity)) : l.hasLinearVelocity = !1, s.angularVelocity ? (l.hasAngularVelocity = !0, l.angularVelocity.copy(s.angularVelocity)) : l.hasAngularVelocity = !1)); a !== null && (r = t.getPose(e.targetRaySpace, n), r === null && s !== null && (r = s), r !== null && (a.matrix.fromArray(r.transform.matrix), a.matrix.decompose(a.position, a.rotation, a.scale), a.matrixWorldNeedsUpdate = !0, r.linearVelocity ? (a.hasLinearVelocity = !0, a.linearVelocity.copy(r.linearVelocity)) : a.hasLinearVelocity = !1, r.angularVelocity ? (a.hasAngularVelocity = !0, a.angularVelocity.copy(r.angularVelocity)) : a.hasAngularVelocity = !1, this.dispatchEvent(Tj))) } return a !== null && (a.visible = r !== null), l !== null && (l.visible = s !== null), c !== null && (c.visible = o !== null), this } _getHandJoint(e, t) { if (e.joints[t.jointName] === void 0) { const n = new Ma; n.matrixAutoUpdate = !1, n.visible = !1, e.joints[t.jointName] = n, e.add(n) } return e.joints[t.jointName] } } class FF extends wn { constructor(e, t, n, r, s, o, a, l, c, f) { if (f = f !== void 0 ? f : Rl, f !== Rl && f !== au) throw new Error("DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat"); n === void 0 && f === Rl && (n = Aa), n === void 0 && f === au && (n = bl), super(null, r, s, o, a, l, f, n, c), this.isDepthTexture = !0, this.image = { width: e, height: t }, this.magFilter = a !== void 0 ? a : zn, this.minFilter = l !== void 0 ? l : zn, this.flipY = !1, this.generateMipmaps = !1, this.compareFunction = null } copy(e) { return super.copy(e), this.compareFunction = e.compareFunction, this } toJSON(e) { const t = super.toJSON(e); return this.compareFunction !== null && (t.compareFunction = this.compareFunction), t } } class bj extends Ko { constructor(e, t) { super(); const n = this; let r = null, s = 1, o = null, a = "local-floor", l = 1, c = null, f = null, d = null, p = null, m = null, y = null; const _ = t.getContextAttributes(); let x = null, g = null; const A = [], M = [], S = new Vn; S.layers.enable(1), S.viewport = new on; const C = new Vn; C.layers.enable(2), C.viewport = new on; const T = [S, C], R = new OF; R.layers.enable(1), R.layers.enable(2); let B = null, b = null; this.cameraAutoUpdate = !0, this.enabled = !1, this.isPresenting = !1, this.getController = function (G) { let K = A[G]; return K === void 0 && (K = new XA, A[G] = K), K.getTargetRaySpace() }, this.getControllerGrip = function (G) { let K = A[G]; return K === void 0 && (K = new XA, A[G] = K), K.getGripSpace() }, this.getHand = function (G) { let K = A[G]; return K === void 0 && (K = new XA, A[G] = K), K.getHandSpace() }; function I(G) { const K = M.indexOf(G.inputSource); if (K === -1) return; const ye = A[K]; ye !== void 0 && (ye.update(G.inputSource, G.frame, c || o), ye.dispatchEvent({ type: G.type, data: G.inputSource })) } function N() { r.removeEventListener("select", I), r.removeEventListener("selectstart", I), r.removeEventListener("selectend", I), r.removeEventListener("squeeze", I), r.removeEventListener("squeezestart", I), r.removeEventListener("squeezeend", I), r.removeEventListener("end", N), r.removeEventListener("inputsourceschange", V); for (let G = 0; G < A.length; G++) { const K = M[G]; K !== null && (M[G] = null, A[G].disconnect(K)) } B = null, b = null, e.setRenderTarget(x), m = null, p = null, d = null, r = null, g = null, L.stop(), n.isPresenting = !1, n.dispatchEvent({ type: "sessionend" }) } this.setFramebufferScaleFactor = function (G) { s = G, n.isPresenting === !0 && console.warn("THREE.WebXRManager: Cannot change framebuffer scale while presenting.") }, this.setReferenceSpaceType = function (G) { a = G, n.isPresenting === !0 && console.warn("THREE.WebXRManager: Cannot change reference space type while presenting.") }, this.getReferenceSpace = function () { return c || o }, this.setReferenceSpace = function (G) { c = G }, this.getBaseLayer = function () { return p !== null ? p : m }, this.getBinding = function () { return d }, this.getFrame = function () { return y }, this.getSession = function () { return r }, this.setSession = async function (G) { if (r = G, r !== null) { if (x = e.getRenderTarget(), r.addEventListener("select", I), r.addEventListener("selectstart", I), r.addEventListener("selectend", I), r.addEventListener("squeeze", I), r.addEventListener("squeezestart", I), r.addEventListener("squeezeend", I), r.addEventListener("end", N), r.addEventListener("inputsourceschange", V), _.xrCompatible !== !0 && await t.makeXRCompatible(), r.renderState.layers === void 0 || e.capabilities.isWebGL2 === !1) { const K = { antialias: r.renderState.layers === void 0 ? _.antialias : !0, alpha: !0, depth: _.depth, stencil: _.stencil, framebufferScaleFactor: s }; m = new XRWebGLLayer(r, t, K), r.updateRenderState({ baseLayer: m }), g = new mo(m.framebufferWidth, m.framebufferHeight, { format: Pr, type: Go, colorSpace: e.outputColorSpace, stencilBuffer: _.stencil }) } else { let K = null, ye = null, ge = null; _.depth && (ge = _.stencil ? t.DEPTH24_STENCIL8 : t.DEPTH_COMPONENT24, K = _.stencil ? au : Rl, ye = _.stencil ? bl : Aa); const xe = { colorFormat: t.RGBA8, depthFormat: ge, scaleFactor: s }; d = new XRWebGLBinding(r, t), p = d.createProjectionLayer(xe), r.updateRenderState({ layers: [p] }), g = new mo(p.textureWidth, p.textureHeight, { format: Pr, type: Go, depthTexture: new FF(p.textureWidth, p.textureHeight, ye, void 0, void 0, void 0, void 0, void 0, void 0, K), stencilBuffer: _.stencil, colorSpace: e.outputColorSpace, samples: _.antialias ? 4 : 0 }); const Be = e.properties.get(g); Be.__ignoreDepthValues = p.ignoreDepthValues } g.isXRRenderTarget = !0, this.setFoveation(l), c = null, o = await r.requestReferenceSpace(a), L.setContext(r), L.start(), n.isPresenting = !0, n.dispatchEvent({ type: "sessionstart" }) } }, this.getEnvironmentBlendMode = function () { if (r !== null) return r.environmentBlendMode }; function V(G) { for (let K = 0; K < G.removed.length; K++) { const ye = G.removed[K], ge = M.indexOf(ye); ge >= 0 && (M[ge] = null, A[ge].disconnect(ye)) } for (let K = 0; K < G.added.length; K++) { const ye = G.added[K]; let ge = M.indexOf(ye); if (ge === -1) { for (let Be = 0; Be < A.length; Be++)if (Be >= M.length) { M.push(ye), ge = Be; break } else if (M[Be] === null) { M[Be] = ye, ge = Be; break } if (ge === -1) break } const xe = A[ge]; xe && xe.connect(ye) } } const J = new k, j = new k; function q(G, K, ye) { J.setFromMatrixPosition(K.matrixWorld), j.setFromMatrixPosition(ye.matrixWorld); const ge = J.distanceTo(j), xe = K.projectionMatrix.elements, Be = ye.projectionMatrix.elements, Ie = xe[14] / (xe[10] - 1), Je = xe[14] / (xe[10] + 1), ut = (xe[9] + 1) / xe[5], Bt = (xe[9] - 1) / xe[5], Ge = (xe[8] - 1) / xe[0], H = (Be[8] + 1) / Be[0], pe = Ie * Ge, fe = Ie * H, Ee = ge / (-Ge + H), ve = Ee * -Ge; K.matrixWorld.decompose(G.position, G.quaternion, G.scale), G.translateX(ve), G.translateZ(Ee), G.matrixWorld.compose(G.position, G.quaternion, G.scale), G.matrixWorldInverse.copy(G.matrixWorld).invert(); const Z = Ie + Ee, Fe = Je + Ee, Ve = pe - ve, st = fe + (ge - ve), ot = ut * Je / Fe * Z, Yt = Bt * Je / Fe * Z; G.projectionMatrix.makePerspective(Ve, st, ot, Yt, Z, Fe), G.projectionMatrixInverse.copy(G.projectionMatrix).invert() } function ne(G, K) { K === null ? G.matrixWorld.copy(G.matrix) : G.matrixWorld.multiplyMatrices(K.matrixWorld, G.matrix), G.matrixWorldInverse.copy(G.matrixWorld).invert() } this.updateCamera = function (G) { if (r === null) return; R.near = C.near = S.near = G.near, R.far = C.far = S.far = G.far, (B !== R.near || b !== R.far) && (r.updateRenderState({ depthNear: R.near, depthFar: R.far }), B = R.near, b = R.far); const K = G.parent, ye = R.cameras; ne(R, K); for (let ge = 0; ge < ye.length; ge++)ne(ye[ge], K); ye.length === 2 ? q(R, S, C) : R.projectionMatrix.copy(S.projectionMatrix), Q(G, R, K) }; function Q(G, K, ye) { ye === null ? G.matrix.copy(K.matrixWorld) : (G.matrix.copy(ye.matrixWorld), G.matrix.invert(), G.matrix.multiply(K.matrixWorld)), G.matrix.decompose(G.position, G.quaternion, G.scale), G.updateMatrixWorld(!0); const ge = G.children; for (let xe = 0, Be = ge.length; xe < Be; xe++)ge[xe].updateMatrixWorld(!0); G.projectionMatrix.copy(K.projectionMatrix), G.projectionMatrixInverse.copy(K.projectionMatrixInverse), G.isPerspectiveCamera && (G.fov = vh * 2 * Math.atan(1 / G.projectionMatrix.elements[5]), G.zoom = 1) } this.getCamera = function () { return R }, this.getFoveation = function () { if (!(p === null && m === null)) return l }, this.setFoveation = function (G) { l = G, p !== null && (p.fixedFoveation = G), m !== null && m.fixedFoveation !== void 0 && (m.fixedFoveation = G) }; let F = null; function Y(G, K) { if (f = K.getViewerPose(c || o), y = K, f !== null) { const ye = f.views; m !== null && (e.setRenderTargetFramebuffer(g, m.framebuffer), e.setRenderTarget(g)); let ge = !1; ye.length !== R.cameras.length && (R.cameras.length = 0, ge = !0); for (let xe = 0; xe < ye.length; xe++) { const Be = ye[xe]; let Ie = null; if (m !== null) Ie = m.getViewport(Be); else { const ut = d.getViewSubImage(p, Be); Ie = ut.viewport, xe === 0 && (e.setRenderTargetTextures(g, ut.colorTexture, p.ignoreDepthValues ? void 0 : ut.depthStencilTexture), e.setRenderTarget(g)) } let Je = T[xe]; Je === void 0 && (Je = new Vn, Je.layers.enable(xe), Je.viewport = new on, T[xe] = Je), Je.matrix.fromArray(Be.transform.matrix), Je.matrix.decompose(Je.position, Je.quaternion, Je.scale), Je.projectionMatrix.fromArray(Be.projectionMatrix), Je.projectionMatrixInverse.copy(Je.projectionMatrix).invert(), Je.viewport.set(Ie.x, Ie.y, Ie.width, Ie.height), xe === 0 && (R.matrix.copy(Je.matrix), R.matrix.decompose(R.position, R.quaternion, R.scale)), ge === !0 && R.cameras.push(Je) } } for (let ye = 0; ye < A.length; ye++) { const ge = M[ye], xe = A[ye]; ge !== null && xe !== void 0 && xe.update(ge, K, c || o) } F && F(G, K), K.detectedPlanes && n.dispatchEvent({ type: "planesdetected", data: K }), y = null } const L = new RF; L.setAnimationLoop(Y), this.setAnimationLoop = function (G) { F = G }, this.dispose = function () { } } } function Rj(i, e) { function t(x, g) { x.matrixAutoUpdate === !0 && x.updateMatrix(), g.value.copy(x.matrix) } function n(x, g) { g.color.getRGB(x.fogColor.value, EF(i)), g.isFog ? (x.fogNear.value = g.near, x.fogFar.value = g.far) : g.isFogExp2 && (x.fogDensity.value = g.density) } function r(x, g, A, M, S) { g.isMeshBasicMaterial || g.isMeshLambertMaterial ? s(x, g) : g.isMeshToonMaterial ? (s(x, g), d(x, g)) : g.isMeshPhongMaterial ? (s(x, g), f(x, g)) : g.isMeshStandardMaterial ? (s(x, g), p(x, g), g.isMeshPhysicalMaterial && m(x, g, S)) : g.isMeshMatcapMaterial ? (s(x, g), y(x, g)) : g.isMeshDepthMaterial ? s(x, g) : g.isMeshDistanceMaterial ? (s(x, g), _(x, g)) : g.isMeshNormalMaterial ? s(x, g) : g.isLineBasicMaterial ? (o(x, g), g.isLineDashedMaterial && a(x, g)) : g.isPointsMaterial ? l(x, g, A, M) : g.isSpriteMaterial ? c(x, g) : g.isShadowMaterial ? (x.color.value.copy(g.color), x.opacity.value = g.opacity) : g.isShaderMaterial && (g.uniformsNeedUpdate = !1) } function s(x, g) { x.opacity.value = g.opacity, g.color && x.diffuse.value.copy(g.color), g.emissive && x.emissive.value.copy(g.emissive).multiplyScalar(g.emissiveIntensity), g.map && (x.map.value = g.map, t(g.map, x.mapTransform)), g.alphaMap && (x.alphaMap.value = g.alphaMap, t(g.alphaMap, x.alphaMapTransform)), g.bumpMap && (x.bumpMap.value = g.bumpMap, t(g.bumpMap, x.bumpMapTransform), x.bumpScale.value = g.bumpScale, g.side === _r && (x.bumpScale.value *= -1)), g.normalMap && (x.normalMap.value = g.normalMap, t(g.normalMap, x.normalMapTransform), x.normalScale.value.copy(g.normalScale), g.side === _r && x.normalScale.value.negate()), g.displacementMap && (x.displacementMap.value = g.displacementMap, t(g.displacementMap, x.displacementMapTransform), x.displacementScale.value = g.displacementScale, x.displacementBias.value = g.displacementBias), g.emissiveMap && (x.emissiveMap.value = g.emissiveMap, t(g.emissiveMap, x.emissiveMapTransform)), g.specularMap && (x.specularMap.value = g.specularMap, t(g.specularMap, x.specularMapTransform)), g.alphaTest > 0 && (x.alphaTest.value = g.alphaTest); const A = e.get(g).envMap; if (A && (x.envMap.value = A, x.flipEnvMap.value = A.isCubeTexture && A.isRenderTargetTexture === !1 ? -1 : 1, x.reflectivity.value = g.reflectivity, x.ior.value = g.ior, x.refractionRatio.value = g.refractionRatio), g.lightMap) { x.lightMap.value = g.lightMap; const M = i._useLegacyLights === !0 ? Math.PI : 1; x.lightMapIntensity.value = g.lightMapIntensity * M, t(g.lightMap, x.lightMapTransform) } g.aoMap && (x.aoMap.value = g.aoMap, x.aoMapIntensity.value = g.aoMapIntensity, t(g.aoMap, x.aoMapTransform)) } function o(x, g) { x.diffuse.value.copy(g.color), x.opacity.value = g.opacity, g.map && (x.map.value = g.map, t(g.map, x.mapTransform)) } function a(x, g) { x.dashSize.value = g.dashSize, x.totalSize.value = g.dashSize + g.gapSize, x.scale.value = g.scale } function l(x, g, A, M) { x.diffuse.value.copy(g.color), x.opacity.value = g.opacity, x.size.value = g.size * A, x.scale.value = M * .5, g.map && (x.map.value = g.map, t(g.map, x.uvTransform)), g.alphaMap && (x.alphaMap.value = g.alphaMap, t(g.alphaMap, x.alphaMapTransform)), g.alphaTest > 0 && (x.alphaTest.value = g.alphaTest) } function c(x, g) { x.diffuse.value.copy(g.color), x.opacity.value = g.opacity, x.rotation.value = g.rotation, g.map && (x.map.value = g.map, t(g.map, x.mapTransform)), g.alphaMap && (x.alphaMap.value = g.alphaMap, t(g.alphaMap, x.alphaMapTransform)), g.alphaTest > 0 && (x.alphaTest.value = g.alphaTest) } function f(x, g) { x.specular.value.copy(g.specular), x.shininess.value = Math.max(g.shininess, 1e-4) } function d(x, g) { g.gradientMap && (x.gradientMap.value = g.gradientMap) } function p(x, g) { x.metalness.value = g.metalness, g.metalnessMap && (x.metalnessMap.value = g.metalnessMap, t(g.metalnessMap, x.metalnessMapTransform)), x.roughness.value = g.roughness, g.roughnessMap && (x.roughnessMap.value = g.roughnessMap, t(g.roughnessMap, x.roughnessMapTransform)), e.get(g).envMap && (x.envMapIntensity.value = g.envMapIntensity) } function m(x, g, A) { x.ior.value = g.ior, g.sheen > 0 && (x.sheenColor.value.copy(g.sheenColor).multiplyScalar(g.sheen), x.sheenRoughness.value = g.sheenRoughness, g.sheenColorMap && (x.sheenColorMap.value = g.sheenColorMap, t(g.sheenColorMap, x.sheenColorMapTransform)), g.sheenRoughnessMap && (x.sheenRoughnessMap.value = g.sheenRoughnessMap, t(g.sheenRoughnessMap, x.sheenRoughnessMapTransform))), g.clearcoat > 0 && (x.clearcoat.value = g.clearcoat, x.clearcoatRoughness.value = g.clearcoatRoughness, g.clearcoatMap && (x.clearcoatMap.value = g.clearcoatMap, t(g.clearcoatMap, x.clearcoatMapTransform)), g.clearcoatRoughnessMap && (x.clearcoatRoughnessMap.value = g.clearcoatRoughnessMap, t(g.clearcoatRoughnessMap, x.clearcoatRoughnessMapTransform)), g.clearcoatNormalMap && (x.clearcoatNormalMap.value = g.clearcoatNormalMap, t(g.clearcoatNormalMap, x.clearcoatNormalMapTransform), x.clearcoatNormalScale.value.copy(g.clearcoatNormalScale), g.side === _r && x.clearcoatNormalScale.value.negate())), g.iridescence > 0 && (x.iridescence.value = g.iridescence, x.iridescenceIOR.value = g.iridescenceIOR, x.iridescenceThicknessMinimum.value = g.iridescenceThicknessRange[0], x.iridescenceThicknessMaximum.value = g.iridescenceThicknessRange[1], g.iridescenceMap && (x.iridescenceMap.value = g.iridescenceMap, t(g.iridescenceMap, x.iridescenceMapTransform)), g.iridescenceThicknessMap && (x.iridescenceThicknessMap.value = g.iridescenceThicknessMap, t(g.iridescenceThicknessMap, x.iridescenceThicknessMapTransform))), g.transmission > 0 && (x.transmission.value = g.transmission, x.transmissionSamplerMap.value = A.texture, x.transmissionSamplerSize.value.set(A.width, A.height), g.transmissionMap && (x.transmissionMap.value = g.transmissionMap, t(g.transmissionMap, x.transmissionMapTransform)), x.thickness.value = g.thickness, g.thicknessMap && (x.thicknessMap.value = g.thicknessMap, t(g.thicknessMap, x.thicknessMapTransform)), x.attenuationDistance.value = g.attenuationDistance, x.attenuationColor.value.copy(g.attenuationColor)), g.anisotropy > 0 && (x.anisotropyVector.value.set(g.anisotropy * Math.cos(g.anisotropyRotation), g.anisotropy * Math.sin(g.anisotropyRotation)), g.anisotropyMap && (x.anisotropyMap.value = g.anisotropyMap, t(g.anisotropyMap, x.anisotropyMapTransform))), x.specularIntensity.value = g.specularIntensity, x.specularColor.value.copy(g.specularColor), g.specularColorMap && (x.specularColorMap.value = g.specularColorMap, t(g.specularColorMap, x.specularColorMapTransform)), g.specularIntensityMap && (x.specularIntensityMap.value = g.specularIntensityMap, t(g.specularIntensityMap, x.specularIntensityMapTransform)) } function y(x, g) { g.matcap && (x.matcap.value = g.matcap) } function _(x, g) { const A = e.get(g).light; x.referencePosition.value.setFromMatrixPosition(A.matrixWorld), x.nearDistance.value = A.shadow.camera.near, x.farDistance.value = A.shadow.camera.far } return { refreshFogUniforms: n, refreshMaterialUniforms: r } } function Pj(i, e, t, n) { let r = {}, s = {}, o = []; const a = t.isWebGL2 ? i.getParameter(i.MAX_UNIFORM_BUFFER_BINDINGS) : 0; function l(A, M) { const S = M.program; n.uniformBlockBinding(A, S) } function c(A, M) { let S = r[A.id]; S === void 0 && (y(A), S = f(A), r[A.id] = S, A.addEventListener("dispose", x)); const C = M.program; n.updateUBOMapping(A, C); const T = e.render.frame; s[A.id] !== T && (p(A), s[A.id] = T) } function f(A) { const M = d(); A.__bindingPointIndex = M; const S = i.createBuffer(), C = A.__size, T = A.usage; return i.bindBuffer(i.UNIFORM_BUFFER, S), i.bufferData(i.UNIFORM_BUFFER, C, T), i.bindBuffer(i.UNIFORM_BUFFER, null), i.bindBufferBase(i.UNIFORM_BUFFER, M, S), S } function d() { for (let A = 0; A < a; A++)if (o.indexOf(A) === -1) return o.push(A), A; return console.error("THREE.WebGLRenderer: Maximum number of simultaneously usable uniforms groups reached."), 0 } function p(A) { const M = r[A.id], S = A.uniforms, C = A.__cache; i.bindBuffer(i.UNIFORM_BUFFER, M); for (let T = 0, R = S.length; T < R; T++) { const B = S[T]; if (m(B, T, C) === !0) { const b = B.__offset, I = Array.isArray(B.value) ? B.value : [B.value]; let N = 0; for (let V = 0; V < I.length; V++) { const J = I[V], j = _(J); typeof J == "number" ? (B.__data[0] = J, i.bufferSubData(i.UNIFORM_BUFFER, b + N, B.__data)) : J.isMatrix3 ? (B.__data[0] = J.elements[0], B.__data[1] = J.elements[1], B.__data[2] = J.elements[2], B.__data[3] = J.elements[0], B.__data[4] = J.elements[3], B.__data[5] = J.elements[4], B.__data[6] = J.elements[5], B.__data[7] = J.elements[0], B.__data[8] = J.elements[6], B.__data[9] = J.elements[7], B.__data[10] = J.elements[8], B.__data[11] = J.elements[0]) : (J.toArray(B.__data, N), N += j.storage / Float32Array.BYTES_PER_ELEMENT) } i.bufferSubData(i.UNIFORM_BUFFER, b, B.__data) } } i.bindBuffer(i.UNIFORM_BUFFER, null) } function m(A, M, S) { const C = A.value; if (S[M] === void 0) { if (typeof C == "number") S[M] = C; else { const T = Array.isArray(C) ? C : [C], R = []; for (let B = 0; B < T.length; B++)R.push(T[B].clone()); S[M] = R } return !0 } else if (typeof C == "number") { if (S[M] !== C) return S[M] = C, !0 } else { const T = Array.isArray(S[M]) ? S[M] : [S[M]], R = Array.isArray(C) ? C : [C]; for (let B = 0; B < T.length; B++) { const b = T[B]; if (b.equals(R[B]) === !1) return b.copy(R[B]), !0 } } return !1 } function y(A) { const M = A.uniforms; let S = 0; const C = 16; let T = 0; for (let R = 0, B = M.length; R < B; R++) { const b = M[R], I = { boundary: 0, storage: 0 }, N = Array.isArray(b.value) ? b.value : [b.value]; for (let V = 0, J = N.length; V < J; V++) { const j = N[V], q = _(j); I.boundary += q.boundary, I.storage += q.storage } if (b.__data = new Float32Array(I.storage / Float32Array.BYTES_PER_ELEMENT), b.__offset = S, R > 0) { T = S % C; const V = C - T; T !== 0 && V - I.boundary < 0 && (S += C - T, b.__offset = S) } S += I.storage } return T = S % C, T > 0 && (S += C - T), A.__size = S, A.__cache = {}, this } function _(A) { const M = { boundary: 0, storage: 0 }; return typeof A == "number" ? (M.boundary = 4, M.storage = 4) : A.isVector2 ? (M.boundary = 8, M.storage = 8) : A.isVector3 || A.isColor ? (M.boundary = 16, M.storage = 12) : A.isVector4 ? (M.boundary = 16, M.storage = 16) : A.isMatrix3 ? (M.boundary = 48, M.storage = 48) : A.isMatrix4 ? (M.boundary = 64, M.storage = 64) : A.isTexture ? console.warn("THREE.WebGLRenderer: Texture samplers can not be part of an uniforms group.") : console.warn("THREE.WebGLRenderer: Unsupported uniform value type.", A), M } function x(A) { const M = A.target; M.removeEventListener("dispose", x); const S = o.indexOf(M.__bindingPointIndex); o.splice(S, 1), i.deleteBuffer(r[M.id]), delete r[M.id], delete s[M.id] } function g() { for (const A in r) i.deleteBuffer(r[A]); o = [], r = {}, s = {} } return { bind: l, update: c, dispose: g } } function Ij() { const i = Gp("canvas"); return i.style.display = "block", i } class bE { constructor(e = {}) { const { canvas: t = Ij(), context: n = null, depth: r = !0, stencil: s = !0, alpha: o = !1, antialias: a = !1, premultipliedAlpha: l = !0, preserveDrawingBuffer: c = !1, powerPreference: f = "default", failIfMajorPerformanceCaveat: d = !1 } = e; this.isWebGLRenderer = !0; let p; n !== null ? p = n.getContextAttributes().alpha : p = o; const m = new Uint32Array(4), y = new Int32Array(4); let _ = null, x = null; const g = [], A = []; this.domElement = t, this.debug = { checkShaderErrors: !0, onShaderError: null }, this.autoClear = !0, this.autoClearColor = !0, this.autoClearDepth = !0, this.autoClearStencil = !0, this.sortObjects = !0, this.clippingPlanes = [], this.localClippingEnabled = !1, this.outputColorSpace = bt, this._useLegacyLights = !1, this.toneMapping = Ho, this.toneMappingExposure = 1; const M = this; let S = !1, C = 0, T = 0, R = null, B = -1, b = null; const I = new on, N = new on; let V = null; const J = new We(0); let j = 0, q = t.width, ne = t.height, Q = 1, F = null, Y = null; const L = new on(0, 0, q, ne), G = new on(0, 0, q, ne); let K = !1; const ye = new zv; let ge = !1, xe = !1, Be = null; const Ie = new yt, Je = new _e, ut = new k, Bt = { background: null, fog: null, environment: null, overrideMaterial: null, isScene: !0 }; function Ge() { return R === null ? Q : 1 } let H = n; function pe(O, ie) { for (let ae = 0; ae < O.length; ae++) { const te = O[ae], ue = t.getContext(te, ie); if (ue !== null) return ue } return null } try { const O = { alpha: !0, depth: r, stencil: s, antialias: a, premultipliedAlpha: l, preserveDrawingBuffer: c, powerPreference: f, failIfMajorPerformanceCaveat: d }; if ("setAttribute" in t && t.setAttribute("data-engine", `three.js r${rm}`), t.addEventListener("webglcontextlost", Oe, !1), t.addEventListener("webglcontextrestored", se, !1), t.addEventListener("webglcontextcreationerror", Se, !1), H === null) { const ie = ["webgl2", "webgl", "experimental-webgl"]; if (M.isWebGL1Renderer === !0 && ie.shift(), H = pe(ie, O), H === null) throw pe(ie) ? new Error("Error creating WebGL context with your selected attributes.") : new Error("Error creating WebGL context.") } typeof WebGLRenderingContext < "u" && H instanceof WebGLRenderingContext && console.warn("THREE.WebGLRenderer: WebGL 1 support was deprecated in r153 and will be removed in r163."), H.getShaderPrecisionFormat === void 0 && (H.getShaderPrecisionFormat = function () { return { rangeMin: 1, rangeMax: 1, precision: 1 } }) } catch (O) { throw console.error("THREE.WebGLRenderer: " + O.message), O } let fe, Ee, ve, Z, Fe, Ve, st, ot, Yt, U, D, re, Ae, Me, Ce, qe, Te, oe, X, he, we, be, De, lt; function vt() { fe = new JJ(H), Ee = new zJ(H, fe, e), fe.init(Ee), be = new DF(H, fe, Ee), ve = new Ej(H, fe, Ee), Z = new KJ(H), Fe = new dj, Ve = new Cj(H, fe, ve, Fe, Ee, be, Z), st = new GJ(M), ot = new XJ(M), Yt = new s6(H, Ee), De = new NJ(H, fe, Yt, Ee), U = new YJ(H, Yt, Z, De), D = new $J(H, U, Yt, Z), X = new ZJ(H, Ee, Ve), qe = new HJ(Fe), re = new hj(M, st, ot, fe, Ee, De, qe), Ae = new Rj(M, Fe), Me = new mj, Ce = new Aj(fe, Ee), oe = new kJ(M, st, ot, ve, D, p, l), Te = new Sj(M, D, Ee), lt = new Pj(H, Z, Ee, ve), he = new UJ(H, fe, Z, Ee), we = new jJ(H, fe, Z, Ee), Z.programs = re.programs, M.capabilities = Ee, M.extensions = fe, M.properties = Fe, M.renderLists = Me, M.shadowMap = Te, M.state = ve, M.info = Z } vt(); const W = new bj(M, H); this.xr = W, this.getContext = function () { return H }, this.getContextAttributes = function () { return H.getContextAttributes() }, this.forceContextLoss = function () { const O = fe.get("WEBGL_lose_context"); O && O.loseContext() }, this.forceContextRestore = function () { const O = fe.get("WEBGL_lose_context"); O && O.restoreContext() }, this.getPixelRatio = function () { return Q }, this.setPixelRatio = function (O) { O !== void 0 && (Q = O, this.setSize(q, ne, !1)) }, this.getSize = function (O) { return O.set(q, ne) }, this.setSize = function (O, ie, ae = !0) { if (W.isPresenting) { console.warn("THREE.WebGLRenderer: Can't change size while VR device is presenting."); return } q = O, ne = ie, t.width = Math.floor(O * Q), t.height = Math.floor(ie * Q), ae === !0 && (t.style.width = O + "px", t.style.height = ie + "px"), this.setViewport(0, 0, O, ie) }, this.getDrawingBufferSize = function (O) { return O.set(q * Q, ne * Q).floor() }, this.setDrawingBufferSize = function (O, ie, ae) { q = O, ne = ie, Q = ae, t.width = Math.floor(O * ae), t.height = Math.floor(ie * ae), this.setViewport(0, 0, O, ie) }, this.getCurrentViewport = function (O) { return O.copy(I) }, this.getViewport = function (O) { return O.copy(L) }, this.setViewport = function (O, ie, ae, te) { O.isVector4 ? L.set(O.x, O.y, O.z, O.w) : L.set(O, ie, ae, te), ve.viewport(I.copy(L).multiplyScalar(Q).floor()) }, this.getScissor = function (O) { return O.copy(G) }, this.setScissor = function (O, ie, ae, te) { O.isVector4 ? G.set(O.x, O.y, O.z, O.w) : G.set(O, ie, ae, te), ve.scissor(N.copy(G).multiplyScalar(Q).floor()) }, this.getScissorTest = function () { return K }, this.setScissorTest = function (O) { ve.setScissorTest(K = O) }, this.setOpaqueSort = function (O) { F = O }, this.setTransparentSort = function (O) { Y = O }, this.getClearColor = function (O) { return O.copy(oe.getClearColor()) }, this.setClearColor = function () { oe.setClearColor.apply(oe, arguments) }, this.getClearAlpha = function () { return oe.getClearAlpha() }, this.setClearAlpha = function () { oe.setClearAlpha.apply(oe, arguments) }, this.clear = function (O = !0, ie = !0, ae = !0) { let te = 0; if (O) { let ue = !1; if (R !== null) { const Ue = R.texture.format; ue = Ue === mE || Ue === pE || Ue === dE } if (ue) { const Ue = R.texture.type, Ke = Ue === Go || Ue === Aa || Ue === kv || Ue === bl || Ue === fE || Ue === hE, nt = oe.getClearColor(), ft = oe.getClearAlpha(), wt = nt.r, Qe = nt.g, Ze = nt.b; Ke ? (m[0] = wt, m[1] = Qe, m[2] = Ze, m[3] = ft, H.clearBufferuiv(H.COLOR, 0, m)) : (y[0] = wt, y[1] = Qe, y[2] = Ze, y[3] = ft, H.clearBufferiv(H.COLOR, 0, y)) } else te |= H.COLOR_BUFFER_BIT } ie && (te |= H.DEPTH_BUFFER_BIT), ae && (te |= H.STENCIL_BUFFER_BIT), H.clear(te) }, this.clearColor = function () { this.clear(!0, !1, !1) }, this.clearDepth = function () { this.clear(!1, !0, !1) }, this.clearStencil = function () { this.clear(!1, !1, !0) }, this.dispose = function () { t.removeEventListener("webglcontextlost", Oe, !1), t.removeEventListener("webglcontextrestored", se, !1), t.removeEventListener("webglcontextcreationerror", Se, !1), Me.dispose(), Ce.dispose(), Fe.dispose(), st.dispose(), ot.dispose(), D.dispose(), De.dispose(), lt.dispose(), re.dispose(), W.dispose(), W.removeEventListener("sessionstart", Ne), W.removeEventListener("sessionend", At), Be && (Be.dispose(), Be = null), Lt.stop() }; function Oe(O) { O.preventDefault(), console.log("THREE.WebGLRenderer: Context Lost."), S = !0 } function se() { console.log("THREE.WebGLRenderer: Context Restored."), S = !1; const O = Z.autoReset, ie = Te.enabled, ae = Te.autoUpdate, te = Te.needsUpdate, ue = Te.type; vt(), Z.autoReset = O, Te.enabled = ie, Te.autoUpdate = ae, Te.needsUpdate = te, Te.type = ue } function Se(O) { console.error("THREE.WebGLRenderer: A WebGL context could not be created. Reason: ", O.statusMessage) } function ke(O) { const ie = O.target; ie.removeEventListener("dispose", ke), St(ie) } function St(O) { Qt(O), Fe.remove(O) } function Qt(O) { const ie = Fe.get(O).programs; ie !== void 0 && (ie.forEach(function (ae) { re.releaseProgram(ae) }), O.isShaderMaterial && re.releaseShaderCache(O)) } this.renderBufferDirect = function (O, ie, ae, te, ue, Ue) { ie === null && (ie = Bt); const Ke = ue.isMesh && ue.matrixWorld.determinant() < 0, nt = ai(O, ie, ae, te, ue); ve.setMaterial(te, Ke); let ft = ae.index, wt = 1; if (te.wireframe === !0) { if (ft = U.getWireframeAttribute(ae), ft === void 0) return; wt = 2 } const Qe = ae.drawRange, Ze = ae.attributes.position; let zt = Qe.start * wt, sn = (Qe.start + Qe.count) * wt; Ue !== null && (zt = Math.max(zt, Ue.start * wt), sn = Math.min(sn, (Ue.start + Ue.count) * wt)), ft !== null ? (zt = Math.max(zt, 0), sn = Math.min(sn, ft.count)) : Ze != null && (zt = Math.max(zt, 0), sn = Math.min(sn, Ze.count)); const Ri = sn - zt; if (Ri < 0 || Ri === 1 / 0) return; De.setup(ue, te, nt, ae, ft); let li, Nt = he; if (ft !== null && (li = Yt.get(ft), Nt = we, Nt.setIndex(li)), ue.isMesh) te.wireframe === !0 ? (ve.setLineWidth(te.wireframeLinewidth * Ge()), Nt.setMode(H.LINES)) : Nt.setMode(H.TRIANGLES); else if (ue.isLine) { let gt = te.linewidth; gt === void 0 && (gt = 1), ve.setLineWidth(gt * Ge()), ue.isLineSegments ? Nt.setMode(H.LINES) : ue.isLineLoop ? Nt.setMode(H.LINE_LOOP) : Nt.setMode(H.LINE_STRIP) } else ue.isPoints ? Nt.setMode(H.POINTS) : ue.isSprite && Nt.setMode(H.TRIANGLES); if (ue.isInstancedMesh) Nt.renderInstances(zt, Ri, ue.count); else if (ae.isInstancedBufferGeometry) { const gt = ae._maxInstanceCount !== void 0 ? ae._maxInstanceCount : 1 / 0, jt = Math.min(ae.instanceCount, gt); Nt.renderInstances(zt, Ri, jt) } else Nt.render(zt, Ri) }, this.compile = function (O, ie) { function ae(te, ue, Ue) { te.transparent === !0 && te.side === ro && te.forceSinglePass === !1 ? (te.side = _r, te.needsUpdate = !0, Mt(te, ue, Ue), te.side = Jo, te.needsUpdate = !0, Mt(te, ue, Ue), te.side = ro) : Mt(te, ue, Ue) } x = Ce.get(O), x.init(), A.push(x), O.traverseVisible(function (te) { te.isLight && te.layers.test(ie.layers) && (x.pushLight(te), te.castShadow && x.pushShadow(te)) }), x.setupLights(M._useLegacyLights), O.traverse(function (te) { const ue = te.material; if (ue) if (Array.isArray(ue)) for (let Ue = 0; Ue < ue.length; Ue++) { const Ke = ue[Ue]; ae(Ke, O, te) } else ae(ue, O, te) }), A.pop(), x = null }; let $t = null; function ht(O) { $t && $t(O) } function Ne() { Lt.stop() } function At() { Lt.start() } const Lt = new RF; Lt.setAnimationLoop(ht), typeof self < "u" && Lt.setContext(self), this.setAnimationLoop = function (O) { $t = O, W.setAnimationLoop(O), O === null ? Lt.stop() : Lt.start() }, W.addEventListener("sessionstart", Ne), W.addEventListener("sessionend", At), this.render = function (O, ie) { if (ie !== void 0 && ie.isCamera !== !0) { console.error("THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera."); return } if (S === !0) return; O.matrixWorldAutoUpdate === !0 && O.updateMatrixWorld(), ie.parent === null && ie.matrixWorldAutoUpdate === !0 && ie.updateMatrixWorld(), W.enabled === !0 && W.isPresenting === !0 && (W.cameraAutoUpdate === !0 && W.updateCamera(ie), ie = W.getCamera()), O.isScene === !0 && O.onBeforeRender(M, O, ie, R), x = Ce.get(O, A.length), x.init(), A.push(x), Ie.multiplyMatrices(ie.projectionMatrix, ie.matrixWorldInverse), ye.setFromProjectionMatrix(Ie), xe = this.localClippingEnabled, ge = qe.init(this.clippingPlanes, xe), _ = Me.get(O, g.length), _.init(), g.push(_), je(O, ie, 0, M.sortObjects), _.finish(), M.sortObjects === !0 && _.sort(F, Y), this.info.render.frame++, ge === !0 && qe.beginShadows(); const ae = x.state.shadowsArray; if (Te.render(ae, O, ie), ge === !0 && qe.endShadows(), this.info.autoReset === !0 && this.info.reset(), oe.render(_, O), x.setupLights(M._useLegacyLights), ie.isArrayCamera) { const te = ie.cameras; for (let ue = 0, Ue = te.length; ue < Ue; ue++) { const Ke = te[ue]; Ft(_, O, Ke, Ke.viewport) } } else Ft(_, O, ie); R !== null && (Ve.updateMultisampleRenderTarget(R), Ve.updateRenderTargetMipmap(R)), O.isScene === !0 && O.onAfterRender(M, O, ie), De.resetDefaultState(), B = -1, b = null, A.pop(), A.length > 0 ? x = A[A.length - 1] : x = null, g.pop(), g.length > 0 ? _ = g[g.length - 1] : _ = null }; function je(O, ie, ae, te) { if (O.visible === !1) return; if (O.layers.test(ie.layers)) { if (O.isGroup) ae = O.renderOrder; else if (O.isLOD) O.autoUpdate === !0 && O.update(ie); else if (O.isLight) x.pushLight(O), O.castShadow && x.pushShadow(O); else if (O.isSprite) { if (!O.frustumCulled || ye.intersectsSprite(O)) { te && ut.setFromMatrixPosition(O.matrixWorld).applyMatrix4(Ie); const Ke = D.update(O), nt = O.material; nt.visible && _.push(O, Ke, nt, ae, ut.z, null) } } else if ((O.isMesh || O.isLine || O.isPoints) && (!O.frustumCulled || ye.intersectsObject(O))) { const Ke = D.update(O), nt = O.material; if (te && (O.boundingSphere !== void 0 ? (O.boundingSphere === null && O.computeBoundingSphere(), ut.copy(O.boundingSphere.center)) : (Ke.boundingSphere === null && Ke.computeBoundingSphere(), ut.copy(Ke.boundingSphere.center)), ut.applyMatrix4(O.matrixWorld).applyMatrix4(Ie)), Array.isArray(nt)) { const ft = Ke.groups; for (let wt = 0, Qe = ft.length; wt < Qe; wt++) { const Ze = ft[wt], zt = nt[Ze.materialIndex]; zt && zt.visible && _.push(O, Ke, zt, ae, ut.z, Ze) } } else nt.visible && _.push(O, Ke, nt, ae, ut.z, null) } } const Ue = O.children; for (let Ke = 0, nt = Ue.length; Ke < nt; Ke++)je(Ue[Ke], ie, ae, te) } function Ft(O, ie, ae, te) { const ue = O.opaque, Ue = O.transmissive, Ke = O.transparent; x.setupLightsView(ae), ge === !0 && qe.setGlobalState(M.clippingPlanes, ae), Ue.length > 0 && pt(ue, Ue, ie, ae), te && ve.viewport(I.copy(te)), ue.length > 0 && _t(ue, ie, ae), Ue.length > 0 && _t(Ue, ie, ae), Ke.length > 0 && _t(Ke, ie, ae), ve.buffers.depth.setTest(!0), ve.buffers.depth.setMask(!0), ve.buffers.color.setMask(!0), ve.setPolygonOffset(!1) } function pt(O, ie, ae, te) { const ue = Ee.isWebGL2; Be === null && (Be = new mo(1, 1, { generateMipmaps: !0, type: fe.has("EXT_color_buffer_half_float") ? gh : Go, minFilter: Yo, samples: ue ? 4 : 0 })), M.getDrawingBufferSize(Je), ue ? Be.setSize(Je.x, Je.y) : Be.setSize(sv(Je.x), sv(Je.y)); const Ue = M.getRenderTarget(); M.setRenderTarget(Be), M.getClearColor(J), j = M.getClearAlpha(), j < 1 && M.setClearColor(16777215, .5), M.clear(); const Ke = M.toneMapping; M.toneMapping = Ho, _t(O, ae, te), Ve.updateMultisampleRenderTarget(Be), Ve.updateRenderTargetMipmap(Be); let nt = !1; for (let ft = 0, wt = ie.length; ft < wt; ft++) { const Qe = ie[ft], Ze = Qe.object, zt = Qe.geometry, sn = Qe.material, Ri = Qe.group; if (sn.side === ro && Ze.layers.test(te.layers)) { const li = sn.side; sn.side = _r, sn.needsUpdate = !0, Sn(Ze, ae, te, zt, sn, Ri), sn.side = li, sn.needsUpdate = !0, nt = !0 } } nt === !0 && (Ve.updateMultisampleRenderTarget(Be), Ve.updateRenderTargetMipmap(Be)), M.setRenderTarget(Ue), M.setClearColor(J, j), M.toneMapping = Ke } function _t(O, ie, ae) { const te = ie.isScene === !0 ? ie.overrideMaterial : null; for (let ue = 0, Ue = O.length; ue < Ue; ue++) { const Ke = O[ue], nt = Ke.object, ft = Ke.geometry, wt = te === null ? Ke.material : te, Qe = Ke.group; nt.layers.test(ae.layers) && Sn(nt, ie, ae, ft, wt, Qe) } } function Sn(O, ie, ae, te, ue, Ue) { O.onBeforeRender(M, ie, ae, te, ue, Ue), O.modelViewMatrix.multiplyMatrices(ae.matrixWorldInverse, O.matrixWorld), O.normalMatrix.getNormalMatrix(O.modelViewMatrix), ue.onBeforeRender(M, ie, ae, te, O, Ue), ue.transparent === !0 && ue.side === ro && ue.forceSinglePass === !1 ? (ue.side = _r, ue.needsUpdate = !0, M.renderBufferDirect(ae, ie, te, ue, O, Ue), ue.side = Jo, ue.needsUpdate = !0, M.renderBufferDirect(ae, ie, te, ue, O, Ue), ue.side = ro) : M.renderBufferDirect(ae, ie, te, ue, O, Ue), O.onAfterRender(M, ie, ae, te, ue, Ue) } function Mt(O, ie, ae) { ie.isScene !== !0 && (ie = Bt); const te = Fe.get(O), ue = x.state.lights, Ue = x.state.shadowsArray, Ke = ue.state.version, nt = re.getParameters(O, ue.state, Ue, ie, ae), ft = re.getProgramCacheKey(nt); let wt = te.programs; te.environment = O.isMeshStandardMaterial ? ie.environment : null, te.fog = ie.fog, te.envMap = (O.isMeshStandardMaterial ? ot : st).get(O.envMap || te.environment), wt === void 0 && (O.addEventListener("dispose", ke), wt = new Map, te.programs = wt); let Qe = wt.get(ft); if (Qe !== void 0) { if (te.currentProgram === Qe && te.lightsStateVersion === Ke) return hn(O, nt), Qe } else nt.uniforms = re.getUniforms(O), O.onBuild(ae, nt, M), O.onBeforeCompile(nt, M), Qe = re.acquireProgram(nt, ft), wt.set(ft, Qe), te.uniforms = nt.uniforms; const Ze = te.uniforms; (!O.isShaderMaterial && !O.isRawShaderMaterial || O.clipping === !0) && (Ze.clippingPlanes = qe.uniform), hn(O, nt), te.needsLights = ln(O), te.lightsStateVersion = Ke, te.needsLights && (Ze.ambientLightColor.value = ue.state.ambient, Ze.lightProbe.value = ue.state.probe, Ze.directionalLights.value = ue.state.directional, Ze.directionalLightShadows.value = ue.state.directionalShadow, Ze.spotLights.value = ue.state.spot, Ze.spotLightShadows.value = ue.state.spotShadow, Ze.rectAreaLights.value = ue.state.rectArea, Ze.ltc_1.value = ue.state.rectAreaLTC1, Ze.ltc_2.value = ue.state.rectAreaLTC2, Ze.pointLights.value = ue.state.point, Ze.pointLightShadows.value = ue.state.pointShadow, Ze.hemisphereLights.value = ue.state.hemi, Ze.directionalShadowMap.value = ue.state.directionalShadowMap, Ze.directionalShadowMatrix.value = ue.state.directionalShadowMatrix, Ze.spotShadowMap.value = ue.state.spotShadowMap, Ze.spotLightMatrix.value = ue.state.spotLightMatrix, Ze.spotLightMap.value = ue.state.spotLightMap, Ze.pointShadowMap.value = ue.state.pointShadowMap, Ze.pointShadowMatrix.value = ue.state.pointShadowMatrix); const zt = Qe.getUniforms(), sn = fy.seqWithValue(zt.seq, Ze); return te.currentProgram = Qe, te.uniformsList = sn, Qe } function hn(O, ie) { const ae = Fe.get(O); ae.outputColorSpace = ie.outputColorSpace, ae.instancing = ie.instancing, ae.instancingColor = ie.instancingColor, ae.skinning = ie.skinning, ae.morphTargets = ie.morphTargets, ae.morphNormals = ie.morphNormals, ae.morphColors = ie.morphColors, ae.morphTargetsCount = ie.morphTargetsCount, ae.numClippingPlanes = ie.numClippingPlanes, ae.numIntersection = ie.numClipIntersection, ae.vertexAlphas = ie.vertexAlphas, ae.vertexTangents = ie.vertexTangents, ae.toneMapping = ie.toneMapping } function ai(O, ie, ae, te, ue) { ie.isScene !== !0 && (ie = Bt), Ve.resetTextureUnits(); const Ue = ie.fog, Ke = te.isMeshStandardMaterial ? ie.environment : null, nt = R === null ? M.outputColorSpace : R.isXRRenderTarget === !0 ? R.texture.colorSpace : po, ft = (te.isMeshStandardMaterial ? ot : st).get(te.envMap || Ke), wt = te.vertexColors === !0 && !!ae.attributes.color && ae.attributes.color.itemSize === 4, Qe = !!ae.attributes.tangent && (!!te.normalMap || te.anisotropy > 0), Ze = !!ae.morphAttributes.position, zt = !!ae.morphAttributes.normal, sn = !!ae.morphAttributes.color; let Ri = Ho; te.toneMapped && (R === null || R.isXRRenderTarget === !0) && (Ri = M.toneMapping); const li = ae.morphAttributes.position || ae.morphAttributes.normal || ae.morphAttributes.color, Nt = li !== void 0 ? li.length : 0, gt = Fe.get(te), jt = x.state.lights; if (ge === !0 && (xe === !0 || O !== b)) { const Ui = O === b && te.id === B; qe.setState(te, O, Ui) } let dt = !1; te.version === gt.__version ? (gt.needsLights && gt.lightsStateVersion !== jt.state.version || gt.outputColorSpace !== nt || ue.isInstancedMesh && gt.instancing === !1 || !ue.isInstancedMesh && gt.instancing === !0 || ue.isSkinnedMesh && gt.skinning === !1 || !ue.isSkinnedMesh && gt.skinning === !0 || ue.isInstancedMesh && gt.instancingColor === !0 && ue.instanceColor === null || ue.isInstancedMesh && gt.instancingColor === !1 && ue.instanceColor !== null || gt.envMap !== ft || te.fog === !0 && gt.fog !== Ue || gt.numClippingPlanes !== void 0 && (gt.numClippingPlanes !== qe.numPlanes || gt.numIntersection !== qe.numIntersection) || gt.vertexAlphas !== wt || gt.vertexTangents !== Qe || gt.morphTargets !== Ze || gt.morphNormals !== zt || gt.morphColors !== sn || gt.toneMapping !== Ri || Ee.isWebGL2 === !0 && gt.morphTargetsCount !== Nt) && (dt = !0) : (dt = !0, gt.__version = te.version); let Ni = gt.currentProgram; dt === !0 && (Ni = Mt(te, ie, ue)); let ci = !1, Zn = !1, Vs = !1; const On = Ni.getUniforms(), Fn = gt.uniforms; if (ve.useProgram(Ni.program) && (ci = !0, Zn = !0, Vs = !0), te.id !== B && (B = te.id, Zn = !0), ci || b !== O) { if (On.setValue(H, "projectionMatrix", O.projectionMatrix), Ee.logarithmicDepthBuffer && On.setValue(H, "logDepthBufFC", 2 / (Math.log(O.far + 1) / Math.LN2)), b !== O && (b = O, Zn = !0, Vs = !0), te.isShaderMaterial || te.isMeshPhongMaterial || te.isMeshToonMaterial || te.isMeshStandardMaterial || te.envMap) { const Ui = On.map.cameraPosition; Ui !== void 0 && Ui.setValue(H, ut.setFromMatrixPosition(O.matrixWorld)) } (te.isMeshPhongMaterial || te.isMeshToonMaterial || te.isMeshLambertMaterial || te.isMeshBasicMaterial || te.isMeshStandardMaterial || te.isShaderMaterial) && On.setValue(H, "isOrthographic", O.isOrthographicCamera === !0), (te.isMeshPhongMaterial || te.isMeshToonMaterial || te.isMeshLambertMaterial || te.isMeshBasicMaterial || te.isMeshStandardMaterial || te.isShaderMaterial || te.isShadowMaterial || ue.isSkinnedMesh) && On.setValue(H, "viewMatrix", O.matrixWorldInverse) } if (ue.isSkinnedMesh) { On.setOptional(H, ue, "bindMatrix"), On.setOptional(H, ue, "bindMatrixInverse"); const Ui = ue.skeleton; Ui && (Ee.floatVertexTextures ? (Ui.boneTexture === null && Ui.computeBoneTexture(), On.setValue(H, "boneTexture", Ui.boneTexture, Ve), On.setValue(H, "boneTextureSize", Ui.boneTextureSize)) : console.warn("THREE.WebGLRenderer: SkinnedMesh can only be used with WebGL 2. With WebGL 1 OES_texture_float and vertex textures support is required.")) } const ka = ae.morphAttributes; if ((ka.position !== void 0 || ka.normal !== void 0 || ka.color !== void 0 && Ee.isWebGL2 === !0) && X.update(ue, ae, Ni), (Zn || gt.receiveShadow !== ue.receiveShadow) && (gt.receiveShadow = ue.receiveShadow, On.setValue(H, "receiveShadow", ue.receiveShadow)), te.isMeshGouraudMaterial && te.envMap !== null && (Fn.envMap.value = ft, Fn.flipEnvMap.value = ft.isCubeTexture && ft.isRenderTargetTexture === !1 ? -1 : 1), Zn && (On.setValue(H, "toneMappingExposure", M.toneMappingExposure), gt.needsLights && Jn(Fn, Vs), Ue && te.fog === !0 && Ae.refreshFogUniforms(Fn, Ue), Ae.refreshMaterialUniforms(Fn, te, Q, ne, Be), fy.upload(H, gt.uniformsList, Fn, Ve)), te.isShaderMaterial && te.uniformsNeedUpdate === !0 && (fy.upload(H, gt.uniformsList, Fn, Ve), te.uniformsNeedUpdate = !1), te.isSpriteMaterial && On.setValue(H, "center", ue.center), On.setValue(H, "modelViewMatrix", ue.modelViewMatrix), On.setValue(H, "normalMatrix", ue.normalMatrix), On.setValue(H, "modelMatrix", ue.matrixWorld), te.isShaderMaterial || te.isRawShaderMaterial) { const Ui = te.uniformsGroups; for (let vu = 0, _u = Ui.length; vu < _u; vu++)if (Ee.isWebGL2) { const Dh = Ui[vu]; lt.update(Dh, Ni), lt.bind(Dh, Ni) } else console.warn("THREE.WebGLRenderer: Uniform Buffer Objects can only be used with WebGL 2.") } return Ni } function Jn(O, ie) { O.ambientLightColor.needsUpdate = ie, O.lightProbe.needsUpdate = ie, O.directionalLights.needsUpdate = ie, O.directionalLightShadows.needsUpdate = ie, O.pointLights.needsUpdate = ie, O.pointLightShadows.needsUpdate = ie, O.spotLights.needsUpdate = ie, O.spotLightShadows.needsUpdate = ie, O.rectAreaLights.needsUpdate = ie, O.hemisphereLights.needsUpdate = ie } function ln(O) { return O.isMeshLambertMaterial || O.isMeshToonMaterial || O.isMeshPhongMaterial || O.isMeshStandardMaterial || O.isShadowMaterial || O.isShaderMaterial && O.lights === !0 } this.getActiveCubeFace = function () { return C }, this.getActiveMipmapLevel = function () { return T }, this.getRenderTarget = function () { return R }, this.setRenderTargetTextures = function (O, ie, ae) { Fe.get(O.texture).__webglTexture = ie, Fe.get(O.depthTexture).__webglTexture = ae; const te = Fe.get(O); te.__hasExternalTextures = !0, te.__hasExternalTextures && (te.__autoAllocateDepthBuffer = ae === void 0, te.__autoAllocateDepthBuffer || fe.has("WEBGL_multisampled_render_to_texture") === !0 && (console.warn("THREE.WebGLRenderer: Render-to-texture extension was disabled because an external texture was provided"), te.__useRenderToTexture = !1)) }, this.setRenderTargetFramebuffer = function (O, ie) { const ae = Fe.get(O); ae.__webglFramebuffer = ie, ae.__useDefaultFramebuffer = ie === void 0 }, this.setRenderTarget = function (O, ie = 0, ae = 0) { R = O, C = ie, T = ae; let te = !0, ue = null, Ue = !1, Ke = !1; if (O) { const ft = Fe.get(O); ft.__useDefaultFramebuffer !== void 0 ? (ve.bindFramebuffer(H.FRAMEBUFFER, null), te = !1) : ft.__webglFramebuffer === void 0 ? Ve.setupRenderTarget(O) : ft.__hasExternalTextures && Ve.rebindTextures(O, Fe.get(O.texture).__webglTexture, Fe.get(O.depthTexture).__webglTexture); const wt = O.texture; (wt.isData3DTexture || wt.isDataArrayTexture || wt.isCompressedArrayTexture) && (Ke = !0); const Qe = Fe.get(O).__webglFramebuffer; O.isWebGLCubeRenderTarget ? (Array.isArray(Qe[ie]) ? ue = Qe[ie][ae] : ue = Qe[ie], Ue = !0) : Ee.isWebGL2 && O.samples > 0 && Ve.useMultisampledRTT(O) === !1 ? ue = Fe.get(O).__webglMultisampledFramebuffer : Array.isArray(Qe) ? ue = Qe[ae] : ue = Qe, I.copy(O.viewport), N.copy(O.scissor), V = O.scissorTest } else I.copy(L).multiplyScalar(Q).floor(), N.copy(G).multiplyScalar(Q).floor(), V = K; if (ve.bindFramebuffer(H.FRAMEBUFFER, ue) && Ee.drawBuffers && te && ve.drawBuffers(O, ue), ve.viewport(I), ve.scissor(N), ve.setScissorTest(V), Ue) { const ft = Fe.get(O.texture); H.framebufferTexture2D(H.FRAMEBUFFER, H.COLOR_ATTACHMENT0, H.TEXTURE_CUBE_MAP_POSITIVE_X + ie, ft.__webglTexture, ae) } else if (Ke) { const ft = Fe.get(O.texture), wt = ie || 0; H.framebufferTextureLayer(H.FRAMEBUFFER, H.COLOR_ATTACHMENT0, ft.__webglTexture, ae || 0, wt) } B = -1 }, this.readRenderTargetPixels = function (O, ie, ae, te, ue, Ue, Ke) { if (!(O && O.isWebGLRenderTarget)) { console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget."); return } let nt = Fe.get(O).__webglFramebuffer; if (O.isWebGLCubeRenderTarget && Ke !== void 0 && (nt = nt[Ke]), nt) { ve.bindFramebuffer(H.FRAMEBUFFER, nt); try { const ft = O.texture, wt = ft.format, Qe = ft.type; if (wt !== Pr && be.convert(wt) !== H.getParameter(H.IMPLEMENTATION_COLOR_READ_FORMAT)) { console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format."); return } const Ze = Qe === gh && (fe.has("EXT_color_buffer_half_float") || Ee.isWebGL2 && fe.has("EXT_color_buffer_float")); if (Qe !== Go && be.convert(Qe) !== H.getParameter(H.IMPLEMENTATION_COLOR_READ_TYPE) && !(Qe === Do && (Ee.isWebGL2 || fe.has("OES_texture_float") || fe.has("WEBGL_color_buffer_float"))) && !Ze) { console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type."); return } ie >= 0 && ie <= O.width - te && ae >= 0 && ae <= O.height - ue && H.readPixels(ie, ae, te, ue, be.convert(wt), be.convert(Qe), Ue) } finally { const ft = R !== null ? Fe.get(R).__webglFramebuffer : null; ve.bindFramebuffer(H.FRAMEBUFFER, ft) } } }, this.copyFramebufferToTexture = function (O, ie, ae = 0) { const te = Math.pow(2, -ae), ue = Math.floor(ie.image.width * te), Ue = Math.floor(ie.image.height * te); Ve.setTexture2D(ie, 0), H.copyTexSubImage2D(H.TEXTURE_2D, ae, 0, 0, O.x, O.y, ue, Ue), ve.unbindTexture() }, this.copyTextureToTexture = function (O, ie, ae, te = 0) { const ue = ie.image.width, Ue = ie.image.height, Ke = be.convert(ae.format), nt = be.convert(ae.type); Ve.setTexture2D(ae, 0), H.pixelStorei(H.UNPACK_FLIP_Y_WEBGL, ae.flipY), H.pixelStorei(H.UNPACK_PREMULTIPLY_ALPHA_WEBGL, ae.premultiplyAlpha), H.pixelStorei(H.UNPACK_ALIGNMENT, ae.unpackAlignment), ie.isDataTexture ? H.texSubImage2D(H.TEXTURE_2D, te, O.x, O.y, ue, Ue, Ke, nt, ie.image.data) : ie.isCompressedTexture ? H.compressedTexSubImage2D(H.TEXTURE_2D, te, O.x, O.y, ie.mipmaps[0].width, ie.mipmaps[0].height, Ke, ie.mipmaps[0].data) : H.texSubImage2D(H.TEXTURE_2D, te, O.x, O.y, Ke, nt, ie.image), te === 0 && ae.generateMipmaps && H.generateMipmap(H.TEXTURE_2D), ve.unbindTexture() }, this.copyTextureToTexture3D = function (O, ie, ae, te, ue = 0) { if (M.isWebGL1Renderer) { console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: can only be used with WebGL2."); return } const Ue = O.max.x - O.min.x + 1, Ke = O.max.y - O.min.y + 1, nt = O.max.z - O.min.z + 1, ft = be.convert(te.format), wt = be.convert(te.type); let Qe; if (te.isData3DTexture) Ve.setTexture3D(te, 0), Qe = H.TEXTURE_3D; else if (te.isDataArrayTexture) Ve.setTexture2DArray(te, 0), Qe = H.TEXTURE_2D_ARRAY; else { console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: only supports THREE.DataTexture3D and THREE.DataTexture2DArray."); return } H.pixelStorei(H.UNPACK_FLIP_Y_WEBGL, te.flipY), H.pixelStorei(H.UNPACK_PREMULTIPLY_ALPHA_WEBGL, te.premultiplyAlpha), H.pixelStorei(H.UNPACK_ALIGNMENT, te.unpackAlignment); const Ze = H.getParameter(H.UNPACK_ROW_LENGTH), zt = H.getParameter(H.UNPACK_IMAGE_HEIGHT), sn = H.getParameter(H.UNPACK_SKIP_PIXELS), Ri = H.getParameter(H.UNPACK_SKIP_ROWS), li = H.getParameter(H.UNPACK_SKIP_IMAGES), Nt = ae.isCompressedTexture ? ae.mipmaps[0] : ae.image; H.pixelStorei(H.UNPACK_ROW_LENGTH, Nt.width), H.pixelStorei(H.UNPACK_IMAGE_HEIGHT, Nt.height), H.pixelStorei(H.UNPACK_SKIP_PIXELS, O.min.x), H.pixelStorei(H.UNPACK_SKIP_ROWS, O.min.y), H.pixelStorei(H.UNPACK_SKIP_IMAGES, O.min.z), ae.isDataTexture || ae.isData3DTexture ? H.texSubImage3D(Qe, ue, ie.x, ie.y, ie.z, Ue, Ke, nt, ft, wt, Nt.data) : ae.isCompressedArrayTexture ? (console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: untested support for compressed srcTexture."), H.compressedTexSubImage3D(Qe, ue, ie.x, ie.y, ie.z, Ue, Ke, nt, ft, Nt.data)) : H.texSubImage3D(Qe, ue, ie.x, ie.y, ie.z, Ue, Ke, nt, ft, wt, Nt), H.pixelStorei(H.UNPACK_ROW_LENGTH, Ze), H.pixelStorei(H.UNPACK_IMAGE_HEIGHT, zt), H.pixelStorei(H.UNPACK_SKIP_PIXELS, sn), H.pixelStorei(H.UNPACK_SKIP_ROWS, Ri), H.pixelStorei(H.UNPACK_SKIP_IMAGES, li), ue === 0 && te.generateMipmaps && H.generateMipmap(Qe), ve.unbindTexture() }, this.initTexture = function (O) { O.isCubeTexture ? Ve.setTextureCube(O, 0) : O.isData3DTexture ? Ve.setTexture3D(O, 0) : O.isDataArrayTexture || O.isCompressedArrayTexture ? Ve.setTexture2DArray(O, 0) : Ve.setTexture2D(O, 0), ve.unbindTexture() }, this.resetState = function () { C = 0, T = 0, R = null, ve.reset(), De.reset() }, typeof __THREE_DEVTOOLS__ < "u" && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe", { detail: this })) } get coordinateSystem() { return Oo } get physicallyCorrectLights() { return console.warn("THREE.WebGLRenderer: The property .physicallyCorrectLights has been removed. Set renderer.useLegacyLights instead."), !this.useLegacyLights } set physicallyCorrectLights(e) { console.warn("THREE.WebGLRenderer: The property .physicallyCorrectLights has been removed. Set renderer.useLegacyLights instead."), this.useLegacyLights = !e } get outputEncoding() { return console.warn("THREE.WebGLRenderer: Property .outputEncoding has been removed. Use .outputColorSpace instead."), this.outputColorSpace === bt ? Pl : vE } set outputEncoding(e) { console.warn("THREE.WebGLRenderer: Property .outputEncoding has been removed. Use .outputColorSpace instead."), this.outputColorSpace = e === Pl ? bt : po } get useLegacyLights() { return console.warn("THREE.WebGLRenderer: The property .useLegacyLights has been deprecated. Migrate your lighting according to the following guide: https://discourse.threejs.org/t/updates-to-lighting-in-three-js-r155/53733."), this._useLegacyLights } set useLegacyLights(e) { console.warn("THREE.WebGLRenderer: The property .useLegacyLights has been deprecated. Migrate your lighting according to the following guide: https://discourse.threejs.org/t/updates-to-lighting-in-three-js-r155/53733."), this._useLegacyLights = e } } class kF extends bE { } kF.prototype.isWebGL1Renderer = !0; class Gv { constructor(e, t = 25e-5) { this.isFogExp2 = !0, this.name = "", this.color = new We(e), this.density = t } clone() { return new Gv(this.color, this.density) } toJSON() { return { type: "FogExp2", color: this.color.getHex(), density: this.density } } } class Vv { constructor(e, t = 1, n = 1e3) { this.isFog = !0, this.name = "", this.color = new We(e), this.near = t, this.far = n } clone() { return new Vv(this.color, this.near, this.far) } toJSON() { return { type: "Fog", color: this.color.getHex(), near: this.near, far: this.far } } } class ov extends qt { constructor() { super(), this.isScene = !0, this.type = "Scene", this.background = null, this.environment = null, this.fog = null, this.backgroundBlurriness = 0, this.backgroundIntensity = 1, this.overrideMaterial = null, typeof __THREE_DEVTOOLS__ < "u" && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe", { detail: this })) } copy(e, t) { return super.copy(e, t), e.background !== null && (this.background = e.background.clone()), e.environment !== null && (this.environment = e.environment.clone()), e.fog !== null && (this.fog = e.fog.clone()), this.backgroundBlurriness = e.backgroundBlurriness, this.backgroundIntensity = e.backgroundIntensity, e.overrideMaterial !== null && (this.overrideMaterial = e.overrideMaterial.clone()), this.matrixAutoUpdate = e.matrixAutoUpdate, this } toJSON(e) { const t = super.toJSON(e); return this.fog !== null && (t.object.fog = this.fog.toJSON()), this.backgroundBlurriness > 0 && (t.object.backgroundBlurriness = this.backgroundBlurriness), this.backgroundIntensity !== 1 && (t.object.backgroundIntensity = this.backgroundIntensity), t } } class um { constructor(e, t) { this.isInterleavedBuffer = !0, this.array = e, this.stride = t, this.count = e !== void 0 ? e.length / t : 0, this.usage = zp, this.updateRange = { offset: 0, count: -1 }, this.version = 0, this.uuid = ss() } onUploadCallback() { } set needsUpdate(e) { e === !0 && this.version++ } setUsage(e) { return this.usage = e, this } copy(e) { return this.array = new e.array.constructor(e.array), this.count = e.count, this.stride = e.stride, this.usage = e.usage, this } copyAt(e, t, n) { e *= this.stride, n *= t.stride; for (let r = 0, s = this.stride; r < s; r++)this.array[e + r] = t.array[n + r]; return this } set(e, t = 0) { return this.array.set(e, t), this } clone(e) { e.arrayBuffers === void 0 && (e.arrayBuffers = {}), this.array.buffer._uuid === void 0 && (this.array.buffer._uuid = ss()), e.arrayBuffers[this.array.buffer._uuid] === void 0 && (e.arrayBuffers[this.array.buffer._uuid] = this.array.slice(0).buffer); const t = new this.array.constructor(e.arrayBuffers[this.array.buffer._uuid]), n = new this.constructor(t, this.stride); return n.setUsage(this.usage), n } onUpload(e) { return this.onUploadCallback = e, this } toJSON(e) { return e.arrayBuffers === void 0 && (e.arrayBuffers = {}), this.array.buffer._uuid === void 0 && (this.array.buffer._uuid = ss()), e.arrayBuffers[this.array.buffer._uuid] === void 0 && (e.arrayBuffers[this.array.buffer._uuid] = Array.from(new Uint32Array(this.array.buffer))), { uuid: this.uuid, buffer: this.array.buffer._uuid, type: this.array.constructor.name, stride: this.stride } } } const lr = new k; class zl { constructor(e, t, n, r = !1) { this.isInterleavedBufferAttribute = !0, this.name = "", this.data = e, this.itemSize = t, this.offset = n, this.normalized = r } get count() { return this.data.count } get array() { return this.data.array } set needsUpdate(e) { this.data.needsUpdate = e } applyMatrix4(e) { for (let t = 0, n = this.data.count; t < n; t++)lr.fromBufferAttribute(this, t), lr.applyMatrix4(e), this.setXYZ(t, lr.x, lr.y, lr.z); return this } applyNormalMatrix(e) { for (let t = 0, n = this.count; t < n; t++)lr.fromBufferAttribute(this, t), lr.applyNormalMatrix(e), this.setXYZ(t, lr.x, lr.y, lr.z); return this } transformDirection(e) { for (let t = 0, n = this.count; t < n; t++)lr.fromBufferAttribute(this, t), lr.transformDirection(e), this.setXYZ(t, lr.x, lr.y, lr.z); return this } setX(e, t) { return this.normalized && (t = It(t, this.array)), this.data.array[e * this.data.stride + this.offset] = t, this } setY(e, t) { return this.normalized && (t = It(t, this.array)), this.data.array[e * this.data.stride + this.offset + 1] = t, this } setZ(e, t) { return this.normalized && (t = It(t, this.array)), this.data.array[e * this.data.stride + this.offset + 2] = t, this } setW(e, t) { return this.normalized && (t = It(t, this.array)), this.data.array[e * this.data.stride + this.offset + 3] = t, this } getX(e) { let t = this.data.array[e * this.data.stride + this.offset]; return this.normalized && (t = Ir(t, this.array)), t } getY(e) { let t = this.data.array[e * this.data.stride + this.offset + 1]; return this.normalized && (t = Ir(t, this.array)), t } getZ(e) { let t = this.data.array[e * this.data.stride + this.offset + 2]; return this.normalized && (t = Ir(t, this.array)), t } getW(e) { let t = this.data.array[e * this.data.stride + this.offset + 3]; return this.normalized && (t = Ir(t, this.array)), t } setXY(e, t, n) { return e = e * this.data.stride + this.offset, this.normalized && (t = It(t, this.array), n = It(n, this.array)), this.data.array[e + 0] = t, this.data.array[e + 1] = n, this } setXYZ(e, t, n, r) { return e = e * this.data.stride + this.offset, this.normalized && (t = It(t, this.array), n = It(n, this.array), r = It(r, this.array)), this.data.array[e + 0] = t, this.data.array[e + 1] = n, this.data.array[e + 2] = r, this } setXYZW(e, t, n, r, s) { return e = e * this.data.stride + this.offset, this.normalized && (t = It(t, this.array), n = It(n, this.array), r = It(r, this.array), s = It(s, this.array)), this.data.array[e + 0] = t, this.data.array[e + 1] = n, this.data.array[e + 2] = r, this.data.array[e + 3] = s, this } clone(e) { if (e === void 0) { console.log("THREE.InterleavedBufferAttribute.clone(): Cloning an interleaved buffer attribute will de-interleave buffer data."); const t = []; for (let n = 0; n < this.count; n++) { const r = n * this.data.stride + this.offset; for (let s = 0; s < this.itemSize; s++)t.push(this.data.array[r + s]) } return new rn(new this.array.constructor(t), this.itemSize, this.normalized) } else return e.interleavedBuffers === void 0 && (e.interleavedBuffers = {}), e.interleavedBuffers[this.data.uuid] === void 0 && (e.interleavedBuffers[this.data.uuid] = this.data.clone(e)), new zl(e.interleavedBuffers[this.data.uuid], this.itemSize, this.offset, this.normalized) } toJSON(e) { if (e === void 0) { console.log("THREE.InterleavedBufferAttribute.toJSON(): Serializing an interleaved buffer attribute will de-interleave buffer data."); const t = []; for (let n = 0; n < this.count; n++) { const r = n * this.data.stride + this.offset; for (let s = 0; s < this.itemSize; s++)t.push(this.data.array[r + s]) } return { itemSize: this.itemSize, type: this.array.constructor.name, array: t, normalized: this.normalized } } else return e.interleavedBuffers === void 0 && (e.interleavedBuffers = {}), e.interleavedBuffers[this.data.uuid] === void 0 && (e.interleavedBuffers[this.data.uuid] = this.data.toJSON(e)), { isInterleavedBufferAttribute: !0, itemSize: this.itemSize, data: this.data.uuid, offset: this.offset, normalized: this.normalized } } } class RE extends oi { constructor(e) { super(), this.isSpriteMaterial = !0, this.type = "SpriteMaterial", this.color = new We(16777215), this.map = null, this.alphaMap = null, this.rotation = 0, this.sizeAttenuation = !0, this.transparent = !0, this.fog = !0, this.setValues(e) } copy(e) { return super.copy(e), this.color.copy(e.color), this.map = e.map, this.alphaMap = e.alphaMap, this.rotation = e.rotation, this.sizeAttenuation = e.sizeAttenuation, this.fog = e.fog, this } } let $u; const md = new k, ef = new k, tf = new k, nf = new _e, gd = new _e, NF = new yt, l0 = new k, yd = new k, c0 = new k, DP = new _e, JA = new _e, OP = new _e; class UF extends qt { constructor(e) { if (super(), this.isSprite = !0, this.type = "Sprite", $u === void 0) { $u = new Rt; const t = new Float32Array([-.5, -.5, 0, 0, 0, .5, -.5, 0, 1, 0, .5, .5, 0, 1, 1, -.5, .5, 0, 0, 1]), n = new um(t, 5); $u.setIndex([0, 1, 2, 0, 2, 3]), $u.setAttribute("position", new zl(n, 3, 0, !1)), $u.setAttribute("uv", new zl(n, 2, 3, !1)) } this.geometry = $u, this.material = e !== void 0 ? e : new RE, this.center = new _e(.5, .5) } raycast(e, t) { e.camera === null && console.error('THREE.Sprite: "Raycaster.camera" needs to be set in order to raycast against sprites.'), ef.setFromMatrixScale(this.matrixWorld), NF.copy(e.camera.matrixWorld), this.modelViewMatrix.multiplyMatrices(e.camera.matrixWorldInverse, this.matrixWorld), tf.setFromMatrixPosition(this.modelViewMatrix), e.camera.isPerspectiveCamera && this.material.sizeAttenuation === !1 && ef.multiplyScalar(-tf.z); const n = this.material.rotation; let r, s; n !== 0 && (s = Math.cos(n), r = Math.sin(n)); const o = this.center; u0(l0.set(-.5, -.5, 0), tf, o, ef, r, s), u0(yd.set(.5, -.5, 0), tf, o, ef, r, s), u0(c0.set(.5, .5, 0), tf, o, ef, r, s), DP.set(0, 0), JA.set(1, 0), OP.set(1, 1); let a = e.ray.intersectTriangle(l0, yd, c0, !1, md); if (a === null && (u0(yd.set(-.5, .5, 0), tf, o, ef, r, s), JA.set(0, 1), a = e.ray.intersectTriangle(l0, c0, yd, !1, md), a === null)) return; const l = e.ray.origin.distanceTo(md); l < e.near || l > e.far || t.push({ distance: l, point: md.clone(), uv: br.getInterpolation(md, l0, yd, c0, DP, JA, OP, new _e), face: null, object: this }) } copy(e, t) { return super.copy(e, t), e.center !== void 0 && this.center.copy(e.center), this.material = e.material, this } } function u0(i, e, t, n, r, s) { nf.subVectors(i, t).addScalar(.5).multiply(n), r !== void 0 ? (gd.x = s * nf.x - r * nf.y, gd.y = r * nf.x + s * nf.y) : gd.copy(nf), i.copy(e), i.x += gd.x, i.y += gd.y, i.applyMatrix4(NF) } const f0 = new k, FP = new k; class zF extends qt { constructor() { super(), this._currentLevel = 0, this.type = "LOD", Object.defineProperties(this, { levels: { enumerable: !0, value: [] }, isLOD: { value: !0 } }), this.autoUpdate = !0 } copy(e) { super.copy(e, !1); const t = e.levels; for (let n = 0, r = t.length; n < r; n++) { const s = t[n]; this.addLevel(s.object.clone(), s.distance, s.hysteresis) } return this.autoUpdate = e.autoUpdate, this } addLevel(e, t = 0, n = 0) { t = Math.abs(t); const r = this.levels; let s; for (s = 0; s < r.length && !(t < r[s].distance); s++); return r.splice(s, 0, { distance: t, hysteresis: n, object: e }), this.add(e), this } getCurrentLevel() { return this._currentLevel } getObjectForDistance(e) { const t = this.levels; if (t.length > 0) { let n, r; for (n = 1, r = t.length; n < r; n++) { let s = t[n].distance; if (t[n].object.visible && (s -= s * t[n].hysteresis), e < s) break } return t[n - 1].object } return null } raycast(e, t) { if (this.levels.length > 0) { f0.setFromMatrixPosition(this.matrixWorld); const r = e.ray.origin.distanceTo(f0); this.getObjectForDistance(r).raycast(e, t) } } update(e) { const t = this.levels; if (t.length > 1) { f0.setFromMatrixPosition(e.matrixWorld), FP.setFromMatrixPosition(this.matrixWorld); const n = f0.distanceTo(FP) / e.zoom; t[0].object.visible = !0; let r, s; for (r = 1, s = t.length; r < s; r++) { let o = t[r].distance; if (t[r].object.visible && (o -= o * t[r].hysteresis), n >= o) t[r - 1].object.visible = !1, t[r].object.visible = !0; else break } for (this._currentLevel = r - 1; r < s; r++)t[r].object.visible = !1 } } toJSON(e) { const t = super.toJSON(e); this.autoUpdate === !1 && (t.object.autoUpdate = !1), t.object.levels = []; const n = this.levels; for (let r = 0, s = n.length; r < s; r++) { const o = n[r]; t.object.levels.push({ object: o.object.uuid, distance: o.distance, hysteresis: o.hysteresis }) } return t } } const kP = new k, NP = new on, UP = new on, Bj = new k, zP = new yt, rf = new k, YA = new Gs, HP = new yt, jA = new Ph; class PE extends Ei { constructor(e, t) { super(e, t), this.isSkinnedMesh = !0, this.type = "SkinnedMesh", this.bindMode = "attached", this.bindMatrix = new yt, this.bindMatrixInverse = new yt, this.boundingBox = null, this.boundingSphere = null } computeBoundingBox() { const e = this.geometry; this.boundingBox === null && (this.boundingBox = new yo), this.boundingBox.makeEmpty(); const t = e.getAttribute("position"); for (let n = 0; n < t.count; n++)rf.fromBufferAttribute(t, n), this.applyBoneTransform(n, rf), this.boundingBox.expandByPoint(rf) } computeBoundingSphere() { const e = this.geometry; this.boundingSphere === null && (this.boundingSphere = new Gs), this.boundingSphere.makeEmpty(); const t = e.getAttribute("position"); for (let n = 0; n < t.count; n++)rf.fromBufferAttribute(t, n), this.applyBoneTransform(n, rf), this.boundingSphere.expandByPoint(rf) } copy(e, t) { return super.copy(e, t), this.bindMode = e.bindMode, this.bindMatrix.copy(e.bindMatrix), this.bindMatrixInverse.copy(e.bindMatrixInverse), this.skeleton = e.skeleton, e.boundingBox !== null && (this.boundingBox = e.boundingBox.clone()), e.boundingSphere !== null && (this.boundingSphere = e.boundingSphere.clone()), this } raycast(e, t) { const n = this.material, r = this.matrixWorld; n !== void 0 && (this.boundingSphere === null && this.computeBoundingSphere(), YA.copy(this.boundingSphere), YA.applyMatrix4(r), e.ray.intersectsSphere(YA) !== !1 && (HP.copy(r).invert(), jA.copy(e.ray).applyMatrix4(HP), !(this.boundingBox !== null && jA.intersectsBox(this.boundingBox) === !1) && this._computeIntersections(e, t, jA))) } getVertexPosition(e, t) { return super.getVertexPosition(e, t), this.applyBoneTransform(e, t), t } bind(e, t) { this.skeleton = e, t === void 0 && (this.updateMatrixWorld(!0), this.skeleton.calculateInverses(), t = this.matrixWorld), this.bindMatrix.copy(t), this.bindMatrixInverse.copy(t).invert() } pose() { this.skeleton.pose() } normalizeSkinWeights() { const e = new on, t = this.geometry.attributes.skinWeight; for (let n = 0, r = t.count; n < r; n++) { e.fromBufferAttribute(t, n); const s = 1 / e.manhattanLength(); s !== 1 / 0 ? e.multiplyScalar(s) : e.set(1, 0, 0, 0), t.setXYZW(n, e.x, e.y, e.z, e.w) } } updateMatrixWorld(e) { super.updateMatrixWorld(e), this.bindMode === "attached" ? this.bindMatrixInverse.copy(this.matrixWorld).invert() : this.bindMode === "detached" ? this.bindMatrixInverse.copy(this.bindMatrix).invert() : console.warn("THREE.SkinnedMesh: Unrecognized bindMode: " + this.bindMode) } applyBoneTransform(e, t) { const n = this.skeleton, r = this.geometry; NP.fromBufferAttribute(r.attributes.skinIndex, e), UP.fromBufferAttribute(r.attributes.skinWeight, e), kP.copy(t).applyMatrix4(this.bindMatrix), t.set(0, 0, 0); for (let s = 0; s < 4; s++) { const o = UP.getComponent(s); if (o !== 0) { const a = NP.getComponent(s); zP.multiplyMatrices(n.bones[a].matrixWorld, n.boneInverses[a]), t.addScaledVector(Bj.copy(kP).applyMatrix4(zP), o) } } return t.applyMatrix4(this.bindMatrixInverse) } boneTransform(e, t) { return console.warn("THREE.SkinnedMesh: .boneTransform() was renamed to .applyBoneTransform() in r151."), this.applyBoneTransform(e, t) } } class Wv extends qt { constructor() { super(), this.isBone = !0, this.type = "Bone" } } class Kf extends wn { constructor(e = null, t = 1, n = 1, r, s, o, a, l, c = zn, f = zn, d, p) { super(null, o, a, l, c, f, r, s, d, p), this.isDataTexture = !0, this.image = { data: e, width: t, height: n }, this.generateMipmaps = !1, this.flipY = !1, this.unpackAlignment = 1 } } const GP = new yt, Lj = new yt; class fm { constructor(e = [], t = []) { this.uuid = ss(), this.bones = e.slice(0), this.boneInverses = t, this.boneMatrices = null, this.boneTexture = null, this.boneTextureSize = 0, this.init() } init() { const e = this.bones, t = this.boneInverses; if (this.boneMatrices = new Float32Array(e.length * 16), t.length === 0) this.calculateInverses(); else if (e.length !== t.length) { console.warn("THREE.Skeleton: Number of inverse bone matrices does not match amount of bones."), this.boneInverses = []; for (let n = 0, r = this.bones.length; n < r; n++)this.boneInverses.push(new yt) } } calculateInverses() { this.boneInverses.length = 0; for (let e = 0, t = this.bones.length; e < t; e++) { const n = new yt; this.bones[e] && n.copy(this.bones[e].matrixWorld).invert(), this.boneInverses.push(n) } } pose() { for (let e = 0, t = this.bones.length; e < t; e++) { const n = this.bones[e]; n && n.matrixWorld.copy(this.boneInverses[e]).invert() } for (let e = 0, t = this.bones.length; e < t; e++) { const n = this.bones[e]; n && (n.parent && n.parent.isBone ? (n.matrix.copy(n.parent.matrixWorld).invert(), n.matrix.multiply(n.matrixWorld)) : n.matrix.copy(n.matrixWorld), n.matrix.decompose(n.position, n.quaternion, n.scale)) } } update() { const e = this.bones, t = this.boneInverses, n = this.boneMatrices, r = this.boneTexture; for (let s = 0, o = e.length; s < o; s++) { const a = e[s] ? e[s].matrixWorld : Lj; GP.multiplyMatrices(a, t[s]), GP.toArray(n, s * 16) } r !== null && (r.needsUpdate = !0) } clone() { return new fm(this.bones, this.boneInverses) } computeBoneTexture() { let e = Math.sqrt(this.bones.length * 4); e = xF(e), e = Math.max(e, 4); const t = new Float32Array(e * e * 4); t.set(this.boneMatrices); const n = new Kf(t, e, e, Pr, Do); return n.needsUpdate = !0, this.boneMatrices = t, this.boneTexture = n, this.boneTextureSize = e, this } getBoneByName(e) { for (let t = 0, n = this.bones.length; t < n; t++) { const r = this.bones[t]; if (r.name === e) return r } } dispose() { this.boneTexture !== null && (this.boneTexture.dispose(), this.boneTexture = null) } fromJSON(e, t) { this.uuid = e.uuid; for (let n = 0, r = e.bones.length; n < r; n++) { const s = e.bones[n]; let o = t[s]; o === void 0 && (console.warn("THREE.Skeleton: No bone found with UUID:", s), o = new Wv), this.bones.push(o), this.boneInverses.push(new yt().fromArray(e.boneInverses[n])) } return this.init(), this } toJSON() { const e = { metadata: { version: 4.6, type: "Skeleton", generator: "Skeleton.toJSON" }, bones: [], boneInverses: [] }; e.uuid = this.uuid; const t = this.bones, n = this.boneInverses; for (let r = 0, s = t.length; r < s; r++) { const o = t[r]; e.bones.push(o.uuid); const a = n[r]; e.boneInverses.push(a.toArray()) } return e } } class xh extends rn { constructor(e, t, n, r = 1) { super(e, t, n), this.isInstancedBufferAttribute = !0, this.meshPerAttribute = r } copy(e) { return super.copy(e), this.meshPerAttribute = e.meshPerAttribute, this } toJSON() { const e = super.toJSON(); return e.meshPerAttribute = this.meshPerAttribute, e.isInstancedBufferAttribute = !0, e } } const sf = new yt, VP = new yt, h0 = [], WP = new yo, Dj = new yt, vd = new Ei, _d = new Gs; class IE extends Ei { constructor(e, t, n) { super(e, t), this.isInstancedMesh = !0, this.instanceMatrix = new xh(new Float32Array(n * 16), 16), this.instanceColor = null, this.count = n, this.boundingBox = null, this.boundingSphere = null; for (let r = 0; r < n; r++)this.setMatrixAt(r, Dj) } computeBoundingBox() { const e = this.geometry, t = this.count; this.boundingBox === null && (this.boundingBox = new yo), e.boundingBox === null && e.computeBoundingBox(), this.boundingBox.makeEmpty(); for (let n = 0; n < t; n++)this.getMatrixAt(n, sf), WP.copy(e.boundingBox).applyMatrix4(sf), this.boundingBox.union(WP) } computeBoundingSphere() { const e = this.geometry, t = this.count; this.boundingSphere === null && (this.boundingSphere = new Gs), e.boundingSphere === null && e.computeBoundingSphere(), this.boundingSphere.makeEmpty(); for (let n = 0; n < t; n++)this.getMatrixAt(n, sf), _d.copy(e.boundingSphere).applyMatrix4(sf), this.boundingSphere.union(_d) } copy(e, t) { return super.copy(e, t), this.instanceMatrix.copy(e.instanceMatrix), e.instanceColor !== null && (this.instanceColor = e.instanceColor.clone()), this.count = e.count, e.boundingBox !== null && (this.boundingBox = e.boundingBox.clone()), e.boundingSphere !== null && (this.boundingSphere = e.boundingSphere.clone()), this } getColorAt(e, t) { t.fromArray(this.instanceColor.array, e * 3) } getMatrixAt(e, t) { t.fromArray(this.instanceMatrix.array, e * 16) } raycast(e, t) { const n = this.matrixWorld, r = this.count; if (vd.geometry = this.geometry, vd.material = this.material, vd.material !== void 0 && (this.boundingSphere === null && this.computeBoundingSphere(), _d.copy(this.boundingSphere), _d.applyMatrix4(n), e.ray.intersectsSphere(_d) !== !1)) for (let s = 0; s < r; s++) { this.getMatrixAt(s, sf), VP.multiplyMatrices(n, sf), vd.matrixWorld = VP, vd.raycast(e, h0); for (let o = 0, a = h0.length; o < a; o++) { const l = h0[o]; l.instanceId = s, l.object = this, t.push(l) } h0.length = 0 } } setColorAt(e, t) { this.instanceColor === null && (this.instanceColor = new xh(new Float32Array(this.instanceMatrix.count * 3), 3)), t.toArray(this.instanceColor.array, e * 3) } setMatrixAt(e, t) { t.toArray(this.instanceMatrix.array, e * 16) } updateMorphTargets() { } dispose() { this.dispatchEvent({ type: "dispose" }) } } class ir extends oi { constructor(e) { super(), this.isLineBasicMaterial = !0, this.type = "LineBasicMaterial", this.color = new We(16777215), this.map = null, this.linewidth = 1, this.linecap = "round", this.linejoin = "round", this.fog = !0, this.setValues(e) } copy(e) { return super.copy(e), this.color.copy(e.color), this.map = e.map, this.linewidth = e.linewidth, this.linecap = e.linecap, this.linejoin = e.linejoin, this.fog = e.fog, this } } const XP = new k, JP = new k, YP = new yt, KA = new Ph, d0 = new Gs; class Oa extends qt { constructor(e = new Rt, t = new ir) { super(), this.isLine = !0, this.type = "Line", this.geometry = e, this.material = t, this.updateMorphTargets() } copy(e, t) { return super.copy(e, t), this.material = e.material, this.geometry = e.geometry, this } computeLineDistances() { const e = this.geometry; if (e.index === null) { const t = e.attributes.position, n = [0]; for (let r = 1, s = t.count; r < s; r++)XP.fromBufferAttribute(t, r - 1), JP.fromBufferAttribute(t, r), n[r] = n[r - 1], n[r] += XP.distanceTo(JP); e.setAttribute("lineDistance", new rt(n, 1)) } else console.warn("THREE.Line.computeLineDistances(): Computation only possible with non-indexed BufferGeometry."); return this } raycast(e, t) { const n = this.geometry, r = this.matrixWorld, s = e.params.Line.threshold, o = n.drawRange; if (n.boundingSphere === null && n.computeBoundingSphere(), d0.copy(n.boundingSphere), d0.applyMatrix4(r), d0.radius += s, e.ray.intersectsSphere(d0) === !1) return; YP.copy(r).invert(), KA.copy(e.ray).applyMatrix4(YP); const a = s / ((this.scale.x + this.scale.y + this.scale.z) / 3), l = a * a, c = new k, f = new k, d = new k, p = new k, m = this.isLineSegments ? 2 : 1, y = n.index, x = n.attributes.position; if (y !== null) { const g = Math.max(0, o.start), A = Math.min(y.count, o.start + o.count); for (let M = g, S = A - 1; M < S; M += m) { const C = y.getX(M), T = y.getX(M + 1); if (c.fromBufferAttribute(x, C), f.fromBufferAttribute(x, T), KA.distanceSqToSegment(c, f, p, d) > l) continue; p.applyMatrix4(this.matrixWorld); const B = e.ray.origin.distanceTo(p); B < e.near || B > e.far || t.push({ distance: B, point: d.clone().applyMatrix4(this.matrixWorld), index: M, face: null, faceIndex: null, object: this }) } } else { const g = Math.max(0, o.start), A = Math.min(x.count, o.start + o.count); for (let M = g, S = A - 1; M < S; M += m) { if (c.fromBufferAttribute(x, M), f.fromBufferAttribute(x, M + 1), KA.distanceSqToSegment(c, f, p, d) > l) continue; p.applyMatrix4(this.matrixWorld); const T = e.ray.origin.distanceTo(p); T < e.near || T > e.far || t.push({ distance: T, point: d.clone().applyMatrix4(this.matrixWorld), index: M, face: null, faceIndex: null, object: this }) } } } updateMorphTargets() { const t = this.geometry.morphAttributes, n = Object.keys(t); if (n.length > 0) { const r = t[n[0]]; if (r !== void 0) { this.morphTargetInfluences = [], this.morphTargetDictionary = {}; for (let s = 0, o = r.length; s < o; s++) { const a = r[s].name || String(s); this.morphTargetInfluences.push(0), this.morphTargetDictionary[a] = s } } } } } const jP = new k, KP = new k; class vo extends Oa { constructor(e, t) { super(e, t), this.isLineSegments = !0, this.type = "LineSegments" } computeLineDistances() { const e = this.geometry; if (e.index === null) { const t = e.attributes.position, n = []; for (let r = 0, s = t.count; r < s; r += 2)jP.fromBufferAttribute(t, r), KP.fromBufferAttribute(t, r + 1), n[r] = r === 0 ? 0 : n[r - 1], n[r + 1] = n[r] + jP.distanceTo(KP); e.setAttribute("lineDistance", new rt(n, 1)) } else console.warn("THREE.LineSegments.computeLineDistances(): Computation only possible with non-indexed BufferGeometry."); return this } } class BE extends Oa { constructor(e, t) { super(e, t), this.isLineLoop = !0, this.type = "LineLoop" } } class Xv extends oi { constructor(e) { super(), this.isPointsMaterial = !0, this.type = "PointsMaterial", this.color = new We(16777215), this.map = null, this.alphaMap = null, this.size = 1, this.sizeAttenuation = !0, this.fog = !0, this.setValues(e) } copy(e) { return super.copy(e), this.color.copy(e.color), this.map = e.map, this.alphaMap = e.alphaMap, this.size = e.size, this.sizeAttenuation = e.sizeAttenuation, this.fog = e.fog, this } } const qP = new yt, AS = new Ph, p0 = new Gs, m0 = new k; class LE extends qt { constructor(e = new Rt, t = new Xv) { super(), this.isPoints = !0, this.type = "Points", this.geometry = e, this.material = t, this.updateMorphTargets() } copy(e, t) { return super.copy(e, t), this.material = e.material, this.geometry = e.geometry, this } raycast(e, t) { const n = this.geometry, r = this.matrixWorld, s = e.params.Points.threshold, o = n.drawRange; if (n.boundingSphere === null && n.computeBoundingSphere(), p0.copy(n.boundingSphere), p0.applyMatrix4(r), p0.radius += s, e.ray.intersectsSphere(p0) === !1) return; qP.copy(r).invert(), AS.copy(e.ray).applyMatrix4(qP); const a = s / ((this.scale.x + this.scale.y + this.scale.z) / 3), l = a * a, c = n.index, d = n.attributes.position; if (c !== null) { const p = Math.max(0, o.start), m = Math.min(c.count, o.start + o.count); for (let y = p, _ = m; y < _; y++) { const x = c.getX(y); m0.fromBufferAttribute(d, x), QP(m0, x, l, r, e, t, this) } } else { const p = Math.max(0, o.start), m = Math.min(d.count, o.start + o.count); for (let y = p, _ = m; y < _; y++)m0.fromBufferAttribute(d, y), QP(m0, y, l, r, e, t, this) } } updateMorphTargets() { const t = this.geometry.morphAttributes, n = Object.keys(t); if (n.length > 0) { const r = t[n[0]]; if (r !== void 0) { this.morphTargetInfluences = [], this.morphTargetDictionary = {}; for (let s = 0, o = r.length; s < o; s++) { const a = r[s].name || String(s); this.morphTargetInfluences.push(0), this.morphTargetDictionary[a] = s } } } } } function QP(i, e, t, n, r, s, o) { const a = AS.distanceSqToPoint(i); if (a < t) { const l = new k; AS.closestPointToPoint(i, l), l.applyMatrix4(n); const c = r.ray.origin.distanceTo(l); if (c < r.near || c > r.far) return; s.push({ distance: c, distanceToRay: Math.sqrt(a), point: l, index: e, face: null, object: o }) } } class Oj extends wn { constructor(e, t, n, r, s, o, a, l, c) { super(e, t, n, r, s, o, a, l, c), this.isVideoTexture = !0, this.minFilter = o !== void 0 ? o : Pn, this.magFilter = s !== void 0 ? s : Pn, this.generateMipmaps = !1; const f = this; function d() { f.needsUpdate = !0, e.requestVideoFrameCallback(d) } "requestVideoFrameCallback" in e && e.requestVideoFrameCallback(d) } clone() { return new this.constructor(this.image).copy(this) } update() { const e = this.image; "requestVideoFrameCallback" in e === !1 && e.readyState >= e.HAVE_CURRENT_DATA && (this.needsUpdate = !0) } } class Fj extends wn { constructor(e, t) { super({ width: e, height: t }), this.isFramebufferTexture = !0, this.magFilter = zn, this.minFilter = zn, this.generateMipmaps = !1, this.needsUpdate = !0 } } class Jv extends wn { constructor(e, t, n, r, s, o, a, l, c, f, d, p) { super(null, o, a, l, c, f, r, s, d, p), this.isCompressedTexture = !0, this.image = { width: t, height: n }, this.mipmaps = e, this.flipY = !1, this.generateMipmaps = !1 } } class kj extends Jv { constructor(e, t, n, r, s, o) { super(e, t, n, s, o), this.isCompressedArrayTexture = !0, this.image.depth = r, this.wrapR = Di } } class Nj extends Jv { constructor(e, t, n) { super(void 0, e[0].width, e[0].height, t, n, Da), this.isCompressedCubeTexture = !0, this.isCubeTexture = !0, this.image = e } } class Uj extends wn { constructor(e, t, n, r, s, o, a, l, c) { super(e, t, n, r, s, o, a, l, c), this.isCanvasTexture = !0, this.needsUpdate = !0 } } class _o { constructor() { this.type = "Curve", this.arcLengthDivisions = 200 } getPoint() { return console.warn("THREE.Curve: .getPoint() not implemented."), null } getPointAt(e, t) { const n = this.getUtoTmapping(e); return this.getPoint(n, t) } getPoints(e = 5) { const t = []; for (let n = 0; n <= e; n++)t.push(this.getPoint(n / e)); return t } getSpacedPoints(e = 5) { const t = []; for (let n = 0; n <= e; n++)t.push(this.getPointAt(n / e)); return t } getLength() { const e = this.getLengths(); return e[e.length - 1] } getLengths(e = this.arcLengthDivisions) { if (this.cacheArcLengths && this.cacheArcLengths.length === e + 1 && !this.needsUpdate) return this.cacheArcLengths; this.needsUpdate = !1; const t = []; let n, r = this.getPoint(0), s = 0; t.push(0); for (let o = 1; o <= e; o++)n = this.getPoint(o / e), s += n.distanceTo(r), t.push(s), r = n; return this.cacheArcLengths = t, t } updateArcLengths() { this.needsUpdate = !0, this.getLengths() } getUtoTmapping(e, t) { const n = this.getLengths(); let r = 0; const s = n.length; let o; t ? o = t : o = e * n[s - 1]; let a = 0, l = s - 1, c; for (; a <= l;)if (r = Math.floor(a + (l - a) / 2), c = n[r] - o, c < 0) a = r + 1; else if (c > 0) l = r - 1; else { l = r; break } if (r = l, n[r] === o) return r / (s - 1); const f = n[r], p = n[r + 1] - f, m = (o - f) / p; return (r + m) / (s - 1) } getTangent(e, t) { let r = e - 1e-4, s = e + 1e-4; r < 0 && (r = 0), s > 1 && (s = 1); const o = this.getPoint(r), a = this.getPoint(s), l = t || (o.isVector2 ? new _e : new k); return l.copy(a).sub(o).normalize(), l } getTangentAt(e, t) { const n = this.getUtoTmapping(e); return this.getTangent(n, t) } computeFrenetFrames(e, t) { const n = new k, r = [], s = [], o = [], a = new k, l = new yt; for (let m = 0; m <= e; m++) { const y = m / e; r[m] = this.getTangentAt(y, new k) } s[0] = new k, o[0] = new k; let c = Number.MAX_VALUE; const f = Math.abs(r[0].x), d = Math.abs(r[0].y), p = Math.abs(r[0].z); f <= c && (c = f, n.set(1, 0, 0)), d <= c && (c = d, n.set(0, 1, 0)), p <= c && n.set(0, 0, 1), a.crossVectors(r[0], n).normalize(), s[0].crossVectors(r[0], a), o[0].crossVectors(r[0], s[0]); for (let m = 1; m <= e; m++) { if (s[m] = s[m - 1].clone(), o[m] = o[m - 1].clone(), a.crossVectors(r[m - 1], r[m]), a.length() > Number.EPSILON) { a.normalize(); const y = Math.acos(Gn(r[m - 1].dot(r[m]), -1, 1)); s[m].applyMatrix4(l.makeRotationAxis(a, y)) } o[m].crossVectors(r[m], s[m]) } if (t === !0) { let m = Math.acos(Gn(s[0].dot(s[e]), -1, 1)); m /= e, r[0].dot(a.crossVectors(s[0], s[e])) > 0 && (m = -m); for (let y = 1; y <= e; y++)s[y].applyMatrix4(l.makeRotationAxis(r[y], m * y)), o[y].crossVectors(r[y], s[y]) } return { tangents: r, normals: s, binormals: o } } clone() { return new this.constructor().copy(this) } copy(e) { return this.arcLengthDivisions = e.arcLengthDivisions, this } toJSON() { const e = { metadata: { version: 4.6, type: "Curve", generator: "Curve.toJSON" } }; return e.arcLengthDivisions = this.arcLengthDivisions, e.type = this.type, e } fromJSON(e) { return this.arcLengthDivisions = e.arcLengthDivisions, this } } class Yv extends _o { constructor(e = 0, t = 0, n = 1, r = 1, s = 0, o = Math.PI * 2, a = !1, l = 0) { super(), this.isEllipseCurve = !0, this.type = "EllipseCurve", this.aX = e, this.aY = t, this.xRadius = n, this.yRadius = r, this.aStartAngle = s, this.aEndAngle = o, this.aClockwise = a, this.aRotation = l } getPoint(e, t) { const n = t || new _e, r = Math.PI * 2; let s = this.aEndAngle - this.aStartAngle; const o = Math.abs(s) < Number.EPSILON; for (; s < 0;)s += r; for (; s > r;)s -= r; s < Number.EPSILON && (o ? s = 0 : s = r), this.aClockwise === !0 && !o && (s === r ? s = -r : s = s - r); const a = this.aStartAngle + e * s; let l = this.aX + this.xRadius * Math.cos(a), c = this.aY + this.yRadius * Math.sin(a); if (this.aRotation !== 0) { const f = Math.cos(this.aRotation), d = Math.sin(this.aRotation), p = l - this.aX, m = c - this.aY; l = p * f - m * d + this.aX, c = p * d + m * f + this.aY } return n.set(l, c) } copy(e) { return super.copy(e), this.aX = e.aX, this.aY = e.aY, this.xRadius = e.xRadius, this.yRadius = e.yRadius, this.aStartAngle = e.aStartAngle, this.aEndAngle = e.aEndAngle, this.aClockwise = e.aClockwise, this.aRotation = e.aRotation, this } toJSON() { const e = super.toJSON(); return e.aX = this.aX, e.aY = this.aY, e.xRadius = this.xRadius, e.yRadius = this.yRadius, e.aStartAngle = this.aStartAngle, e.aEndAngle = this.aEndAngle, e.aClockwise = this.aClockwise, e.aRotation = this.aRotation, e } fromJSON(e) { return super.fromJSON(e), this.aX = e.aX, this.aY = e.aY, this.xRadius = e.xRadius, this.yRadius = e.yRadius, this.aStartAngle = e.aStartAngle, this.aEndAngle = e.aEndAngle, this.aClockwise = e.aClockwise, this.aRotation = e.aRotation, this } } class HF extends Yv { constructor(e, t, n, r, s, o) { super(e, t, n, n, r, s, o), this.isArcCurve = !0, this.type = "ArcCurve" } } function DE() { let i = 0, e = 0, t = 0, n = 0; function r(s, o, a, l) { i = s, e = a, t = -3 * s + 3 * o - 2 * a - l, n = 2 * s - 2 * o + a + l } return { initCatmullRom: function (s, o, a, l, c) { r(o, a, c * (a - s), c * (l - o)) }, initNonuniformCatmullRom: function (s, o, a, l, c, f, d) { let p = (o - s) / c - (a - s) / (c + f) + (a - o) / f, m = (a - o) / f - (l - o) / (f + d) + (l - a) / d; p *= f, m *= f, r(o, a, p, m) }, calc: function (s) { const o = s * s, a = o * s; return i + e * s + t * o + n * a } } } const g0 = new k, qA = new DE, QA = new DE, ZA = new DE; class GF extends _o { constructor(e = [], t = !1, n = "centripetal", r = .5) { super(), this.isCatmullRomCurve3 = !0, this.type = "CatmullRomCurve3", this.points = e, this.closed = t, this.curveType = n, this.tension = r } getPoint(e, t = new k) { const n = t, r = this.points, s = r.length, o = (s - (this.closed ? 0 : 1)) * e; let a = Math.floor(o), l = o - a; this.closed ? a += a > 0 ? 0 : (Math.floor(Math.abs(a) / s) + 1) * s : l === 0 && a === s - 1 && (a = s - 2, l = 1); let c, f; this.closed || a > 0 ? c = r[(a - 1) % s] : (g0.subVectors(r[0], r[1]).add(r[0]), c = g0); const d = r[a % s], p = r[(a + 1) % s]; if (this.closed || a + 2 < s ? f = r[(a + 2) % s] : (g0.subVectors(r[s - 1], r[s - 2]).add(r[s - 1]), f = g0), this.curveType === "centripetal" || this.curveType === "chordal") { const m = this.curveType === "chordal" ? .5 : .25; let y = Math.pow(c.distanceToSquared(d), m), _ = Math.pow(d.distanceToSquared(p), m), x = Math.pow(p.distanceToSquared(f), m); _ < 1e-4 && (_ = 1), y < 1e-4 && (y = _), x < 1e-4 && (x = _), qA.initNonuniformCatmullRom(c.x, d.x, p.x, f.x, y, _, x), QA.initNonuniformCatmullRom(c.y, d.y, p.y, f.y, y, _, x), ZA.initNonuniformCatmullRom(c.z, d.z, p.z, f.z, y, _, x) } else this.curveType === "catmullrom" && (qA.initCatmullRom(c.x, d.x, p.x, f.x, this.tension), QA.initCatmullRom(c.y, d.y, p.y, f.y, this.tension), ZA.initCatmullRom(c.z, d.z, p.z, f.z, this.tension)); return n.set(qA.calc(l), QA.calc(l), ZA.calc(l)), n } copy(e) { super.copy(e), this.points = []; for (let t = 0, n = e.points.length; t < n; t++) { const r = e.points[t]; this.points.push(r.clone()) } return this.closed = e.closed, this.curveType = e.curveType, this.tension = e.tension, this } toJSON() { const e = super.toJSON(); e.points = []; for (let t = 0, n = this.points.length; t < n; t++) { const r = this.points[t]; e.points.push(r.toArray()) } return e.closed = this.closed, e.curveType = this.curveType, e.tension = this.tension, e } fromJSON(e) { super.fromJSON(e), this.points = []; for (let t = 0, n = e.points.length; t < n; t++) { const r = e.points[t]; this.points.push(new k().fromArray(r)) } return this.closed = e.closed, this.curveType = e.curveType, this.tension = e.tension, this } } function ZP(i, e, t, n, r) { const s = (n - e) * .5, o = (r - t) * .5, a = i * i, l = i * a; return (2 * t - 2 * n + s + o) * l + (-3 * t + 3 * n - 2 * s - o) * a + s * i + t } function zj(i, e) { const t = 1 - i; return t * t * e } function Hj(i, e) { return 2 * (1 - i) * i * e } function Gj(i, e) { return i * i * e } function ap(i, e, t, n) { return zj(i, e) + Hj(i, t) + Gj(i, n) } function Vj(i, e) { const t = 1 - i; return t * t * t * e } function Wj(i, e) { const t = 1 - i; return 3 * t * t * i * e } function Xj(i, e) { return 3 * (1 - i) * i * i * e } function Jj(i, e) { return i * i * i * e } function lp(i, e, t, n, r) { return Vj(i, e) + Wj(i, t) + Xj(i, n) + Jj(i, r) } class OE extends _o { constructor(e = new _e, t = new _e, n = new _e, r = new _e) { super(), this.isCubicBezierCurve = !0, this.type = "CubicBezierCurve", this.v0 = e, this.v1 = t, this.v2 = n, this.v3 = r } getPoint(e, t = new _e) { const n = t, r = this.v0, s = this.v1, o = this.v2, a = this.v3; return n.set(lp(e, r.x, s.x, o.x, a.x), lp(e, r.y, s.y, o.y, a.y)), n } copy(e) { return super.copy(e), this.v0.copy(e.v0), this.v1.copy(e.v1), this.v2.copy(e.v2), this.v3.copy(e.v3), this } toJSON() { const e = super.toJSON(); return e.v0 = this.v0.toArray(), e.v1 = this.v1.toArray(), e.v2 = this.v2.toArray(), e.v3 = this.v3.toArray(), e } fromJSON(e) { return super.fromJSON(e), this.v0.fromArray(e.v0), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this.v3.fromArray(e.v3), this } } class VF extends _o { constructor(e = new k, t = new k, n = new k, r = new k) { super(), this.isCubicBezierCurve3 = !0, this.type = "CubicBezierCurve3", this.v0 = e, this.v1 = t, this.v2 = n, this.v3 = r } getPoint(e, t = new k) { const n = t, r = this.v0, s = this.v1, o = this.v2, a = this.v3; return n.set(lp(e, r.x, s.x, o.x, a.x), lp(e, r.y, s.y, o.y, a.y), lp(e, r.z, s.z, o.z, a.z)), n } copy(e) { return super.copy(e), this.v0.copy(e.v0), this.v1.copy(e.v1), this.v2.copy(e.v2), this.v3.copy(e.v3), this } toJSON() { const e = super.toJSON(); return e.v0 = this.v0.toArray(), e.v1 = this.v1.toArray(), e.v2 = this.v2.toArray(), e.v3 = this.v3.toArray(), e } fromJSON(e) { return super.fromJSON(e), this.v0.fromArray(e.v0), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this.v3.fromArray(e.v3), this } } class jv extends _o { constructor(e = new _e, t = new _e) { super(), this.isLineCurve = !0, this.type = "LineCurve", this.v1 = e, this.v2 = t } getPoint(e, t = new _e) { const n = t; return e === 1 ? n.copy(this.v2) : (n.copy(this.v2).sub(this.v1), n.multiplyScalar(e).add(this.v1)), n } getPointAt(e, t) { return this.getPoint(e, t) } getTangent(e, t = new _e) { return t.subVectors(this.v2, this.v1).normalize() } getTangentAt(e, t) { return this.getTangent(e, t) } copy(e) { return super.copy(e), this.v1.copy(e.v1), this.v2.copy(e.v2), this } toJSON() { const e = super.toJSON(); return e.v1 = this.v1.toArray(), e.v2 = this.v2.toArray(), e } fromJSON(e) { return super.fromJSON(e), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this } } class WF extends _o { constructor(e = new k, t = new k) { super(), this.isLineCurve3 = !0, this.type = "LineCurve3", this.v1 = e, this.v2 = t } getPoint(e, t = new k) { const n = t; return e === 1 ? n.copy(this.v2) : (n.copy(this.v2).sub(this.v1), n.multiplyScalar(e).add(this.v1)), n } getPointAt(e, t) { return this.getPoint(e, t) } getTangent(e, t = new k) { return t.subVectors(this.v2, this.v1).normalize() } getTangentAt(e, t) { return this.getTangent(e, t) } copy(e) { return super.copy(e), this.v1.copy(e.v1), this.v2.copy(e.v2), this } toJSON() { const e = super.toJSON(); return e.v1 = this.v1.toArray(), e.v2 = this.v2.toArray(), e } fromJSON(e) { return super.fromJSON(e), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this } } class FE extends _o { constructor(e = new _e, t = new _e, n = new _e) { super(), this.isQuadraticBezierCurve = !0, this.type = "QuadraticBezierCurve", this.v0 = e, this.v1 = t, this.v2 = n } getPoint(e, t = new _e) { const n = t, r = this.v0, s = this.v1, o = this.v2; return n.set(ap(e, r.x, s.x, o.x), ap(e, r.y, s.y, o.y)), n } copy(e) { return super.copy(e), this.v0.copy(e.v0), this.v1.copy(e.v1), this.v2.copy(e.v2), this } toJSON() { const e = super.toJSON(); return e.v0 = this.v0.toArray(), e.v1 = this.v1.toArray(), e.v2 = this.v2.toArray(), e } fromJSON(e) { return super.fromJSON(e), this.v0.fromArray(e.v0), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this } } class kE extends _o { constructor(e = new k, t = new k, n = new k) { super(), this.isQuadraticBezierCurve3 = !0, this.type = "QuadraticBezierCurve3", this.v0 = e, this.v1 = t, this.v2 = n } getPoint(e, t = new k) { const n = t, r = this.v0, s = this.v1, o = this.v2; return n.set(ap(e, r.x, s.x, o.x), ap(e, r.y, s.y, o.y), ap(e, r.z, s.z, o.z)), n } copy(e) { return super.copy(e), this.v0.copy(e.v0), this.v1.copy(e.v1), this.v2.copy(e.v2), this } toJSON() { const e = super.toJSON(); return e.v0 = this.v0.toArray(), e.v1 = this.v1.toArray(), e.v2 = this.v2.toArray(), e } fromJSON(e) { return super.fromJSON(e), this.v0.fromArray(e.v0), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this } } class NE extends _o { constructor(e = []) { super(), this.isSplineCurve = !0, this.type = "SplineCurve", this.points = e } getPoint(e, t = new _e) { const n = t, r = this.points, s = (r.length - 1) * e, o = Math.floor(s), a = s - o, l = r[o === 0 ? o : o - 1], c = r[o], f = r[o > r.length - 2 ? r.length - 1 : o + 1], d = r[o > r.length - 3 ? r.length - 1 : o + 2]; return n.set(ZP(a, l.x, c.x, f.x, d.x), ZP(a, l.y, c.y, f.y, d.y)), n } copy(e) { super.copy(e), this.points = []; for (let t = 0, n = e.points.length; t < n; t++) { const r = e.points[t]; this.points.push(r.clone()) } return this } toJSON() { const e = super.toJSON(); e.points = []; for (let t = 0, n = this.points.length; t < n; t++) { const r = this.points[t]; e.points.push(r.toArray()) } return e } fromJSON(e) { super.fromJSON(e), this.points = []; for (let t = 0, n = e.points.length; t < n; t++) { const r = e.points[t]; this.points.push(new _e().fromArray(r)) } return this } } var UE = Object.freeze({ __proto__: null, ArcCurve: HF, CatmullRomCurve3: GF, CubicBezierCurve: OE, CubicBezierCurve3: VF, EllipseCurve: Yv, LineCurve: jv, LineCurve3: WF, QuadraticBezierCurve: FE, QuadraticBezierCurve3: kE, SplineCurve: NE }); class XF extends _o { constructor() { super(), this.type = "CurvePath", this.curves = [], this.autoClose = !1 } add(e) { this.curves.push(e) } closePath() { const e = this.curves[0].getPoint(0), t = this.curves[this.curves.length - 1].getPoint(1); e.equals(t) || this.curves.push(new jv(t, e)) } getPoint(e, t) { const n = e * this.getLength(), r = this.getCurveLengths(); let s = 0; for (; s < r.length;) { if (r[s] >= n) { const o = r[s] - n, a = this.curves[s], l = a.getLength(), c = l === 0 ? 0 : 1 - o / l; return a.getPointAt(c, t) } s++ } return null } getLength() { const e = this.getCurveLengths(); return e[e.length - 1] } updateArcLengths() { this.needsUpdate = !0, this.cacheLengths = null, this.getCurveLengths() } getCurveLengths() { if (this.cacheLengths && this.cacheLengths.length === this.curves.length) return this.cacheLengths; const e = []; let t = 0; for (let n = 0, r = this.curves.length; n < r; n++)t += this.curves[n].getLength(), e.push(t); return this.cacheLengths = e, e } getSpacedPoints(e = 40) { const t = []; for (let n = 0; n <= e; n++)t.push(this.getPoint(n / e)); return this.autoClose && t.push(t[0]), t } getPoints(e = 12) { const t = []; let n; for (let r = 0, s = this.curves; r < s.length; r++) { const o = s[r], a = o.isEllipseCurve ? e * 2 : o.isLineCurve || o.isLineCurve3 ? 1 : o.isSplineCurve ? e * o.points.length : e, l = o.getPoints(a); for (let c = 0; c < l.length; c++) { const f = l[c]; n && n.equals(f) || (t.push(f), n = f) } } return this.autoClose && t.length > 1 && !t[t.length - 1].equals(t[0]) && t.push(t[0]), t } copy(e) { super.copy(e), this.curves = []; for (let t = 0, n = e.curves.length; t < n; t++) { const r = e.curves[t]; this.curves.push(r.clone()) } return this.autoClose = e.autoClose, this } toJSON() { const e = super.toJSON(); e.autoClose = this.autoClose, e.curves = []; for (let t = 0, n = this.curves.length; t < n; t++) { const r = this.curves[t]; e.curves.push(r.toJSON()) } return e } fromJSON(e) { super.fromJSON(e), this.autoClose = e.autoClose, this.curves = []; for (let t = 0, n = e.curves.length; t < n; t++) { const r = e.curves[t]; this.curves.push(new UE[r.type]().fromJSON(r)) } return this } } class Vp extends XF { constructor(e) { super(), this.type = "Path", this.currentPoint = new _e, e && this.setFromPoints(e) } setFromPoints(e) { this.moveTo(e[0].x, e[0].y); for (let t = 1, n = e.length; t < n; t++)this.lineTo(e[t].x, e[t].y); return this } moveTo(e, t) { return this.currentPoint.set(e, t), this } lineTo(e, t) { const n = new jv(this.currentPoint.clone(), new _e(e, t)); return this.curves.push(n), this.currentPoint.set(e, t), this } quadraticCurveTo(e, t, n, r) { const s = new FE(this.currentPoint.clone(), new _e(e, t), new _e(n, r)); return this.curves.push(s), this.currentPoint.set(n, r), this } bezierCurveTo(e, t, n, r, s, o) { const a = new OE(this.currentPoint.clone(), new _e(e, t), new _e(n, r), new _e(s, o)); return this.curves.push(a), this.currentPoint.set(s, o), this } splineThru(e) { const t = [this.currentPoint.clone()].concat(e), n = new NE(t); return this.curves.push(n), this.currentPoint.copy(e[e.length - 1]), this } arc(e, t, n, r, s, o) { const a = this.currentPoint.x, l = this.currentPoint.y; return this.absarc(e + a, t + l, n, r, s, o), this } absarc(e, t, n, r, s, o) { return this.absellipse(e, t, n, n, r, s, o), this } ellipse(e, t, n, r, s, o, a, l) { const c = this.currentPoint.x, f = this.currentPoint.y; return this.absellipse(e + c, t + f, n, r, s, o, a, l), this } absellipse(e, t, n, r, s, o, a, l) { const c = new Yv(e, t, n, r, s, o, a, l); if (this.curves.length > 0) { const d = c.getPoint(0); d.equals(this.currentPoint) || this.lineTo(d.x, d.y) } this.curves.push(c); const f = c.getPoint(1); return this.currentPoint.copy(f), this } copy(e) { return super.copy(e), this.currentPoint.copy(e.currentPoint), this } toJSON() { const e = super.toJSON(); return e.currentPoint = this.currentPoint.toArray(), e } fromJSON(e) { return super.fromJSON(e), this.currentPoint.fromArray(e.currentPoint), this } } class hm extends Rt { constructor(e = [new _e(0, -.5), new _e(.5, 0), new _e(0, .5)], t = 12, n = 0, r = Math.PI * 2) { super(), this.type = "LatheGeometry", this.parameters = { points: e, segments: t, phiStart: n, phiLength: r }, t = Math.floor(t), r = Gn(r, 0, Math.PI * 2); const s = [], o = [], a = [], l = [], c = [], f = 1 / t, d = new k, p = new _e, m = new k, y = new k, _ = new k; let x = 0, g = 0; for (let A = 0; A <= e.length - 1; A++)switch (A) { case 0: x = e[A + 1].x - e[A].x, g = e[A + 1].y - e[A].y, m.x = g * 1, m.y = -x, m.z = g * 0, _.copy(m), m.normalize(), l.push(m.x, m.y, m.z); break; case e.length - 1: l.push(_.x, _.y, _.z); break; default: x = e[A + 1].x - e[A].x, g = e[A + 1].y - e[A].y, m.x = g * 1, m.y = -x, m.z = g * 0, y.copy(m), m.x += _.x, m.y += _.y, m.z += _.z, m.normalize(), l.push(m.x, m.y, m.z), _.copy(y) }for (let A = 0; A <= t; A++) { const M = n + A * f * r, S = Math.sin(M), C = Math.cos(M); for (let T = 0; T <= e.length - 1; T++) { d.x = e[T].x * S, d.y = e[T].y, d.z = e[T].x * C, o.push(d.x, d.y, d.z), p.x = A / t, p.y = T / (e.length - 1), a.push(p.x, p.y); const R = l[3 * T + 0] * S, B = l[3 * T + 1], b = l[3 * T + 0] * C; c.push(R, B, b) } } for (let A = 0; A < t; A++)for (let M = 0; M < e.length - 1; M++) { const S = M + A * e.length, C = S, T = S + e.length, R = S + e.length + 1, B = S + 1; s.push(C, T, B), s.push(R, B, T) } this.setIndex(s), this.setAttribute("position", new rt(o, 3)), this.setAttribute("uv", new rt(a, 2)), this.setAttribute("normal", new rt(c, 3)) } copy(e) { return super.copy(e), this.parameters = Object.assign({}, e.parameters), this } static fromJSON(e) { return new hm(e.points, e.segments, e.phiStart, e.phiLength) } } class Kv extends hm { constructor(e = 1, t = 1, n = 4, r = 8) { const s = new Vp; s.absarc(0, -t / 2, e, Math.PI * 1.5, 0), s.absarc(0, t / 2, e, 0, Math.PI * .5), super(s.getPoints(n), r), this.type = "CapsuleGeometry", this.parameters = { radius: e, length: t, capSegments: n, radialSegments: r } } static fromJSON(e) { return new Kv(e.radius, e.length, e.capSegments, e.radialSegments) } } class qv extends Rt { constructor(e = 1, t = 32, n = 0, r = Math.PI * 2) { super(), this.type = "CircleGeometry", this.parameters = { radius: e, segments: t, thetaStart: n, thetaLength: r }, t = Math.max(3, t); const s = [], o = [], a = [], l = [], c = new k, f = new _e; o.push(0, 0, 0), a.push(0, 0, 1), l.push(.5, .5); for (let d = 0, p = 3; d <= t; d++, p += 3) { const m = n + d / t * r; c.x = e * Math.cos(m), c.y = e * Math.sin(m), o.push(c.x, c.y, c.z), a.push(0, 0, 1), f.x = (o[p] / e + 1) / 2, f.y = (o[p + 1] / e + 1) / 2, l.push(f.x, f.y) } for (let d = 1; d <= t; d++)s.push(d, d + 1, 0); this.setIndex(s), this.setAttribute("position", new rt(o, 3)), this.setAttribute("normal", new rt(a, 3)), this.setAttribute("uv", new rt(l, 2)) } copy(e) { return super.copy(e), this.parameters = Object.assign({}, e.parameters), this } static fromJSON(e) { return new qv(e.radius, e.segments, e.thetaStart, e.thetaLength) } } class Bh extends Rt { constructor(e = 1, t = 1, n = 1, r = 32, s = 1, o = !1, a = 0, l = Math.PI * 2) { super(), this.type = "CylinderGeometry", this.parameters = { radiusTop: e, radiusBottom: t, height: n, radialSegments: r, heightSegments: s, openEnded: o, thetaStart: a, thetaLength: l }; const c = this; r = Math.floor(r), s = Math.floor(s); const f = [], d = [], p = [], m = []; let y = 0; const _ = [], x = n / 2; let g = 0; A(), o === !1 && (e > 0 && M(!0), t > 0 && M(!1)), this.setIndex(f), this.setAttribute("position", new rt(d, 3)), this.setAttribute("normal", new rt(p, 3)), this.setAttribute("uv", new rt(m, 2)); function A() { const S = new k, C = new k; let T = 0; const R = (t - e) / n; for (let B = 0; B <= s; B++) { const b = [], I = B / s, N = I * (t - e) + e; for (let V = 0; V <= r; V++) { const J = V / r, j = J * l + a, q = Math.sin(j), ne = Math.cos(j); C.x = N * q, C.y = -I * n + x, C.z = N * ne, d.push(C.x, C.y, C.z), S.set(q, R, ne).normalize(), p.push(S.x, S.y, S.z), m.push(J, 1 - I), b.push(y++) } _.push(b) } for (let B = 0; B < r; B++)for (let b = 0; b < s; b++) { const I = _[b][B], N = _[b + 1][B], V = _[b + 1][B + 1], J = _[b][B + 1]; f.push(I, N, J), f.push(N, V, J), T += 6 } c.addGroup(g, T, 0), g += T } function M(S) { const C = y, T = new _e, R = new k; let B = 0; const b = S === !0 ? e : t, I = S === !0 ? 1 : -1; for (let V = 1; V <= r; V++)d.push(0, x * I, 0), p.push(0, I, 0), m.push(.5, .5), y++; const N = y; for (let V = 0; V <= r; V++) { const j = V / r * l + a, q = Math.cos(j), ne = Math.sin(j); R.x = b * ne, R.y = x * I, R.z = b * q, d.push(R.x, R.y, R.z), p.push(0, I, 0), T.x = q * .5 + .5, T.y = ne * .5 * I + .5, m.push(T.x, T.y), y++ } for (let V = 0; V < r; V++) { const J = C + V, j = N + V; S === !0 ? f.push(j, j + 1, J) : f.push(j + 1, j, J), B += 3 } c.addGroup(g, B, S === !0 ? 1 : 2), g += B } } copy(e) { return super.copy(e), this.parameters = Object.assign({}, e.parameters), this } static fromJSON(e) { return new Bh(e.radiusTop, e.radiusBottom, e.height, e.radialSegments, e.heightSegments, e.openEnded, e.thetaStart, e.thetaLength) } } class Qv extends Bh { constructor(e = 1, t = 1, n = 32, r = 1, s = !1, o = 0, a = Math.PI * 2) { super(0, e, t, n, r, s, o, a), this.type = "ConeGeometry", this.parameters = { radius: e, height: t, radialSegments: n, heightSegments: r, openEnded: s, thetaStart: o, thetaLength: a } } static fromJSON(e) { return new Qv(e.radius, e.height, e.radialSegments, e.heightSegments, e.openEnded, e.thetaStart, e.thetaLength) } } class Yl extends Rt { constructor(e = [], t = [], n = 1, r = 0) { super(), this.type = "PolyhedronGeometry", this.parameters = { vertices: e, indices: t, radius: n, detail: r }; const s = [], o = []; a(r), c(n), f(), this.setAttribute("position", new rt(s, 3)), this.setAttribute("normal", new rt(s.slice(), 3)), this.setAttribute("uv", new rt(o, 2)), r === 0 ? this.computeVertexNormals() : this.normalizeNormals(); function a(A) { const M = new k, S = new k, C = new k; for (let T = 0; T < t.length; T += 3)m(t[T + 0], M), m(t[T + 1], S), m(t[T + 2], C), l(M, S, C, A) } function l(A, M, S, C) { const T = C + 1, R = []; for (let B = 0; B <= T; B++) { R[B] = []; const b = A.clone().lerp(S, B / T), I = M.clone().lerp(S, B / T), N = T - B; for (let V = 0; V <= N; V++)V === 0 && B === T ? R[B][V] = b : R[B][V] = b.clone().lerp(I, V / N) } for (let B = 0; B < T; B++)for (let b = 0; b < 2 * (T - B) - 1; b++) { const I = Math.floor(b / 2); b % 2 === 0 ? (p(R[B][I + 1]), p(R[B + 1][I]), p(R[B][I])) : (p(R[B][I + 1]), p(R[B + 1][I + 1]), p(R[B + 1][I])) } } function c(A) { const M = new k; for (let S = 0; S < s.length; S += 3)M.x = s[S + 0], M.y = s[S + 1], M.z = s[S + 2], M.normalize().multiplyScalar(A), s[S + 0] = M.x, s[S + 1] = M.y, s[S + 2] = M.z } function f() { const A = new k; for (let M = 0; M < s.length; M += 3) { A.x = s[M + 0], A.y = s[M + 1], A.z = s[M + 2]; const S = x(A) / 2 / Math.PI + .5, C = g(A) / Math.PI + .5; o.push(S, 1 - C) } y(), d() } function d() { for (let A = 0; A < o.length; A += 6) { const M = o[A + 0], S = o[A + 2], C = o[A + 4], T = Math.max(M, S, C), R = Math.min(M, S, C); T > .9 && R < .1 && (M < .2 && (o[A + 0] += 1), S < .2 && (o[A + 2] += 1), C < .2 && (o[A + 4] += 1)) } } function p(A) { s.push(A.x, A.y, A.z) } function m(A, M) { const S = A * 3; M.x = e[S + 0], M.y = e[S + 1], M.z = e[S + 2] } function y() { const A = new k, M = new k, S = new k, C = new k, T = new _e, R = new _e, B = new _e; for (let b = 0, I = 0; b < s.length; b += 9, I += 6) { A.set(s[b + 0], s[b + 1], s[b + 2]), M.set(s[b + 3], s[b + 4], s[b + 5]), S.set(s[b + 6], s[b + 7], s[b + 8]), T.set(o[I + 0], o[I + 1]), R.set(o[I + 2], o[I + 3]), B.set(o[I + 4], o[I + 5]), C.copy(A).add(M).add(S).divideScalar(3); const N = x(C); _(T, I + 0, A, N), _(R, I + 2, M, N), _(B, I + 4, S, N) } } function _(A, M, S, C) { C < 0 && A.x === 1 && (o[M] = A.x - 1), S.x === 0 && S.z === 0 && (o[M] = C / 2 / Math.PI + .5) } function x(A) { return Math.atan2(A.z, -A.x) } function g(A) { return Math.atan2(-A.y, Math.sqrt(A.x * A.x + A.z * A.z)) } } copy(e) { return super.copy(e), this.parameters = Object.assign({}, e.parameters), this } static fromJSON(e) { return new Yl(e.vertices, e.indices, e.radius, e.details) } } class Zv extends Yl { constructor(e = 1, t = 0) { const n = (1 + Math.sqrt(5)) / 2, r = 1 / n, s = [-1, -1, -1, -1, -1, 1, -1, 1, -1, -1, 1, 1, 1, -1, -1, 1, -1, 1, 1, 1, -1, 1, 1, 1, 0, -r, -n, 0, -r, n, 0, r, -n, 0, r, n, -r, -n, 0, -r, n, 0, r, -n, 0, r, n, 0, -n, 0, -r, n, 0, -r, -n, 0, r, n, 0, r], o = [3, 11, 7, 3, 7, 15, 3, 15, 13, 7, 19, 17, 7, 17, 6, 7, 6, 15, 17, 4, 8, 17, 8, 10, 17, 10, 6, 8, 0, 16, 8, 16, 2, 8, 2, 10, 0, 12, 1, 0, 1, 18, 0, 18, 16, 6, 10, 2, 6, 2, 13, 6, 13, 15, 2, 16, 18, 2, 18, 3, 2, 3, 13, 18, 1, 9, 18, 9, 11, 18, 11, 3, 4, 14, 12, 4, 12, 0, 4, 0, 8, 11, 9, 5, 11, 5, 19, 11, 19, 7, 19, 5, 14, 19, 14, 4, 19, 4, 17, 1, 12, 14, 1, 14, 5, 1, 5, 9]; super(s, o, e, t), this.type = "DodecahedronGeometry", this.parameters = { radius: e, detail: t } } static fromJSON(e) { return new Zv(e.radius, e.detail) } } const y0 = new k, v0 = new k, $A = new k, _0 = new br; class JF extends Rt { constructor(e = null, t = 1) { if (super(), this.type = "EdgesGeometry", this.parameters = { geometry: e, thresholdAngle: t }, e !== null) { const r = Math.pow(10, 4), s = Math.cos(Yc * t), o = e.getIndex(), a = e.getAttribute("position"), l = o ? o.count : a.count, c = [0, 0, 0], f = ["a", "b", "c"], d = new Array(3), p = {}, m = []; for (let y = 0; y < l; y += 3) { o ? (c[0] = o.getX(y), c[1] = o.getX(y + 1), c[2] = o.getX(y + 2)) : (c[0] = y, c[1] = y + 1, c[2] = y + 2); const { a: _, b: x, c: g } = _0; if (_.fromBufferAttribute(a, c[0]), x.fromBufferAttribute(a, c[1]), g.fromBufferAttribute(a, c[2]), _0.getNormal($A), d[0] = `${Math.round(_.x * r)},${Math.round(_.y * r)},${Math.round(_.z * r)}`, d[1] = `${Math.round(x.x * r)},${Math.round(x.y * r)},${Math.round(x.z * r)}`, d[2] = `${Math.round(g.x * r)},${Math.round(g.y * r)},${Math.round(g.z * r)}`, !(d[0] === d[1] || d[1] === d[2] || d[2] === d[0])) for (let A = 0; A < 3; A++) { const M = (A + 1) % 3, S = d[A], C = d[M], T = _0[f[A]], R = _0[f[M]], B = `${S}_${C}`, b = `${C}_${S}`; b in p && p[b] ? ($A.dot(p[b].normal) <= s && (m.push(T.x, T.y, T.z), m.push(R.x, R.y, R.z)), p[b] = null) : B in p || (p[B] = { index0: c[A], index1: c[M], normal: $A.clone() }) } } for (const y in p) if (p[y]) { const { index0: _, index1: x } = p[y]; y0.fromBufferAttribute(a, _), v0.fromBufferAttribute(a, x), m.push(y0.x, y0.y, y0.z), m.push(v0.x, v0.y, v0.z) } this.setAttribute("position", new rt(m, 3)) } } copy(e) { return super.copy(e), this.parameters = Object.assign({}, e.parameters), this } } class Kc extends Vp { constructor(e) { super(e), this.uuid = ss(), this.type = "Shape", this.holes = [] } getPointsHoles(e) { const t = []; for (let n = 0, r = this.holes.length; n < r; n++)t[n] = this.holes[n].getPoints(e); return t } extractPoints(e) { return { shape: this.getPoints(e), holes: this.getPointsHoles(e) } } copy(e) { super.copy(e), this.holes = []; for (let t = 0, n = e.holes.length; t < n; t++) { const r = e.holes[t]; this.holes.push(r.clone()) } return this } toJSON() { const e = super.toJSON(); e.uuid = this.uuid, e.holes = []; for (let t = 0, n = this.holes.length; t < n; t++) { const r = this.holes[t]; e.holes.push(r.toJSON()) } return e } fromJSON(e) { super.fromJSON(e), this.uuid = e.uuid, this.holes = []; for (let t = 0, n = e.holes.length; t < n; t++) { const r = e.holes[t]; this.holes.push(new Vp().fromJSON(r)) } return this } } const Yj = { triangulate: function (i, e, t = 2) { const n = e && e.length, r = n ? e[0] * t : i.length; let s = YF(i, 0, r, t, !0); const o = []; if (!s || s.next === s.prev) return o; let a, l, c, f, d, p, m; if (n && (s = Zj(i, e, s, t)), i.length > 80 * t) { a = c = i[0], l = f = i[1]; for (let y = t; y < r; y += t)d = i[y], p = i[y + 1], d < a && (a = d), p < l && (l = p), d > c && (c = d), p > f && (f = p); m = Math.max(c - a, f - l), m = m !== 0 ? 32767 / m : 0 } return Wp(s, o, t, a, l, m, 0), o } }; function YF(i, e, t, n, r) { let s, o; if (r === c7(i, e, t, n) > 0) for (s = e; s < t; s += n)o = $P(s, i[s], i[s + 1], o); else for (s = t - n; s >= e; s -= n)o = $P(s, i[s], i[s + 1], o); return o && $v(o, o.next) && (Jp(o), o = o.next), o } function cu(i, e) { if (!i) return i; e || (e = i); let t = i, n; do if (n = !1, !t.steiner && ($v(t, t.next) || Bn(t.prev, t, t.next) === 0)) { if (Jp(t), t = e = t.prev, t === t.next) break; n = !0 } else t = t.next; while (n || t !== e); return e } function Wp(i, e, t, n, r, s, o) { if (!i) return; !o && s && i7(i, n, r, s); let a = i, l, c; for (; i.prev !== i.next;) { if (l = i.prev, c = i.next, s ? Kj(i, n, r, s) : jj(i)) { e.push(l.i / t | 0), e.push(i.i / t | 0), e.push(c.i / t | 0), Jp(i), i = c.next, a = c.next; continue } if (i = c, i === a) { o ? o === 1 ? (i = qj(cu(i), e, t), Wp(i, e, t, n, r, s, 2)) : o === 2 && Qj(i, e, t, n, r, s) : Wp(cu(i), e, t, n, r, s, 1); break } } } function jj(i) { const e = i.prev, t = i, n = i.next; if (Bn(e, t, n) >= 0) return !1; const r = e.x, s = t.x, o = n.x, a = e.y, l = t.y, c = n.y, f = r < s ? r < o ? r : o : s < o ? s : o, d = a < l ? a < c ? a : c : l < c ? l : c, p = r > s ? r > o ? r : o : s > o ? s : o, m = a > l ? a > c ? a : c : l > c ? l : c; let y = n.next; for (; y !== e;) { if (y.x >= f && y.x <= p && y.y >= d && y.y <= m && Bf(r, a, s, l, o, c, y.x, y.y) && Bn(y.prev, y, y.next) >= 0) return !1; y = y.next } return !0 } function Kj(i, e, t, n) { const r = i.prev, s = i, o = i.next; if (Bn(r, s, o) >= 0) return !1; const a = r.x, l = s.x, c = o.x, f = r.y, d = s.y, p = o.y, m = a < l ? a < c ? a : c : l < c ? l : c, y = f < d ? f < p ? f : p : d < p ? d : p, _ = a > l ? a > c ? a : c : l > c ? l : c, x = f > d ? f > p ? f : p : d > p ? d : p, g = MS(m, y, e, t, n), A = MS(_, x, e, t, n); let M = i.prevZ, S = i.nextZ; for (; M && M.z >= g && S && S.z <= A;) { if (M.x >= m && M.x <= _ && M.y >= y && M.y <= x && M !== r && M !== o && Bf(a, f, l, d, c, p, M.x, M.y) && Bn(M.prev, M, M.next) >= 0 || (M = M.prevZ, S.x >= m && S.x <= _ && S.y >= y && S.y <= x && S !== r && S !== o && Bf(a, f, l, d, c, p, S.x, S.y) && Bn(S.prev, S, S.next) >= 0)) return !1; S = S.nextZ } for (; M && M.z >= g;) { if (M.x >= m && M.x <= _ && M.y >= y && M.y <= x && M !== r && M !== o && Bf(a, f, l, d, c, p, M.x, M.y) && Bn(M.prev, M, M.next) >= 0) return !1; M = M.prevZ } for (; S && S.z <= A;) { if (S.x >= m && S.x <= _ && S.y >= y && S.y <= x && S !== r && S !== o && Bf(a, f, l, d, c, p, S.x, S.y) && Bn(S.prev, S, S.next) >= 0) return !1; S = S.nextZ } return !0 } function qj(i, e, t) { let n = i; do { const r = n.prev, s = n.next.next; !$v(r, s) && jF(r, n, n.next, s) && Xp(r, s) && Xp(s, r) && (e.push(r.i / t | 0), e.push(n.i / t | 0), e.push(s.i / t | 0), Jp(n), Jp(n.next), n = i = s), n = n.next } while (n !== i); return cu(n) } function Qj(i, e, t, n, r, s) { let o = i; do { let a = o.next.next; for (; a !== o.prev;) { if (o.i !== a.i && o7(o, a)) { let l = KF(o, a); o = cu(o, o.next), l = cu(l, l.next), Wp(o, e, t, n, r, s, 0), Wp(l, e, t, n, r, s, 0); return } a = a.next } o = o.next } while (o !== i) } function Zj(i, e, t, n) { const r = []; let s, o, a, l, c; for (s = 0, o = e.length; s < o; s++)a = e[s] * n, l = s < o - 1 ? e[s + 1] * n : i.length, c = YF(i, a, l, n, !1), c === c.next && (c.steiner = !0), r.push(s7(c)); for (r.sort($j), s = 0; s < r.length; s++)t = e7(r[s], t); return t } function $j(i, e) { return i.x - e.x } function e7(i, e) { const t = t7(i, e); if (!t) return e; const n = KF(t, i); return cu(n, n.next), cu(t, t.next) } function t7(i, e) { let t = e, n = -1 / 0, r; const s = i.x, o = i.y; do { if (o <= t.y && o >= t.next.y && t.next.y !== t.y) { const p = t.x + (o - t.y) * (t.next.x - t.x) / (t.next.y - t.y); if (p <= s && p > n && (n = p, r = t.x < t.next.x ? t : t.next, p === s)) return r } t = t.next } while (t !== e); if (!r) return null; const a = r, l = r.x, c = r.y; let f = 1 / 0, d; t = r; do s >= t.x && t.x >= l && s !== t.x && Bf(o < c ? s : n, o, l, c, o < c ? n : s, o, t.x, t.y) && (d = Math.abs(o - t.y) / (s - t.x), Xp(t, i) && (d < f || d === f && (t.x > r.x || t.x === r.x && n7(r, t))) && (r = t, f = d)), t = t.next; while (t !== a); return r } function n7(i, e) { return Bn(i.prev, i, e.prev) < 0 && Bn(e.next, i, i.next) < 0 } function i7(i, e, t, n) { let r = i; do r.z === 0 && (r.z = MS(r.x, r.y, e, t, n)), r.prevZ = r.prev, r.nextZ = r.next, r = r.next; while (r !== i); r.prevZ.nextZ = null, r.prevZ = null, r7(r) } function r7(i) { let e, t, n, r, s, o, a, l, c = 1; do { for (t = i, i = null, s = null, o = 0; t;) { for (o++, n = t, a = 0, e = 0; e < c && (a++, n = n.nextZ, !!n); e++); for (l = c; a > 0 || l > 0 && n;)a !== 0 && (l === 0 || !n || t.z <= n.z) ? (r = t, t = t.nextZ, a--) : (r = n, n = n.nextZ, l--), s ? s.nextZ = r : i = r, r.prevZ = s, s = r; t = n } s.nextZ = null, c *= 2 } while (o > 1); return i } function MS(i, e, t, n, r) { return i = (i - t) * r | 0, e = (e - n) * r | 0, i = (i | i << 8) & 16711935, i = (i | i << 4) & 252645135, i = (i | i << 2) & 858993459, i = (i | i << 1) & 1431655765, e = (e | e << 8) & 16711935, e = (e | e << 4) & 252645135, e = (e | e << 2) & 858993459, e = (e | e << 1) & 1431655765, i | e << 1 } function s7(i) { let e = i, t = i; do (e.x < t.x || e.x === t.x && e.y < t.y) && (t = e), e = e.next; while (e !== i); return t } function Bf(i, e, t, n, r, s, o, a) { return (r - o) * (e - a) >= (i - o) * (s - a) && (i - o) * (n - a) >= (t - o) * (e - a) && (t - o) * (s - a) >= (r - o) * (n - a) } function o7(i, e) { return i.next.i !== e.i && i.prev.i !== e.i && !a7(i, e) && (Xp(i, e) && Xp(e, i) && l7(i, e) && (Bn(i.prev, i, e.prev) || Bn(i, e.prev, e)) || $v(i, e) && Bn(i.prev, i, i.next) > 0 && Bn(e.prev, e, e.next) > 0) } function Bn(i, e, t) { return (e.y - i.y) * (t.x - e.x) - (e.x - i.x) * (t.y - e.y) } function $v(i, e) { return i.x === e.x && i.y === e.y } function jF(i, e, t, n) { const r = A0(Bn(i, e, t)), s = A0(Bn(i, e, n)), o = A0(Bn(t, n, i)), a = A0(Bn(t, n, e)); return !!(r !== s && o !== a || r === 0 && x0(i, t, e) || s === 0 && x0(i, n, e) || o === 0 && x0(t, i, n) || a === 0 && x0(t, e, n)) } function x0(i, e, t) { return e.x <= Math.max(i.x, t.x) && e.x >= Math.min(i.x, t.x) && e.y <= Math.max(i.y, t.y) && e.y >= Math.min(i.y, t.y) } function A0(i) { return i > 0 ? 1 : i < 0 ? -1 : 0 } function a7(i, e) { let t = i; do { if (t.i !== i.i && t.next.i !== i.i && t.i !== e.i && t.next.i !== e.i && jF(t, t.next, i, e)) return !0; t = t.next } while (t !== i); return !1 } function Xp(i, e) { return Bn(i.prev, i, i.next) < 0 ? Bn(i, e, i.next) >= 0 && Bn(i, i.prev, e) >= 0 : Bn(i, e, i.prev) < 0 || Bn(i, i.next, e) < 0 } function l7(i, e) { let t = i, n = !1; const r = (i.x + e.x) / 2, s = (i.y + e.y) / 2; do t.y > s != t.next.y > s && t.next.y !== t.y && r < (t.next.x - t.x) * (s - t.y) / (t.next.y - t.y) + t.x && (n = !n), t = t.next; while (t !== i); return n } function KF(i, e) { const t = new wS(i.i, i.x, i.y), n = new wS(e.i, e.x, e.y), r = i.next, s = e.prev; return i.next = e, e.prev = i, t.next = r, r.prev = t, n.next = t, t.prev = n, s.next = n, n.prev = s, n } function $P(i, e, t, n) { const r = new wS(i, e, t); return n ? (r.next = n.next, r.prev = n, n.next.prev = r, n.next = r) : (r.prev = r, r.next = r), r } function Jp(i) { i.next.prev = i.prev, i.prev.next = i.next, i.prevZ && (i.prevZ.nextZ = i.nextZ), i.nextZ && (i.nextZ.prevZ = i.prevZ) } function wS(i, e, t) { this.i = i, this.x = e, this.y = t, this.prev = null, this.next = null, this.z = 0, this.prevZ = null, this.nextZ = null, this.steiner = !1 } function c7(i, e, t, n) { let r = 0; for (let s = e, o = t - n; s < t; s += n)r += (i[o] - i[s]) * (i[s + 1] + i[o + 1]), o = s; return r } class Vo { static area(e) { const t = e.length; let n = 0; for (let r = t - 1, s = 0; s < t; r = s++)n += e[r].x * e[s].y - e[s].x * e[r].y; return n * .5 } static isClockWise(e) { return Vo.area(e) < 0 } static triangulateShape(e, t) { const n = [], r = [], s = []; eI(e), tI(n, e); let o = e.length; t.forEach(eI); for (let l = 0; l < t.length; l++)r.push(o), o += t[l].length, tI(n, t[l]); const a = Yj.triangulate(n, r); for (let l = 0; l < a.length; l += 3)s.push(a.slice(l, l + 3)); return s } } function eI(i) { const e = i.length; e > 2 && i[e - 1].equals(i[0]) && i.pop() } function tI(i, e) { for (let t = 0; t < e.length; t++)i.push(e[t].x), i.push(e[t].y) } class e_ extends Rt { constructor(e = new Kc([new _e(.5, .5), new _e(-.5, .5), new _e(-.5, -.5), new _e(.5, -.5)]), t = {}) { super(), this.type = "ExtrudeGeometry", this.parameters = { shapes: e, options: t }, e = Array.isArray(e) ? e : [e]; const n = this, r = [], s = []; for (let a = 0, l = e.length; a < l; a++) { const c = e[a]; o(c) } this.setAttribute("position", new rt(r, 3)), this.setAttribute("uv", new rt(s, 2)), this.computeVertexNormals(); function o(a) { const l = [], c = t.curveSegments !== void 0 ? t.curveSegments : 12, f = t.steps !== void 0 ? t.steps : 1, d = t.depth !== void 0 ? t.depth : 1; let p = t.bevelEnabled !== void 0 ? t.bevelEnabled : !0, m = t.bevelThickness !== void 0 ? t.bevelThickness : .2, y = t.bevelSize !== void 0 ? t.bevelSize : m - .1, _ = t.bevelOffset !== void 0 ? t.bevelOffset : 0, x = t.bevelSegments !== void 0 ? t.bevelSegments : 3; const g = t.extrudePath, A = t.UVGenerator !== void 0 ? t.UVGenerator : u7; let M, S = !1, C, T, R, B; g && (M = g.getSpacedPoints(f), S = !0, p = !1, C = g.computeFrenetFrames(f, !1), T = new k, R = new k, B = new k), p || (x = 0, m = 0, y = 0, _ = 0); const b = a.extractPoints(c); let I = b.shape; const N = b.holes; if (!Vo.isClockWise(I)) { I = I.reverse(); for (let H = 0, pe = N.length; H < pe; H++) { const fe = N[H]; Vo.isClockWise(fe) && (N[H] = fe.reverse()) } } const J = Vo.triangulateShape(I, N), j = I; for (let H = 0, pe = N.length; H < pe; H++) { const fe = N[H]; I = I.concat(fe) } function q(H, pe, fe) { return pe || console.error("THREE.ExtrudeGeometry: vec does not exist"), H.clone().addScaledVector(pe, fe) } const ne = I.length, Q = J.length; function F(H, pe, fe) { let Ee, ve, Z; const Fe = H.x - pe.x, Ve = H.y - pe.y, st = fe.x - H.x, ot = fe.y - H.y, Yt = Fe * Fe + Ve * Ve, U = Fe * ot - Ve * st; if (Math.abs(U) > Number.EPSILON) { const D = Math.sqrt(Yt), re = Math.sqrt(st * st + ot * ot), Ae = pe.x - Ve / D, Me = pe.y + Fe / D, Ce = fe.x - ot / re, qe = fe.y + st / re, Te = ((Ce - Ae) * ot - (qe - Me) * st) / (Fe * ot - Ve * st); Ee = Ae + Fe * Te - H.x, ve = Me + Ve * Te - H.y; const oe = Ee * Ee + ve * ve; if (oe <= 2) return new _e(Ee, ve); Z = Math.sqrt(oe / 2) } else { let D = !1; Fe > Number.EPSILON ? st > Number.EPSILON && (D = !0) : Fe < -Number.EPSILON ? st < -Number.EPSILON && (D = !0) : Math.sign(Ve) === Math.sign(ot) && (D = !0), D ? (Ee = -Ve, ve = Fe, Z = Math.sqrt(Yt)) : (Ee = Fe, ve = Ve, Z = Math.sqrt(Yt / 2)) } return new _e(Ee / Z, ve / Z) } const Y = []; for (let H = 0, pe = j.length, fe = pe - 1, Ee = H + 1; H < pe; H++, fe++, Ee++)fe === pe && (fe = 0), Ee === pe && (Ee = 0), Y[H] = F(j[H], j[fe], j[Ee]); const L = []; let G, K = Y.concat(); for (let H = 0, pe = N.length; H < pe; H++) { const fe = N[H]; G = []; for (let Ee = 0, ve = fe.length, Z = ve - 1, Fe = Ee + 1; Ee < ve; Ee++, Z++, Fe++)Z === ve && (Z = 0), Fe === ve && (Fe = 0), G[Ee] = F(fe[Ee], fe[Z], fe[Fe]); L.push(G), K = K.concat(G) } for (let H = 0; H < x; H++) { const pe = H / x, fe = m * Math.cos(pe * Math.PI / 2), Ee = y * Math.sin(pe * Math.PI / 2) + _; for (let ve = 0, Z = j.length; ve < Z; ve++) { const Fe = q(j[ve], Y[ve], Ee); Ie(Fe.x, Fe.y, -fe) } for (let ve = 0, Z = N.length; ve < Z; ve++) { const Fe = N[ve]; G = L[ve]; for (let Ve = 0, st = Fe.length; Ve < st; Ve++) { const ot = q(Fe[Ve], G[Ve], Ee); Ie(ot.x, ot.y, -fe) } } } const ye = y + _; for (let H = 0; H < ne; H++) { const pe = p ? q(I[H], K[H], ye) : I[H]; S ? (R.copy(C.normals[0]).multiplyScalar(pe.x), T.copy(C.binormals[0]).multiplyScalar(pe.y), B.copy(M[0]).add(R).add(T), Ie(B.x, B.y, B.z)) : Ie(pe.x, pe.y, 0) } for (let H = 1; H <= f; H++)for (let pe = 0; pe < ne; pe++) { const fe = p ? q(I[pe], K[pe], ye) : I[pe]; S ? (R.copy(C.normals[H]).multiplyScalar(fe.x), T.copy(C.binormals[H]).multiplyScalar(fe.y), B.copy(M[H]).add(R).add(T), Ie(B.x, B.y, B.z)) : Ie(fe.x, fe.y, d / f * H) } for (let H = x - 1; H >= 0; H--) { const pe = H / x, fe = m * Math.cos(pe * Math.PI / 2), Ee = y * Math.sin(pe * Math.PI / 2) + _; for (let ve = 0, Z = j.length; ve < Z; ve++) { const Fe = q(j[ve], Y[ve], Ee); Ie(Fe.x, Fe.y, d + fe) } for (let ve = 0, Z = N.length; ve < Z; ve++) { const Fe = N[ve]; G = L[ve]; for (let Ve = 0, st = Fe.length; Ve < st; Ve++) { const ot = q(Fe[Ve], G[Ve], Ee); S ? Ie(ot.x, ot.y + M[f - 1].y, M[f - 1].x + fe) : Ie(ot.x, ot.y, d + fe) } } } ge(), xe(); function ge() { const H = r.length / 3; if (p) { let pe = 0, fe = ne * pe; for (let Ee = 0; Ee < Q; Ee++) { const ve = J[Ee]; Je(ve[2] + fe, ve[1] + fe, ve[0] + fe) } pe = f + x * 2, fe = ne * pe; for (let Ee = 0; Ee < Q; Ee++) { const ve = J[Ee]; Je(ve[0] + fe, ve[1] + fe, ve[2] + fe) } } else { for (let pe = 0; pe < Q; pe++) { const fe = J[pe]; Je(fe[2], fe[1], fe[0]) } for (let pe = 0; pe < Q; pe++) { const fe = J[pe]; Je(fe[0] + ne * f, fe[1] + ne * f, fe[2] + ne * f) } } n.addGroup(H, r.length / 3 - H, 0) } function xe() { const H = r.length / 3; let pe = 0; Be(j, pe), pe += j.length; for (let fe = 0, Ee = N.length; fe < Ee; fe++) { const ve = N[fe]; Be(ve, pe), pe += ve.length } n.addGroup(H, r.length / 3 - H, 1) } function Be(H, pe) { let fe = H.length; for (; --fe >= 0;) { const Ee = fe; let ve = fe - 1; ve < 0 && (ve = H.length - 1); for (let Z = 0, Fe = f + x * 2; Z < Fe; Z++) { const Ve = ne * Z, st = ne * (Z + 1), ot = pe + Ee + Ve, Yt = pe + ve + Ve, U = pe + ve + st, D = pe + Ee + st; ut(ot, Yt, U, D) } } } function Ie(H, pe, fe) { l.push(H), l.push(pe), l.push(fe) } function Je(H, pe, fe) { Bt(H), Bt(pe), Bt(fe); const Ee = r.length / 3, ve = A.generateTopUV(n, r, Ee - 3, Ee - 2, Ee - 1); Ge(ve[0]), Ge(ve[1]), Ge(ve[2]) } function ut(H, pe, fe, Ee) { Bt(H), Bt(pe), Bt(Ee), Bt(pe), Bt(fe), Bt(Ee); const ve = r.length / 3, Z = A.generateSideWallUV(n, r, ve - 6, ve - 3, ve - 2, ve - 1); Ge(Z[0]), Ge(Z[1]), Ge(Z[3]), Ge(Z[1]), Ge(Z[2]), Ge(Z[3]) } function Bt(H) { r.push(l[H * 3 + 0]), r.push(l[H * 3 + 1]), r.push(l[H * 3 + 2]) } function Ge(H) { s.push(H.x), s.push(H.y) } } } copy(e) { return super.copy(e), this.parameters = Object.assign({}, e.parameters), this } toJSON() { const e = super.toJSON(), t = this.parameters.shapes, n = this.parameters.options; return f7(t, n, e) } static fromJSON(e, t) { const n = []; for (let s = 0, o = e.shapes.length; s < o; s++) { const a = t[e.shapes[s]]; n.push(a) } const r = e.options.extrudePath; return r !== void 0 && (e.options.extrudePath = new UE[r.type]().fromJSON(r)), new e_(n, e.options) } } const u7 = { generateTopUV: function (i, e, t, n, r) { const s = e[t * 3], o = e[t * 3 + 1], a = e[n * 3], l = e[n * 3 + 1], c = e[r * 3], f = e[r * 3 + 1]; return [new _e(s, o), new _e(a, l), new _e(c, f)] }, generateSideWallUV: function (i, e, t, n, r, s) { const o = e[t * 3], a = e[t * 3 + 1], l = e[t * 3 + 2], c = e[n * 3], f = e[n * 3 + 1], d = e[n * 3 + 2], p = e[r * 3], m = e[r * 3 + 1], y = e[r * 3 + 2], _ = e[s * 3], x = e[s * 3 + 1], g = e[s * 3 + 2]; return Math.abs(a - f) < Math.abs(o - c) ? [new _e(o, 1 - l), new _e(c, 1 - d), new _e(p, 1 - y), new _e(_, 1 - g)] : [new _e(a, 1 - l), new _e(f, 1 - d), new _e(m, 1 - y), new _e(x, 1 - g)] } }; function f7(i, e, t) { if (t.shapes = [], Array.isArray(i)) for (let n = 0, r = i.length; n < r; n++) { const s = i[n]; t.shapes.push(s.uuid) } else t.shapes.push(i.uuid); return t.options = Object.assign({}, e), e.extrudePath !== void 0 && (t.options.extrudePath = e.extrudePath.toJSON()), t } class t_ extends Yl { constructor(e = 1, t = 0) { const n = (1 + Math.sqrt(5)) / 2, r = [-1, n, 0, 1, n, 0, -1, -n, 0, 1, -n, 0, 0, -1, n, 0, 1, n, 0, -1, -n, 0, 1, -n, n, 0, -1, n, 0, 1, -n, 0, -1, -n, 0, 1], s = [0, 11, 5, 0, 5, 1, 0, 1, 7, 0, 7, 10, 0, 10, 11, 1, 5, 9, 5, 11, 4, 11, 10, 2, 10, 7, 6, 7, 1, 8, 3, 9, 4, 3, 4, 2, 3, 2, 6, 3, 6, 8, 3, 8, 9, 4, 9, 5, 2, 4, 11, 6, 2, 10, 8, 6, 7, 9, 8, 1]; super(r, s, e, t), this.type = "IcosahedronGeometry", this.parameters = { radius: e, detail: t } } static fromJSON(e) { return new t_(e.radius, e.detail) } } class dm extends Yl { constructor(e = 1, t = 0) { const n = [1, 0, 0, -1, 0, 0, 0, 1, 0, 0, -1, 0, 0, 0, 1, 0, 0, -1], r = [0, 2, 4, 0, 4, 3, 0, 3, 5, 0, 5, 2, 1, 2, 5, 1, 5, 3, 1, 3, 4, 1, 4, 2]; super(n, r, e, t), this.type = "OctahedronGeometry", this.parameters = { radius: e, detail: t } } static fromJSON(e) { return new dm(e.radius, e.detail) } } class n_ extends Rt { constructor(e = .5, t = 1, n = 32, r = 1, s = 0, o = Math.PI * 2) { super(), this.type = "RingGeometry", this.parameters = { innerRadius: e, outerRadius: t, thetaSegments: n, phiSegments: r, thetaStart: s, thetaLength: o }, n = Math.max(3, n), r = Math.max(1, r); const a = [], l = [], c = [], f = []; let d = e; const p = (t - e) / r, m = new k, y = new _e; for (let _ = 0; _ <= r; _++) { for (let x = 0; x <= n; x++) { const g = s + x / n * o; m.x = d * Math.cos(g), m.y = d * Math.sin(g), l.push(m.x, m.y, m.z), c.push(0, 0, 1), y.x = (m.x / t + 1) / 2, y.y = (m.y / t + 1) / 2, f.push(y.x, y.y) } d += p } for (let _ = 0; _ < r; _++) { const x = _ * (n + 1); for (let g = 0; g < n; g++) { const A = g + x, M = A, S = A + n + 1, C = A + n + 2, T = A + 1; a.push(M, S, T), a.push(S, C, T) } } this.setIndex(a), this.setAttribute("position", new rt(l, 3)), this.setAttribute("normal", new rt(c, 3)), this.setAttribute("uv", new rt(f, 2)) } copy(e) { return super.copy(e), this.parameters = Object.assign({}, e.parameters), this } static fromJSON(e) { return new n_(e.innerRadius, e.outerRadius, e.thetaSegments, e.phiSegments, e.thetaStart, e.thetaLength) } } class i_ extends Rt { constructor(e = new Kc([new _e(0, .5), new _e(-.5, -.5), new _e(.5, -.5)]), t = 12) { super(), this.type = "ShapeGeometry", this.parameters = { shapes: e, curveSegments: t }; const n = [], r = [], s = [], o = []; let a = 0, l = 0; if (Array.isArray(e) === !1) c(e); else for (let f = 0; f < e.length; f++)c(e[f]), this.addGroup(a, l, f), a += l, l = 0; this.setIndex(n), this.setAttribute("position", new rt(r, 3)), this.setAttribute("normal", new rt(s, 3)), this.setAttribute("uv", new rt(o, 2)); function c(f) { const d = r.length / 3, p = f.extractPoints(t); let m = p.shape; const y = p.holes; Vo.isClockWise(m) === !1 && (m = m.reverse()); for (let x = 0, g = y.length; x < g; x++) { const A = y[x]; Vo.isClockWise(A) === !0 && (y[x] = A.reverse()) } const _ = Vo.triangulateShape(m, y); for (let x = 0, g = y.length; x < g; x++) { const A = y[x]; m = m.concat(A) } for (let x = 0, g = m.length; x < g; x++) { const A = m[x]; r.push(A.x, A.y, 0), s.push(0, 0, 1), o.push(A.x, A.y) } for (let x = 0, g = _.length; x < g; x++) { const A = _[x], M = A[0] + d, S = A[1] + d, C = A[2] + d; n.push(M, S, C), l += 3 } } } copy(e) { return super.copy(e), this.parameters = Object.assign({}, e.parameters), this } toJSON() { const e = super.toJSON(), t = this.parameters.shapes; return h7(t, e) } static fromJSON(e, t) { const n = []; for (let r = 0, s = e.shapes.length; r < s; r++) { const o = t[e.shapes[r]]; n.push(o) } return new i_(n, e.curveSegments) } } function h7(i, e) { if (e.shapes = [], Array.isArray(i)) for (let t = 0, n = i.length; t < n; t++) { const r = i[t]; e.shapes.push(r.uuid) } else e.shapes.push(i.uuid); return e } class pm extends Rt { constructor(e = 1, t = 32, n = 16, r = 0, s = Math.PI * 2, o = 0, a = Math.PI) { super(), this.type = "SphereGeometry", this.parameters = { radius: e, widthSegments: t, heightSegments: n, phiStart: r, phiLength: s, thetaStart: o, thetaLength: a }, t = Math.max(3, Math.floor(t)), n = Math.max(2, Math.floor(n)); const l = Math.min(o + a, Math.PI); let c = 0; const f = [], d = new k, p = new k, m = [], y = [], _ = [], x = []; for (let g = 0; g <= n; g++) { const A = [], M = g / n; let S = 0; g === 0 && o === 0 ? S = .5 / t : g === n && l === Math.PI && (S = -.5 / t); for (let C = 0; C <= t; C++) { const T = C / t; d.x = -e * Math.cos(r + T * s) * Math.sin(o + M * a), d.y = e * Math.cos(o + M * a), d.z = e * Math.sin(r + T * s) * Math.sin(o + M * a), y.push(d.x, d.y, d.z), p.copy(d).normalize(), _.push(p.x, p.y, p.z), x.push(T + S, 1 - M), A.push(c++) } f.push(A) } for (let g = 0; g < n; g++)for (let A = 0; A < t; A++) { const M = f[g][A + 1], S = f[g][A], C = f[g + 1][A], T = f[g + 1][A + 1]; (g !== 0 || o > 0) && m.push(M, S, T), (g !== n - 1 || l < Math.PI) && m.push(S, C, T) } this.setIndex(m), this.setAttribute("position", new rt(y, 3)), this.setAttribute("normal", new rt(_, 3)), this.setAttribute("uv", new rt(x, 2)) } copy(e) { return super.copy(e), this.parameters = Object.assign({}, e.parameters), this } static fromJSON(e) { return new pm(e.radius, e.widthSegments, e.heightSegments, e.phiStart, e.phiLength, e.thetaStart, e.thetaLength) } } class r_ extends Yl { constructor(e = 1, t = 0) { const n = [1, 1, 1, -1, -1, 1, -1, 1, -1, 1, -1, -1], r = [2, 1, 0, 0, 3, 2, 1, 3, 0, 2, 3, 1]; super(n, r, e, t), this.type = "TetrahedronGeometry", this.parameters = { radius: e, detail: t } } static fromJSON(e) { return new r_(e.radius, e.detail) } } class s_ extends Rt { constructor(e = 1, t = .4, n = 12, r = 48, s = Math.PI * 2) { super(), this.type = "TorusGeometry", this.parameters = { radius: e, tube: t, radialSegments: n, tubularSegments: r, arc: s }, n = Math.floor(n), r = Math.floor(r); const o = [], a = [], l = [], c = [], f = new k, d = new k, p = new k; for (let m = 0; m <= n; m++)for (let y = 0; y <= r; y++) { const _ = y / r * s, x = m / n * Math.PI * 2; d.x = (e + t * Math.cos(x)) * Math.cos(_), d.y = (e + t * Math.cos(x)) * Math.sin(_), d.z = t * Math.sin(x), a.push(d.x, d.y, d.z), f.x = e * Math.cos(_), f.y = e * Math.sin(_), p.subVectors(d, f).normalize(), l.push(p.x, p.y, p.z), c.push(y / r), c.push(m / n) } for (let m = 1; m <= n; m++)for (let y = 1; y <= r; y++) { const _ = (r + 1) * m + y - 1, x = (r + 1) * (m - 1) + y - 1, g = (r + 1) * (m - 1) + y, A = (r + 1) * m + y; o.push(_, x, A), o.push(x, g, A) } this.setIndex(o), this.setAttribute("position", new rt(a, 3)), this.setAttribute("normal", new rt(l, 3)), this.setAttribute("uv", new rt(c, 2)) } copy(e) { return super.copy(e), this.parameters = Object.assign({}, e.parameters), this } static fromJSON(e) { return new s_(e.radius, e.tube, e.radialSegments, e.tubularSegments, e.arc) } } class o_ extends Rt { constructor(e = 1, t = .4, n = 64, r = 8, s = 2, o = 3) { super(), this.type = "TorusKnotGeometry", this.parameters = { radius: e, tube: t, tubularSegments: n, radialSegments: r, p: s, q: o }, n = Math.floor(n), r = Math.floor(r); const a = [], l = [], c = [], f = [], d = new k, p = new k, m = new k, y = new k, _ = new k, x = new k, g = new k; for (let M = 0; M <= n; ++M) { const S = M / n * s * Math.PI * 2; A(S, s, o, e, m), A(S + .01, s, o, e, y), x.subVectors(y, m), g.addVectors(y, m), _.crossVectors(x, g), g.crossVectors(_, x), _.normalize(), g.normalize(); for (let C = 0; C <= r; ++C) { const T = C / r * Math.PI * 2, R = -t * Math.cos(T), B = t * Math.sin(T); d.x = m.x + (R * g.x + B * _.x), d.y = m.y + (R * g.y + B * _.y), d.z = m.z + (R * g.z + B * _.z), l.push(d.x, d.y, d.z), p.subVectors(d, m).normalize(), c.push(p.x, p.y, p.z), f.push(M / n), f.push(C / r) } } for (let M = 1; M <= n; M++)for (let S = 1; S <= r; S++) { const C = (r + 1) * (M - 1) + (S - 1), T = (r + 1) * M + (S - 1), R = (r + 1) * M + S, B = (r + 1) * (M - 1) + S; a.push(C, T, B), a.push(T, R, B) } this.setIndex(a), this.setAttribute("position", new rt(l, 3)), this.setAttribute("normal", new rt(c, 3)), this.setAttribute("uv", new rt(f, 2)); function A(M, S, C, T, R) { const B = Math.cos(M), b = Math.sin(M), I = C / S * M, N = Math.cos(I); R.x = T * (2 + N) * .5 * B, R.y = T * (2 + N) * b * .5, R.z = T * Math.sin(I) * .5 } } copy(e) { return super.copy(e), this.parameters = Object.assign({}, e.parameters), this } static fromJSON(e) { return new o_(e.radius, e.tube, e.tubularSegments, e.radialSegments, e.p, e.q) } } class a_ extends Rt { constructor(e = new kE(new k(-1, -1, 0), new k(-1, 1, 0), new k(1, 1, 0)), t = 64, n = 1, r = 8, s = !1) { super(), this.type = "TubeGeometry", this.parameters = { path: e, tubularSegments: t, radius: n, radialSegments: r, closed: s }; const o = e.computeFrenetFrames(t, s); this.tangents = o.tangents, this.normals = o.normals, this.binormals = o.binormals; const a = new k, l = new k, c = new _e; let f = new k; const d = [], p = [], m = [], y = []; _(), this.setIndex(y), this.setAttribute("position", new rt(d, 3)), this.setAttribute("normal", new rt(p, 3)), this.setAttribute("uv", new rt(m, 2)); function _() { for (let M = 0; M < t; M++)x(M); x(s === !1 ? t : 0), A(), g() } function x(M) { f = e.getPointAt(M / t, f); const S = o.normals[M], C = o.binormals[M]; for (let T = 0; T <= r; T++) { const R = T / r * Math.PI * 2, B = Math.sin(R), b = -Math.cos(R); l.x = b * S.x + B * C.x, l.y = b * S.y + B * C.y, l.z = b * S.z + B * C.z, l.normalize(), p.push(l.x, l.y, l.z), a.x = f.x + n * l.x, a.y = f.y + n * l.y, a.z = f.z + n * l.z, d.push(a.x, a.y, a.z) } } function g() { for (let M = 1; M <= t; M++)for (let S = 1; S <= r; S++) { const C = (r + 1) * (M - 1) + (S - 1), T = (r + 1) * M + (S - 1), R = (r + 1) * M + S, B = (r + 1) * (M - 1) + S; y.push(C, T, B), y.push(T, R, B) } } function A() { for (let M = 0; M <= t; M++)for (let S = 0; S <= r; S++)c.x = M / t, c.y = S / r, m.push(c.x, c.y) } } copy(e) { return super.copy(e), this.parameters = Object.assign({}, e.parameters), this } toJSON() { const e = super.toJSON(); return e.path = this.parameters.path.toJSON(), e } static fromJSON(e) { return new a_(new UE[e.path.type]().fromJSON(e.path), e.tubularSegments, e.radius, e.radialSegments, e.closed) } } class qF extends Rt { constructor(e = null) { if (super(), this.type = "WireframeGeometry", this.parameters = { geometry: e }, e !== null) { const t = [], n = new Set, r = new k, s = new k; if (e.index !== null) { const o = e.attributes.position, a = e.index; let l = e.groups; l.length === 0 && (l = [{ start: 0, count: a.count, materialIndex: 0 }]); for (let c = 0, f = l.length; c < f; ++c) { const d = l[c], p = d.start, m = d.count; for (let y = p, _ = p + m; y < _; y += 3)for (let x = 0; x < 3; x++) { const g = a.getX(y + x), A = a.getX(y + (x + 1) % 3); r.fromBufferAttribute(o, g), s.fromBufferAttribute(o, A), nI(r, s, n) === !0 && (t.push(r.x, r.y, r.z), t.push(s.x, s.y, s.z)) } } } else { const o = e.attributes.position; for (let a = 0, l = o.count / 3; a < l; a++)for (let c = 0; c < 3; c++) { const f = 3 * a + c, d = 3 * a + (c + 1) % 3; r.fromBufferAttribute(o, f), s.fromBufferAttribute(o, d), nI(r, s, n) === !0 && (t.push(r.x, r.y, r.z), t.push(s.x, s.y, s.z)) } } this.setAttribute("position", new rt(t, 3)) } } copy(e) { return super.copy(e), this.parameters = Object.assign({}, e.parameters), this } } function nI(i, e, t) { const n = `${i.x},${i.y},${i.z}-${e.x},${e.y},${e.z}`, r = `${e.x},${e.y},${e.z}-${i.x},${i.y},${i.z}`; return t.has(n) === !0 || t.has(r) === !0 ? !1 : (t.add(n), t.add(r), !0) } var iI = Object.freeze({ __proto__: null, BoxGeometry: pu, CapsuleGeometry: Kv, CircleGeometry: qv, ConeGeometry: Qv, CylinderGeometry: Bh, DodecahedronGeometry: Zv, EdgesGeometry: JF, ExtrudeGeometry: e_, IcosahedronGeometry: t_, LatheGeometry: hm, OctahedronGeometry: dm, PlaneGeometry: cm, PolyhedronGeometry: Yl, RingGeometry: n_, ShapeGeometry: i_, SphereGeometry: pm, TetrahedronGeometry: r_, TorusGeometry: s_, TorusKnotGeometry: o_, TubeGeometry: a_, WireframeGeometry: qF }); class QF extends oi { constructor(e) { super(), this.isShadowMaterial = !0, this.type = "ShadowMaterial", this.color = new We(0), this.transparent = !0, this.fog = !0, this.setValues(e) } copy(e) { return super.copy(e), this.color.copy(e.color), this.fog = e.fog, this } } class ZF extends jo { constructor(e) { super(e), this.isRawShaderMaterial = !0, this.type = "RawShaderMaterial" } } class mm extends oi { constructor(e) { super(), this.isMeshStandardMaterial = !0, this.defines = { STANDARD: "" }, this.type = "MeshStandardMaterial", this.color = new We(16777215), this.roughness = 1, this.metalness = 0, this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new We(0), this.emissiveIntensity = 1, this.emissiveMap = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = Jl, this.normalScale = new _e(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.roughnessMap = null, this.metalnessMap = null, this.alphaMap = null, this.envMap = null, this.envMapIntensity = 1, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.flatShading = !1, this.fog = !0, this.setValues(e) } copy(e) { return super.copy(e), this.defines = { STANDARD: "" }, this.color.copy(e.color), this.roughness = e.roughness, this.metalness = e.metalness, this.map = e.map, this.lightMap = e.lightMap, this.lightMapIntensity = e.lightMapIntensity, this.aoMap = e.aoMap, this.aoMapIntensity = e.aoMapIntensity, this.emissive.copy(e.emissive), this.emissiveMap = e.emissiveMap, this.emissiveIntensity = e.emissiveIntensity, this.bumpMap = e.bumpMap, this.bumpScale = e.bumpScale, this.normalMap = e.normalMap, this.normalMapType = e.normalMapType, this.normalScale.copy(e.normalScale), this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this.roughnessMap = e.roughnessMap, this.metalnessMap = e.metalnessMap, this.alphaMap = e.alphaMap, this.envMap = e.envMap, this.envMapIntensity = e.envMapIntensity, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.wireframeLinecap = e.wireframeLinecap, this.wireframeLinejoin = e.wireframeLinejoin, this.flatShading = e.flatShading, this.fog = e.fog, this } } class qo extends mm { constructor(e) { super(), this.isMeshPhysicalMaterial = !0, this.defines = { STANDARD: "", PHYSICAL: "" }, this.type = "MeshPhysicalMaterial", this.anisotropyRotation = 0, this.anisotropyMap = null, this.clearcoatMap = null, this.clearcoatRoughness = 0, this.clearcoatRoughnessMap = null, this.clearcoatNormalScale = new _e(1, 1), this.clearcoatNormalMap = null, this.ior = 1.5, Object.defineProperty(this, "reflectivity", { get: function () { return Gn(2.5 * (this.ior - 1) / (this.ior + 1), 0, 1) }, set: function (t) { this.ior = (1 + .4 * t) / (1 - .4 * t) } }), this.iridescenceMap = null, this.iridescenceIOR = 1.3, this.iridescenceThicknessRange = [100, 400], this.iridescenceThicknessMap = null, this.sheenColor = new We(0), this.sheenColorMap = null, this.sheenRoughness = 1, this.sheenRoughnessMap = null, this.transmissionMap = null, this.thickness = 0, this.thicknessMap = null, this.attenuationDistance = 1 / 0, this.attenuationColor = new We(1, 1, 1), this.specularIntensity = 1, this.specularIntensityMap = null, this.specularColor = new We(1, 1, 1), this.specularColorMap = null, this._anisotropy = 0, this._clearcoat = 0, this._iridescence = 0, this._sheen = 0, this._transmission = 0, this.setValues(e) } get anisotropy() { return this._anisotropy } set anisotropy(e) { this._anisotropy > 0 != e > 0 && this.version++, this._anisotropy = e } get clearcoat() { return this._clearcoat } set clearcoat(e) { this._clearcoat > 0 != e > 0 && this.version++, this._clearcoat = e } get iridescence() { return this._iridescence } set iridescence(e) { this._iridescence > 0 != e > 0 && this.version++, this._iridescence = e } get sheen() { return this._sheen } set sheen(e) { this._sheen > 0 != e > 0 && this.version++, this._sheen = e } get transmission() { return this._transmission } set transmission(e) { this._transmission > 0 != e > 0 && this.version++, this._transmission = e } copy(e) { return super.copy(e), this.defines = { STANDARD: "", PHYSICAL: "" }, this.anisotropy = e.anisotropy, this.anisotropyRotation = e.anisotropyRotation, this.anisotropyMap = e.anisotropyMap, this.clearcoat = e.clearcoat, this.clearcoatMap = e.clearcoatMap, this.clearcoatRoughness = e.clearcoatRoughness, this.clearcoatRoughnessMap = e.clearcoatRoughnessMap, this.clearcoatNormalMap = e.clearcoatNormalMap, this.clearcoatNormalScale.copy(e.clearcoatNormalScale), this.ior = e.ior, this.iridescence = e.iridescence, this.iridescenceMap = e.iridescenceMap, this.iridescenceIOR = e.iridescenceIOR, this.iridescenceThicknessRange = [...e.iridescenceThicknessRange], this.iridescenceThicknessMap = e.iridescenceThicknessMap, this.sheen = e.sheen, this.sheenColor.copy(e.sheenColor), this.sheenColorMap = e.sheenColorMap, this.sheenRoughness = e.sheenRoughness, this.sheenRoughnessMap = e.sheenRoughnessMap, this.transmission = e.transmission, this.transmissionMap = e.transmissionMap, this.thickness = e.thickness, this.thicknessMap = e.thicknessMap, this.attenuationDistance = e.attenuationDistance, this.attenuationColor.copy(e.attenuationColor), this.specularIntensity = e.specularIntensity, this.specularIntensityMap = e.specularIntensityMap, this.specularColor.copy(e.specularColor), this.specularColorMap = e.specularColorMap, this } } class $F extends oi { constructor(e) { super(), this.isMeshPhongMaterial = !0, this.type = "MeshPhongMaterial", this.color = new We(16777215), this.specular = new We(1118481), this.shininess = 30, this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new We(0), this.emissiveIntensity = 1, this.emissiveMap = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = Jl, this.normalScale = new _e(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.specularMap = null, this.alphaMap = null, this.envMap = null, this.combine = sm, this.reflectivity = 1, this.refractionRatio = .98, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.flatShading = !1, this.fog = !0, this.setValues(e) } copy(e) { return super.copy(e), this.color.copy(e.color), this.specular.copy(e.specular), this.shininess = e.shininess, this.map = e.map, this.lightMap = e.lightMap, this.lightMapIntensity = e.lightMapIntensity, this.aoMap = e.aoMap, this.aoMapIntensity = e.aoMapIntensity, this.emissive.copy(e.emissive), this.emissiveMap = e.emissiveMap, this.emissiveIntensity = e.emissiveIntensity, this.bumpMap = e.bumpMap, this.bumpScale = e.bumpScale, this.normalMap = e.normalMap, this.normalMapType = e.normalMapType, this.normalScale.copy(e.normalScale), this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this.specularMap = e.specularMap, this.alphaMap = e.alphaMap, this.envMap = e.envMap, this.combine = e.combine, this.reflectivity = e.reflectivity, this.refractionRatio = e.refractionRatio, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.wireframeLinecap = e.wireframeLinecap, this.wireframeLinejoin = e.wireframeLinejoin, this.flatShading = e.flatShading, this.fog = e.fog, this } } class ek extends oi { constructor(e) { super(), this.isMeshToonMaterial = !0, this.defines = { TOON: "" }, this.type = "MeshToonMaterial", this.color = new We(16777215), this.map = null, this.gradientMap = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new We(0), this.emissiveIntensity = 1, this.emissiveMap = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = Jl, this.normalScale = new _e(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.alphaMap = null, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.fog = !0, this.setValues(e) } copy(e) { return super.copy(e), this.color.copy(e.color), this.map = e.map, this.gradientMap = e.gradientMap, this.lightMap = e.lightMap, this.lightMapIntensity = e.lightMapIntensity, this.aoMap = e.aoMap, this.aoMapIntensity = e.aoMapIntensity, this.emissive.copy(e.emissive), this.emissiveMap = e.emissiveMap, this.emissiveIntensity = e.emissiveIntensity, this.bumpMap = e.bumpMap, this.bumpScale = e.bumpScale, this.normalMap = e.normalMap, this.normalMapType = e.normalMapType, this.normalScale.copy(e.normalScale), this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this.alphaMap = e.alphaMap, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.wireframeLinecap = e.wireframeLinecap, this.wireframeLinejoin = e.wireframeLinejoin, this.fog = e.fog, this } } class tk extends oi { constructor(e) { super(), this.isMeshNormalMaterial = !0, this.type = "MeshNormalMaterial", this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = Jl, this.normalScale = new _e(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.wireframe = !1, this.wireframeLinewidth = 1, this.flatShading = !1, this.setValues(e) } copy(e) { return super.copy(e), this.bumpMap = e.bumpMap, this.bumpScale = e.bumpScale, this.normalMap = e.normalMap, this.normalMapType = e.normalMapType, this.normalScale.copy(e.normalScale), this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.flatShading = e.flatShading, this } } class nk extends oi { constructor(e) { super(), this.isMeshLambertMaterial = !0, this.type = "MeshLambertMaterial", this.color = new We(16777215), this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new We(0), this.emissiveIntensity = 1, this.emissiveMap = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = Jl, this.normalScale = new _e(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.specularMap = null, this.alphaMap = null, this.envMap = null, this.combine = sm, this.reflectivity = 1, this.refractionRatio = .98, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.flatShading = !1, this.fog = !0, this.setValues(e) } copy(e) { return super.copy(e), this.color.copy(e.color), this.map = e.map, this.lightMap = e.lightMap, this.lightMapIntensity = e.lightMapIntensity, this.aoMap = e.aoMap, this.aoMapIntensity = e.aoMapIntensity, this.emissive.copy(e.emissive), this.emissiveMap = e.emissiveMap, this.emissiveIntensity = e.emissiveIntensity, this.bumpMap = e.bumpMap, this.bumpScale = e.bumpScale, this.normalMap = e.normalMap, this.normalMapType = e.normalMapType, this.normalScale.copy(e.normalScale), this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this.specularMap = e.specularMap, this.alphaMap = e.alphaMap, this.envMap = e.envMap, this.combine = e.combine, this.reflectivity = e.reflectivity, this.refractionRatio = e.refractionRatio, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.wireframeLinecap = e.wireframeLinecap, this.wireframeLinejoin = e.wireframeLinejoin, this.flatShading = e.flatShading, this.fog = e.fog, this } } class ik extends oi { constructor(e) { super(), this.isMeshMatcapMaterial = !0, this.defines = { MATCAP: "" }, this.type = "MeshMatcapMaterial", this.color = new We(16777215), this.matcap = null, this.map = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = Jl, this.normalScale = new _e(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.alphaMap = null, this.flatShading = !1, this.fog = !0, this.setValues(e) } copy(e) { return super.copy(e), this.defines = { MATCAP: "" }, this.color.copy(e.color), this.matcap = e.matcap, this.map = e.map, this.bumpMap = e.bumpMap, this.bumpScale = e.bumpScale, this.normalMap = e.normalMap, this.normalMapType = e.normalMapType, this.normalScale.copy(e.normalScale), this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this.alphaMap = e.alphaMap, this.flatShading = e.flatShading, this.fog = e.fog, this } } class rk extends ir { constructor(e) { super(), this.isLineDashedMaterial = !0, this.type = "LineDashedMaterial", this.scale = 1, this.dashSize = 3, this.gapSize = 1, this.setValues(e) } copy(e) { return super.copy(e), this.scale = e.scale, this.dashSize = e.dashSize, this.gapSize = e.gapSize, this } } function Es(i, e, t) { return zE(i) ? new i.constructor(i.subarray(e, t !== void 0 ? t : i.length)) : i.slice(e, t) } function Oc(i, e, t) { return !i || !t && i.constructor === e ? i : typeof e.BYTES_PER_ELEMENT == "number" ? new e(i) : Array.prototype.slice.call(i) } function zE(i) { return ArrayBuffer.isView(i) && !(i instanceof DataView) } function sk(i) { function e(r, s) { return i[r] - i[s] } const t = i.length, n = new Array(t); for (let r = 0; r !== t; ++r)n[r] = r; return n.sort(e), n } function SS(i, e, t) { const n = i.length, r = new i.constructor(n); for (let s = 0, o = 0; o !== n; ++s) { const a = t[s] * e; for (let l = 0; l !== e; ++l)r[o++] = i[a + l] } return r } function HE(i, e, t, n) { let r = 1, s = i[0]; for (; s !== void 0 && s[n] === void 0;)s = i[r++]; if (s === void 0) return; let o = s[n]; if (o !== void 0) if (Array.isArray(o)) do o = s[n], o !== void 0 && (e.push(s.time), t.push.apply(t, o)), s = i[r++]; while (s !== void 0); else if (o.toArray !== void 0) do o = s[n], o !== void 0 && (e.push(s.time), o.toArray(t, t.length)), s = i[r++]; while (s !== void 0); else do o = s[n], o !== void 0 && (e.push(s.time), t.push(o)), s = i[r++]; while (s !== void 0) } function d7(i, e, t, n, r = 30) { const s = i.clone(); s.name = e; const o = []; for (let l = 0; l < s.tracks.length; ++l) { const c = s.tracks[l], f = c.getValueSize(), d = [], p = []; for (let m = 0; m < c.times.length; ++m) { const y = c.times[m] * r; if (!(y < t || y >= n)) { d.push(c.times[m]); for (let _ = 0; _ < f; ++_)p.push(c.values[m * f + _]) } } d.length !== 0 && (c.times = Oc(d, c.times.constructor), c.values = Oc(p, c.values.constructor), o.push(c)) } s.tracks = o; let a = 1 / 0; for (let l = 0; l < s.tracks.length; ++l)a > s.tracks[l].times[0] && (a = s.tracks[l].times[0]); for (let l = 0; l < s.tracks.length; ++l)s.tracks[l].shift(-1 * a); return s.resetDuration(), s } function p7(i, e = 0, t = i, n = 30) { n <= 0 && (n = 30); const r = t.tracks.length, s = e / n; for (let o = 0; o < r; ++o) { const a = t.tracks[o], l = a.ValueTypeName; if (l === "bool" || l === "string") continue; const c = i.tracks.find(function (g) { return g.name === a.name && g.ValueTypeName === l }); if (c === void 0) continue; let f = 0; const d = a.getValueSize(); a.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline && (f = d / 3); let p = 0; const m = c.getValueSize(); c.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline && (p = m / 3); const y = a.times.length - 1; let _; if (s <= a.times[0]) { const g = f, A = d - f; _ = Es(a.values, g, A) } else if (s >= a.times[y]) { const g = y * d + f, A = g + d - f; _ = Es(a.values, g, A) } else { const g = a.createInterpolant(), A = f, M = d - f; g.evaluate(s), _ = Es(g.resultBuffer, A, M) } l === "quaternion" && new Ti().fromArray(_).normalize().conjugate().toArray(_); const x = c.times.length; for (let g = 0; g < x; ++g) { const A = g * m + p; if (l === "quaternion") Ti.multiplyQuaternionsFlat(c.values, A, _, 0, c.values, A); else { const M = m - p * 2; for (let S = 0; S < M; ++S)c.values[A + S] -= _[S] } } } return i.blendMode = gE, i } const m7 = { arraySlice: Es, convertArray: Oc, isTypedArray: zE, getKeyframeOrder: sk, sortedArray: SS, flattenJSON: HE, subclip: d7, makeClipAdditive: p7 }; class Lh { constructor(e, t, n, r) { this.parameterPositions = e, this._cachedIndex = 0, this.resultBuffer = r !== void 0 ? r : new t.constructor(n), this.sampleValues = t, this.valueSize = n, this.settings = null, this.DefaultSettings_ = {} } evaluate(e) { const t = this.parameterPositions; let n = this._cachedIndex, r = t[n], s = t[n - 1]; e: { t: { let o; n: { i: if (!(e < r)) { for (let a = n + 2; ;) { if (r === void 0) { if (e < s) break i; return n = t.length, this._cachedIndex = n, this.copySampleValue_(n - 1) } if (n === a) break; if (s = r, r = t[++n], e < r) break t } o = t.length; break n } if (!(e >= s)) { const a = t[1]; e < a && (n = 2, s = a); for (let l = n - 2; ;) { if (s === void 0) return this._cachedIndex = 0, this.copySampleValue_(0); if (n === l) break; if (r = s, s = t[--n - 1], e >= s) break t } o = n, n = 0; break n } break e } for (; n < o;) { const a = n + o >>> 1; e < t[a] ? o = a : n = a + 1 } if (r = t[n], s = t[n - 1], s === void 0) return this._cachedIndex = 0, this.copySampleValue_(0); if (r === void 0) return n = t.length, this._cachedIndex = n, this.copySampleValue_(n - 1) } this._cachedIndex = n, this.intervalChanged_(n, s, r) } return this.interpolate_(n, s, e, r) } getSettings_() { return this.settings || this.DefaultSettings_ } copySampleValue_(e) { const t = this.resultBuffer, n = this.sampleValues, r = this.valueSize, s = e * r; for (let o = 0; o !== r; ++o)t[o] = n[s + o]; return t } interpolate_() { throw new Error("call to abstract method") } intervalChanged_() { } } class ok extends Lh { constructor(e, t, n, r) { super(e, t, n, r), this._weightPrev = -0, this._offsetPrev = -0, this._weightNext = -0, this._offsetNext = -0, this.DefaultSettings_ = { endingStart: Bc, endingEnd: Bc } } intervalChanged_(e, t, n) { const r = this.parameterPositions; let s = e - 2, o = e + 1, a = r[s], l = r[o]; if (a === void 0) switch (this.getSettings_().endingStart) { case Lc: s = e, a = 2 * t - n; break; case Up: s = r.length - 2, a = t + r[s] - r[s + 1]; break; default: s = e, a = n }if (l === void 0) switch (this.getSettings_().endingEnd) { case Lc: o = e, l = 2 * n - t; break; case Up: o = 1, l = n + r[1] - r[0]; break; default: o = e - 1, l = t }const c = (n - t) * .5, f = this.valueSize; this._weightPrev = c / (t - a), this._weightNext = c / (l - n), this._offsetPrev = s * f, this._offsetNext = o * f } interpolate_(e, t, n, r) { const s = this.resultBuffer, o = this.sampleValues, a = this.valueSize, l = e * a, c = l - a, f = this._offsetPrev, d = this._offsetNext, p = this._weightPrev, m = this._weightNext, y = (n - t) / (r - t), _ = y * y, x = _ * y, g = -p * x + 2 * p * _ - p * y, A = (1 + p) * x + (-1.5 - 2 * p) * _ + (-.5 + p) * y + 1, M = (-1 - m) * x + (1.5 + m) * _ + .5 * y, S = m * x - m * _; for (let C = 0; C !== a; ++C)s[C] = g * o[f + C] + A * o[c + C] + M * o[l + C] + S * o[d + C]; return s } } class GE extends Lh { constructor(e, t, n, r) { super(e, t, n, r) } interpolate_(e, t, n, r) { const s = this.resultBuffer, o = this.sampleValues, a = this.valueSize, l = e * a, c = l - a, f = (n - t) / (r - t), d = 1 - f; for (let p = 0; p !== a; ++p)s[p] = o[c + p] * d + o[l + p] * f; return s } } class ak extends Lh { constructor(e, t, n, r) { super(e, t, n, r) } interpolate_(e) { return this.copySampleValue_(e - 1) } } class xo { constructor(e, t, n, r) { if (e === void 0) throw new Error("THREE.KeyframeTrack: track name is undefined"); if (t === void 0 || t.length === 0) throw new Error("THREE.KeyframeTrack: no keyframes in track named " + e); this.name = e, this.times = Oc(t, this.TimeBufferType), this.values = Oc(n, this.ValueBufferType), this.setInterpolation(r || this.DefaultInterpolation) } static toJSON(e) { const t = e.constructor; let n; if (t.toJSON !== this.toJSON) n = t.toJSON(e); else { n = { name: e.name, times: Oc(e.times, Array), values: Oc(e.values, Array) }; const r = e.getInterpolation(); r !== e.DefaultInterpolation && (n.interpolation = r) } return n.type = e.ValueTypeName, n } InterpolantFactoryMethodDiscrete(e) { return new ak(this.times, this.values, this.getValueSize(), e) } InterpolantFactoryMethodLinear(e) { return new GE(this.times, this.values, this.getValueSize(), e) } InterpolantFactoryMethodSmooth(e) { return new ok(this.times, this.values, this.getValueSize(), e) } setInterpolation(e) { let t; switch (e) { case yh: t = this.InterpolantFactoryMethodDiscrete; break; case lu: t = this.InterpolantFactoryMethodLinear; break; case cy: t = this.InterpolantFactoryMethodSmooth; break }if (t === void 0) { const n = "unsupported interpolation for " + this.ValueTypeName + " keyframe track named " + this.name; if (this.createInterpolant === void 0) if (e !== this.DefaultInterpolation) this.setInterpolation(this.DefaultInterpolation); else throw new Error(n); return console.warn("THREE.KeyframeTrack:", n), this } return this.createInterpolant = t, this } getInterpolation() { switch (this.createInterpolant) { case this.InterpolantFactoryMethodDiscrete: return yh; case this.InterpolantFactoryMethodLinear: return lu; case this.InterpolantFactoryMethodSmooth: return cy } } getValueSize() { return this.values.length / this.times.length } shift(e) { if (e !== 0) { const t = this.times; for (let n = 0, r = t.length; n !== r; ++n)t[n] += e } return this } scale(e) { if (e !== 1) { const t = this.times; for (let n = 0, r = t.length; n !== r; ++n)t[n] *= e } return this } trim(e, t) { const n = this.times, r = n.length; let s = 0, o = r - 1; for (; s !== r && n[s] < e;)++s; for (; o !== -1 && n[o] > t;)--o; if (++o, s !== 0 || o !== r) { s >= o && (o = Math.max(o, 1), s = o - 1); const a = this.getValueSize(); this.times = Es(n, s, o), this.values = Es(this.values, s * a, o * a) } return this } validate() { let e = !0; const t = this.getValueSize(); t - Math.floor(t) !== 0 && (console.error("THREE.KeyframeTrack: Invalid value size in track.", this), e = !1); const n = this.times, r = this.values, s = n.length; s === 0 && (console.error("THREE.KeyframeTrack: Track is empty.", this), e = !1); let o = null; for (let a = 0; a !== s; a++) { const l = n[a]; if (typeof l == "number" && isNaN(l)) { console.error("THREE.KeyframeTrack: Time is not a valid number.", this, a, l), e = !1; break } if (o !== null && o > l) { console.error("THREE.KeyframeTrack: Out of order keys.", this, a, l, o), e = !1; break } o = l } if (r !== void 0 && zE(r)) for (let a = 0, l = r.length; a !== l; ++a) { const c = r[a]; if (isNaN(c)) { console.error("THREE.KeyframeTrack: Value is not a valid number.", this, a, c), e = !1; break } } return e } optimize() { const e = Es(this.times), t = Es(this.values), n = this.getValueSize(), r = this.getInterpolation() === cy, s = e.length - 1; let o = 1; for (let a = 1; a < s; ++a) { let l = !1; const c = e[a], f = e[a + 1]; if (c !== f && (a !== 1 || c !== e[0])) if (r) l = !0; else { const d = a * n, p = d - n, m = d + n; for (let y = 0; y !== n; ++y) { const _ = t[d + y]; if (_ !== t[p + y] || _ !== t[m + y]) { l = !0; break } } } if (l) { if (a !== o) { e[o] = e[a]; const d = a * n, p = o * n; for (let m = 0; m !== n; ++m)t[p + m] = t[d + m] } ++o } } if (s > 0) { e[o] = e[s]; for (let a = s * n, l = o * n, c = 0; c !== n; ++c)t[l + c] = t[a + c]; ++o } return o !== e.length ? (this.times = Es(e, 0, o), this.values = Es(t, 0, o * n)) : (this.times = e, this.values = t), this } clone() { const e = Es(this.times, 0), t = Es(this.values, 0), n = this.constructor, r = new n(this.name, e, t); return r.createInterpolant = this.createInterpolant, r } } xo.prototype.TimeBufferType = Float32Array; xo.prototype.ValueBufferType = Float32Array; xo.prototype.DefaultInterpolation = lu; class mu extends xo { } mu.prototype.ValueTypeName = "bool"; mu.prototype.ValueBufferType = Array; mu.prototype.DefaultInterpolation = yh; mu.prototype.InterpolantFactoryMethodLinear = void 0; mu.prototype.InterpolantFactoryMethodSmooth = void 0; class VE extends xo { } VE.prototype.ValueTypeName = "color"; class Ah extends xo { } Ah.prototype.ValueTypeName = "number"; class lk extends Lh { constructor(e, t, n, r) { super(e, t, n, r) } interpolate_(e, t, n, r) { const s = this.resultBuffer, o = this.sampleValues, a = this.valueSize, l = (n - t) / (r - t); let c = e * a; for (let f = c + a; c !== f; c += 4)Ti.slerpFlat(s, 0, o, c - a, o, c, l); return s } } class Hl extends xo { InterpolantFactoryMethodLinear(e) { return new lk(this.times, this.values, this.getValueSize(), e) } } Hl.prototype.ValueTypeName = "quaternion"; Hl.prototype.DefaultInterpolation = lu; Hl.prototype.InterpolantFactoryMethodSmooth = void 0; class gu extends xo { } gu.prototype.ValueTypeName = "string"; gu.prototype.ValueBufferType = Array; gu.prototype.DefaultInterpolation = yh; gu.prototype.InterpolantFactoryMethodLinear = void 0; gu.prototype.InterpolantFactoryMethodSmooth = void 0; class Mh extends xo { } Mh.prototype.ValueTypeName = "vector"; class wh { constructor(e, t = -1, n, r = Nv) { this.name = e, this.tracks = n, this.duration = t, this.blendMode = r, this.uuid = ss(), this.duration < 0 && this.resetDuration() } static parse(e) { const t = [], n = e.tracks, r = 1 / (e.fps || 1); for (let o = 0, a = n.length; o !== a; ++o)t.push(y7(n[o]).scale(r)); const s = new this(e.name, e.duration, t, e.blendMode); return s.uuid = e.uuid, s } static toJSON(e) { const t = [], n = e.tracks, r = { name: e.name, duration: e.duration, tracks: t, uuid: e.uuid, blendMode: e.blendMode }; for (let s = 0, o = n.length; s !== o; ++s)t.push(xo.toJSON(n[s])); return r } static CreateFromMorphTargetSequence(e, t, n, r) { const s = t.length, o = []; for (let a = 0; a < s; a++) { let l = [], c = []; l.push((a + s - 1) % s, a, (a + 1) % s), c.push(0, 1, 0); const f = sk(l); l = SS(l, 1, f), c = SS(c, 1, f), !r && l[0] === 0 && (l.push(s), c.push(c[0])), o.push(new Ah(".morphTargetInfluences[" + t[a].name + "]", l, c).scale(1 / n)) } return new this(e, -1, o) } static findByName(e, t) { let n = e; if (!Array.isArray(e)) { const r = e; n = r.geometry && r.geometry.animations || r.animations } for (let r = 0; r < n.length; r++)if (n[r].name === t) return n[r]; return null } static CreateClipsFromMorphTargetSequences(e, t, n) { const r = {}, s = /^([\w-]*?)([\d]+)$/; for (let a = 0, l = e.length; a < l; a++) { const c = e[a], f = c.name.match(s); if (f && f.length > 1) { const d = f[1]; let p = r[d]; p || (r[d] = p = []), p.push(c) } } const o = []; for (const a in r) o.push(this.CreateFromMorphTargetSequence(a, r[a], t, n)); return o } static parseAnimation(e, t) { if (!e) return console.error("THREE.AnimationClip: No animation in JSONLoader data."), null; const n = function (d, p, m, y, _) { if (m.length !== 0) { const x = [], g = []; HE(m, x, g, y), x.length !== 0 && _.push(new d(p, x, g)) } }, r = [], s = e.name || "default", o = e.fps || 30, a = e.blendMode; let l = e.length || -1; const c = e.hierarchy || []; for (let d = 0; d < c.length; d++) { const p = c[d].keys; if (!(!p || p.length === 0)) if (p[0].morphTargets) { const m = {}; let y; for (y = 0; y < p.length; y++)if (p[y].morphTargets) for (let _ = 0; _ < p[y].morphTargets.length; _++)m[p[y].morphTargets[_]] = -1; for (const _ in m) { const x = [], g = []; for (let A = 0; A !== p[y].morphTargets.length; ++A) { const M = p[y]; x.push(M.time), g.push(M.morphTarget === _ ? 1 : 0) } r.push(new Ah(".morphTargetInfluence[" + _ + "]", x, g)) } l = m.length * o } else { const m = ".bones[" + t[d].name + "]"; n(Mh, m + ".position", p, "pos", r), n(Hl, m + ".quaternion", p, "rot", r), n(Mh, m + ".scale", p, "scl", r) } } return r.length === 0 ? null : new this(s, l, r, a) } resetDuration() { const e = this.tracks; let t = 0; for (let n = 0, r = e.length; n !== r; ++n) { const s = this.tracks[n]; t = Math.max(t, s.times[s.times.length - 1]) } return this.duration = t, this } trim() { for (let e = 0; e < this.tracks.length; e++)this.tracks[e].trim(0, this.duration); return this } validate() { let e = !0; for (let t = 0; t < this.tracks.length; t++)e = e && this.tracks[t].validate(); return e } optimize() { for (let e = 0; e < this.tracks.length; e++)this.tracks[e].optimize(); return this } clone() { const e = []; for (let t = 0; t < this.tracks.length; t++)e.push(this.tracks[t].clone()); return new this.constructor(this.name, this.duration, e, this.blendMode) } toJSON() { return this.constructor.toJSON(this) } } function g7(i) { switch (i.toLowerCase()) { case "scalar": case "double": case "float": case "number": case "integer": return Ah; case "vector": case "vector2": case "vector3": case "vector4": return Mh; case "color": return VE; case "quaternion": return Hl; case "bool": case "boolean": return mu; case "string": return gu }throw new Error("THREE.KeyframeTrack: Unsupported typeName: " + i) } function y7(i) { if (i.type === void 0) throw new Error("THREE.KeyframeTrack: track type undefined, can not parse"); const e = g7(i.type); if (i.times === void 0) { const t = [], n = []; HE(i.keys, t, n, "value"), i.times = t, i.values = n } return e.parse !== void 0 ? e.parse(i) : new e(i.name, i.times, i.values, i.interpolation) } const uu = { enabled: !1, files: {}, add: function (i, e) { this.enabled !== !1 && (this.files[i] = e) }, get: function (i) { if (this.enabled !== !1) return this.files[i] }, remove: function (i) { delete this.files[i] }, clear: function () { this.files = {} } }; class WE { constructor(e, t, n) { const r = this; let s = !1, o = 0, a = 0, l; const c = []; this.onStart = void 0, this.onLoad = e, this.onProgress = t, this.onError = n, this.itemStart = function (f) { a++, s === !1 && r.onStart !== void 0 && r.onStart(f, o, a), s = !0 }, this.itemEnd = function (f) { o++, r.onProgress !== void 0 && r.onProgress(f, o, a), o === a && (s = !1, r.onLoad !== void 0 && r.onLoad()) }, this.itemError = function (f) { r.onError !== void 0 && r.onError(f) }, this.resolveURL = function (f) { return l ? l(f) : f }, this.setURLModifier = function (f) { return l = f, this }, this.addHandler = function (f, d) { return c.push(f, d), this }, this.removeHandler = function (f) { const d = c.indexOf(f); return d !== -1 && c.splice(d, 2), this }, this.getHandler = function (f) { for (let d = 0, p = c.length; d < p; d += 2) { const m = c[d], y = c[d + 1]; if (m.global && (m.lastIndex = 0), m.test(f)) return y } return null } } } const ck = new WE; class rr { constructor(e) { this.manager = e !== void 0 ? e : ck, this.crossOrigin = "anonymous", this.withCredentials = !1, this.path = "", this.resourcePath = "", this.requestHeader = {} } load() { } loadAsync(e, t) { const n = this; return new Promise(function (r, s) { n.load(e, r, t, s) }) } parse() { } setCrossOrigin(e) { return this.crossOrigin = e, this } setWithCredentials(e) { return this.withCredentials = e, this } setPath(e) { return this.path = e, this } setResourcePath(e) { return this.resourcePath = e, this } setRequestHeader(e) { return this.requestHeader = e, this } } rr.DEFAULT_MATERIAL_NAME = "__DEFAULT"; const ca = {}; class v7 extends Error { constructor(e, t) { super(e), this.response = t } } class ls extends rr { constructor(e) { super(e) } load(e, t, n, r) { e === void 0 && (e = ""), this.path !== void 0 && (e = this.path + e), e = this.manager.resolveURL(e); const s = uu.get(e); if (s !== void 0) return this.manager.itemStart(e), setTimeout(() => { t && t(s), this.manager.itemEnd(e) }, 0), s; if (ca[e] !== void 0) { ca[e].push({ onLoad: t, onProgress: n, onError: r }); return } ca[e] = [], ca[e].push({ onLoad: t, onProgress: n, onError: r }); const o = new Request(e, { headers: new Headers(this.requestHeader), credentials: this.withCredentials ? "include" : "same-origin" }), a = this.mimeType, l = this.responseType; fetch(o).then(c => { if (c.status === 200 || c.status === 0) { if (c.status === 0 && console.warn("THREE.FileLoader: HTTP Status 0 received."), typeof ReadableStream > "u" || c.body === void 0 || c.body.getReader === void 0) return c; const f = ca[e], d = c.body.getReader(), p = c.headers.get("Content-Length") || c.headers.get("X-File-Size"), m = p ? parseInt(p) : 0, y = m !== 0; let _ = 0; const x = new ReadableStream({ start(g) { A(); function A() { d.read().then(({ done: M, value: S }) => { if (M) g.close(); else { _ += S.byteLength; const C = new ProgressEvent("progress", { lengthComputable: y, loaded: _, total: m }); for (let T = 0, R = f.length; T < R; T++) { const B = f[T]; B.onProgress && B.onProgress(C) } g.enqueue(S), A() } }) } } }); return new Response(x) } else throw new v7(`fetch for "${c.url}" responded with ${c.status}: ${c.statusText}`, c) }).then(c => { switch (l) { case "arraybuffer": return c.arrayBuffer(); case "blob": return c.blob(); case "document": return c.text().then(f => new DOMParser().parseFromString(f, a)); case "json": return c.json(); default: if (a === void 0) return c.text(); { const d = /charset="?([^;"\s]*)"?/i.exec(a), p = d && d[1] ? d[1].toLowerCase() : void 0, m = new TextDecoder(p); return c.arrayBuffer().then(y => m.decode(y)) } } }).then(c => { uu.add(e, c); const f = ca[e]; delete ca[e]; for (let d = 0, p = f.length; d < p; d++) { const m = f[d]; m.onLoad && m.onLoad(c) } }).catch(c => { const f = ca[e]; if (f === void 0) throw this.manager.itemError(e), c; delete ca[e]; for (let d = 0, p = f.length; d < p; d++) { const m = f[d]; m.onError && m.onError(c) } this.manager.itemError(e) }).finally(() => { this.manager.itemEnd(e) }), this.manager.itemStart(e) } setResponseType(e) { return this.responseType = e, this } setMimeType(e) { return this.mimeType = e, this } } class _7 extends rr { constructor(e) { super(e) } load(e, t, n, r) { const s = this, o = new ls(this.manager); o.setPath(this.path), o.setRequestHeader(this.requestHeader), o.setWithCredentials(this.withCredentials), o.load(e, function (a) { try { t(s.parse(JSON.parse(a))) } catch (l) { r ? r(l) : console.error(l), s.manager.itemError(e) } }, n, r) } parse(e) { const t = []; for (let n = 0; n < e.length; n++) { const r = wh.parse(e[n]); t.push(r) } return t } } class x7 extends rr { constructor(e) { super(e) } load(e, t, n, r) { const s = this, o = [], a = new Jv, l = new ls(this.manager); l.setPath(this.path), l.setResponseType("arraybuffer"), l.setRequestHeader(this.requestHeader), l.setWithCredentials(s.withCredentials); let c = 0; function f(d) { l.load(e[d], function (p) { const m = s.parse(p, !0); o[d] = { width: m.width, height: m.height, format: m.format, mipmaps: m.mipmaps }, c += 1, c === 6 && (m.mipmapCount === 1 && (a.minFilter = Pn), a.image = o, a.format = m.format, a.needsUpdate = !0, t && t(a)) }, n, r) } if (Array.isArray(e)) for (let d = 0, p = e.length; d < p; ++d)f(d); else l.load(e, function (d) { const p = s.parse(d, !0); if (p.isCubemap) { const m = p.mipmaps.length / p.mipmapCount; for (let y = 0; y < m; y++) { o[y] = { mipmaps: [] }; for (let _ = 0; _ < p.mipmapCount; _++)o[y].mipmaps.push(p.mipmaps[y * p.mipmapCount + _]), o[y].format = p.format, o[y].width = p.width, o[y].height = p.height } a.image = o } else a.image.width = p.width, a.image.height = p.height, a.mipmaps = p.mipmaps; p.mipmapCount === 1 && (a.minFilter = Pn), a.format = p.format, a.needsUpdate = !0, t && t(a) }, n, r); return a } } class Yp extends rr { constructor(e) { super(e) } load(e, t, n, r) { this.path !== void 0 && (e = this.path + e), e = this.manager.resolveURL(e); const s = this, o = uu.get(e); if (o !== void 0) return s.manager.itemStart(e), setTimeout(function () { t && t(o), s.manager.itemEnd(e) }, 0), o; const a = Gp("img"); function l() { f(), uu.add(e, this), t && t(this), s.manager.itemEnd(e) } function c(d) { f(), r && r(d), s.manager.itemError(e), s.manager.itemEnd(e) } function f() { a.removeEventListener("load", l, !1), a.removeEventListener("error", c, !1) } return a.addEventListener("load", l, !1), a.addEventListener("error", c, !1), e.slice(0, 5) !== "data:" && this.crossOrigin !== void 0 && (a.crossOrigin = this.crossOrigin), s.manager.itemStart(e), a.src = e, a } } class A7 extends rr { constructor(e) { super(e) } load(e, t, n, r) { const s = new lm; s.colorSpace = bt; const o = new Yp(this.manager); o.setCrossOrigin(this.crossOrigin), o.setPath(this.path); let a = 0; function l(c) { o.load(e[c], function (f) { s.images[c] = f, a++, a === 6 && (s.needsUpdate = !0, t && t(s)) }, void 0, r) } for (let c = 0; c < e.length; ++c)l(c); return s } } class M7 extends rr { constructor(e) { super(e) } load(e, t, n, r) { const s = this, o = new Kf, a = new ls(this.manager); return a.setResponseType("arraybuffer"), a.setRequestHeader(this.requestHeader), a.setPath(this.path), a.setWithCredentials(s.withCredentials), a.load(e, function (l) { let c; try { c = s.parse(l) } catch (f) { if (r !== void 0) r(f); else { console.error(f); return } } if (!c) return r(); c.image !== void 0 ? o.image = c.image : c.data !== void 0 && (o.image.width = c.width, o.image.height = c.height, o.image.data = c.data), o.wrapS = c.wrapS !== void 0 ? c.wrapS : Di, o.wrapT = c.wrapT !== void 0 ? c.wrapT : Di, o.magFilter = c.magFilter !== void 0 ? c.magFilter : Pn, o.minFilter = c.minFilter !== void 0 ? c.minFilter : Pn, o.anisotropy = c.anisotropy !== void 0 ? c.anisotropy : 1, c.colorSpace !== void 0 ? o.colorSpace = c.colorSpace : c.encoding !== void 0 && (o.encoding = c.encoding), c.flipY !== void 0 && (o.flipY = c.flipY), c.format !== void 0 && (o.format = c.format), c.type !== void 0 && (o.type = c.type), c.mipmaps !== void 0 && (o.mipmaps = c.mipmaps, o.minFilter = Yo), c.mipmapCount === 1 && (o.minFilter = Pn), c.generateMipmaps !== void 0 && (o.generateMipmaps = c.generateMipmaps), o.needsUpdate = !0, t && t(o, c) }, n, r), o } } class uk extends rr { constructor(e) { super(e) } load(e, t, n, r) { const s = new wn, o = new Yp(this.manager); return o.setCrossOrigin(this.crossOrigin), o.setPath(this.path), o.load(e, function (a) { s.image = a, s.needsUpdate = !0, t !== void 0 && t(s) }, n, r), s } } class jl extends qt { constructor(e, t = 1) { super(), this.isLight = !0, this.type = "Light", this.color = new We(e), this.intensity = t } dispose() { } copy(e, t) { return super.copy(e, t), this.color.copy(e.color), this.intensity = e.intensity, this } toJSON(e) { const t = super.toJSON(e); return t.object.color = this.color.getHex(), t.object.intensity = this.intensity, this.groundColor !== void 0 && (t.object.groundColor = this.groundColor.getHex()), this.distance !== void 0 && (t.object.distance = this.distance), this.angle !== void 0 && (t.object.angle = this.angle), this.decay !== void 0 && (t.object.decay = this.decay), this.penumbra !== void 0 && (t.object.penumbra = this.penumbra), this.shadow !== void 0 && (t.object.shadow = this.shadow.toJSON()), t } } class fk extends jl { constructor(e, t, n) { super(e, n), this.isHemisphereLight = !0, this.type = "HemisphereLight", this.position.copy(qt.DEFAULT_UP), this.updateMatrix(), this.groundColor = new We(t) } copy(e, t) { return super.copy(e, t), this.groundColor.copy(e.groundColor), this } } const eM = new yt, rI = new k, sI = new k; class XE { constructor(e) { this.camera = e, this.bias = 0, this.normalBias = 0, this.radius = 1, this.blurSamples = 8, this.mapSize = new _e(512, 512), this.map = null, this.mapPass = null, this.matrix = new yt, this.autoUpdate = !0, this.needsUpdate = !1, this._frustum = new zv, this._frameExtents = new _e(1, 1), this._viewportCount = 1, this._viewports = [new on(0, 0, 1, 1)] } getViewportCount() { return this._viewportCount } getFrustum() { return this._frustum } updateMatrices(e) { const t = this.camera, n = this.matrix; rI.setFromMatrixPosition(e.matrixWorld), t.position.copy(rI), sI.setFromMatrixPosition(e.target.matrixWorld), t.lookAt(sI), t.updateMatrixWorld(), eM.multiplyMatrices(t.projectionMatrix, t.matrixWorldInverse), this._frustum.setFromProjectionMatrix(eM), n.set(.5, 0, 0, .5, 0, .5, 0, .5, 0, 0, .5, .5, 0, 0, 0, 1), n.multiply(eM) } getViewport(e) { return this._viewports[e] } getFrameExtents() { return this._frameExtents } dispose() { this.map && this.map.dispose(), this.mapPass && this.mapPass.dispose() } copy(e) { return this.camera = e.camera.clone(), this.bias = e.bias, this.radius = e.radius, this.mapSize.copy(e.mapSize), this } clone() { return new this.constructor().copy(this) } toJSON() { const e = {}; return this.bias !== 0 && (e.bias = this.bias), this.normalBias !== 0 && (e.normalBias = this.normalBias), this.radius !== 1 && (e.radius = this.radius), (this.mapSize.x !== 512 || this.mapSize.y !== 512) && (e.mapSize = this.mapSize.toArray()), e.camera = this.camera.toJSON(!1).object, delete e.camera.matrix, e } } class w7 extends XE { constructor() { super(new Vn(50, 1, .5, 500)), this.isSpotLightShadow = !0, this.focus = 1 } updateMatrices(e) { const t = this.camera, n = vh * 2 * e.angle * this.focus, r = this.mapSize.width / this.mapSize.height, s = e.distance || t.far; (n !== t.fov || r !== t.aspect || s !== t.far) && (t.fov = n, t.aspect = r, t.far = s, t.updateProjectionMatrix()), super.updateMatrices(e) } copy(e) { return super.copy(e), this.focus = e.focus, this } } class JE extends jl { constructor(e, t, n = 0, r = Math.PI / 3, s = 0, o = 2) { super(e, t), this.isSpotLight = !0, this.type = "SpotLight", this.position.copy(qt.DEFAULT_UP), this.updateMatrix(), this.target = new qt, this.distance = n, this.angle = r, this.penumbra = s, this.decay = o, this.map = null, this.shadow = new w7 } get power() { return this.intensity * Math.PI } set power(e) { this.intensity = e / Math.PI } dispose() { this.shadow.dispose() } copy(e, t) { return super.copy(e, t), this.distance = e.distance, this.angle = e.angle, this.penumbra = e.penumbra, this.decay = e.decay, this.target = e.target.clone(), this.shadow = e.shadow.clone(), this } } const oI = new yt, xd = new k, tM = new k; class S7 extends XE { constructor() { super(new Vn(90, 1, .5, 500)), this.isPointLightShadow = !0, this._frameExtents = new _e(4, 2), this._viewportCount = 6, this._viewports = [new on(2, 1, 1, 1), new on(0, 1, 1, 1), new on(3, 1, 1, 1), new on(1, 1, 1, 1), new on(3, 0, 1, 1), new on(1, 0, 1, 1)], this._cubeDirections = [new k(1, 0, 0), new k(-1, 0, 0), new k(0, 0, 1), new k(0, 0, -1), new k(0, 1, 0), new k(0, -1, 0)], this._cubeUps = [new k(0, 1, 0), new k(0, 1, 0), new k(0, 1, 0), new k(0, 1, 0), new k(0, 0, 1), new k(0, 0, -1)] } updateMatrices(e, t = 0) { const n = this.camera, r = this.matrix, s = e.distance || n.far; s !== n.far && (n.far = s, n.updateProjectionMatrix()), xd.setFromMatrixPosition(e.matrixWorld), n.position.copy(xd), tM.copy(n.position), tM.add(this._cubeDirections[t]), n.up.copy(this._cubeUps[t]), n.lookAt(tM), n.updateMatrixWorld(), r.makeTranslation(-xd.x, -xd.y, -xd.z), oI.multiplyMatrices(n.projectionMatrix, n.matrixWorldInverse), this._frustum.setFromProjectionMatrix(oI) } } class YE extends jl { constructor(e, t, n = 0, r = 2) { super(e, t), this.isPointLight = !0, this.type = "PointLight", this.distance = n, this.decay = r, this.shadow = new S7 } get power() { return this.intensity * 4 * Math.PI } set power(e) { this.intensity = e / (4 * Math.PI) } dispose() { this.shadow.dispose() } copy(e, t) { return super.copy(e, t), this.distance = e.distance, this.decay = e.decay, this.shadow = e.shadow.clone(), this } } class E7 extends XE { constructor() { super(new Ca(-5, 5, 5, -5, .5, 500)), this.isDirectionalLightShadow = !0 } } class jE extends jl { constructor(e, t) { super(e, t), this.isDirectionalLight = !0, this.type = "DirectionalLight", this.position.copy(qt.DEFAULT_UP), this.updateMatrix(), this.target = new qt, this.shadow = new E7 } dispose() { this.shadow.dispose() } copy(e) { return super.copy(e), this.target = e.target.clone(), this.shadow = e.shadow.clone(), this } } class hk extends jl { constructor(e, t) { super(e, t), this.isAmbientLight = !0, this.type = "AmbientLight" } } class dk extends jl { constructor(e, t, n = 10, r = 10) { super(e, t), this.isRectAreaLight = !0, this.type = "RectAreaLight", this.width = n, this.height = r } get power() { return this.intensity * this.width * this.height * Math.PI } set power(e) { this.intensity = e / (this.width * this.height * Math.PI) } copy(e) { return super.copy(e), this.width = e.width, this.height = e.height, this } toJSON(e) { const t = super.toJSON(e); return t.object.width = this.width, t.object.height = this.height, t } } class pk { constructor() { this.isSphericalHarmonics3 = !0, this.coefficients = []; for (let e = 0; e < 9; e++)this.coefficients.push(new k) } set(e) { for (let t = 0; t < 9; t++)this.coefficients[t].copy(e[t]); return this } zero() { for (let e = 0; e < 9; e++)this.coefficients[e].set(0, 0, 0); return this } getAt(e, t) { const n = e.x, r = e.y, s = e.z, o = this.coefficients; return t.copy(o[0]).multiplyScalar(.282095), t.addScaledVector(o[1], .488603 * r), t.addScaledVector(o[2], .488603 * s), t.addScaledVector(o[3], .488603 * n), t.addScaledVector(o[4], 1.092548 * (n * r)), t.addScaledVector(o[5], 1.092548 * (r * s)), t.addScaledVector(o[6], .315392 * (3 * s * s - 1)), t.addScaledVector(o[7], 1.092548 * (n * s)), t.addScaledVector(o[8], .546274 * (n * n - r * r)), t } getIrradianceAt(e, t) { const n = e.x, r = e.y, s = e.z, o = this.coefficients; return t.copy(o[0]).multiplyScalar(.886227), t.addScaledVector(o[1], 2 * .511664 * r), t.addScaledVector(o[2], 2 * .511664 * s), t.addScaledVector(o[3], 2 * .511664 * n), t.addScaledVector(o[4], 2 * .429043 * n * r), t.addScaledVector(o[5], 2 * .429043 * r * s), t.addScaledVector(o[6], .743125 * s * s - .247708), t.addScaledVector(o[7], 2 * .429043 * n * s), t.addScaledVector(o[8], .429043 * (n * n - r * r)), t } add(e) { for (let t = 0; t < 9; t++)this.coefficients[t].add(e.coefficients[t]); return this } addScaledSH(e, t) { for (let n = 0; n < 9; n++)this.coefficients[n].addScaledVector(e.coefficients[n], t); return this } scale(e) { for (let t = 0; t < 9; t++)this.coefficients[t].multiplyScalar(e); return this } lerp(e, t) { for (let n = 0; n < 9; n++)this.coefficients[n].lerp(e.coefficients[n], t); return this } equals(e) { for (let t = 0; t < 9; t++)if (!this.coefficients[t].equals(e.coefficients[t])) return !1; return !0 } copy(e) { return this.set(e.coefficients) } clone() { return new this.constructor().copy(this) } fromArray(e, t = 0) { const n = this.coefficients; for (let r = 0; r < 9; r++)n[r].fromArray(e, t + r * 3); return this } toArray(e = [], t = 0) { const n = this.coefficients; for (let r = 0; r < 9; r++)n[r].toArray(e, t + r * 3); return e } static getBasisAt(e, t) { const n = e.x, r = e.y, s = e.z; t[0] = .282095, t[1] = .488603 * r, t[2] = .488603 * s, t[3] = .488603 * n, t[4] = 1.092548 * n * r, t[5] = 1.092548 * r * s, t[6] = .315392 * (3 * s * s - 1), t[7] = 1.092548 * n * s, t[8] = .546274 * (n * n - r * r) } } class l_ extends jl { constructor(e = new pk, t = 1) { super(void 0, t), this.isLightProbe = !0, this.sh = e } copy(e) { return super.copy(e), this.sh.copy(e.sh), this } fromJSON(e) { return this.intensity = e.intensity, this.sh.fromArray(e.sh), this } toJSON(e) { const t = super.toJSON(e); return t.object.sh = this.sh.toArray(), t } } class c_ extends rr { constructor(e) { super(e), this.textures = {} } load(e, t, n, r) { const s = this, o = new ls(s.manager); o.setPath(s.path), o.setRequestHeader(s.requestHeader), o.setWithCredentials(s.withCredentials), o.load(e, function (a) { try { t(s.parse(JSON.parse(a))) } catch (l) { r ? r(l) : console.error(l), s.manager.itemError(e) } }, n, r) } parse(e) { const t = this.textures; function n(s) { return t[s] === void 0 && console.warn("THREE.MaterialLoader: Undefined texture", s), t[s] } const r = c_.createMaterialFromType(e.type); if (e.uuid !== void 0 && (r.uuid = e.uuid), e.name !== void 0 && (r.name = e.name), e.color !== void 0 && r.color !== void 0 && r.color.setHex(e.color), e.roughness !== void 0 && (r.roughness = e.roughness), e.metalness !== void 0 && (r.metalness = e.metalness), e.sheen !== void 0 && (r.sheen = e.sheen), e.sheenColor !== void 0 && (r.sheenColor = new We().setHex(e.sheenColor)), e.sheenRoughness !== void 0 && (r.sheenRoughness = e.sheenRoughness), e.emissive !== void 0 && r.emissive !== void 0 && r.emissive.setHex(e.emissive), e.specular !== void 0 && r.specular !== void 0 && r.specular.setHex(e.specular), e.specularIntensity !== void 0 && (r.specularIntensity = e.specularIntensity), e.specularColor !== void 0 && r.specularColor !== void 0 && r.specularColor.setHex(e.specularColor), e.shininess !== void 0 && (r.shininess = e.shininess), e.clearcoat !== void 0 && (r.clearcoat = e.clearcoat), e.clearcoatRoughness !== void 0 && (r.clearcoatRoughness = e.clearcoatRoughness), e.iridescence !== void 0 && (r.iridescence = e.iridescence), e.iridescenceIOR !== void 0 && (r.iridescenceIOR = e.iridescenceIOR), e.iridescenceThicknessRange !== void 0 && (r.iridescenceThicknessRange = e.iridescenceThicknessRange), e.transmission !== void 0 && (r.transmission = e.transmission), e.thickness !== void 0 && (r.thickness = e.thickness), e.attenuationDistance !== void 0 && (r.attenuationDistance = e.attenuationDistance), e.attenuationColor !== void 0 && r.attenuationColor !== void 0 && r.attenuationColor.setHex(e.attenuationColor), e.anisotropy !== void 0 && (r.anisotropy = e.anisotropy), e.anisotropyRotation !== void 0 && (r.anisotropyRotation = e.anisotropyRotation), e.fog !== void 0 && (r.fog = e.fog), e.flatShading !== void 0 && (r.flatShading = e.flatShading), e.blending !== void 0 && (r.blending = e.blending), e.combine !== void 0 && (r.combine = e.combine), e.side !== void 0 && (r.side = e.side), e.shadowSide !== void 0 && (r.shadowSide = e.shadowSide), e.opacity !== void 0 && (r.opacity = e.opacity), e.transparent !== void 0 && (r.transparent = e.transparent), e.alphaTest !== void 0 && (r.alphaTest = e.alphaTest), e.alphaHash !== void 0 && (r.alphaHash = e.alphaHash), e.depthTest !== void 0 && (r.depthTest = e.depthTest), e.depthWrite !== void 0 && (r.depthWrite = e.depthWrite), e.colorWrite !== void 0 && (r.colorWrite = e.colorWrite), e.stencilWrite !== void 0 && (r.stencilWrite = e.stencilWrite), e.stencilWriteMask !== void 0 && (r.stencilWriteMask = e.stencilWriteMask), e.stencilFunc !== void 0 && (r.stencilFunc = e.stencilFunc), e.stencilRef !== void 0 && (r.stencilRef = e.stencilRef), e.stencilFuncMask !== void 0 && (r.stencilFuncMask = e.stencilFuncMask), e.stencilFail !== void 0 && (r.stencilFail = e.stencilFail), e.stencilZFail !== void 0 && (r.stencilZFail = e.stencilZFail), e.stencilZPass !== void 0 && (r.stencilZPass = e.stencilZPass), e.wireframe !== void 0 && (r.wireframe = e.wireframe), e.wireframeLinewidth !== void 0 && (r.wireframeLinewidth = e.wireframeLinewidth), e.wireframeLinecap !== void 0 && (r.wireframeLinecap = e.wireframeLinecap), e.wireframeLinejoin !== void 0 && (r.wireframeLinejoin = e.wireframeLinejoin), e.rotation !== void 0 && (r.rotation = e.rotation), e.linewidth !== 1 && (r.linewidth = e.linewidth), e.dashSize !== void 0 && (r.dashSize = e.dashSize), e.gapSize !== void 0 && (r.gapSize = e.gapSize), e.scale !== void 0 && (r.scale = e.scale), e.polygonOffset !== void 0 && (r.polygonOffset = e.polygonOffset), e.polygonOffsetFactor !== void 0 && (r.polygonOffsetFactor = e.polygonOffsetFactor), e.polygonOffsetUnits !== void 0 && (r.polygonOffsetUnits = e.polygonOffsetUnits), e.dithering !== void 0 && (r.dithering = e.dithering), e.alphaToCoverage !== void 0 && (r.alphaToCoverage = e.alphaToCoverage), e.premultipliedAlpha !== void 0 && (r.premultipliedAlpha = e.premultipliedAlpha), e.forceSinglePass !== void 0 && (r.forceSinglePass = e.forceSinglePass), e.visible !== void 0 && (r.visible = e.visible), e.toneMapped !== void 0 && (r.toneMapped = e.toneMapped), e.userData !== void 0 && (r.userData = e.userData), e.vertexColors !== void 0 && (typeof e.vertexColors == "number" ? r.vertexColors = e.vertexColors > 0 : r.vertexColors = e.vertexColors), e.uniforms !== void 0) for (const s in e.uniforms) { const o = e.uniforms[s]; switch (r.uniforms[s] = {}, o.type) { case "t": r.uniforms[s].value = n(o.value); break; case "c": r.uniforms[s].value = new We().setHex(o.value); break; case "v2": r.uniforms[s].value = new _e().fromArray(o.value); break; case "v3": r.uniforms[s].value = new k().fromArray(o.value); break; case "v4": r.uniforms[s].value = new on().fromArray(o.value); break; case "m3": r.uniforms[s].value = new Ot().fromArray(o.value); break; case "m4": r.uniforms[s].value = new yt().fromArray(o.value); break; default: r.uniforms[s].value = o.value } } if (e.defines !== void 0 && (r.defines = e.defines), e.vertexShader !== void 0 && (r.vertexShader = e.vertexShader), e.fragmentShader !== void 0 && (r.fragmentShader = e.fragmentShader), e.glslVersion !== void 0 && (r.glslVersion = e.glslVersion), e.extensions !== void 0) for (const s in e.extensions) r.extensions[s] = e.extensions[s]; if (e.lights !== void 0 && (r.lights = e.lights), e.clipping !== void 0 && (r.clipping = e.clipping), e.size !== void 0 && (r.size = e.size), e.sizeAttenuation !== void 0 && (r.sizeAttenuation = e.sizeAttenuation), e.map !== void 0 && (r.map = n(e.map)), e.matcap !== void 0 && (r.matcap = n(e.matcap)), e.alphaMap !== void 0 && (r.alphaMap = n(e.alphaMap)), e.bumpMap !== void 0 && (r.bumpMap = n(e.bumpMap)), e.bumpScale !== void 0 && (r.bumpScale = e.bumpScale), e.normalMap !== void 0 && (r.normalMap = n(e.normalMap)), e.normalMapType !== void 0 && (r.normalMapType = e.normalMapType), e.normalScale !== void 0) { let s = e.normalScale; Array.isArray(s) === !1 && (s = [s, s]), r.normalScale = new _e().fromArray(s) } return e.displacementMap !== void 0 && (r.displacementMap = n(e.displacementMap)), e.displacementScale !== void 0 && (r.displacementScale = e.displacementScale), e.displacementBias !== void 0 && (r.displacementBias = e.displacementBias), e.roughnessMap !== void 0 && (r.roughnessMap = n(e.roughnessMap)), e.metalnessMap !== void 0 && (r.metalnessMap = n(e.metalnessMap)), e.emissiveMap !== void 0 && (r.emissiveMap = n(e.emissiveMap)), e.emissiveIntensity !== void 0 && (r.emissiveIntensity = e.emissiveIntensity), e.specularMap !== void 0 && (r.specularMap = n(e.specularMap)), e.specularIntensityMap !== void 0 && (r.specularIntensityMap = n(e.specularIntensityMap)), e.specularColorMap !== void 0 && (r.specularColorMap = n(e.specularColorMap)), e.envMap !== void 0 && (r.envMap = n(e.envMap)), e.envMapIntensity !== void 0 && (r.envMapIntensity = e.envMapIntensity), e.reflectivity !== void 0 && (r.reflectivity = e.reflectivity), e.refractionRatio !== void 0 && (r.refractionRatio = e.refractionRatio), e.lightMap !== void 0 && (r.lightMap = n(e.lightMap)), e.lightMapIntensity !== void 0 && (r.lightMapIntensity = e.lightMapIntensity), e.aoMap !== void 0 && (r.aoMap = n(e.aoMap)), e.aoMapIntensity !== void 0 && (r.aoMapIntensity = e.aoMapIntensity), e.gradientMap !== void 0 && (r.gradientMap = n(e.gradientMap)), e.clearcoatMap !== void 0 && (r.clearcoatMap = n(e.clearcoatMap)), e.clearcoatRoughnessMap !== void 0 && (r.clearcoatRoughnessMap = n(e.clearcoatRoughnessMap)), e.clearcoatNormalMap !== void 0 && (r.clearcoatNormalMap = n(e.clearcoatNormalMap)), e.clearcoatNormalScale !== void 0 && (r.clearcoatNormalScale = new _e().fromArray(e.clearcoatNormalScale)), e.iridescenceMap !== void 0 && (r.iridescenceMap = n(e.iridescenceMap)), e.iridescenceThicknessMap !== void 0 && (r.iridescenceThicknessMap = n(e.iridescenceThicknessMap)), e.transmissionMap !== void 0 && (r.transmissionMap = n(e.transmissionMap)), e.thicknessMap !== void 0 && (r.thicknessMap = n(e.thicknessMap)), e.anisotropyMap !== void 0 && (r.anisotropyMap = n(e.anisotropyMap)), e.sheenColorMap !== void 0 && (r.sheenColorMap = n(e.sheenColorMap)), e.sheenRoughnessMap !== void 0 && (r.sheenRoughnessMap = n(e.sheenRoughnessMap)), r } setTextures(e) { return this.textures = e, this } static createMaterialFromType(e) { const t = { ShadowMaterial: QF, SpriteMaterial: RE, RawShaderMaterial: ZF, ShaderMaterial: jo, PointsMaterial: Xv, MeshPhysicalMaterial: qo, MeshStandardMaterial: mm, MeshPhongMaterial: $F, MeshToonMaterial: ek, MeshNormalMaterial: tk, MeshLambertMaterial: nk, MeshDepthMaterial: CE, MeshDistanceMaterial: TE, MeshBasicMaterial: ts, MeshMatcapMaterial: ik, LineDashedMaterial: rk, LineBasicMaterial: ir, Material: oi }; return new t[e] } } class Wo { static decodeText(e) { if (typeof TextDecoder < "u") return new TextDecoder().decode(e); let t = ""; for (let n = 0, r = e.length; n < r; n++)t += String.fromCharCode(e[n]); try { return decodeURIComponent(escape(t)) } catch { return t } } static extractUrlBase(e) { const t = e.lastIndexOf("/"); return t === -1 ? "./" : e.slice(0, t + 1) } static resolveURL(e, t) { return typeof e != "string" || e === "" ? "" : (/^https?:\/\//i.test(t) && /^\//.test(e) && (t = t.replace(/(^https?:\/\/[^\/]+).*/i, "$1")), /^(https?:)?\/\//i.test(e) || /^data:.*,.*$/i.test(e) || /^blob:.*$/i.test(e) ? e : t + e) } } class mk extends Rt { constructor() { super(), this.isInstancedBufferGeometry = !0, this.type = "InstancedBufferGeometry", this.instanceCount = 1 / 0 } copy(e) { return super.copy(e), this.instanceCount = e.instanceCount, this } toJSON() { const e = super.toJSON(); return e.instanceCount = this.instanceCount, e.isInstancedBufferGeometry = !0, e } } class gk extends rr { constructor(e) { super(e) } load(e, t, n, r) { const s = this, o = new ls(s.manager); o.setPath(s.path), o.setRequestHeader(s.requestHeader), o.setWithCredentials(s.withCredentials), o.load(e, function (a) { try { t(s.parse(JSON.parse(a))) } catch (l) { r ? r(l) : console.error(l), s.manager.itemError(e) } }, n, r) } parse(e) { const t = {}, n = {}; function r(m, y) { if (t[y] !== void 0) return t[y]; const x = m.interleavedBuffers[y], g = s(m, x.buffer), A = Pf(x.type, g), M = new um(A, x.stride); return M.uuid = x.uuid, t[y] = M, M } function s(m, y) { if (n[y] !== void 0) return n[y]; const x = m.arrayBuffers[y], g = new Uint32Array(x).buffer; return n[y] = g, g } const o = e.isInstancedBufferGeometry ? new mk : new Rt, a = e.data.index; if (a !== void 0) { const m = Pf(a.type, a.array); o.setIndex(new rn(m, 1)) } const l = e.data.attributes; for (const m in l) { const y = l[m]; let _; if (y.isInterleavedBufferAttribute) { const x = r(e.data, y.data); _ = new zl(x, y.itemSize, y.offset, y.normalized) } else { const x = Pf(y.type, y.array), g = y.isInstancedBufferAttribute ? xh : rn; _ = new g(x, y.itemSize, y.normalized) } y.name !== void 0 && (_.name = y.name), y.usage !== void 0 && _.setUsage(y.usage), y.updateRange !== void 0 && (_.updateRange.offset = y.updateRange.offset, _.updateRange.count = y.updateRange.count), o.setAttribute(m, _) } const c = e.data.morphAttributes; if (c) for (const m in c) { const y = c[m], _ = []; for (let x = 0, g = y.length; x < g; x++) { const A = y[x]; let M; if (A.isInterleavedBufferAttribute) { const S = r(e.data, A.data); M = new zl(S, A.itemSize, A.offset, A.normalized) } else { const S = Pf(A.type, A.array); M = new rn(S, A.itemSize, A.normalized) } A.name !== void 0 && (M.name = A.name), _.push(M) } o.morphAttributes[m] = _ } e.data.morphTargetsRelative && (o.morphTargetsRelative = !0); const d = e.data.groups || e.data.drawcalls || e.data.offsets; if (d !== void 0) for (let m = 0, y = d.length; m !== y; ++m) { const _ = d[m]; o.addGroup(_.start, _.count, _.materialIndex) } const p = e.data.boundingSphere; if (p !== void 0) { const m = new k; p.center !== void 0 && m.fromArray(p.center), o.boundingSphere = new Gs(m, p.radius) } return e.name && (o.name = e.name), e.userData && (o.userData = e.userData), o } } class C7 extends rr { constructor(e) { super(e) } load(e, t, n, r) { const s = this, o = this.path === "" ? Wo.extractUrlBase(e) : this.path; this.resourcePath = this.resourcePath || o; const a = new ls(this.manager); a.setPath(this.path), a.setRequestHeader(this.requestHeader), a.setWithCredentials(this.withCredentials), a.load(e, function (l) { let c = null; try { c = JSON.parse(l) } catch (d) { r !== void 0 && r(d), console.error("THREE:ObjectLoader: Can't parse " + e + ".", d.message); return } const f = c.metadata; if (f === void 0 || f.type === void 0 || f.type.toLowerCase() === "geometry") { r !== void 0 && r(new Error("THREE.ObjectLoader: Can't load " + e)), console.error("THREE.ObjectLoader: Can't load " + e); return } s.parse(c, t) }, n, r) } async loadAsync(e, t) { const n = this, r = this.path === "" ? Wo.extractUrlBase(e) : this.path; this.resourcePath = this.resourcePath || r; const s = new ls(this.manager); s.setPath(this.path), s.setRequestHeader(this.requestHeader), s.setWithCredentials(this.withCredentials); const o = await s.loadAsync(e, t), a = JSON.parse(o), l = a.metadata; if (l === void 0 || l.type === void 0 || l.type.toLowerCase() === "geometry") throw new Error("THREE.ObjectLoader: Can't load " + e); return await n.parseAsync(a) } parse(e, t) { const n = this.parseAnimations(e.animations), r = this.parseShapes(e.shapes), s = this.parseGeometries(e.geometries, r), o = this.parseImages(e.images, function () { t !== void 0 && t(c) }), a = this.parseTextures(e.textures, o), l = this.parseMaterials(e.materials, a), c = this.parseObject(e.object, s, l, a, n), f = this.parseSkeletons(e.skeletons, c); if (this.bindSkeletons(c, f), t !== void 0) { let d = !1; for (const p in o) if (o[p].data instanceof HTMLImageElement) { d = !0; break } d === !1 && t(c) } return c } async parseAsync(e) { const t = this.parseAnimations(e.animations), n = this.parseShapes(e.shapes), r = this.parseGeometries(e.geometries, n), s = await this.parseImagesAsync(e.images), o = this.parseTextures(e.textures, s), a = this.parseMaterials(e.materials, o), l = this.parseObject(e.object, r, a, o, t), c = this.parseSkeletons(e.skeletons, l); return this.bindSkeletons(l, c), l } parseShapes(e) { const t = {}; if (e !== void 0) for (let n = 0, r = e.length; n < r; n++) { const s = new Kc().fromJSON(e[n]); t[s.uuid] = s } return t } parseSkeletons(e, t) { const n = {}, r = {}; if (t.traverse(function (s) { s.isBone && (r[s.uuid] = s) }), e !== void 0) for (let s = 0, o = e.length; s < o; s++) { const a = new fm().fromJSON(e[s], r); n[a.uuid] = a } return n } parseGeometries(e, t) { const n = {}; if (e !== void 0) { const r = new gk; for (let s = 0, o = e.length; s < o; s++) { let a; const l = e[s]; switch (l.type) { case "BufferGeometry": case "InstancedBufferGeometry": a = r.parse(l); break; default: l.type in iI ? a = iI[l.type].fromJSON(l, t) : console.warn(`THREE.ObjectLoader: Unsupported geometry type "${l.type}"`) }a.uuid = l.uuid, l.name !== void 0 && (a.name = l.name), l.userData !== void 0 && (a.userData = l.userData), n[l.uuid] = a } } return n } parseMaterials(e, t) { const n = {}, r = {}; if (e !== void 0) { const s = new c_; s.setTextures(t); for (let o = 0, a = e.length; o < a; o++) { const l = e[o]; n[l.uuid] === void 0 && (n[l.uuid] = s.parse(l)), r[l.uuid] = n[l.uuid] } } return r } parseAnimations(e) { const t = {}; if (e !== void 0) for (let n = 0; n < e.length; n++) { const r = e[n], s = wh.parse(r); t[s.uuid] = s } return t } parseImages(e, t) { const n = this, r = {}; let s; function o(l) { return n.manager.itemStart(l), s.load(l, function () { n.manager.itemEnd(l) }, void 0, function () { n.manager.itemError(l), n.manager.itemEnd(l) }) } function a(l) { if (typeof l == "string") { const c = l, f = /^(\/\/)|([a-z]+:(\/\/)?)/i.test(c) ? c : n.resourcePath + c; return o(f) } else return l.data ? { data: Pf(l.type, l.data), width: l.width, height: l.height } : null } if (e !== void 0 && e.length > 0) { const l = new WE(t); s = new Yp(l), s.setCrossOrigin(this.crossOrigin); for (let c = 0, f = e.length; c < f; c++) { const d = e[c], p = d.url; if (Array.isArray(p)) { const m = []; for (let y = 0, _ = p.length; y < _; y++) { const x = p[y], g = a(x); g !== null && (g instanceof HTMLImageElement ? m.push(g) : m.push(new Kf(g.data, g.width, g.height))) } r[d.uuid] = new Dc(m) } else { const m = a(d.url); r[d.uuid] = new Dc(m) } } } return r } async parseImagesAsync(e) { const t = this, n = {}; let r; async function s(o) { if (typeof o == "string") { const a = o, l = /^(\/\/)|([a-z]+:(\/\/)?)/i.test(a) ? a : t.resourcePath + a; return await r.loadAsync(l) } else return o.data ? { data: Pf(o.type, o.data), width: o.width, height: o.height } : null } if (e !== void 0 && e.length > 0) { r = new Yp(this.manager), r.setCrossOrigin(this.crossOrigin); for (let o = 0, a = e.length; o < a; o++) { const l = e[o], c = l.url; if (Array.isArray(c)) { const f = []; for (let d = 0, p = c.length; d < p; d++) { const m = c[d], y = await s(m); y !== null && (y instanceof HTMLImageElement ? f.push(y) : f.push(new Kf(y.data, y.width, y.height))) } n[l.uuid] = new Dc(f) } else { const f = await s(l.url); n[l.uuid] = new Dc(f) } } } return n } parseTextures(e, t) { function n(s, o) { return typeof s == "number" ? s : (console.warn("THREE.ObjectLoader.parseTexture: Constant should be in numeric form.", s), o[s]) } const r = {}; if (e !== void 0) for (let s = 0, o = e.length; s < o; s++) { const a = e[s]; a.image === void 0 && console.warn('THREE.ObjectLoader: No "image" specified for', a.uuid), t[a.image] === void 0 && console.warn("THREE.ObjectLoader: Undefined image", a.image); const l = t[a.image], c = l.data; let f; Array.isArray(c) ? (f = new lm, c.length === 6 && (f.needsUpdate = !0)) : (c && c.data ? f = new Kf : f = new wn, c && (f.needsUpdate = !0)), f.source = l, f.uuid = a.uuid, a.name !== void 0 && (f.name = a.name), a.mapping !== void 0 && (f.mapping = n(a.mapping, T7)), a.channel !== void 0 && (f.channel = a.channel), a.offset !== void 0 && f.offset.fromArray(a.offset), a.repeat !== void 0 && f.repeat.fromArray(a.repeat), a.center !== void 0 && f.center.fromArray(a.center), a.rotation !== void 0 && (f.rotation = a.rotation), a.wrap !== void 0 && (f.wrapS = n(a.wrap[0], aI), f.wrapT = n(a.wrap[1], aI)), a.format !== void 0 && (f.format = a.format), a.internalFormat !== void 0 && (f.internalFormat = a.internalFormat), a.type !== void 0 && (f.type = a.type), a.colorSpace !== void 0 && (f.colorSpace = a.colorSpace), a.encoding !== void 0 && (f.encoding = a.encoding), a.minFilter !== void 0 && (f.minFilter = n(a.minFilter, lI)), a.magFilter !== void 0 && (f.magFilter = n(a.magFilter, lI)), a.anisotropy !== void 0 && (f.anisotropy = a.anisotropy), a.flipY !== void 0 && (f.flipY = a.flipY), a.generateMipmaps !== void 0 && (f.generateMipmaps = a.generateMipmaps), a.premultiplyAlpha !== void 0 && (f.premultiplyAlpha = a.premultiplyAlpha), a.unpackAlignment !== void 0 && (f.unpackAlignment = a.unpackAlignment), a.compareFunction !== void 0 && (f.compareFunction = a.compareFunction), a.userData !== void 0 && (f.userData = a.userData), r[a.uuid] = f } return r } parseObject(e, t, n, r, s) { let o; function a(p) { return t[p] === void 0 && console.warn("THREE.ObjectLoader: Undefined geometry", p), t[p] } function l(p) { if (p !== void 0) { if (Array.isArray(p)) { const m = []; for (let y = 0, _ = p.length; y < _; y++) { const x = p[y]; n[x] === void 0 && console.warn("THREE.ObjectLoader: Undefined material", x), m.push(n[x]) } return m } return n[p] === void 0 && console.warn("THREE.ObjectLoader: Undefined material", p), n[p] } } function c(p) { return r[p] === void 0 && console.warn("THREE.ObjectLoader: Undefined texture", p), r[p] } let f, d; switch (e.type) { case "Scene": o = new ov, e.background !== void 0 && (Number.isInteger(e.background) ? o.background = new We(e.background) : o.background = c(e.background)), e.environment !== void 0 && (o.environment = c(e.environment)), e.fog !== void 0 && (e.fog.type === "Fog" ? o.fog = new Vv(e.fog.color, e.fog.near, e.fog.far) : e.fog.type === "FogExp2" && (o.fog = new Gv(e.fog.color, e.fog.density))), e.backgroundBlurriness !== void 0 && (o.backgroundBlurriness = e.backgroundBlurriness), e.backgroundIntensity !== void 0 && (o.backgroundIntensity = e.backgroundIntensity); break; case "PerspectiveCamera": o = new Vn(e.fov, e.aspect, e.near, e.far), e.focus !== void 0 && (o.focus = e.focus), e.zoom !== void 0 && (o.zoom = e.zoom), e.filmGauge !== void 0 && (o.filmGauge = e.filmGauge), e.filmOffset !== void 0 && (o.filmOffset = e.filmOffset), e.view !== void 0 && (o.view = Object.assign({}, e.view)); break; case "OrthographicCamera": o = new Ca(e.left, e.right, e.top, e.bottom, e.near, e.far), e.zoom !== void 0 && (o.zoom = e.zoom), e.view !== void 0 && (o.view = Object.assign({}, e.view)); break; case "AmbientLight": o = new hk(e.color, e.intensity); break; case "DirectionalLight": o = new jE(e.color, e.intensity); break; case "PointLight": o = new YE(e.color, e.intensity, e.distance, e.decay); break; case "RectAreaLight": o = new dk(e.color, e.intensity, e.width, e.height); break; case "SpotLight": o = new JE(e.color, e.intensity, e.distance, e.angle, e.penumbra, e.decay); break; case "HemisphereLight": o = new fk(e.color, e.groundColor, e.intensity); break; case "LightProbe": o = new l_().fromJSON(e); break; case "SkinnedMesh": f = a(e.geometry), d = l(e.material), o = new PE(f, d), e.bindMode !== void 0 && (o.bindMode = e.bindMode), e.bindMatrix !== void 0 && o.bindMatrix.fromArray(e.bindMatrix), e.skeleton !== void 0 && (o.skeleton = e.skeleton); break; case "Mesh": f = a(e.geometry), d = l(e.material), o = new Ei(f, d); break; case "InstancedMesh": f = a(e.geometry), d = l(e.material); const p = e.count, m = e.instanceMatrix, y = e.instanceColor; o = new IE(f, d, p), o.instanceMatrix = new xh(new Float32Array(m.array), 16), y !== void 0 && (o.instanceColor = new xh(new Float32Array(y.array), y.itemSize)); break; case "LOD": o = new zF; break; case "Line": o = new Oa(a(e.geometry), l(e.material)); break; case "LineLoop": o = new BE(a(e.geometry), l(e.material)); break; case "LineSegments": o = new vo(a(e.geometry), l(e.material)); break; case "PointCloud": case "Points": o = new LE(a(e.geometry), l(e.material)); break; case "Sprite": o = new UF(l(e.material)); break; case "Group": o = new Ma; break; case "Bone": o = new Wv; break; default: o = new qt }if (o.uuid = e.uuid, e.name !== void 0 && (o.name = e.name), e.matrix !== void 0 ? (o.matrix.fromArray(e.matrix), e.matrixAutoUpdate !== void 0 && (o.matrixAutoUpdate = e.matrixAutoUpdate), o.matrixAutoUpdate && o.matrix.decompose(o.position, o.quaternion, o.scale)) : (e.position !== void 0 && o.position.fromArray(e.position), e.rotation !== void 0 && o.rotation.fromArray(e.rotation), e.quaternion !== void 0 && o.quaternion.fromArray(e.quaternion), e.scale !== void 0 && o.scale.fromArray(e.scale)), e.up !== void 0 && o.up.fromArray(e.up), e.castShadow !== void 0 && (o.castShadow = e.castShadow), e.receiveShadow !== void 0 && (o.receiveShadow = e.receiveShadow), e.shadow && (e.shadow.bias !== void 0 && (o.shadow.bias = e.shadow.bias), e.shadow.normalBias !== void 0 && (o.shadow.normalBias = e.shadow.normalBias), e.shadow.radius !== void 0 && (o.shadow.radius = e.shadow.radius), e.shadow.mapSize !== void 0 && o.shadow.mapSize.fromArray(e.shadow.mapSize), e.shadow.camera !== void 0 && (o.shadow.camera = this.parseObject(e.shadow.camera))), e.visible !== void 0 && (o.visible = e.visible), e.frustumCulled !== void 0 && (o.frustumCulled = e.frustumCulled), e.renderOrder !== void 0 && (o.renderOrder = e.renderOrder), e.userData !== void 0 && (o.userData = e.userData), e.layers !== void 0 && (o.layers.mask = e.layers), e.children !== void 0) { const p = e.children; for (let m = 0; m < p.length; m++)o.add(this.parseObject(p[m], t, n, r, s)) } if (e.animations !== void 0) { const p = e.animations; for (let m = 0; m < p.length; m++) { const y = p[m]; o.animations.push(s[y]) } } if (e.type === "LOD") { e.autoUpdate !== void 0 && (o.autoUpdate = e.autoUpdate); const p = e.levels; for (let m = 0; m < p.length; m++) { const y = p[m], _ = o.getObjectByProperty("uuid", y.object); _ !== void 0 && o.addLevel(_, y.distance, y.hysteresis) } } return o } bindSkeletons(e, t) { Object.keys(t).length !== 0 && e.traverse(function (n) { if (n.isSkinnedMesh === !0 && n.skeleton !== void 0) { const r = t[n.skeleton]; r === void 0 ? console.warn("THREE.ObjectLoader: No skeleton found with UUID:", n.skeleton) : n.bind(r, n.bindMatrix) } }) } } const T7 = { UVMapping: Ov, CubeReflectionMapping: Da, CubeRefractionMapping: Nl, EquirectangularReflectionMapping: Fp, EquirectangularRefractionMapping: kp, CubeUVReflectionMapping: Rh }, aI = { RepeatWrapping: Ul, ClampToEdgeWrapping: Di, MirroredRepeatWrapping: mh }, lI = { NearestFilter: zn, NearestMipmapNearestFilter: Np, NearestMipmapLinearFilter: Yf, LinearFilter: Pn, LinearMipmapNearestFilter: Fv, LinearMipmapLinearFilter: Yo }; class yk extends rr { constructor(e) { super(e), this.isImageBitmapLoader = !0, typeof createImageBitmap > "u" && console.warn("THREE.ImageBitmapLoader: createImageBitmap() not supported."), typeof fetch > "u" && console.warn("THREE.ImageBitmapLoader: fetch() not supported."), this.options = { premultiplyAlpha: "none" } } setOptions(e) { return this.options = e, this } load(e, t, n, r) { e === void 0 && (e = ""), this.path !== void 0 && (e = this.path + e), e = this.manager.resolveURL(e); const s = this, o = uu.get(e); if (o !== void 0) return s.manager.itemStart(e), setTimeout(function () { t && t(o), s.manager.itemEnd(e) }, 0), o; const a = {}; a.credentials = this.crossOrigin === "anonymous" ? "same-origin" : "include", a.headers = this.requestHeader, fetch(e, a).then(function (l) { return l.blob() }).then(function (l) { return createImageBitmap(l, Object.assign(s.options, { colorSpaceConversion: "none" })) }).then(function (l) { uu.add(e, l), t && t(l), s.manager.itemEnd(e) }).catch(function (l) { r && r(l), s.manager.itemError(e), s.manager.itemEnd(e) }), s.manager.itemStart(e) } } let M0; class KE { static getContext() { return M0 === void 0 && (M0 = new (window.AudioContext || window.webkitAudioContext)), M0 } static setContext(e) { M0 = e } } class b7 extends rr { constructor(e) { super(e) } load(e, t, n, r) { const s = this, o = new ls(this.manager); o.setResponseType("arraybuffer"), o.setPath(this.path), o.setRequestHeader(this.requestHeader), o.setWithCredentials(this.withCredentials), o.load(e, function (l) { try { const c = l.slice(0); KE.getContext().decodeAudioData(c, function (d) { t(d) }, a) } catch (c) { a(c) } }, n, r); function a(l) { r ? r(l) : console.error(l), s.manager.itemError(e) } } } class R7 extends l_ { constructor(e, t, n = 1) { super(void 0, n), this.isHemisphereLightProbe = !0; const r = new We().set(e), s = new We().set(t), o = new k(r.r, r.g, r.b), a = new k(s.r, s.g, s.b), l = Math.sqrt(Math.PI), c = l * Math.sqrt(.75); this.sh.coefficients[0].copy(o).add(a).multiplyScalar(l), this.sh.coefficients[1].copy(o).sub(a).multiplyScalar(c) } } class P7 extends l_ { constructor(e, t = 1) { super(void 0, t), this.isAmbientLightProbe = !0; const n = new We().set(e); this.sh.coefficients[0].set(n.r, n.g, n.b).multiplyScalar(2 * Math.sqrt(Math.PI)) } } const cI = new yt, uI = new yt, uc = new yt; class I7 { constructor() { this.type = "StereoCamera", this.aspect = 1, this.eyeSep = .064, this.cameraL = new Vn, this.cameraL.layers.enable(1), this.cameraL.matrixAutoUpdate = !1, this.cameraR = new Vn, this.cameraR.layers.enable(2), this.cameraR.matrixAutoUpdate = !1, this._cache = { focus: null, fov: null, aspect: null, near: null, far: null, zoom: null, eyeSep: null } } update(e) { const t = this._cache; if (t.focus !== e.focus || t.fov !== e.fov || t.aspect !== e.aspect * this.aspect || t.near !== e.near || t.far !== e.far || t.zoom !== e.zoom || t.eyeSep !== this.eyeSep) { t.focus = e.focus, t.fov = e.fov, t.aspect = e.aspect * this.aspect, t.near = e.near, t.far = e.far, t.zoom = e.zoom, t.eyeSep = this.eyeSep, uc.copy(e.projectionMatrix); const r = t.eyeSep / 2, s = r * t.near / t.focus, o = t.near * Math.tan(Yc * t.fov * .5) / t.zoom; let a, l; uI.elements[12] = -r, cI.elements[12] = r, a = -o * t.aspect + s, l = o * t.aspect + s, uc.elements[0] = 2 * t.near / (l - a), uc.elements[8] = (l + a) / (l - a), this.cameraL.projectionMatrix.copy(uc), a = -o * t.aspect - s, l = o * t.aspect - s, uc.elements[0] = 2 * t.near / (l - a), uc.elements[8] = (l + a) / (l - a), this.cameraR.projectionMatrix.copy(uc) } this.cameraL.matrixWorld.copy(e.matrixWorld).multiply(uI), this.cameraR.matrixWorld.copy(e.matrixWorld).multiply(cI) } } class qE { constructor(e = !0) { this.autoStart = e, this.startTime = 0, this.oldTime = 0, this.elapsedTime = 0, this.running = !1 } start() { this.startTime = fI(), this.oldTime = this.startTime, this.elapsedTime = 0, this.running = !0 } stop() { this.getElapsedTime(), this.running = !1, this.autoStart = !1 } getElapsedTime() { return this.getDelta(), this.elapsedTime } getDelta() { let e = 0; if (this.autoStart && !this.running) return this.start(), 0; if (this.running) { const t = fI(); e = (t - this.oldTime) / 1e3, this.oldTime = t, this.elapsedTime += e } return e } } function fI() { return (typeof performance > "u" ? Date : performance).now() } const fc = new k, hI = new Ti, B7 = new k, hc = new k; class L7 extends qt { constructor() { super(), this.type = "AudioListener", this.context = KE.getContext(), this.gain = this.context.createGain(), this.gain.connect(this.context.destination), this.filter = null, this.timeDelta = 0, this._clock = new qE } getInput() { return this.gain } removeFilter() { return this.filter !== null && (this.gain.disconnect(this.filter), this.filter.disconnect(this.context.destination), this.gain.connect(this.context.destination), this.filter = null), this } getFilter() { return this.filter } setFilter(e) { return this.filter !== null ? (this.gain.disconnect(this.filter), this.filter.disconnect(this.context.destination)) : this.gain.disconnect(this.context.destination), this.filter = e, this.gain.connect(this.filter), this.filter.connect(this.context.destination), this } getMasterVolume() { return this.gain.gain.value } setMasterVolume(e) { return this.gain.gain.setTargetAtTime(e, this.context.currentTime, .01), this } updateMatrixWorld(e) { super.updateMatrixWorld(e); const t = this.context.listener, n = this.up; if (this.timeDelta = this._clock.getDelta(), this.matrixWorld.decompose(fc, hI, B7), hc.set(0, 0, -1).applyQuaternion(hI), t.positionX) { const r = this.context.currentTime + this.timeDelta; t.positionX.linearRampToValueAtTime(fc.x, r), t.positionY.linearRampToValueAtTime(fc.y, r), t.positionZ.linearRampToValueAtTime(fc.z, r), t.forwardX.linearRampToValueAtTime(hc.x, r), t.forwardY.linearRampToValueAtTime(hc.y, r), t.forwardZ.linearRampToValueAtTime(hc.z, r), t.upX.linearRampToValueAtTime(n.x, r), t.upY.linearRampToValueAtTime(n.y, r), t.upZ.linearRampToValueAtTime(n.z, r) } else t.setPosition(fc.x, fc.y, fc.z), t.setOrientation(hc.x, hc.y, hc.z, n.x, n.y, n.z) } } class vk extends qt { constructor(e) { super(), this.type = "Audio", this.listener = e, this.context = e.context, this.gain = this.context.createGain(), this.gain.connect(e.getInput()), this.autoplay = !1, this.buffer = null, this.detune = 0, this.loop = !1, this.loopStart = 0, this.loopEnd = 0, this.offset = 0, this.duration = void 0, this.playbackRate = 1, this.isPlaying = !1, this.hasPlaybackControl = !0, this.source = null, this.sourceType = "empty", this._startedAt = 0, this._progress = 0, this._connected = !1, this.filters = [] } getOutput() { return this.gain } setNodeSource(e) { return this.hasPlaybackControl = !1, this.sourceType = "audioNode", this.source = e, this.connect(), this } setMediaElementSource(e) { return this.hasPlaybackControl = !1, this.sourceType = "mediaNode", this.source = this.context.createMediaElementSource(e), this.connect(), this } setMediaStreamSource(e) { return this.hasPlaybackControl = !1, this.sourceType = "mediaStreamNode", this.source = this.context.createMediaStreamSource(e), this.connect(), this } setBuffer(e) { return this.buffer = e, this.sourceType = "buffer", this.autoplay && this.play(), this } play(e = 0) { if (this.isPlaying === !0) { console.warn("THREE.Audio: Audio is already playing."); return } if (this.hasPlaybackControl === !1) { console.warn("THREE.Audio: this Audio has no playback control."); return } this._startedAt = this.context.currentTime + e; const t = this.context.createBufferSource(); return t.buffer = this.buffer, t.loop = this.loop, t.loopStart = this.loopStart, t.loopEnd = this.loopEnd, t.onended = this.onEnded.bind(this), t.start(this._startedAt, this._progress + this.offset, this.duration), this.isPlaying = !0, this.source = t, this.setDetune(this.detune), this.setPlaybackRate(this.playbackRate), this.connect() } pause() { if (this.hasPlaybackControl === !1) { console.warn("THREE.Audio: this Audio has no playback control."); return } return this.isPlaying === !0 && (this._progress += Math.max(this.context.currentTime - this._startedAt, 0) * this.playbackRate, this.loop === !0 && (this._progress = this._progress % (this.duration || this.buffer.duration)), this.source.stop(), this.source.onended = null, this.isPlaying = !1), this } stop() { if (this.hasPlaybackControl === !1) { console.warn("THREE.Audio: this Audio has no playback control."); return } return this._progress = 0, this.source !== null && (this.source.stop(), this.source.onended = null), this.isPlaying = !1, this } connect() { if (this.filters.length > 0) { this.source.connect(this.filters[0]); for (let e = 1, t = this.filters.length; e < t; e++)this.filters[e - 1].connect(this.filters[e]); this.filters[this.filters.length - 1].connect(this.getOutput()) } else this.source.connect(this.getOutput()); return this._connected = !0, this } disconnect() { if (this.filters.length > 0) { this.source.disconnect(this.filters[0]); for (let e = 1, t = this.filters.length; e < t; e++)this.filters[e - 1].disconnect(this.filters[e]); this.filters[this.filters.length - 1].disconnect(this.getOutput()) } else this.source.disconnect(this.getOutput()); return this._connected = !1, this } getFilters() { return this.filters } setFilters(e) { return e || (e = []), this._connected === !0 ? (this.disconnect(), this.filters = e.slice(), this.connect()) : this.filters = e.slice(), this } setDetune(e) { if (this.detune = e, this.source.detune !== void 0) return this.isPlaying === !0 && this.source.detune.setTargetAtTime(this.detune, this.context.currentTime, .01), this } getDetune() { return this.detune } getFilter() { return this.getFilters()[0] } setFilter(e) { return this.setFilters(e ? [e] : []) } setPlaybackRate(e) { if (this.hasPlaybackControl === !1) { console.warn("THREE.Audio: this Audio has no playback control."); return } return this.playbackRate = e, this.isPlaying === !0 && this.source.playbackRate.setTargetAtTime(this.playbackRate, this.context.currentTime, .01), this } getPlaybackRate() { return this.playbackRate } onEnded() { this.isPlaying = !1 } getLoop() { return this.hasPlaybackControl === !1 ? (console.warn("THREE.Audio: this Audio has no playback control."), !1) : this.loop } setLoop(e) { if (this.hasPlaybackControl === !1) { console.warn("THREE.Audio: this Audio has no playback control."); return } return this.loop = e, this.isPlaying === !0 && (this.source.loop = this.loop), this } setLoopStart(e) { return this.loopStart = e, this } setLoopEnd(e) { return this.loopEnd = e, this } getVolume() { return this.gain.gain.value } setVolume(e) { return this.gain.gain.setTargetAtTime(e, this.context.currentTime, .01), this } } const dc = new k, dI = new Ti, D7 = new k, pc = new k; class O7 extends vk { constructor(e) { super(e), this.panner = this.context.createPanner(), this.panner.panningModel = "HRTF", this.panner.connect(this.gain) } connect() { super.connect(), this.panner.connect(this.gain) } disconnect() { super.disconnect(), this.panner.disconnect(this.gain) } getOutput() { return this.panner } getRefDistance() { return this.panner.refDistance } setRefDistance(e) { return this.panner.refDistance = e, this } getRolloffFactor() { return this.panner.rolloffFactor } setRolloffFactor(e) { return this.panner.rolloffFactor = e, this } getDistanceModel() { return this.panner.distanceModel } setDistanceModel(e) { return this.panner.distanceModel = e, this } getMaxDistance() { return this.panner.maxDistance } setMaxDistance(e) { return this.panner.maxDistance = e, this } setDirectionalCone(e, t, n) { return this.panner.coneInnerAngle = e, this.panner.coneOuterAngle = t, this.panner.coneOuterGain = n, this } updateMatrixWorld(e) { if (super.updateMatrixWorld(e), this.hasPlaybackControl === !0 && this.isPlaying === !1) return; this.matrixWorld.decompose(dc, dI, D7), pc.set(0, 0, 1).applyQuaternion(dI); const t = this.panner; if (t.positionX) { const n = this.context.currentTime + this.listener.timeDelta; t.positionX.linearRampToValueAtTime(dc.x, n), t.positionY.linearRampToValueAtTime(dc.y, n), t.positionZ.linearRampToValueAtTime(dc.z, n), t.orientationX.linearRampToValueAtTime(pc.x, n), t.orientationY.linearRampToValueAtTime(pc.y, n), t.orientationZ.linearRampToValueAtTime(pc.z, n) } else t.setPosition(dc.x, dc.y, dc.z), t.setOrientation(pc.x, pc.y, pc.z) } } class F7 { constructor(e, t = 2048) { this.analyser = e.context.createAnalyser(), this.analyser.fftSize = t, this.data = new Uint8Array(this.analyser.frequencyBinCount), e.getOutput().connect(this.analyser) } getFrequencyData() { return this.analyser.getByteFrequencyData(this.data), this.data } getAverageFrequency() { let e = 0; const t = this.getFrequencyData(); for (let n = 0; n < t.length; n++)e += t[n]; return e / t.length } } class _k { constructor(e, t, n) { this.binding = e, this.valueSize = n; let r, s, o; switch (t) { case "quaternion": r = this._slerp, s = this._slerpAdditive, o = this._setAdditiveIdentityQuaternion, this.buffer = new Float64Array(n * 6), this._workIndex = 5; break; case "string": case "bool": r = this._select, s = this._select, o = this._setAdditiveIdentityOther, this.buffer = new Array(n * 5); break; default: r = this._lerp, s = this._lerpAdditive, o = this._setAdditiveIdentityNumeric, this.buffer = new Float64Array(n * 5) }this._mixBufferRegion = r, this._mixBufferRegionAdditive = s, this._setIdentity = o, this._origIndex = 3, this._addIndex = 4, this.cumulativeWeight = 0, this.cumulativeWeightAdditive = 0, this.useCount = 0, this.referenceCount = 0 } accumulate(e, t) { const n = this.buffer, r = this.valueSize, s = e * r + r; let o = this.cumulativeWeight; if (o === 0) { for (let a = 0; a !== r; ++a)n[s + a] = n[a]; o = t } else { o += t; const a = t / o; this._mixBufferRegion(n, s, 0, a, r) } this.cumulativeWeight = o } accumulateAdditive(e) { const t = this.buffer, n = this.valueSize, r = n * this._addIndex; this.cumulativeWeightAdditive === 0 && this._setIdentity(), this._mixBufferRegionAdditive(t, r, 0, e, n), this.cumulativeWeightAdditive += e } apply(e) { const t = this.valueSize, n = this.buffer, r = e * t + t, s = this.cumulativeWeight, o = this.cumulativeWeightAdditive, a = this.binding; if (this.cumulativeWeight = 0, this.cumulativeWeightAdditive = 0, s < 1) { const l = t * this._origIndex; this._mixBufferRegion(n, r, l, 1 - s, t) } o > 0 && this._mixBufferRegionAdditive(n, r, this._addIndex * t, 1, t); for (let l = t, c = t + t; l !== c; ++l)if (n[l] !== n[l + t]) { a.setValue(n, r); break } } saveOriginalState() { const e = this.binding, t = this.buffer, n = this.valueSize, r = n * this._origIndex; e.getValue(t, r); for (let s = n, o = r; s !== o; ++s)t[s] = t[r + s % n]; this._setIdentity(), this.cumulativeWeight = 0, this.cumulativeWeightAdditive = 0 } restoreOriginalState() { const e = this.valueSize * 3; this.binding.setValue(this.buffer, e) } _setAdditiveIdentityNumeric() { const e = this._addIndex * this.valueSize, t = e + this.valueSize; for (let n = e; n < t; n++)this.buffer[n] = 0 } _setAdditiveIdentityQuaternion() { this._setAdditiveIdentityNumeric(), this.buffer[this._addIndex * this.valueSize + 3] = 1 } _setAdditiveIdentityOther() { const e = this._origIndex * this.valueSize, t = this._addIndex * this.valueSize; for (let n = 0; n < this.valueSize; n++)this.buffer[t + n] = this.buffer[e + n] } _select(e, t, n, r, s) { if (r >= .5) for (let o = 0; o !== s; ++o)e[t + o] = e[n + o] } _slerp(e, t, n, r) { Ti.slerpFlat(e, t, e, t, e, n, r) } _slerpAdditive(e, t, n, r, s) { const o = this._workIndex * s; Ti.multiplyQuaternionsFlat(e, o, e, t, e, n), Ti.slerpFlat(e, t, e, t, e, o, r) } _lerp(e, t, n, r, s) { const o = 1 - r; for (let a = 0; a !== s; ++a) { const l = t + a; e[l] = e[l] * o + e[n + a] * r } } _lerpAdditive(e, t, n, r, s) { for (let o = 0; o !== s; ++o) { const a = t + o; e[a] = e[a] + e[n + o] * r } } } const QE = "\\[\\]\\.:\\/", k7 = new RegExp("[" + QE + "]", "g"), ZE = "[^" + QE + "]", N7 = "[^" + QE.replace("\\.", "") + "]", U7 = /((?:WC+[\/:])*)/.source.replace("WC", ZE), z7 = /(WCOD+)?/.source.replace("WCOD", N7), H7 = /(?:\.(WC+)(?:\[(.+)\])?)?/.source.replace("WC", ZE), G7 = /\.(WC+)(?:\[(.+)\])?/.source.replace("WC", ZE), V7 = new RegExp("^" + U7 + z7 + H7 + G7 + "$"), W7 = ["material", "materials", "bones", "map"]; class X7 { constructor(e, t, n) { const r = n || Kt.parseTrackName(t); this._targetGroup = e, this._bindings = e.subscribe_(t, r) } getValue(e, t) { this.bind(); const n = this._targetGroup.nCachedObjects_, r = this._bindings[n]; r !== void 0 && r.getValue(e, t) } setValue(e, t) { const n = this._bindings; for (let r = this._targetGroup.nCachedObjects_, s = n.length; r !== s; ++r)n[r].setValue(e, t) } bind() { const e = this._bindings; for (let t = this._targetGroup.nCachedObjects_, n = e.length; t !== n; ++t)e[t].bind() } unbind() { const e = this._bindings; for (let t = this._targetGroup.nCachedObjects_, n = e.length; t !== n; ++t)e[t].unbind() } } class Kt { constructor(e, t, n) { this.path = t, this.parsedPath = n || Kt.parseTrackName(t), this.node = Kt.findNode(e, this.parsedPath.nodeName), this.rootNode = e, this.getValue = this._getValue_unbound, this.setValue = this._setValue_unbound } static create(e, t, n) { return e && e.isAnimationObjectGroup ? new Kt.Composite(e, t, n) : new Kt(e, t, n) } static sanitizeNodeName(e) { return e.replace(/\s/g, "_").replace(k7, "") } static parseTrackName(e) { const t = V7.exec(e); if (t === null) throw new Error("PropertyBinding: Cannot parse trackName: " + e); const n = { nodeName: t[2], objectName: t[3], objectIndex: t[4], propertyName: t[5], propertyIndex: t[6] }, r = n.nodeName && n.nodeName.lastIndexOf("."); if (r !== void 0 && r !== -1) { const s = n.nodeName.substring(r + 1); W7.indexOf(s) !== -1 && (n.nodeName = n.nodeName.substring(0, r), n.objectName = s) } if (n.propertyName === null || n.propertyName.length === 0) throw new Error("PropertyBinding: can not parse propertyName from trackName: " + e); return n } static findNode(e, t) { if (t === void 0 || t === "" || t === "." || t === -1 || t === e.name || t === e.uuid) return e; if (e.skeleton) { const n = e.skeleton.getBoneByName(t); if (n !== void 0) return n } if (e.children) { const n = function (s) { for (let o = 0; o < s.length; o++) { const a = s[o]; if (a.name === t || a.uuid === t) return a; const l = n(a.children); if (l) return l } return null }, r = n(e.children); if (r) return r } return null } _getValue_unavailable() { } _setValue_unavailable() { } _getValue_direct(e, t) { e[t] = this.targetObject[this.propertyName] } _getValue_array(e, t) { const n = this.resolvedProperty; for (let r = 0, s = n.length; r !== s; ++r)e[t++] = n[r] } _getValue_arrayElement(e, t) { e[t] = this.resolvedProperty[this.propertyIndex] } _getValue_toArray(e, t) { this.resolvedProperty.toArray(e, t) } _setValue_direct(e, t) { this.targetObject[this.propertyName] = e[t] } _setValue_direct_setNeedsUpdate(e, t) { this.targetObject[this.propertyName] = e[t], this.targetObject.needsUpdate = !0 } _setValue_direct_setMatrixWorldNeedsUpdate(e, t) { this.targetObject[this.propertyName] = e[t], this.targetObject.matrixWorldNeedsUpdate = !0 } _setValue_array(e, t) { const n = this.resolvedProperty; for (let r = 0, s = n.length; r !== s; ++r)n[r] = e[t++] } _setValue_array_setNeedsUpdate(e, t) { const n = this.resolvedProperty; for (let r = 0, s = n.length; r !== s; ++r)n[r] = e[t++]; this.targetObject.needsUpdate = !0 } _setValue_array_setMatrixWorldNeedsUpdate(e, t) { const n = this.resolvedProperty; for (let r = 0, s = n.length; r !== s; ++r)n[r] = e[t++]; this.targetObject.matrixWorldNeedsUpdate = !0 } _setValue_arrayElement(e, t) { this.resolvedProperty[this.propertyIndex] = e[t] } _setValue_arrayElement_setNeedsUpdate(e, t) { this.resolvedProperty[this.propertyIndex] = e[t], this.targetObject.needsUpdate = !0 } _setValue_arrayElement_setMatrixWorldNeedsUpdate(e, t) { this.resolvedProperty[this.propertyIndex] = e[t], this.targetObject.matrixWorldNeedsUpdate = !0 } _setValue_fromArray(e, t) { this.resolvedProperty.fromArray(e, t) } _setValue_fromArray_setNeedsUpdate(e, t) { this.resolvedProperty.fromArray(e, t), this.targetObject.needsUpdate = !0 } _setValue_fromArray_setMatrixWorldNeedsUpdate(e, t) { this.resolvedProperty.fromArray(e, t), this.targetObject.matrixWorldNeedsUpdate = !0 } _getValue_unbound(e, t) { this.bind(), this.getValue(e, t) } _setValue_unbound(e, t) { this.bind(), this.setValue(e, t) } bind() { let e = this.node; const t = this.parsedPath, n = t.objectName, r = t.propertyName; let s = t.propertyIndex; if (e || (e = Kt.findNode(this.rootNode, t.nodeName), this.node = e), this.getValue = this._getValue_unavailable, this.setValue = this._setValue_unavailable, !e) { console.warn("THREE.PropertyBinding: No target node found for track: " + this.path + "."); return } if (n) { let c = t.objectIndex; switch (n) { case "materials": if (!e.material) { console.error("THREE.PropertyBinding: Can not bind to material as node does not have a material.", this); return } if (!e.material.materials) { console.error("THREE.PropertyBinding: Can not bind to material.materials as node.material does not have a materials array.", this); return } e = e.material.materials; break; case "bones": if (!e.skeleton) { console.error("THREE.PropertyBinding: Can not bind to bones as node does not have a skeleton.", this); return } e = e.skeleton.bones; for (let f = 0; f < e.length; f++)if (e[f].name === c) { c = f; break } break; case "map": if ("map" in e) { e = e.map; break } if (!e.material) { console.error("THREE.PropertyBinding: Can not bind to material as node does not have a material.", this); return } if (!e.material.map) { console.error("THREE.PropertyBinding: Can not bind to material.map as node.material does not have a map.", this); return } e = e.material.map; break; default: if (e[n] === void 0) { console.error("THREE.PropertyBinding: Can not bind to objectName of node undefined.", this); return } e = e[n] }if (c !== void 0) { if (e[c] === void 0) { console.error("THREE.PropertyBinding: Trying to bind to objectIndex of objectName, but is undefined.", this, e); return } e = e[c] } } const o = e[r]; if (o === void 0) { const c = t.nodeName; console.error("THREE.PropertyBinding: Trying to update property for track: " + c + "." + r + " but it wasn't found.", e); return } let a = this.Versioning.None; this.targetObject = e, e.needsUpdate !== void 0 ? a = this.Versioning.NeedsUpdate : e.matrixWorldNeedsUpdate !== void 0 && (a = this.Versioning.MatrixWorldNeedsUpdate); let l = this.BindingType.Direct; if (s !== void 0) { if (r === "morphTargetInfluences") { if (!e.geometry) { console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.", this); return } if (!e.geometry.morphAttributes) { console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphAttributes.", this); return } e.morphTargetDictionary[s] !== void 0 && (s = e.morphTargetDictionary[s]) } l = this.BindingType.ArrayElement, this.resolvedProperty = o, this.propertyIndex = s } else o.fromArray !== void 0 && o.toArray !== void 0 ? (l = this.BindingType.HasFromToArray, this.resolvedProperty = o) : Array.isArray(o) ? (l = this.BindingType.EntireArray, this.resolvedProperty = o) : this.propertyName = r; this.getValue = this.GetterByBindingType[l], this.setValue = this.SetterByBindingTypeAndVersioning[l][a] } unbind() { this.node = null, this.getValue = this._getValue_unbound, this.setValue = this._setValue_unbound } } Kt.Composite = X7; Kt.prototype.BindingType = { Direct: 0, EntireArray: 1, ArrayElement: 2, HasFromToArray: 3 }; Kt.prototype.Versioning = { None: 0, NeedsUpdate: 1, MatrixWorldNeedsUpdate: 2 }; Kt.prototype.GetterByBindingType = [Kt.prototype._getValue_direct, Kt.prototype._getValue_array, Kt.prototype._getValue_arrayElement, Kt.prototype._getValue_toArray]; Kt.prototype.SetterByBindingTypeAndVersioning = [[Kt.prototype._setValue_direct, Kt.prototype._setValue_direct_setNeedsUpdate, Kt.prototype._setValue_direct_setMatrixWorldNeedsUpdate], [Kt.prototype._setValue_array, Kt.prototype._setValue_array_setNeedsUpdate, Kt.prototype._setValue_array_setMatrixWorldNeedsUpdate], [Kt.prototype._setValue_arrayElement, Kt.prototype._setValue_arrayElement_setNeedsUpdate, Kt.prototype._setValue_arrayElement_setMatrixWorldNeedsUpdate], [Kt.prototype._setValue_fromArray, Kt.prototype._setValue_fromArray_setNeedsUpdate, Kt.prototype._setValue_fromArray_setMatrixWorldNeedsUpdate]]; class J7 { constructor() { this.isAnimationObjectGroup = !0, this.uuid = ss(), this._objects = Array.prototype.slice.call(arguments), this.nCachedObjects_ = 0; const e = {}; this._indicesByUUID = e; for (let n = 0, r = arguments.length; n !== r; ++n)e[arguments[n].uuid] = n; this._paths = [], this._parsedPaths = [], this._bindings = [], this._bindingsIndicesByPath = {}; const t = this; this.stats = { objects: { get total() { return t._objects.length }, get inUse() { return this.total - t.nCachedObjects_ } }, get bindingsPerObject() { return t._bindings.length } } } add() { const e = this._objects, t = this._indicesByUUID, n = this._paths, r = this._parsedPaths, s = this._bindings, o = s.length; let a, l = e.length, c = this.nCachedObjects_; for (let f = 0, d = arguments.length; f !== d; ++f) { const p = arguments[f], m = p.uuid; let y = t[m]; if (y === void 0) { y = l++, t[m] = y, e.push(p); for (let _ = 0, x = o; _ !== x; ++_)s[_].push(new Kt(p, n[_], r[_])) } else if (y < c) { a = e[y]; const _ = --c, x = e[_]; t[x.uuid] = y, e[y] = x, t[m] = _, e[_] = p; for (let g = 0, A = o; g !== A; ++g) { const M = s[g], S = M[_]; let C = M[y]; M[y] = S, C === void 0 && (C = new Kt(p, n[g], r[g])), M[_] = C } } else e[y] !== a && console.error("THREE.AnimationObjectGroup: Different objects with the same UUID detected. Clean the caches or recreate your infrastructure when reloading scenes.") } this.nCachedObjects_ = c } remove() { const e = this._objects, t = this._indicesByUUID, n = this._bindings, r = n.length; let s = this.nCachedObjects_; for (let o = 0, a = arguments.length; o !== a; ++o) { const l = arguments[o], c = l.uuid, f = t[c]; if (f !== void 0 && f >= s) { const d = s++, p = e[d]; t[p.uuid] = f, e[f] = p, t[c] = d, e[d] = l; for (let m = 0, y = r; m !== y; ++m) { const _ = n[m], x = _[d], g = _[f]; _[f] = x, _[d] = g } } } this.nCachedObjects_ = s } uncache() { const e = this._objects, t = this._indicesByUUID, n = this._bindings, r = n.length; let s = this.nCachedObjects_, o = e.length; for (let a = 0, l = arguments.length; a !== l; ++a) { const c = arguments[a], f = c.uuid, d = t[f]; if (d !== void 0) if (delete t[f], d < s) { const p = --s, m = e[p], y = --o, _ = e[y]; t[m.uuid] = d, e[d] = m, t[_.uuid] = p, e[p] = _, e.pop(); for (let x = 0, g = r; x !== g; ++x) { const A = n[x], M = A[p], S = A[y]; A[d] = M, A[p] = S, A.pop() } } else { const p = --o, m = e[p]; p > 0 && (t[m.uuid] = d), e[d] = m, e.pop(); for (let y = 0, _ = r; y !== _; ++y) { const x = n[y]; x[d] = x[p], x.pop() } } } this.nCachedObjects_ = s } subscribe_(e, t) { const n = this._bindingsIndicesByPath; let r = n[e]; const s = this._bindings; if (r !== void 0) return s[r]; const o = this._paths, a = this._parsedPaths, l = this._objects, c = l.length, f = this.nCachedObjects_, d = new Array(c); r = s.length, n[e] = r, o.push(e), a.push(t), s.push(d); for (let p = f, m = l.length; p !== m; ++p) { const y = l[p]; d[p] = new Kt(y, e, t) } return d } unsubscribe_(e) { const t = this._bindingsIndicesByPath, n = t[e]; if (n !== void 0) { const r = this._paths, s = this._parsedPaths, o = this._bindings, a = o.length - 1, l = o[a], c = e[a]; t[c] = n, o[n] = l, o.pop(), s[n] = s[a], s.pop(), r[n] = r[a], r.pop() } } } class xk { constructor(e, t, n = null, r = t.blendMode) { this._mixer = e, this._clip = t, this._localRoot = n, this.blendMode = r; const s = t.tracks, o = s.length, a = new Array(o), l = { endingStart: Bc, endingEnd: Bc }; for (let c = 0; c !== o; ++c) { const f = s[c].createInterpolant(null); a[c] = f, f.settings = l } this._interpolantSettings = l, this._interpolants = a, this._propertyBindings = new Array(o), this._cacheIndex = null, this._byClipCacheIndex = null, this._timeScaleInterpolant = null, this._weightInterpolant = null, this.loop = sF, this._loopCount = -1, this._startTime = null, this.time = 0, this.timeScale = 1, this._effectiveTimeScale = 1, this.weight = 1, this._effectiveWeight = 1, this.repetitions = 1 / 0, this.paused = !1, this.enabled = !0, this.clampWhenFinished = !1, this.zeroSlopeAtStart = !0, this.zeroSlopeAtEnd = !0 } play() { return this._mixer._activateAction(this), this } stop() { return this._mixer._deactivateAction(this), this.reset() } reset() { return this.paused = !1, this.enabled = !0, this.time = 0, this._loopCount = -1, this._startTime = null, this.stopFading().stopWarping() } isRunning() { return this.enabled && !this.paused && this.timeScale !== 0 && this._startTime === null && this._mixer._isActiveAction(this) } isScheduled() { return this._mixer._isActiveAction(this) } startAt(e) { return this._startTime = e, this } setLoop(e, t) { return this.loop = e, this.repetitions = t, this } setEffectiveWeight(e) { return this.weight = e, this._effectiveWeight = this.enabled ? e : 0, this.stopFading() } getEffectiveWeight() { return this._effectiveWeight } fadeIn(e) { return this._scheduleFading(e, 0, 1) } fadeOut(e) { return this._scheduleFading(e, 1, 0) } crossFadeFrom(e, t, n) { if (e.fadeOut(t), this.fadeIn(t), n) { const r = this._clip.duration, s = e._clip.duration, o = s / r, a = r / s; e.warp(1, o, t), this.warp(a, 1, t) } return this } crossFadeTo(e, t, n) { return e.crossFadeFrom(this, t, n) } stopFading() { const e = this._weightInterpolant; return e !== null && (this._weightInterpolant = null, this._mixer._takeBackControlInterpolant(e)), this } setEffectiveTimeScale(e) { return this.timeScale = e, this._effectiveTimeScale = this.paused ? 0 : e, this.stopWarping() } getEffectiveTimeScale() { return this._effectiveTimeScale } setDuration(e) { return this.timeScale = this._clip.duration / e, this.stopWarping() } syncWith(e) { return this.time = e.time, this.timeScale = e.timeScale, this.stopWarping() } halt(e) { return this.warp(this._effectiveTimeScale, 0, e) } warp(e, t, n) { const r = this._mixer, s = r.time, o = this.timeScale; let a = this._timeScaleInterpolant; a === null && (a = r._lendControlInterpolant(), this._timeScaleInterpolant = a); const l = a.parameterPositions, c = a.sampleValues; return l[0] = s, l[1] = s + n, c[0] = e / o, c[1] = t / o, this } stopWarping() { const e = this._timeScaleInterpolant; return e !== null && (this._timeScaleInterpolant = null, this._mixer._takeBackControlInterpolant(e)), this } getMixer() { return this._mixer } getClip() { return this._clip } getRoot() { return this._localRoot || this._mixer._root } _update(e, t, n, r) { if (!this.enabled) { this._updateWeight(e); return } const s = this._startTime; if (s !== null) { const l = (e - s) * n; l < 0 || n === 0 ? t = 0 : (this._startTime = null, t = n * l) } t *= this._updateTimeScale(e); const o = this._updateTime(t), a = this._updateWeight(e); if (a > 0) { const l = this._interpolants, c = this._propertyBindings; switch (this.blendMode) { case gE: for (let f = 0, d = l.length; f !== d; ++f)l[f].evaluate(o), c[f].accumulateAdditive(a); break; case Nv: default: for (let f = 0, d = l.length; f !== d; ++f)l[f].evaluate(o), c[f].accumulate(r, a) } } } _updateWeight(e) { let t = 0; if (this.enabled) { t = this.weight; const n = this._weightInterpolant; if (n !== null) { const r = n.evaluate(e)[0]; t *= r, e > n.parameterPositions[1] && (this.stopFading(), r === 0 && (this.enabled = !1)) } } return this._effectiveWeight = t, t } _updateTimeScale(e) { let t = 0; if (!this.paused) { t = this.timeScale; const n = this._timeScaleInterpolant; if (n !== null) { const r = n.evaluate(e)[0]; t *= r, e > n.parameterPositions[1] && (this.stopWarping(), t === 0 ? this.paused = !0 : this.timeScale = t) } } return this._effectiveTimeScale = t, t } _updateTime(e) { const t = this._clip.duration, n = this.loop; let r = this.time + e, s = this._loopCount; const o = n === oF; if (e === 0) return s === -1 ? r : o && (s & 1) === 1 ? t - r : r; if (n === rF) { s === -1 && (this._loopCount = 0, this._setEndings(!0, !0, !1)); e: { if (r >= t) r = t; else if (r < 0) r = 0; else { this.time = r; break e } this.clampWhenFinished ? this.paused = !0 : this.enabled = !1, this.time = r, this._mixer.dispatchEvent({ type: "finished", action: this, direction: e < 0 ? -1 : 1 }) } } else { if (s === -1 && (e >= 0 ? (s = 0, this._setEndings(!0, this.repetitions === 0, o)) : this._setEndings(this.repetitions === 0, !0, o)), r >= t || r < 0) { const a = Math.floor(r / t); r -= t * a, s += Math.abs(a); const l = this.repetitions - s; if (l <= 0) this.clampWhenFinished ? this.paused = !0 : this.enabled = !1, r = e > 0 ? t : 0, this.time = r, this._mixer.dispatchEvent({ type: "finished", action: this, direction: e > 0 ? 1 : -1 }); else { if (l === 1) { const c = e < 0; this._setEndings(c, !c, o) } else this._setEndings(!1, !1, o); this._loopCount = s, this.time = r, this._mixer.dispatchEvent({ type: "loop", action: this, loopDelta: a }) } } else this.time = r; if (o && (s & 1) === 1) return t - r } return r } _setEndings(e, t, n) { const r = this._interpolantSettings; n ? (r.endingStart = Lc, r.endingEnd = Lc) : (e ? r.endingStart = this.zeroSlopeAtStart ? Lc : Bc : r.endingStart = Up, t ? r.endingEnd = this.zeroSlopeAtEnd ? Lc : Bc : r.endingEnd = Up) } _scheduleFading(e, t, n) { const r = this._mixer, s = r.time; let o = this._weightInterpolant; o === null && (o = r._lendControlInterpolant(), this._weightInterpolant = o); const a = o.parameterPositions, l = o.sampleValues; return a[0] = s, l[0] = t, a[1] = s + e, l[1] = n, this } } const Y7 = new Float32Array(1); class j7 extends Ko { constructor(e) { super(), this._root = e, this._initMemoryManager(), this._accuIndex = 0, this.time = 0, this.timeScale = 1 } _bindAction(e, t) { const n = e._localRoot || this._root, r = e._clip.tracks, s = r.length, o = e._propertyBindings, a = e._interpolants, l = n.uuid, c = this._bindingsByRootAndName; let f = c[l]; f === void 0 && (f = {}, c[l] = f); for (let d = 0; d !== s; ++d) { const p = r[d], m = p.name; let y = f[m]; if (y !== void 0) ++y.referenceCount, o[d] = y; else { if (y = o[d], y !== void 0) { y._cacheIndex === null && (++y.referenceCount, this._addInactiveBinding(y, l, m)); continue } const _ = t && t._propertyBindings[d].binding.parsedPath; y = new _k(Kt.create(n, m, _), p.ValueTypeName, p.getValueSize()), ++y.referenceCount, this._addInactiveBinding(y, l, m), o[d] = y } a[d].resultBuffer = y.buffer } } _activateAction(e) { if (!this._isActiveAction(e)) { if (e._cacheIndex === null) { const n = (e._localRoot || this._root).uuid, r = e._clip.uuid, s = this._actionsByClip[r]; this._bindAction(e, s && s.knownActions[0]), this._addInactiveAction(e, r, n) } const t = e._propertyBindings; for (let n = 0, r = t.length; n !== r; ++n) { const s = t[n]; s.useCount++ === 0 && (this._lendBinding(s), s.saveOriginalState()) } this._lendAction(e) } } _deactivateAction(e) { if (this._isActiveAction(e)) { const t = e._propertyBindings; for (let n = 0, r = t.length; n !== r; ++n) { const s = t[n]; --s.useCount === 0 && (s.restoreOriginalState(), this._takeBackBinding(s)) } this._takeBackAction(e) } } _initMemoryManager() { this._actions = [], this._nActiveActions = 0, this._actionsByClip = {}, this._bindings = [], this._nActiveBindings = 0, this._bindingsByRootAndName = {}, this._controlInterpolants = [], this._nActiveControlInterpolants = 0; const e = this; this.stats = { actions: { get total() { return e._actions.length }, get inUse() { return e._nActiveActions } }, bindings: { get total() { return e._bindings.length }, get inUse() { return e._nActiveBindings } }, controlInterpolants: { get total() { return e._controlInterpolants.length }, get inUse() { return e._nActiveControlInterpolants } } } } _isActiveAction(e) { const t = e._cacheIndex; return t !== null && t < this._nActiveActions } _addInactiveAction(e, t, n) { const r = this._actions, s = this._actionsByClip; let o = s[t]; if (o === void 0) o = { knownActions: [e], actionByRoot: {} }, e._byClipCacheIndex = 0, s[t] = o; else { const a = o.knownActions; e._byClipCacheIndex = a.length, a.push(e) } e._cacheIndex = r.length, r.push(e), o.actionByRoot[n] = e } _removeInactiveAction(e) { const t = this._actions, n = t[t.length - 1], r = e._cacheIndex; n._cacheIndex = r, t[r] = n, t.pop(), e._cacheIndex = null; const s = e._clip.uuid, o = this._actionsByClip, a = o[s], l = a.knownActions, c = l[l.length - 1], f = e._byClipCacheIndex; c._byClipCacheIndex = f, l[f] = c, l.pop(), e._byClipCacheIndex = null; const d = a.actionByRoot, p = (e._localRoot || this._root).uuid; delete d[p], l.length === 0 && delete o[s], this._removeInactiveBindingsForAction(e) } _removeInactiveBindingsForAction(e) { const t = e._propertyBindings; for (let n = 0, r = t.length; n !== r; ++n) { const s = t[n]; --s.referenceCount === 0 && this._removeInactiveBinding(s) } } _lendAction(e) { const t = this._actions, n = e._cacheIndex, r = this._nActiveActions++, s = t[r]; e._cacheIndex = r, t[r] = e, s._cacheIndex = n, t[n] = s } _takeBackAction(e) { const t = this._actions, n = e._cacheIndex, r = --this._nActiveActions, s = t[r]; e._cacheIndex = r, t[r] = e, s._cacheIndex = n, t[n] = s } _addInactiveBinding(e, t, n) { const r = this._bindingsByRootAndName, s = this._bindings; let o = r[t]; o === void 0 && (o = {}, r[t] = o), o[n] = e, e._cacheIndex = s.length, s.push(e) } _removeInactiveBinding(e) { const t = this._bindings, n = e.binding, r = n.rootNode.uuid, s = n.path, o = this._bindingsByRootAndName, a = o[r], l = t[t.length - 1], c = e._cacheIndex; l._cacheIndex = c, t[c] = l, t.pop(), delete a[s], Object.keys(a).length === 0 && delete o[r] } _lendBinding(e) { const t = this._bindings, n = e._cacheIndex, r = this._nActiveBindings++, s = t[r]; e._cacheIndex = r, t[r] = e, s._cacheIndex = n, t[n] = s } _takeBackBinding(e) { const t = this._bindings, n = e._cacheIndex, r = --this._nActiveBindings, s = t[r]; e._cacheIndex = r, t[r] = e, s._cacheIndex = n, t[n] = s } _lendControlInterpolant() { const e = this._controlInterpolants, t = this._nActiveControlInterpolants++; let n = e[t]; return n === void 0 && (n = new GE(new Float32Array(2), new Float32Array(2), 1, Y7), n.__cacheIndex = t, e[t] = n), n } _takeBackControlInterpolant(e) { const t = this._controlInterpolants, n = e.__cacheIndex, r = --this._nActiveControlInterpolants, s = t[r]; e.__cacheIndex = r, t[r] = e, s.__cacheIndex = n, t[n] = s } clipAction(e, t, n) { const r = t || this._root, s = r.uuid; let o = typeof e == "string" ? wh.findByName(r, e) : e; const a = o !== null ? o.uuid : e, l = this._actionsByClip[a]; let c = null; if (n === void 0 && (o !== null ? n = o.blendMode : n = Nv), l !== void 0) { const d = l.actionByRoot[s]; if (d !== void 0 && d.blendMode === n) return d; c = l.knownActions[0], o === null && (o = c._clip) } if (o === null) return null; const f = new xk(this, o, t, n); return this._bindAction(f, c), this._addInactiveAction(f, a, s), f } existingAction(e, t) { const n = t || this._root, r = n.uuid, s = typeof e == "string" ? wh.findByName(n, e) : e, o = s ? s.uuid : e, a = this._actionsByClip[o]; return a !== void 0 && a.actionByRoot[r] || null } stopAllAction() { const e = this._actions, t = this._nActiveActions; for (let n = t - 1; n >= 0; --n)e[n].stop(); return this } update(e) { e *= this.timeScale; const t = this._actions, n = this._nActiveActions, r = this.time += e, s = Math.sign(e), o = this._accuIndex ^= 1; for (let c = 0; c !== n; ++c)t[c]._update(r, e, s, o); const a = this._bindings, l = this._nActiveBindings; for (let c = 0; c !== l; ++c)a[c].apply(o); return this } setTime(e) { this.time = 0; for (let t = 0; t < this._actions.length; t++)this._actions[t].time = 0; return this.update(e) } getRoot() { return this._root } uncacheClip(e) { const t = this._actions, n = e.uuid, r = this._actionsByClip, s = r[n]; if (s !== void 0) { const o = s.knownActions; for (let a = 0, l = o.length; a !== l; ++a) { const c = o[a]; this._deactivateAction(c); const f = c._cacheIndex, d = t[t.length - 1]; c._cacheIndex = null, c._byClipCacheIndex = null, d._cacheIndex = f, t[f] = d, t.pop(), this._removeInactiveBindingsForAction(c) } delete r[n] } } uncacheRoot(e) { const t = e.uuid, n = this._actionsByClip; for (const o in n) { const a = n[o].actionByRoot, l = a[t]; l !== void 0 && (this._deactivateAction(l), this._removeInactiveAction(l)) } const r = this._bindingsByRootAndName, s = r[t]; if (s !== void 0) for (const o in s) { const a = s[o]; a.restoreOriginalState(), this._removeInactiveBinding(a) } } uncacheAction(e, t) { const n = this.existingAction(e, t); n !== null && (this._deactivateAction(n), this._removeInactiveAction(n)) } } class $E { constructor(e) { this.value = e } clone() { return new $E(this.value.clone === void 0 ? this.value : this.value.clone()) } } let K7 = 0; class q7 extends Ko { constructor() { super(), this.isUniformsGroup = !0, Object.defineProperty(this, "id", { value: K7++ }), this.name = "", this.usage = zp, this.uniforms = [] } add(e) { return this.uniforms.push(e), this } remove(e) { const t = this.uniforms.indexOf(e); return t !== -1 && this.uniforms.splice(t, 1), this } setName(e) { return this.name = e, this } setUsage(e) { return this.usage = e, this } dispose() { return this.dispatchEvent({ type: "dispose" }), this } copy(e) { this.name = e.name, this.usage = e.usage; const t = e.uniforms; this.uniforms.length = 0; for (let n = 0, r = t.length; n < r; n++)this.uniforms.push(t[n].clone()); return this } clone() { return new this.constructor().copy(this) } } class Q7 extends um { constructor(e, t, n = 1) { super(e, t), this.isInstancedInterleavedBuffer = !0, this.meshPerAttribute = n } copy(e) { return super.copy(e), this.meshPerAttribute = e.meshPerAttribute, this } clone(e) { const t = super.clone(e); return t.meshPerAttribute = this.meshPerAttribute, t } toJSON(e) { const t = super.toJSON(e); return t.isInstancedInterleavedBuffer = !0, t.meshPerAttribute = this.meshPerAttribute, t } } class Z7 { constructor(e, t, n, r, s) { this.isGLBufferAttribute = !0, this.name = "", this.buffer = e, this.type = t, this.itemSize = n, this.elementSize = r, this.count = s, this.version = 0 } set needsUpdate(e) { e === !0 && this.version++ } setBuffer(e) { return this.buffer = e, this } setType(e, t) { return this.type = e, this.elementSize = t, this } setItemSize(e) { return this.itemSize = e, this } setCount(e) { return this.count = e, this } } class Ak { constructor(e, t, n = 0, r = 1 / 0) { this.ray = new Ph(e, t), this.near = n, this.far = r, this.camera = null, this.layers = new jc, this.params = { Mesh: {}, Line: { threshold: 1 }, LOD: {}, Points: { threshold: 1 }, Sprite: {} } } set(e, t) { this.ray.set(e, t) } setFromCamera(e, t) { t.isPerspectiveCamera ? (this.ray.origin.setFromMatrixPosition(t.matrixWorld), this.ray.direction.set(e.x, e.y, .5).unproject(t).sub(this.ray.origin).normalize(), this.camera = t) : t.isOrthographicCamera ? (this.ray.origin.set(e.x, e.y, (t.near + t.far) / (t.near - t.far)).unproject(t), this.ray.direction.set(0, 0, -1).transformDirection(t.matrixWorld), this.camera = t) : console.error("THREE.Raycaster: Unsupported camera type: " + t.type) } intersectObject(e, t = !0, n = []) { return ES(e, this, n, t), n.sort(pI), n } intersectObjects(e, t = !0, n = []) { for (let r = 0, s = e.length; r < s; r++)ES(e[r], this, n, t); return n.sort(pI), n } } function pI(i, e) { return i.distance - e.distance } function ES(i, e, t, n) { if (i.layers.test(e.layers) && i.raycast(e, t), n === !0) { const r = i.children; for (let s = 0, o = r.length; s < o; s++)ES(r[s], e, t, !0) } } class CS { constructor(e = 1, t = 0, n = 0) { return this.radius = e, this.phi = t, this.theta = n, this } set(e, t, n) { return this.radius = e, this.phi = t, this.theta = n, this } copy(e) { return this.radius = e.radius, this.phi = e.phi, this.theta = e.theta, this } makeSafe() { return this.phi = Math.max(1e-6, Math.min(Math.PI - 1e-6, this.phi)), this } setFromVector3(e) { return this.setFromCartesianCoords(e.x, e.y, e.z) } setFromCartesianCoords(e, t, n) { return this.radius = Math.sqrt(e * e + t * t + n * n), this.radius === 0 ? (this.theta = 0, this.phi = 0) : (this.theta = Math.atan2(e, n), this.phi = Math.acos(Gn(t / this.radius, -1, 1))), this } clone() { return new this.constructor().copy(this) } } class $7 { constructor(e = 1, t = 0, n = 0) { return this.radius = e, this.theta = t, this.y = n, this } set(e, t, n) { return this.radius = e, this.theta = t, this.y = n, this } copy(e) { return this.radius = e.radius, this.theta = e.theta, this.y = e.y, this } setFromVector3(e) { return this.setFromCartesianCoords(e.x, e.y, e.z) } setFromCartesianCoords(e, t, n) { return this.radius = Math.sqrt(e * e + n * n), this.theta = Math.atan2(e, n), this.y = t, this } clone() { return new this.constructor().copy(this) } } const mI = new _e; class eK { constructor(e = new _e(1 / 0, 1 / 0), t = new _e(-1 / 0, -1 / 0)) { this.isBox2 = !0, this.min = e, this.max = t } set(e, t) { return this.min.copy(e), this.max.copy(t), this } setFromPoints(e) { this.makeEmpty(); for (let t = 0, n = e.length; t < n; t++)this.expandByPoint(e[t]); return this } setFromCenterAndSize(e, t) { const n = mI.copy(t).multiplyScalar(.5); return this.min.copy(e).sub(n), this.max.copy(e).add(n), this } clone() { return new this.constructor().copy(this) } copy(e) { return this.min.copy(e.min), this.max.copy(e.max), this } makeEmpty() { return this.min.x = this.min.y = 1 / 0, this.max.x = this.max.y = -1 / 0, this } isEmpty() { return this.max.x < this.min.x || this.max.y < this.min.y } getCenter(e) { return this.isEmpty() ? e.set(0, 0) : e.addVectors(this.min, this.max).multiplyScalar(.5) } getSize(e) { return this.isEmpty() ? e.set(0, 0) : e.subVectors(this.max, this.min) } expandByPoint(e) { return this.min.min(e), this.max.max(e), this } expandByVector(e) { return this.min.sub(e), this.max.add(e), this } expandByScalar(e) { return this.min.addScalar(-e), this.max.addScalar(e), this } containsPoint(e) { return !(e.x < this.min.x || e.x > this.max.x || e.y < this.min.y || e.y > this.max.y) } containsBox(e) { return this.min.x <= e.min.x && e.max.x <= this.max.x && this.min.y <= e.min.y && e.max.y <= this.max.y } getParameter(e, t) { return t.set((e.x - this.min.x) / (this.max.x - this.min.x), (e.y - this.min.y) / (this.max.y - this.min.y)) } intersectsBox(e) { return !(e.max.x < this.min.x || e.min.x > this.max.x || e.max.y < this.min.y || e.min.y > this.max.y) } clampPoint(e, t) { return t.copy(e).clamp(this.min, this.max) } distanceToPoint(e) { return this.clampPoint(e, mI).distanceTo(e) } intersect(e) { return this.min.max(e.min), this.max.min(e.max), this.isEmpty() && this.makeEmpty(), this } union(e) { return this.min.min(e.min), this.max.max(e.max), this } translate(e) { return this.min.add(e), this.max.add(e), this } equals(e) { return e.min.equals(this.min) && e.max.equals(this.max) } } const gI = new k, w0 = new k; class tK { constructor(e = new k, t = new k) { this.start = e, this.end = t } set(e, t) { return this.start.copy(e), this.end.copy(t), this } copy(e) { return this.start.copy(e.start), this.end.copy(e.end), this } getCenter(e) { return e.addVectors(this.start, this.end).multiplyScalar(.5) } delta(e) { return e.subVectors(this.end, this.start) } distanceSq() { return this.start.distanceToSquared(this.end) } distance() { return this.start.distanceTo(this.end) } at(e, t) { return this.delta(t).multiplyScalar(e).add(this.start) } closestPointToPointParameter(e, t) { gI.subVectors(e, this.start), w0.subVectors(this.end, this.start); const n = w0.dot(w0); let s = w0.dot(gI) / n; return t && (s = Gn(s, 0, 1)), s } closestPointToPoint(e, t, n) { const r = this.closestPointToPointParameter(e, t); return this.delta(n).multiplyScalar(r).add(this.start) } applyMatrix4(e) { return this.start.applyMatrix4(e), this.end.applyMatrix4(e), this } equals(e) { return e.start.equals(this.start) && e.end.equals(this.end) } clone() { return new this.constructor().copy(this) } } const yI = new k; class nK extends qt { constructor(e, t) { super(), this.light = e, this.matrix = e.matrixWorld, this.matrixAutoUpdate = !1, this.color = t, this.type = "SpotLightHelper"; const n = new Rt, r = [0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 1, 0, 0, 0, -1, 0, 1, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, -1, 1]; for (let o = 0, a = 1, l = 32; o < l; o++, a++) { const c = o / l * Math.PI * 2, f = a / l * Math.PI * 2; r.push(Math.cos(c), Math.sin(c), 1, Math.cos(f), Math.sin(f), 1) } n.setAttribute("position", new rt(r, 3)); const s = new ir({ fog: !1, toneMapped: !1 }); this.cone = new vo(n, s), this.add(this.cone), this.update() } dispose() { this.cone.geometry.dispose(), this.cone.material.dispose() } update() { this.light.updateWorldMatrix(!0, !1), this.light.target.updateWorldMatrix(!0, !1); const e = this.light.distance ? this.light.distance : 1e3, t = e * Math.tan(this.light.angle); this.cone.scale.set(t, t, e), yI.setFromMatrixPosition(this.light.target.matrixWorld), this.cone.lookAt(yI), this.color !== void 0 ? this.cone.material.color.set(this.color) : this.cone.material.color.copy(this.light.color) } } const Qa = new k, S0 = new yt, nM = new yt; class iK extends vo { constructor(e) { const t = Mk(e), n = new Rt, r = [], s = [], o = new We(0, 0, 1), a = new We(0, 1, 0); for (let c = 0; c < t.length; c++) { const f = t[c]; f.parent && f.parent.isBone && (r.push(0, 0, 0), r.push(0, 0, 0), s.push(o.r, o.g, o.b), s.push(a.r, a.g, a.b)) } n.setAttribute("position", new rt(r, 3)), n.setAttribute("color", new rt(s, 3)); const l = new ir({ vertexColors: !0, depthTest: !1, depthWrite: !1, toneMapped: !1, transparent: !0 }); super(n, l), this.isSkeletonHelper = !0, this.type = "SkeletonHelper", this.root = e, this.bones = t, this.matrix = e.matrixWorld, this.matrixAutoUpdate = !1 } updateMatrixWorld(e) { const t = this.bones, n = this.geometry, r = n.getAttribute("position"); nM.copy(this.root.matrixWorld).invert(); for (let s = 0, o = 0; s < t.length; s++) { const a = t[s]; a.parent && a.parent.isBone && (S0.multiplyMatrices(nM, a.matrixWorld), Qa.setFromMatrixPosition(S0), r.setXYZ(o, Qa.x, Qa.y, Qa.z), S0.multiplyMatrices(nM, a.parent.matrixWorld), Qa.setFromMatrixPosition(S0), r.setXYZ(o + 1, Qa.x, Qa.y, Qa.z), o += 2) } n.getAttribute("position").needsUpdate = !0, super.updateMatrixWorld(e) } dispose() { this.geometry.dispose(), this.material.dispose() } } function Mk(i) { const e = []; i.isBone === !0 && e.push(i); for (let t = 0; t < i.children.length; t++)e.push.apply(e, Mk(i.children[t])); return e } class rK extends Ei { constructor(e, t, n) { const r = new pm(t, 4, 2), s = new ts({ wireframe: !0, fog: !1, toneMapped: !1 }); super(r, s), this.light = e, this.color = n, this.type = "PointLightHelper", this.matrix = this.light.matrixWorld, this.matrixAutoUpdate = !1, this.update() } dispose() { this.geometry.dispose(), this.material.dispose() } update() { this.light.updateWorldMatrix(!0, !1), this.color !== void 0 ? this.material.color.set(this.color) : this.material.color.copy(this.light.color) } } const sK = new k, vI = new We, _I = new We; class oK extends qt { constructor(e, t, n) { super(), this.light = e, this.matrix = e.matrixWorld, this.matrixAutoUpdate = !1, this.color = n, this.type = "HemisphereLightHelper"; const r = new dm(t); r.rotateY(Math.PI * .5), this.material = new ts({ wireframe: !0, fog: !1, toneMapped: !1 }), this.color === void 0 && (this.material.vertexColors = !0); const s = r.getAttribute("position"), o = new Float32Array(s.count * 3); r.setAttribute("color", new rn(o, 3)), this.add(new Ei(r, this.material)), this.update() } dispose() { this.children[0].geometry.dispose(), this.children[0].material.dispose() } update() { const e = this.children[0]; if (this.color !== void 0) this.material.color.set(this.color); else { const t = e.geometry.getAttribute("color"); vI.copy(this.light.color), _I.copy(this.light.groundColor); for (let n = 0, r = t.count; n < r; n++) { const s = n < r / 2 ? vI : _I; t.setXYZ(n, s.r, s.g, s.b) } t.needsUpdate = !0 } this.light.updateWorldMatrix(!0, !1), e.lookAt(sK.setFromMatrixPosition(this.light.matrixWorld).negate()) } } class aK extends vo { constructor(e = 10, t = 10, n = 4473924, r = 8947848) { n = new We(n), r = new We(r); const s = t / 2, o = e / t, a = e / 2, l = [], c = []; for (let p = 0, m = 0, y = -a; p <= t; p++, y += o) { l.push(-a, 0, y, a, 0, y), l.push(y, 0, -a, y, 0, a); const _ = p === s ? n : r; _.toArray(c, m), m += 3, _.toArray(c, m), m += 3, _.toArray(c, m), m += 3, _.toArray(c, m), m += 3 } const f = new Rt; f.setAttribute("position", new rt(l, 3)), f.setAttribute("color", new rt(c, 3)); const d = new ir({ vertexColors: !0, toneMapped: !1 }); super(f, d), this.type = "GridHelper" } dispose() { this.geometry.dispose(), this.material.dispose() } } class lK extends vo { constructor(e = 10, t = 16, n = 8, r = 64, s = 4473924, o = 8947848) { s = new We(s), o = new We(o); const a = [], l = []; if (t > 1) for (let d = 0; d < t; d++) { const p = d / t * (Math.PI * 2), m = Math.sin(p) * e, y = Math.cos(p) * e; a.push(0, 0, 0), a.push(m, 0, y); const _ = d & 1 ? s : o; l.push(_.r, _.g, _.b), l.push(_.r, _.g, _.b) } for (let d = 0; d < n; d++) { const p = d & 1 ? s : o, m = e - e / n * d; for (let y = 0; y < r; y++) { let _ = y / r * (Math.PI * 2), x = Math.sin(_) * m, g = Math.cos(_) * m; a.push(x, 0, g), l.push(p.r, p.g, p.b), _ = (y + 1) / r * (Math.PI * 2), x = Math.sin(_) * m, g = Math.cos(_) * m, a.push(x, 0, g), l.push(p.r, p.g, p.b) } } const c = new Rt; c.setAttribute("position", new rt(a, 3)), c.setAttribute("color", new rt(l, 3)); const f = new ir({ vertexColors: !0, toneMapped: !1 }); super(c, f), this.type = "PolarGridHelper" } dispose() { this.geometry.dispose(), this.material.dispose() } } const xI = new k, E0 = new k, AI = new k; class cK extends qt { constructor(e, t, n) { super(), this.light = e, this.matrix = e.matrixWorld, this.matrixAutoUpdate = !1, this.color = n, this.type = "DirectionalLightHelper", t === void 0 && (t = 1); let r = new Rt; r.setAttribute("position", new rt([-t, t, 0, t, t, 0, t, -t, 0, -t, -t, 0, -t, t, 0], 3)); const s = new ir({ fog: !1, toneMapped: !1 }); this.lightPlane = new Oa(r, s), this.add(this.lightPlane), r = new Rt, r.setAttribute("position", new rt([0, 0, 0, 0, 0, 1], 3)), this.targetLine = new Oa(r, s), this.add(this.targetLine), this.update() } dispose() { this.lightPlane.geometry.dispose(), this.lightPlane.material.dispose(), this.targetLine.geometry.dispose(), this.targetLine.material.dispose() } update() { this.light.updateWorldMatrix(!0, !1), this.light.target.updateWorldMatrix(!0, !1), xI.setFromMatrixPosition(this.light.matrixWorld), E0.setFromMatrixPosition(this.light.target.matrixWorld), AI.subVectors(E0, xI), this.lightPlane.lookAt(E0), this.color !== void 0 ? (this.lightPlane.material.color.set(this.color), this.targetLine.material.color.set(this.color)) : (this.lightPlane.material.color.copy(this.light.color), this.targetLine.material.color.copy(this.light.color)), this.targetLine.lookAt(E0), this.targetLine.scale.z = AI.length() } } const C0 = new k, Nn = new am; class uK extends vo { constructor(e) { const t = new Rt, n = new ir({ color: 16777215, vertexColors: !0, toneMapped: !1 }), r = [], s = [], o = {}; a("n1", "n2"), a("n2", "n4"), a("n4", "n3"), a("n3", "n1"), a("f1", "f2"), a("f2", "f4"), a("f4", "f3"), a("f3", "f1"), a("n1", "f1"), a("n2", "f2"), a("n3", "f3"), a("n4", "f4"), a("p", "n1"), a("p", "n2"), a("p", "n3"), a("p", "n4"), a("u1", "u2"), a("u2", "u3"), a("u3", "u1"), a("c", "t"), a("p", "c"), a("cn1", "cn2"), a("cn3", "cn4"), a("cf1", "cf2"), a("cf3", "cf4"); function a(y, _) { l(y), l(_) } function l(y) { r.push(0, 0, 0), s.push(0, 0, 0), o[y] === void 0 && (o[y] = []), o[y].push(r.length / 3 - 1) } t.setAttribute("position", new rt(r, 3)), t.setAttribute("color", new rt(s, 3)), super(t, n), this.type = "CameraHelper", this.camera = e, this.camera.updateProjectionMatrix && this.camera.updateProjectionMatrix(), this.matrix = e.matrixWorld, this.matrixAutoUpdate = !1, this.pointMap = o, this.update(); const c = new We(16755200), f = new We(16711680), d = new We(43775), p = new We(16777215), m = new We(3355443); this.setColors(c, f, d, p, m) } setColors(e, t, n, r, s) { const a = this.geometry.getAttribute("color"); a.setXYZ(0, e.r, e.g, e.b), a.setXYZ(1, e.r, e.g, e.b), a.setXYZ(2, e.r, e.g, e.b), a.setXYZ(3, e.r, e.g, e.b), a.setXYZ(4, e.r, e.g, e.b), a.setXYZ(5, e.r, e.g, e.b), a.setXYZ(6, e.r, e.g, e.b), a.setXYZ(7, e.r, e.g, e.b), a.setXYZ(8, e.r, e.g, e.b), a.setXYZ(9, e.r, e.g, e.b), a.setXYZ(10, e.r, e.g, e.b), a.setXYZ(11, e.r, e.g, e.b), a.setXYZ(12, e.r, e.g, e.b), a.setXYZ(13, e.r, e.g, e.b), a.setXYZ(14, e.r, e.g, e.b), a.setXYZ(15, e.r, e.g, e.b), a.setXYZ(16, e.r, e.g, e.b), a.setXYZ(17, e.r, e.g, e.b), a.setXYZ(18, e.r, e.g, e.b), a.setXYZ(19, e.r, e.g, e.b), a.setXYZ(20, e.r, e.g, e.b), a.setXYZ(21, e.r, e.g, e.b), a.setXYZ(22, e.r, e.g, e.b), a.setXYZ(23, e.r, e.g, e.b), a.setXYZ(24, t.r, t.g, t.b), a.setXYZ(25, t.r, t.g, t.b), a.setXYZ(26, t.r, t.g, t.b), a.setXYZ(27, t.r, t.g, t.b), a.setXYZ(28, t.r, t.g, t.b), a.setXYZ(29, t.r, t.g, t.b), a.setXYZ(30, t.r, t.g, t.b), a.setXYZ(31, t.r, t.g, t.b), a.setXYZ(32, n.r, n.g, n.b), a.setXYZ(33, n.r, n.g, n.b), a.setXYZ(34, n.r, n.g, n.b), a.setXYZ(35, n.r, n.g, n.b), a.setXYZ(36, n.r, n.g, n.b), a.setXYZ(37, n.r, n.g, n.b), a.setXYZ(38, r.r, r.g, r.b), a.setXYZ(39, r.r, r.g, r.b), a.setXYZ(40, s.r, s.g, s.b), a.setXYZ(41, s.r, s.g, s.b), a.setXYZ(42, s.r, s.g, s.b), a.setXYZ(43, s.r, s.g, s.b), a.setXYZ(44, s.r, s.g, s.b), a.setXYZ(45, s.r, s.g, s.b), a.setXYZ(46, s.r, s.g, s.b), a.setXYZ(47, s.r, s.g, s.b), a.setXYZ(48, s.r, s.g, s.b), a.setXYZ(49, s.r, s.g, s.b), a.needsUpdate = !0 } update() { const e = this.geometry, t = this.pointMap, n = 1, r = 1; Nn.projectionMatrixInverse.copy(this.camera.projectionMatrixInverse), jn("c", t, e, Nn, 0, 0, -1), jn("t", t, e, Nn, 0, 0, 1), jn("n1", t, e, Nn, -n, -r, -1), jn("n2", t, e, Nn, n, -r, -1), jn("n3", t, e, Nn, -n, r, -1), jn("n4", t, e, Nn, n, r, -1), jn("f1", t, e, Nn, -n, -r, 1), jn("f2", t, e, Nn, n, -r, 1), jn("f3", t, e, Nn, -n, r, 1), jn("f4", t, e, Nn, n, r, 1), jn("u1", t, e, Nn, n * .7, r * 1.1, -1), jn("u2", t, e, Nn, -n * .7, r * 1.1, -1), jn("u3", t, e, Nn, 0, r * 2, -1), jn("cf1", t, e, Nn, -n, 0, 1), jn("cf2", t, e, Nn, n, 0, 1), jn("cf3", t, e, Nn, 0, -r, 1), jn("cf4", t, e, Nn, 0, r, 1), jn("cn1", t, e, Nn, -n, 0, -1), jn("cn2", t, e, Nn, n, 0, -1), jn("cn3", t, e, Nn, 0, -r, -1), jn("cn4", t, e, Nn, 0, r, -1), e.getAttribute("position").needsUpdate = !0 } dispose() { this.geometry.dispose(), this.material.dispose() } } function jn(i, e, t, n, r, s, o) { C0.set(r, s, o).unproject(n); const a = e[i]; if (a !== void 0) { const l = t.getAttribute("position"); for (let c = 0, f = a.length; c < f; c++)l.setXYZ(a[c], C0.x, C0.y, C0.z) } } const T0 = new yo; class fK extends vo { constructor(e, t = 16776960) { const n = new Uint16Array([0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7]), r = new Float32Array(8 * 3), s = new Rt; s.setIndex(new rn(n, 1)), s.setAttribute("position", new rn(r, 3)), super(s, new ir({ color: t, toneMapped: !1 })), this.object = e, this.type = "BoxHelper", this.matrixAutoUpdate = !1, this.update() } update(e) { if (e !== void 0 && console.warn("THREE.BoxHelper: .update() has no longer arguments."), this.object !== void 0 && T0.setFromObject(this.object), T0.isEmpty()) return; const t = T0.min, n = T0.max, r = this.geometry.attributes.position, s = r.array; s[0] = n.x, s[1] = n.y, s[2] = n.z, s[3] = t.x, s[4] = n.y, s[5] = n.z, s[6] = t.x, s[7] = t.y, s[8] = n.z, s[9] = n.x, s[10] = t.y, s[11] = n.z, s[12] = n.x, s[13] = n.y, s[14] = t.z, s[15] = t.x, s[16] = n.y, s[17] = t.z, s[18] = t.x, s[19] = t.y, s[20] = t.z, s[21] = n.x, s[22] = t.y, s[23] = t.z, r.needsUpdate = !0, this.geometry.computeBoundingSphere() } setFromObject(e) { return this.object = e, this.update(), this } copy(e, t) { return super.copy(e, t), this.object = e.object, this } dispose() { this.geometry.dispose(), this.material.dispose() } } class hK extends vo { constructor(e, t = 16776960) { const n = new Uint16Array([0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7]), r = [1, 1, 1, -1, 1, 1, -1, -1, 1, 1, -1, 1, 1, 1, -1, -1, 1, -1, -1, -1, -1, 1, -1, -1], s = new Rt; s.setIndex(new rn(n, 1)), s.setAttribute("position", new rt(r, 3)), super(s, new ir({ color: t, toneMapped: !1 })), this.box = e, this.type = "Box3Helper", this.geometry.computeBoundingSphere() } updateMatrixWorld(e) { const t = this.box; t.isEmpty() || (t.getCenter(this.position), t.getSize(this.scale), this.scale.multiplyScalar(.5), super.updateMatrixWorld(e)) } dispose() { this.geometry.dispose(), this.material.dispose() } } class dK extends Oa { constructor(e, t = 1, n = 16776960) { const r = n, s = [1, -1, 0, -1, 1, 0, -1, -1, 0, 1, 1, 0, -1, 1, 0, -1, -1, 0, 1, -1, 0, 1, 1, 0], o = new Rt; o.setAttribute("position", new rt(s, 3)), o.computeBoundingSphere(), super(o, new ir({ color: r, toneMapped: !1 })), this.type = "PlaneHelper", this.plane = e, this.size = t; const a = [1, 1, 0, -1, 1, 0, -1, -1, 0, 1, 1, 0, -1, -1, 0, 1, -1, 0], l = new Rt; l.setAttribute("position", new rt(a, 3)), l.computeBoundingSphere(), this.add(new Ei(l, new ts({ color: r, opacity: .2, transparent: !0, depthWrite: !1, toneMapped: !1 }))) } updateMatrixWorld(e) { this.position.set(0, 0, 0), this.scale.set(.5 * this.size, .5 * this.size, 1), this.lookAt(this.plane.normal), this.translateZ(-this.plane.constant), super.updateMatrixWorld(e) } dispose() { this.geometry.dispose(), this.material.dispose(), this.children[0].geometry.dispose(), this.children[0].material.dispose() } } const MI = new k; let b0, iM; class pK extends qt { constructor(e = new k(0, 0, 1), t = new k(0, 0, 0), n = 1, r = 16776960, s = n * .2, o = s * .2) { super(), this.type = "ArrowHelper", b0 === void 0 && (b0 = new Rt, b0.setAttribute("position", new rt([0, 0, 0, 0, 1, 0], 3)), iM = new Bh(0, .5, 1, 5, 1), iM.translate(0, -.5, 0)), this.position.copy(t), this.line = new Oa(b0, new ir({ color: r, toneMapped: !1 })), this.line.matrixAutoUpdate = !1, this.add(this.line), this.cone = new Ei(iM, new ts({ color: r, toneMapped: !1 })), this.cone.matrixAutoUpdate = !1, this.add(this.cone), this.setDirection(e), this.setLength(n, s, o) } setDirection(e) { if (e.y > .99999) this.quaternion.set(0, 0, 0, 1); else if (e.y < -.99999) this.quaternion.set(1, 0, 0, 0); else { MI.set(e.z, 0, -e.x).normalize(); const t = Math.acos(e.y); this.quaternion.setFromAxisAngle(MI, t) } } setLength(e, t = e * .2, n = t * .2) { this.line.scale.set(1, Math.max(1e-4, e - t), 1), this.line.updateMatrix(), this.cone.scale.set(n, t, n), this.cone.position.y = e, this.cone.updateMatrix() } setColor(e) { this.line.material.color.set(e), this.cone.material.color.set(e) } copy(e) { return super.copy(e, !1), this.line.copy(e.line), this.cone.copy(e.cone), this } dispose() { this.line.geometry.dispose(), this.line.material.dispose(), this.cone.geometry.dispose(), this.cone.material.dispose() } } class mK extends vo { constructor(e = 1) { const t = [0, 0, 0, e, 0, 0, 0, 0, 0, 0, e, 0, 0, 0, 0, 0, 0, e], n = [1, 0, 0, 1, .6, 0, 0, 1, 0, .6, 1, 0, 0, 0, 1, 0, .6, 1], r = new Rt; r.setAttribute("position", new rt(t, 3)), r.setAttribute("color", new rt(n, 3)); const s = new ir({ vertexColors: !0, toneMapped: !1 }); super(r, s), this.type = "AxesHelper" } setColors(e, t, n) { const r = new We, s = this.geometry.attributes.color.array; return r.set(e), r.toArray(s, 0), r.toArray(s, 3), r.set(t), r.toArray(s, 6), r.toArray(s, 9), r.set(n), r.toArray(s, 12), r.toArray(s, 15), this.geometry.attributes.color.needsUpdate = !0, this } dispose() { this.geometry.dispose(), this.material.dispose() } } class gK { constructor() { this.type = "ShapePath", this.color = new We, this.subPaths = [], this.currentPath = null } moveTo(e, t) { return this.currentPath = new Vp, this.subPaths.push(this.currentPath), this.currentPath.moveTo(e, t), this } lineTo(e, t) { return this.currentPath.lineTo(e, t), this } quadraticCurveTo(e, t, n, r) { return this.currentPath.quadraticCurveTo(e, t, n, r), this } bezierCurveTo(e, t, n, r, s, o) { return this.currentPath.bezierCurveTo(e, t, n, r, s, o), this } splineThru(e) { return this.currentPath.splineThru(e), this } toShapes(e) { function t(g) { const A = []; for (let M = 0, S = g.length; M < S; M++) { const C = g[M], T = new Kc; T.curves = C.curves, A.push(T) } return A } function n(g, A) { const M = A.length; let S = !1; for (let C = M - 1, T = 0; T < M; C = T++) { let R = A[C], B = A[T], b = B.x - R.x, I = B.y - R.y; if (Math.abs(I) > Number.EPSILON) { if (I < 0 && (R = A[T], b = -b, B = A[C], I = -I), g.y < R.y || g.y > B.y) continue; if (g.y === R.y) { if (g.x === R.x) return !0 } else { const N = I * (g.x - R.x) - b * (g.y - R.y); if (N === 0) return !0; if (N < 0) continue; S = !S } } else { if (g.y !== R.y) continue; if (B.x <= g.x && g.x <= R.x || R.x <= g.x && g.x <= B.x) return !0 } } return S } const r = Vo.isClockWise, s = this.subPaths; if (s.length === 0) return []; let o, a, l; const c = []; if (s.length === 1) return a = s[0], l = new Kc, l.curves = a.curves, c.push(l), c; let f = !r(s[0].getPoints()); f = e ? !f : f; const d = [], p = []; let m = [], y = 0, _; p[y] = void 0, m[y] = []; for (let g = 0, A = s.length; g < A; g++)a = s[g], _ = a.getPoints(), o = r(_), o = e ? !o : o, o ? (!f && p[y] && y++, p[y] = { s: new Kc, p: _ }, p[y].s.curves = a.curves, f && y++, m[y] = []) : m[y].push({ h: a, p: _[0] }); if (!p[0]) return t(s); if (p.length > 1) { let g = !1, A = 0; for (let M = 0, S = p.length; M < S; M++)d[M] = []; for (let M = 0, S = p.length; M < S; M++) { const C = m[M]; for (let T = 0; T < C.length; T++) { const R = C[T]; let B = !0; for (let b = 0; b < p.length; b++)n(R.p, p[b].p) && (M !== b && A++, B ? (B = !1, d[b].push(R)) : g = !0); B && d[M].push(R) } } A > 0 && g === !1 && (m = d) } let x; for (let g = 0, A = p.length; g < A; g++) { l = p[g].s, c.push(l), x = m[g]; for (let M = 0, S = x.length; M < S; M++)l.holes.push(x[M].h) } return c } } typeof __THREE_DEVTOOLS__ < "u" && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("register", { detail: { revision: rm } })); typeof window < "u" && (window.__THREE__ ? console.warn("WARNING: Multiple instances of Three.js being imported.") : window.__THREE__ = rm); const yK = Object.freeze(Object.defineProperty({ __proto__: null, ACESFilmicToneMapping: cE, AddEquation: Sc, AddOperation: WO, AdditiveAnimationBlendMode: gE, AdditiveBlending: Vw, AlphaFormat: QO, AlwaysCompare: _F, AlwaysDepth: kO, AlwaysStencilFunc: fF, AmbientLight: hk, AmbientLightProbe: P7, AnimationAction: xk, AnimationClip: wh, AnimationLoader: _7, AnimationMixer: j7, AnimationObjectGroup: J7, AnimationUtils: m7, ArcCurve: HF, ArrayCamera: OF, ArrowHelper: pK, Audio: vk, AudioAnalyser: F7, AudioContext: KE, AudioListener: L7, AudioLoader: b7, AxesHelper: mK, BackSide: _r, BasicDepthPacking: lF, BasicShadowMap: wO, Bone: Wv, BooleanKeyframeTrack: mu, Box2: eK, Box3: yo, Box3Helper: hK, BoxGeometry: pu, BoxHelper: fK, BufferAttribute: rn, BufferGeometry: Rt, BufferGeometryLoader: gk, ByteType: KO, Cache: uu, Camera: am, CameraHelper: uK, CanvasTexture: Uj, CapsuleGeometry: Kv, CatmullRomCurve3: GF, CineonToneMapping: YO, CircleGeometry: qv, ClampToEdgeWrapping: Di, Clock: qE, Color: We, ColorKeyframeTrack: VE, ColorManagement: As, CompressedArrayTexture: kj, CompressedCubeTexture: Nj, CompressedTexture: Jv, CompressedTextureLoader: x7, ConeGeometry: Qv, CubeCamera: TF, CubeReflectionMapping: Da, CubeRefractionMapping: Nl, CubeTexture: lm, CubeTextureLoader: A7, CubeUVReflectionMapping: Rh, CubicBezierCurve: OE, CubicBezierCurve3: VF, CubicInterpolant: ok, CullFaceBack: Gw, CullFaceFront: MO, CullFaceFrontBack: O8, CullFaceNone: AO, Curve: _o, CurvePath: XF, CustomBlending: SO, CustomToneMapping: jO, CylinderGeometry: Bh, Cylindrical: $7, Data3DTexture: ME, DataArrayTexture: Uv, DataTexture: Kf, DataTextureLoader: M7, DataUtils: WW, DecrementStencilOp: W8, DecrementWrapStencilOp: J8, DefaultLoadingManager: ck, DepthFormat: Rl, DepthStencilFormat: au, DepthTexture: FF, DirectionalLight: jE, DirectionalLightHelper: cK, DiscreteInterpolant: ak, DisplayP3ColorSpace: _E, DodecahedronGeometry: Zv, DoubleSide: ro, DstAlphaFactor: IO, DstColorFactor: LO, DynamicCopyUsage: aW, DynamicDrawUsage: tW, DynamicReadUsage: rW, EdgesGeometry: JF, EllipseCurve: Yv, EqualCompare: pF, EqualDepth: UO, EqualStencilFunc: q8, EquirectangularReflectionMapping: Fp, EquirectangularRefractionMapping: kp, Euler: om, EventDispatcher: Ko, ExtrudeGeometry: e_, FileLoader: ls, Float16BufferAttribute: qW, Float32BufferAttribute: rt, Float64BufferAttribute: QW, FloatType: Do, Fog: Vv, FogExp2: Gv, FramebufferTexture: Fj, FrontSide: Jo, Frustum: zv, GLBufferAttribute: Z7, GLSL1: cW, GLSL3: yS, GreaterCompare: gF, GreaterDepth: HO, GreaterEqualCompare: vF, GreaterEqualDepth: zO, GreaterEqualStencilFunc: eW, GreaterStencilFunc: Z8, GridHelper: aK, Group: Ma, HalfFloatType: gh, HemisphereLight: fk, HemisphereLightHelper: oK, HemisphereLightProbe: R7, IcosahedronGeometry: t_, ImageBitmapLoader: yk, ImageLoader: Yp, ImageUtils: AE, IncrementStencilOp: V8, IncrementWrapStencilOp: X8, InstancedBufferAttribute: xh, InstancedBufferGeometry: mk, InstancedInterleavedBuffer: Q7, InstancedMesh: IE, Int16BufferAttribute: jW, Int32BufferAttribute: KW, Int8BufferAttribute: XW, IntType: uE, InterleavedBuffer: um, InterleavedBufferAttribute: zl, Interpolant: Lh, InterpolateDiscrete: yh, InterpolateLinear: lu, InterpolateSmooth: cy, InvertStencilOp: Y8, KeepStencilOp: uy, KeyframeTrack: xo, LOD: zF, LatheGeometry: hm, Layers: jc, LessCompare: dF, LessDepth: NO, LessEqualCompare: mF, LessEqualDepth: nv, LessEqualStencilFunc: Q8, LessStencilFunc: K8, Light: jl, LightProbe: l_, Line: Oa, Line3: tK, LineBasicMaterial: ir, LineCurve: jv, LineCurve3: WF, LineDashedMaterial: rk, LineLoop: BE, LineSegments: vo, LinearEncoding: vE, LinearFilter: Pn, LinearInterpolant: GE, LinearMipMapLinearFilter: z8, LinearMipMapNearestFilter: U8, LinearMipmapLinearFilter: Yo, LinearMipmapNearestFilter: Fv, LinearSRGBColorSpace: po, LinearToneMapping: XO, Loader: rr, LoaderUtils: Wo, LoadingManager: WE, LoopOnce: rF, LoopPingPong: oF, LoopRepeat: sF, LuminanceAlphaFormat: $O, LuminanceFormat: ZO, MOUSE: Ac, Material: oi, MaterialLoader: c_, MathUtils: AF, Matrix3: Ot, Matrix4: yt, MaxEquation: Yw, Mesh: Ei, MeshBasicMaterial: ts, MeshDepthMaterial: CE, MeshDistanceMaterial: TE, MeshLambertMaterial: nk, MeshMatcapMaterial: ik, MeshNormalMaterial: tk, MeshPhongMaterial: $F, MeshPhysicalMaterial: qo, MeshStandardMaterial: mm, MeshToonMaterial: ek, MinEquation: Jw, MirroredRepeatWrapping: mh, MixOperation: VO, MultiplyBlending: Xw, MultiplyOperation: sm, NearestFilter: zn, NearestMipMapLinearFilter: N8, NearestMipMapNearestFilter: k8, NearestMipmapLinearFilter: Yf, NearestMipmapNearestFilter: Np, NeverCompare: hF, NeverDepth: FO, NeverStencilFunc: j8, NoBlending: Ea, NoColorSpace: Il, NoToneMapping: Ho, NormalAnimationBlendMode: Nv, NormalBlending: Jc, NotEqualCompare: yF, NotEqualDepth: GO, NotEqualStencilFunc: $8, NumberKeyframeTrack: Ah, Object3D: qt, ObjectLoader: C7, ObjectSpaceNormalMap: uF, OctahedronGeometry: dm, OneFactor: bO, OneMinusDstAlphaFactor: BO, OneMinusDstColorFactor: DO, OneMinusSrcAlphaFactor: lE, OneMinusSrcColorFactor: PO, OrthographicCamera: Ca, PCFShadowMap: Dv, PCFSoftShadowMap: rp, PMREMGenerator: _S, Path: Vp, PerspectiveCamera: Vn, Plane: il, PlaneGeometry: cm, PlaneHelper: dK, PointLight: YE, PointLightHelper: rK, Points: LE, PointsMaterial: Xv, PolarGridHelper: lK, PolyhedronGeometry: Yl, PositionalAudio: O7, PropertyBinding: Kt, PropertyMixer: _k, QuadraticBezierCurve: FE, QuadraticBezierCurve3: kE, Quaternion: Ti, QuaternionKeyframeTrack: Hl, QuaternionLinearInterpolant: lk, RED_GREEN_RGTC2_Format: mS, RED_RGTC1_Format: iF, REVISION: rm, RGBADepthPacking: cF, RGBAFormat: Pr, RGBAIntegerFormat: mE, RGBA_ASTC_10x10_Format: fS, RGBA_ASTC_10x5_Format: lS, RGBA_ASTC_10x6_Format: cS, RGBA_ASTC_10x8_Format: uS, RGBA_ASTC_12x10_Format: hS, RGBA_ASTC_12x12_Format: dS, RGBA_ASTC_4x4_Format: eS, RGBA_ASTC_5x4_Format: tS, RGBA_ASTC_5x5_Format: nS, RGBA_ASTC_6x5_Format: iS, RGBA_ASTC_6x6_Format: rS, RGBA_ASTC_8x5_Format: sS, RGBA_ASTC_8x6_Format: oS, RGBA_ASTC_8x8_Format: aS, RGBA_BPTC_Format: ly, RGBA_ETC2_EAC_Format: $w, RGBA_PVRTC_2BPPV1_Format: Qw, RGBA_PVRTC_4BPPV1_Format: qw, RGBA_S3TC_DXT1_Format: sy, RGBA_S3TC_DXT3_Format: oy, RGBA_S3TC_DXT5_Format: ay, RGB_ETC1_Format: nF, RGB_ETC2_Format: Zw, RGB_PVRTC_2BPPV1_Format: Kw, RGB_PVRTC_4BPPV1_Format: jw, RGB_S3TC_DXT1_Format: ry, RGFormat: tF, RGIntegerFormat: pE, RawShaderMaterial: ZF, Ray: Ph, Raycaster: Ak, RectAreaLight: dk, RedFormat: eF, RedIntegerFormat: dE, ReinhardToneMapping: JO, RenderTarget: wF, RepeatWrapping: Ul, ReplaceStencilOp: G8, ReverseSubtractEquation: CO, RingGeometry: n_, SIGNED_RED_GREEN_RGTC2_Format: gS, SIGNED_RED_RGTC1_Format: pS, SRGBColorSpace: bt, Scene: ov, ShaderChunk: Pt, ShaderLib: io, ShaderMaterial: jo, ShadowMaterial: QF, Shape: Kc, ShapeGeometry: i_, ShapePath: gK, ShapeUtils: Vo, ShortType: qO, Skeleton: fm, SkeletonHelper: iK, SkinnedMesh: PE, Source: Dc, Sphere: Gs, SphereGeometry: pm, Spherical: CS, SphericalHarmonics3: pk, SplineCurve: NE, SpotLight: JE, SpotLightHelper: nK, Sprite: UF, SpriteMaterial: RE, SrcAlphaFactor: aE, SrcAlphaSaturateFactor: OO, SrcColorFactor: RO, StaticCopyUsage: oW, StaticDrawUsage: zp, StaticReadUsage: iW, StereoCamera: I7, StreamCopyUsage: lW, StreamDrawUsage: nW, StreamReadUsage: sW, StringKeyframeTrack: gu, SubtractEquation: EO, SubtractiveBlending: Ww, TOUCH: Mc, TangentSpaceNormalMap: Jl, TetrahedronGeometry: r_, Texture: wn, TextureLoader: uk, TorusGeometry: s_, TorusKnotGeometry: o_, Triangle: br, TriangleFanDrawMode: iv, TriangleStripDrawMode: yE, TrianglesDrawMode: aF, TubeGeometry: a_, TwoPassDoubleSide: F8, UVMapping: Ov, Uint16BufferAttribute: wE, Uint32BufferAttribute: SE, Uint8BufferAttribute: JW, Uint8ClampedBufferAttribute: YW, Uniform: $E, UniformsGroup: q7, UniformsLib: He, UniformsUtils: CF, UnsignedByteType: Go, UnsignedInt248Type: bl, UnsignedIntType: Aa, UnsignedShort4444Type: fE, UnsignedShort5551Type: hE, UnsignedShortType: kv, VSMShadowMap: $s, Vector2: _e, Vector3: k, Vector4: on, VectorKeyframeTrack: Mh, VideoTexture: Oj, WebGL1Renderer: kF, WebGL3DRenderTarget: LW, WebGLArrayRenderTarget: BW, WebGLCoordinateSystem: Oo, WebGLCubeRenderTarget: bF, WebGLMultipleRenderTargets: DW, WebGLRenderTarget: mo, WebGLRenderer: bE, WebGLUtils: DF, WebGPUCoordinateSystem: Hp, WireframeGeometry: qF, WrapAroundEnding: Up, ZeroCurvatureEnding: Bc, ZeroFactor: TO, ZeroSlopeEnding: Lc, ZeroStencilOp: H8, _SRGBAFormat: rv, sRGBEncoding: Pl }, Symbol.toStringTag, { value: "Module" })); var wk = { exports: {} }, yu = {};/**
 * @license React
 * react-reconciler-constants.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */yu.ConcurrentRoot = 1; yu.ContinuousEventPriority = 4; yu.DefaultEventPriority = 16; yu.DiscreteEventPriority = 1; yu.IdleEventPriority = 536870912; yu.LegacyRoot = 0; wk.exports = yu; var Lf = wk.exports; function vK(i) { let e; const t = new Set, n = (c, f) => { const d = typeof c == "function" ? c(e) : c; if (d !== e) { const p = e; e = f ? d : Object.assign({}, e, d), t.forEach(m => m(e, p)) } }, r = () => e, s = (c, f = r, d = Object.is) => { console.warn("[DEPRECATED] Please use `subscribeWithSelector` middleware"); let p = f(e); function m() { const y = f(e); if (!d(p, y)) { const _ = p; c(p = y, _) } } return t.add(m), () => t.delete(m) }, l = { setState: n, getState: r, subscribe: (c, f, d) => f || d ? s(c, f, d) : (t.add(c), () => t.delete(c)), destroy: () => t.clear() }; return e = i(n, r, l), l } const _K = typeof window > "u" || !window.navigator || /ServerSideRendering|^Deno\//.test(window.navigator.userAgent), wI = _K ? ce.useEffect : ce.useLayoutEffect; function xK(i) { const e = typeof i == "function" ? vK(i) : i, t = (n = e.getState, r = Object.is) => { const [, s] = ce.useReducer(x => x + 1, 0), o = e.getState(), a = ce.useRef(o), l = ce.useRef(n), c = ce.useRef(r), f = ce.useRef(!1), d = ce.useRef(); d.current === void 0 && (d.current = n(o)); let p, m = !1; (a.current !== o || l.current !== n || c.current !== r || f.current) && (p = n(o), m = !r(d.current, p)), wI(() => { m && (d.current = p), a.current = o, l.current = n, c.current = r, f.current = !1 }); const y = ce.useRef(o); wI(() => { const x = () => { try { const A = e.getState(), M = l.current(A); c.current(d.current, M) || (a.current = A, d.current = M, s()) } catch { f.current = !0, s() } }, g = e.subscribe(x); return e.getState() !== y.current && x(), g }, []); const _ = m ? p : d.current; return ce.useDebugValue(_), _ }; return Object.assign(t, e), t[Symbol.iterator] = function () { console.warn("[useStore, api] = create() is deprecated and will be removed in v4"); const n = [t, e]; return { next() { const r = n.length <= 0; return { value: n.shift(), done: r } } } }, t } var Sk = { exports: {} }, Ek = { exports: {} }, Ck = {};/**
 * @license React
 * scheduler.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */(function (i) { function e(F, Y) { var L = F.length; F.push(Y); e: for (; 0 < L;) { var G = L - 1 >>> 1, K = F[G]; if (0 < r(K, Y)) F[G] = Y, F[L] = K, L = G; else break e } } function t(F) { return F.length === 0 ? null : F[0] } function n(F) { if (F.length === 0) return null; var Y = F[0], L = F.pop(); if (L !== Y) { F[0] = L; e: for (var G = 0, K = F.length, ye = K >>> 1; G < ye;) { var ge = 2 * (G + 1) - 1, xe = F[ge], Be = ge + 1, Ie = F[Be]; if (0 > r(xe, L)) Be < K && 0 > r(Ie, xe) ? (F[G] = Ie, F[Be] = L, G = Be) : (F[G] = xe, F[ge] = L, G = ge); else if (Be < K && 0 > r(Ie, L)) F[G] = Ie, F[Be] = L, G = Be; else break e } } return Y } function r(F, Y) { var L = F.sortIndex - Y.sortIndex; return L !== 0 ? L : F.id - Y.id } if (typeof performance == "object" && typeof performance.now == "function") { var s = performance; i.unstable_now = function () { return s.now() } } else { var o = Date, a = o.now(); i.unstable_now = function () { return o.now() - a } } var l = [], c = [], f = 1, d = null, p = 3, m = !1, y = !1, _ = !1, x = typeof setTimeout == "function" ? setTimeout : null, g = typeof clearTimeout == "function" ? clearTimeout : null, A = typeof setImmediate < "u" ? setImmediate : null; typeof navigator < "u" && navigator.scheduling !== void 0 && navigator.scheduling.isInputPending !== void 0 && navigator.scheduling.isInputPending.bind(navigator.scheduling); function M(F) { for (var Y = t(c); Y !== null;) { if (Y.callback === null) n(c); else if (Y.startTime <= F) n(c), Y.sortIndex = Y.expirationTime, e(l, Y); else break; Y = t(c) } } function S(F) { if (_ = !1, M(F), !y) if (t(l) !== null) y = !0, ne(C); else { var Y = t(c); Y !== null && Q(S, Y.startTime - F) } } function C(F, Y) { y = !1, _ && (_ = !1, g(B), B = -1), m = !0; var L = p; try { for (M(Y), d = t(l); d !== null && (!(d.expirationTime > Y) || F && !N());) { var G = d.callback; if (typeof G == "function") { d.callback = null, p = d.priorityLevel; var K = G(d.expirationTime <= Y); Y = i.unstable_now(), typeof K == "function" ? d.callback = K : d === t(l) && n(l), M(Y) } else n(l); d = t(l) } if (d !== null) var ye = !0; else { var ge = t(c); ge !== null && Q(S, ge.startTime - Y), ye = !1 } return ye } finally { d = null, p = L, m = !1 } } var T = !1, R = null, B = -1, b = 5, I = -1; function N() { return !(i.unstable_now() - I < b) } function V() { if (R !== null) { var F = i.unstable_now(); I = F; var Y = !0; try { Y = R(!0, F) } finally { Y ? J() : (T = !1, R = null) } } else T = !1 } var J; if (typeof A == "function") J = function () { A(V) }; else if (typeof MessageChannel < "u") { var j = new MessageChannel, q = j.port2; j.port1.onmessage = V, J = function () { q.postMessage(null) } } else J = function () { x(V, 0) }; function ne(F) { R = F, T || (T = !0, J()) } function Q(F, Y) { B = x(function () { F(i.unstable_now()) }, Y) } i.unstable_IdlePriority = 5, i.unstable_ImmediatePriority = 1, i.unstable_LowPriority = 4, i.unstable_NormalPriority = 3, i.unstable_Profiling = null, i.unstable_UserBlockingPriority = 2, i.unstable_cancelCallback = function (F) { F.callback = null }, i.unstable_continueExecution = function () { y || m || (y = !0, ne(C)) }, i.unstable_forceFrameRate = function (F) { 0 > F || 125 < F ? console.error("forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported") : b = 0 < F ? Math.floor(1e3 / F) : 5 }, i.unstable_getCurrentPriorityLevel = function () { return p }, i.unstable_getFirstCallbackNode = function () { return t(l) }, i.unstable_next = function (F) { switch (p) { case 1: case 2: case 3: var Y = 3; break; default: Y = p }var L = p; p = Y; try { return F() } finally { p = L } }, i.unstable_pauseExecution = function () { }, i.unstable_requestPaint = function () { }, i.unstable_runWithPriority = function (F, Y) { switch (F) { case 1: case 2: case 3: case 4: case 5: break; default: F = 3 }var L = p; p = F; try { return Y() } finally { p = L } }, i.unstable_scheduleCallback = function (F, Y, L) { var G = i.unstable_now(); switch (typeof L == "object" && L !== null ? (L = L.delay, L = typeof L == "number" && 0 < L ? G + L : G) : L = G, F) { case 1: var K = -1; break; case 2: K = 250; break; case 5: K = 1073741823; break; case 4: K = 1e4; break; default: K = 5e3 }return K = L + K, F = { id: f++, callback: Y, priorityLevel: F, startTime: L, expirationTime: K, sortIndex: -1 }, L > G ? (F.sortIndex = L, e(c, F), t(l) === null && F === t(c) && (_ ? (g(B), B = -1) : _ = !0, Q(S, L - G))) : (F.sortIndex = K, e(l, F), y || m || (y = !0, ne(C))), F }, i.unstable_shouldYield = N, i.unstable_wrapCallback = function (F) { var Y = p; return function () { var L = p; p = Y; try { return F.apply(this, arguments) } finally { p = L } } } })(Ck); Ek.exports = Ck; var TS = Ek.exports;/**
 * @license React
 * react-reconciler.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */var AK = function (e) {
	var t = {}, n = ce, r = TS, s = Object.assign; function o(u) { for (var h = "https://reactjs.org/docs/error-decoder.html?invariant=" + u, v = 1; v < arguments.length; v++)h += "&args[]=" + encodeURIComponent(arguments[v]); return "Minified React error #" + u + "; visit " + h + " for the full message or use the non-minified dev environment for full errors and additional helpful warnings." } var a = n.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED, l = Symbol.for("react.element"), c = Symbol.for("react.portal"), f = Symbol.for("react.fragment"), d = Symbol.for("react.strict_mode"), p = Symbol.for("react.profiler"), m = Symbol.for("react.provider"), y = Symbol.for("react.context"), _ = Symbol.for("react.forward_ref"), x = Symbol.for("react.suspense"), g = Symbol.for("react.suspense_list"), A = Symbol.for("react.memo"), M = Symbol.for("react.lazy"), S = Symbol.for("react.offscreen"), C = Symbol.iterator; function T(u) { return u === null || typeof u != "object" ? null : (u = C && u[C] || u["@@iterator"], typeof u == "function" ? u : null) } function R(u) { if (u == null) return null; if (typeof u == "function") return u.displayName || u.name || null; if (typeof u == "string") return u; switch (u) { case f: return "Fragment"; case c: return "Portal"; case p: return "Profiler"; case d: return "StrictMode"; case x: return "Suspense"; case g: return "SuspenseList" }if (typeof u == "object") switch (u.$$typeof) { case y: return (u.displayName || "Context") + ".Consumer"; case m: return (u._context.displayName || "Context") + ".Provider"; case _: var h = u.render; return u = u.displayName, u || (u = h.displayName || h.name || "", u = u !== "" ? "ForwardRef(" + u + ")" : "ForwardRef"), u; case A: return h = u.displayName || null, h !== null ? h : R(u.type) || "Memo"; case M: h = u._payload, u = u._init; try { return R(u(h)) } catch { } }return null } function B(u) { var h = u.type; switch (u.tag) { case 24: return "Cache"; case 9: return (h.displayName || "Context") + ".Consumer"; case 10: return (h._context.displayName || "Context") + ".Provider"; case 18: return "DehydratedFragment"; case 11: return u = h.render, u = u.displayName || u.name || "", h.displayName || (u !== "" ? "ForwardRef(" + u + ")" : "ForwardRef"); case 7: return "Fragment"; case 5: return h; case 4: return "Portal"; case 3: return "Root"; case 6: return "Text"; case 16: return R(h); case 8: return h === d ? "StrictMode" : "Mode"; case 22: return "Offscreen"; case 12: return "Profiler"; case 21: return "Scope"; case 13: return "Suspense"; case 19: return "SuspenseList"; case 25: return "TracingMarker"; case 1: case 0: case 17: case 2: case 14: case 15: if (typeof h == "function") return h.displayName || h.name || null; if (typeof h == "string") return h }return null } function b(u) { var h = u, v = u; if (u.alternate) for (; h.return;)h = h.return; else { u = h; do h = u, h.flags & 4098 && (v = h.return), u = h.return; while (u) } return h.tag === 3 ? v : null } function I(u) { if (b(u) !== u) throw Error(o(188)) } function N(u) { var h = u.alternate; if (!h) { if (h = b(u), h === null) throw Error(o(188)); return h !== u ? null : u } for (var v = u, w = h; ;) { var E = v.return; if (E === null) break; var P = E.alternate; if (P === null) { if (w = E.return, w !== null) { v = w; continue } break } if (E.child === P.child) { for (P = E.child; P;) { if (P === v) return I(E), u; if (P === w) return I(E), h; P = P.sibling } throw Error(o(188)) } if (v.return !== w.return) v = E, w = P; else { for (var z = !1, $ = E.child; $;) { if ($ === v) { z = !0, v = E, w = P; break } if ($ === w) { z = !0, w = E, v = P; break } $ = $.sibling } if (!z) { for ($ = P.child; $;) { if ($ === v) { z = !0, v = P, w = E; break } if ($ === w) { z = !0, w = P, v = E; break } $ = $.sibling } if (!z) throw Error(o(189)) } } if (v.alternate !== w) throw Error(o(190)) } if (v.tag !== 3) throw Error(o(188)); return v.stateNode.current === v ? u : h } function V(u) { return u = N(u), u !== null ? J(u) : null } function J(u) { if (u.tag === 5 || u.tag === 6) return u; for (u = u.child; u !== null;) { var h = J(u); if (h !== null) return h; u = u.sibling } return null } function j(u) { if (u.tag === 5 || u.tag === 6) return u; for (u = u.child; u !== null;) { if (u.tag !== 4) { var h = j(u); if (h !== null) return h } u = u.sibling } return null } var q = Array.isArray, ne = e.getPublicInstance, Q = e.getRootHostContext, F = e.getChildHostContext, Y = e.prepareForCommit, L = e.resetAfterCommit, G = e.createInstance, K = e.appendInitialChild, ye = e.finalizeInitialChildren, ge = e.prepareUpdate, xe = e.shouldSetTextContent, Be = e.createTextInstance, Ie = e.scheduleTimeout, Je = e.cancelTimeout, ut = e.noTimeout, Bt = e.isPrimaryRenderer, Ge = e.supportsMutation, H = e.supportsPersistence, pe = e.supportsHydration, fe = e.getInstanceFromNode, Ee = e.preparePortalMount, ve = e.getCurrentEventPriority, Z = e.detachDeletedInstance, Fe = e.supportsMicrotasks, Ve = e.scheduleMicrotask, st = e.supportsTestSelectors, ot = e.findFiberRoot, Yt = e.getBoundingRect, U = e.getTextContent, D = e.isHiddenSubtree, re = e.matchAccessibilityRole, Ae = e.setFocusIfFocusable, Me = e.setupIntersectionObserver, Ce = e.appendChild, qe = e.appendChildToContainer, Te = e.commitTextUpdate, oe = e.commitMount, X = e.commitUpdate, he = e.insertBefore, we = e.insertInContainerBefore, be = e.removeChild, De = e.removeChildFromContainer, lt = e.resetTextContent, vt = e.hideInstance, W = e.hideTextInstance, Oe = e.unhideInstance, se = e.unhideTextInstance, Se = e.clearContainer, ke = e.cloneInstance, St = e.createContainerChildSet, Qt = e.appendChildToContainerChildSet, $t = e.finalizeContainerChildren, ht = e.replaceContainerChildren, Ne = e.cloneHiddenInstance, At = e.cloneHiddenTextInstance, Lt = e.canHydrateInstance, je = e.canHydrateTextInstance, Ft = e.canHydrateSuspenseInstance, pt = e.isSuspenseInstancePending, _t = e.isSuspenseInstanceFallback, Sn = e.registerSuspenseInstanceRetry, Mt = e.getNextHydratableSibling, hn = e.getFirstHydratableChild, ai = e.getFirstHydratableChildWithinContainer, Jn = e.getFirstHydratableChildWithinSuspenseInstance, ln = e.hydrateInstance, O = e.hydrateTextInstance, ie = e.hydrateSuspenseInstance, ae = e.getNextHydratableInstanceAfterSuspenseInstance, te = e.commitHydratedContainer, ue = e.commitHydratedSuspenseInstance, Ue = e.clearSuspenseBoundary, Ke = e.clearSuspenseBoundaryFromContainer, nt = e.shouldDeleteUnhydratedTailInstances, ft = e.didNotMatchHydratedContainerTextInstance, wt = e.didNotMatchHydratedTextInstance, Qe; function Ze(u) {
		if (Qe === void 0) try { throw Error() } catch (v) { var h = v.stack.trim().match(/\n( *(at )?)/); Qe = h && h[1] || "" } return `
`+ Qe + u
	} var zt = !1; function sn(u, h) {
		if (!u || zt) return ""; zt = !0; var v = Error.prepareStackTrace; Error.prepareStackTrace = void 0; try { if (h) if (h = function () { throw Error() }, Object.defineProperty(h.prototype, "props", { set: function () { throw Error() } }), typeof Reflect == "object" && Reflect.construct) { try { Reflect.construct(h, []) } catch (Le) { var w = Le } Reflect.construct(u, [], h) } else { try { h.call() } catch (Le) { w = Le } u.call(h.prototype) } else { try { throw Error() } catch (Le) { w = Le } u() } } catch (Le) {
			if (Le && w && typeof Le.stack == "string") {
				for (var E = Le.stack.split(`
`), P = w.stack.split(`
`), z = E.length - 1, $ = P.length - 1; 1 <= z && 0 <= $ && E[z] !== P[$];)$--; for (; 1 <= z && 0 <= $; z--, $--)if (E[z] !== P[$]) {
					if (z !== 1 || $ !== 1) do if (z--, $--, 0 > $ || E[z] !== P[$]) {
						var me = `
`+ E[z].replace(" at new ", " at "); return u.displayName && me.includes("<anonymous>") && (me = me.replace("<anonymous>", u.displayName)), me
					} while (1 <= z && 0 <= $); break
				}
			}
		} finally { zt = !1, Error.prepareStackTrace = v } return (u = u ? u.displayName || u.name : "") ? Ze(u) : ""
	} var Ri = Object.prototype.hasOwnProperty, li = [], Nt = -1; function gt(u) { return { current: u } } function jt(u) { 0 > Nt || (u.current = li[Nt], li[Nt] = null, Nt--) } function dt(u, h) { Nt++, li[Nt] = u.current, u.current = h } var Ni = {}, ci = gt(Ni), Zn = gt(!1), Vs = Ni; function On(u, h) { var v = u.type.contextTypes; if (!v) return Ni; var w = u.stateNode; if (w && w.__reactInternalMemoizedUnmaskedChildContext === h) return w.__reactInternalMemoizedMaskedChildContext; var E = {}, P; for (P in v) E[P] = h[P]; return w && (u = u.stateNode, u.__reactInternalMemoizedUnmaskedChildContext = h, u.__reactInternalMemoizedMaskedChildContext = E), E } function Fn(u) { return u = u.childContextTypes, u != null } function ka() { jt(Zn), jt(ci) } function Ui(u, h, v) { if (ci.current !== Ni) throw Error(o(168)); dt(ci, h), dt(Zn, v) } function vu(u, h, v) { var w = u.stateNode; if (h = h.childContextTypes, typeof w.getChildContext != "function") return v; w = w.getChildContext(); for (var E in w) if (!(E in h)) throw Error(o(108, B(u) || "Unknown", E)); return s({}, v, w) } function _u(u) { return u = (u = u.stateNode) && u.__reactInternalMemoizedMergedChildContext || Ni, Vs = ci.current, dt(ci, u), dt(Zn, Zn.current), !0 } function Dh(u, h, v) { var w = u.stateNode; if (!w) throw Error(o(169)); v ? (u = vu(u, h, Vs), w.__reactInternalMemoizedMergedChildContext = u, jt(Zn), jt(ci), dt(ci, u)) : jt(Zn), dt(Zn, v) } var Ws = Math.clz32 ? Math.clz32 : $k, Qk = Math.log, Zk = Math.LN2; function $k(u) { return u >>>= 0, u === 0 ? 32 : 31 - (Qk(u) / Zk | 0) | 0 } var vm = 64, _m = 4194304; function Oh(u) { switch (u & -u) { case 1: return 1; case 2: return 2; case 4: return 4; case 8: return 8; case 16: return 16; case 32: return 32; case 64: case 128: case 256: case 512: case 1024: case 2048: case 4096: case 8192: case 16384: case 32768: case 65536: case 131072: case 262144: case 524288: case 1048576: case 2097152: return u & 4194240; case 4194304: case 8388608: case 16777216: case 33554432: case 67108864: return u & 130023424; case 134217728: return 134217728; case 268435456: return 268435456; case 536870912: return 536870912; case 1073741824: return 1073741824; default: return u } } function xm(u, h) { var v = u.pendingLanes; if (v === 0) return 0; var w = 0, E = u.suspendedLanes, P = u.pingedLanes, z = v & 268435455; if (z !== 0) { var $ = z & ~E; $ !== 0 ? w = Oh($) : (P &= z, P !== 0 && (w = Oh(P))) } else z = v & ~E, z !== 0 ? w = Oh(z) : P !== 0 && (w = Oh(P)); if (w === 0) return 0; if (h !== 0 && h !== w && !(h & E) && (E = w & -w, P = h & -h, E >= P || E === 16 && (P & 4194240) !== 0)) return h; if (w & 4 && (w |= v & 16), h = u.entangledLanes, h !== 0) for (u = u.entanglements, h &= w; 0 < h;)v = 31 - Ws(h), E = 1 << v, w |= u[v], h &= ~E; return w } function eN(u, h) { switch (u) { case 1: case 2: case 4: return h + 250; case 8: case 16: case 32: case 64: case 128: case 256: case 512: case 1024: case 2048: case 4096: case 8192: case 16384: case 32768: case 65536: case 131072: case 262144: case 524288: case 1048576: case 2097152: return h + 5e3; case 4194304: case 8388608: case 16777216: case 33554432: case 67108864: return -1; case 134217728: case 268435456: case 536870912: case 1073741824: return -1; default: return -1 } } function tN(u, h) { for (var v = u.suspendedLanes, w = u.pingedLanes, E = u.expirationTimes, P = u.pendingLanes; 0 < P;) { var z = 31 - Ws(P), $ = 1 << z, me = E[z]; me === -1 ? (!($ & v) || $ & w) && (E[z] = eN($, h)) : me <= h && (u.expiredLanes |= $), P &= ~$ } } function f_(u) { return u = u.pendingLanes & -1073741825, u !== 0 ? u : u & 1073741824 ? 1073741824 : 0 } function h_(u) { for (var h = [], v = 0; 31 > v; v++)h.push(u); return h } function Fh(u, h, v) { u.pendingLanes |= h, h !== 536870912 && (u.suspendedLanes = 0, u.pingedLanes = 0), u = u.eventTimes, h = 31 - Ws(h), u[h] = v } function nN(u, h) { var v = u.pendingLanes & ~h; u.pendingLanes = h, u.suspendedLanes = 0, u.pingedLanes = 0, u.expiredLanes &= h, u.mutableReadLanes &= h, u.entangledLanes &= h, h = u.entanglements; var w = u.eventTimes; for (u = u.expirationTimes; 0 < v;) { var E = 31 - Ws(v), P = 1 << E; h[E] = 0, w[E] = -1, u[E] = -1, v &= ~P } } function d_(u, h) { var v = u.entangledLanes |= h; for (u = u.entanglements; v;) { var w = 31 - Ws(v), E = 1 << w; E & h | u[w] & h && (u[w] |= h), v &= ~E } } var en = 0; function iC(u) { return u &= -u, 1 < u ? 4 < u ? u & 268435455 ? 16 : 536870912 : 4 : 1 } var p_ = r.unstable_scheduleCallback, rC = r.unstable_cancelCallback, iN = r.unstable_shouldYield, rN = r.unstable_requestPaint, yi = r.unstable_now, m_ = r.unstable_ImmediatePriority, sN = r.unstable_UserBlockingPriority, g_ = r.unstable_NormalPriority, oN = r.unstable_IdlePriority, Am = null, Ao = null; function aN(u) { if (Ao && typeof Ao.onCommitFiberRoot == "function") try { Ao.onCommitFiberRoot(Am, u, void 0, (u.current.flags & 128) === 128) } catch { } } function lN(u, h) { return u === h && (u !== 0 || 1 / u === 1 / h) || u !== u && h !== h } var Mo = typeof Object.is == "function" ? Object.is : lN, Qo = null, Mm = !1, y_ = !1; function sC(u) { Qo === null ? Qo = [u] : Qo.push(u) } function cN(u) { Mm = !0, sC(u) } function wo() { if (!y_ && Qo !== null) { y_ = !0; var u = 0, h = en; try { var v = Qo; for (en = 1; u < v.length; u++) { var w = v[u]; do w = w(!0); while (w !== null) } Qo = null, Mm = !1 } catch (E) { throw Qo !== null && (Qo = Qo.slice(u + 1)), p_(m_, wo), E } finally { en = h, y_ = !1 } } return null } var uN = a.ReactCurrentBatchConfig; function wm(u, h) { if (Mo(u, h)) return !0; if (typeof u != "object" || u === null || typeof h != "object" || h === null) return !1; var v = Object.keys(u), w = Object.keys(h); if (v.length !== w.length) return !1; for (w = 0; w < v.length; w++) { var E = v[w]; if (!Ri.call(h, E) || !Mo(u[E], h[E])) return !1 } return !0 } function fN(u) { switch (u.tag) { case 5: return Ze(u.type); case 16: return Ze("Lazy"); case 13: return Ze("Suspense"); case 19: return Ze("SuspenseList"); case 0: case 2: case 15: return u = sn(u.type, !1), u; case 11: return u = sn(u.type.render, !1), u; case 1: return u = sn(u.type, !0), u; default: return "" } } function Xs(u, h) { if (u && u.defaultProps) { h = s({}, h), u = u.defaultProps; for (var v in u) h[v] === void 0 && (h[v] = u[v]); return h } return h } var Sm = gt(null), Em = null, xu = null, v_ = null; function __() { v_ = xu = Em = null } function oC(u, h, v) { Bt ? (dt(Sm, h._currentValue), h._currentValue = v) : (dt(Sm, h._currentValue2), h._currentValue2 = v) } function x_(u) { var h = Sm.current; jt(Sm), Bt ? u._currentValue = h : u._currentValue2 = h } function A_(u, h, v) { for (; u !== null;) { var w = u.alternate; if ((u.childLanes & h) !== h ? (u.childLanes |= h, w !== null && (w.childLanes |= h)) : w !== null && (w.childLanes & h) !== h && (w.childLanes |= h), u === v) break; u = u.return } } function Au(u, h) { Em = u, v_ = xu = null, u = u.dependencies, u !== null && u.firstContext !== null && (u.lanes & h && (Gr = !0), u.firstContext = null) } function fs(u) { var h = Bt ? u._currentValue : u._currentValue2; if (v_ !== u) if (u = { context: u, memoizedValue: h, next: null }, xu === null) { if (Em === null) throw Error(o(308)); xu = u, Em.dependencies = { lanes: 0, firstContext: u } } else xu = xu.next = u; return h } var So = null, Na = !1; function M_(u) { u.updateQueue = { baseState: u.memoizedState, firstBaseUpdate: null, lastBaseUpdate: null, shared: { pending: null, interleaved: null, lanes: 0 }, effects: null } } function aC(u, h) { u = u.updateQueue, h.updateQueue === u && (h.updateQueue = { baseState: u.baseState, firstBaseUpdate: u.firstBaseUpdate, lastBaseUpdate: u.lastBaseUpdate, shared: u.shared, effects: u.effects }) } function Zo(u, h) { return { eventTime: u, lane: h, tag: 0, payload: null, callback: null, next: null } } function Ua(u, h) { var v = u.updateQueue; v !== null && (v = v.shared, $n !== null && u.mode & 1 && !(kt & 2) ? (u = v.interleaved, u === null ? (h.next = h, So === null ? So = [v] : So.push(v)) : (h.next = u.next, u.next = h), v.interleaved = h) : (u = v.pending, u === null ? h.next = h : (h.next = u.next, u.next = h), v.pending = h)) } function Cm(u, h, v) { if (h = h.updateQueue, h !== null && (h = h.shared, (v & 4194240) !== 0)) { var w = h.lanes; w &= u.pendingLanes, v |= w, h.lanes = v, d_(u, v) } } function lC(u, h) { var v = u.updateQueue, w = u.alternate; if (w !== null && (w = w.updateQueue, v === w)) { var E = null, P = null; if (v = v.firstBaseUpdate, v !== null) { do { var z = { eventTime: v.eventTime, lane: v.lane, tag: v.tag, payload: v.payload, callback: v.callback, next: null }; P === null ? E = P = z : P = P.next = z, v = v.next } while (v !== null); P === null ? E = P = h : P = P.next = h } else E = P = h; v = { baseState: w.baseState, firstBaseUpdate: E, lastBaseUpdate: P, shared: w.shared, effects: w.effects }, u.updateQueue = v; return } u = v.lastBaseUpdate, u === null ? v.firstBaseUpdate = h : u.next = h, v.lastBaseUpdate = h } function Tm(u, h, v, w) { var E = u.updateQueue; Na = !1; var P = E.firstBaseUpdate, z = E.lastBaseUpdate, $ = E.shared.pending; if ($ !== null) { E.shared.pending = null; var me = $, Le = me.next; me.next = null, z === null ? P = Le : z.next = Le, z = me; var et = u.alternate; et !== null && (et = et.updateQueue, $ = et.lastBaseUpdate, $ !== z && ($ === null ? et.firstBaseUpdate = Le : $.next = Le, et.lastBaseUpdate = me)) } if (P !== null) { var Et = E.baseState; z = 0, et = Le = me = null, $ = P; do { var mt = $.lane, cn = $.eventTime; if ((w & mt) === mt) { et !== null && (et = et.next = { eventTime: cn, lane: 0, tag: $.tag, payload: $.payload, callback: $.callback, next: null }); e: { var ct = u, Vi = $; switch (mt = h, cn = v, Vi.tag) { case 1: if (ct = Vi.payload, typeof ct == "function") { Et = ct.call(cn, Et, mt); break e } Et = ct; break e; case 3: ct.flags = ct.flags & -65537 | 128; case 0: if (ct = Vi.payload, mt = typeof ct == "function" ? ct.call(cn, Et, mt) : ct, mt == null) break e; Et = s({}, Et, mt); break e; case 2: Na = !0 } } $.callback !== null && $.lane !== 0 && (u.flags |= 64, mt = E.effects, mt === null ? E.effects = [$] : mt.push($)) } else cn = { eventTime: cn, lane: mt, tag: $.tag, payload: $.payload, callback: $.callback, next: null }, et === null ? (Le = et = cn, me = Et) : et = et.next = cn, z |= mt; if ($ = $.next, $ === null) { if ($ = E.shared.pending, $ === null) break; mt = $, $ = mt.next, mt.next = null, E.lastBaseUpdate = mt, E.shared.pending = null } } while (1); if (et === null && (me = Et), E.baseState = me, E.firstBaseUpdate = Le, E.lastBaseUpdate = et, h = E.shared.interleaved, h !== null) { E = h; do z |= E.lane, E = E.next; while (E !== h) } else P === null && (E.shared.lanes = 0); Pu |= z, u.lanes = z, u.memoizedState = Et } } function cC(u, h, v) { if (u = h.effects, h.effects = null, u !== null) for (h = 0; h < u.length; h++) { var w = u[h], E = w.callback; if (E !== null) { if (w.callback = null, w = v, typeof E != "function") throw Error(o(191, E)); E.call(w) } } } var uC = new n.Component().refs; function w_(u, h, v, w) { h = u.memoizedState, v = v(w, h), v = v == null ? h : s({}, h, v), u.memoizedState = v, u.lanes === 0 && (u.updateQueue.baseState = v) } var bm = { isMounted: function (u) { return (u = u._reactInternals) ? b(u) === u : !1 }, enqueueSetState: function (u, h, v) { u = u._reactInternals; var w = or(), E = Ga(u), P = Zo(w, E); P.payload = h, v != null && (P.callback = v), Ua(u, P), h = gs(u, E, w), h !== null && Cm(h, u, E) }, enqueueReplaceState: function (u, h, v) { u = u._reactInternals; var w = or(), E = Ga(u), P = Zo(w, E); P.tag = 1, P.payload = h, v != null && (P.callback = v), Ua(u, P), h = gs(u, E, w), h !== null && Cm(h, u, E) }, enqueueForceUpdate: function (u, h) { u = u._reactInternals; var v = or(), w = Ga(u), E = Zo(v, w); E.tag = 2, h != null && (E.callback = h), Ua(u, E), h = gs(u, w, v), h !== null && Cm(h, u, w) } }; function fC(u, h, v, w, E, P, z) { return u = u.stateNode, typeof u.shouldComponentUpdate == "function" ? u.shouldComponentUpdate(w, P, z) : h.prototype && h.prototype.isPureReactComponent ? !wm(v, w) || !wm(E, P) : !0 } function hC(u, h, v) { var w = !1, E = Ni, P = h.contextType; return typeof P == "object" && P !== null ? P = fs(P) : (E = Fn(h) ? Vs : ci.current, w = h.contextTypes, P = (w = w != null) ? On(u, E) : Ni), h = new h(v, P), u.memoizedState = h.state !== null && h.state !== void 0 ? h.state : null, h.updater = bm, u.stateNode = h, h._reactInternals = u, w && (u = u.stateNode, u.__reactInternalMemoizedUnmaskedChildContext = E, u.__reactInternalMemoizedMaskedChildContext = P), h } function dC(u, h, v, w) { u = h.state, typeof h.componentWillReceiveProps == "function" && h.componentWillReceiveProps(v, w), typeof h.UNSAFE_componentWillReceiveProps == "function" && h.UNSAFE_componentWillReceiveProps(v, w), h.state !== u && bm.enqueueReplaceState(h, h.state, null) } function S_(u, h, v, w) { var E = u.stateNode; E.props = v, E.state = u.memoizedState, E.refs = uC, M_(u); var P = h.contextType; typeof P == "object" && P !== null ? E.context = fs(P) : (P = Fn(h) ? Vs : ci.current, E.context = On(u, P)), E.state = u.memoizedState, P = h.getDerivedStateFromProps, typeof P == "function" && (w_(u, h, P, v), E.state = u.memoizedState), typeof h.getDerivedStateFromProps == "function" || typeof E.getSnapshotBeforeUpdate == "function" || typeof E.UNSAFE_componentWillMount != "function" && typeof E.componentWillMount != "function" || (h = E.state, typeof E.componentWillMount == "function" && E.componentWillMount(), typeof E.UNSAFE_componentWillMount == "function" && E.UNSAFE_componentWillMount(), h !== E.state && bm.enqueueReplaceState(E, E.state, null), Tm(u, v, E, w), E.state = u.memoizedState), typeof E.componentDidMount == "function" && (u.flags |= 4194308) } var Mu = [], wu = 0, Rm = null, Pm = 0, hs = [], ds = 0, Kl = null, $o = 1, ea = ""; function ql(u, h) { Mu[wu++] = Pm, Mu[wu++] = Rm, Rm = u, Pm = h } function pC(u, h, v) { hs[ds++] = $o, hs[ds++] = ea, hs[ds++] = Kl, Kl = u; var w = $o; u = ea; var E = 32 - Ws(w) - 1; w &= ~(1 << E), v += 1; var P = 32 - Ws(h) + E; if (30 < P) { var z = E - E % 5; P = (w & (1 << z) - 1).toString(32), w >>= z, E -= z, $o = 1 << 32 - Ws(h) + E | v << E | w, ea = P + u } else $o = 1 << P | v << E | w, ea = u } function E_(u) { u.return !== null && (ql(u, 1), pC(u, 1, 0)) } function C_(u) { for (; u === Rm;)Rm = Mu[--wu], Mu[wu] = null, Pm = Mu[--wu], Mu[wu] = null; for (; u === Kl;)Kl = hs[--ds], hs[ds] = null, ea = hs[--ds], hs[ds] = null, $o = hs[--ds], hs[ds] = null } var zr = null, Hr = null, An = !1, kh = !1, Js = null; function mC(u, h) { var v = ys(5, null, null, 0); v.elementType = "DELETED", v.stateNode = h, v.return = u, h = u.deletions, h === null ? (u.deletions = [v], u.flags |= 16) : h.push(v) } function gC(u, h) { switch (u.tag) { case 5: return h = Lt(h, u.type, u.pendingProps), h !== null ? (u.stateNode = h, zr = u, Hr = hn(h), !0) : !1; case 6: return h = je(h, u.pendingProps), h !== null ? (u.stateNode = h, zr = u, Hr = null, !0) : !1; case 13: if (h = Ft(h), h !== null) { var v = Kl !== null ? { id: $o, overflow: ea } : null; return u.memoizedState = { dehydrated: h, treeContext: v, retryLane: 1073741824 }, v = ys(18, null, null, 0), v.stateNode = h, v.return = u, u.child = v, zr = u, Hr = null, !0 } return !1; default: return !1 } } function T_(u) { return (u.mode & 1) !== 0 && (u.flags & 128) === 0 } function b_(u) { if (An) { var h = Hr; if (h) { var v = h; if (!gC(u, h)) { if (T_(u)) throw Error(o(418)); h = Mt(v); var w = zr; h && gC(u, h) ? mC(w, v) : (u.flags = u.flags & -4097 | 2, An = !1, zr = u) } } else { if (T_(u)) throw Error(o(418)); u.flags = u.flags & -4097 | 2, An = !1, zr = u } } } function yC(u) { for (u = u.return; u !== null && u.tag !== 5 && u.tag !== 3 && u.tag !== 13;)u = u.return; zr = u } function Nh(u) { if (!pe || u !== zr) return !1; if (!An) return yC(u), An = !0, !1; if (u.tag !== 3 && (u.tag !== 5 || nt(u.type) && !xe(u.type, u.memoizedProps))) { var h = Hr; if (h) { if (T_(u)) { for (u = Hr; u;)u = Mt(u); throw Error(o(418)) } for (; h;)mC(u, h), h = Mt(h) } } if (yC(u), u.tag === 13) { if (!pe) throw Error(o(316)); if (u = u.memoizedState, u = u !== null ? u.dehydrated : null, !u) throw Error(o(317)); Hr = ae(u) } else Hr = zr ? Mt(u.stateNode) : null; return !0 } function Su() { pe && (Hr = zr = null, kh = An = !1) } function R_(u) { Js === null ? Js = [u] : Js.push(u) } function Uh(u, h, v) { if (u = v.ref, u !== null && typeof u != "function" && typeof u != "object") { if (v._owner) { if (v = v._owner, v) { if (v.tag !== 1) throw Error(o(309)); var w = v.stateNode } if (!w) throw Error(o(147, u)); var E = w, P = "" + u; return h !== null && h.ref !== null && typeof h.ref == "function" && h.ref._stringRef === P ? h.ref : (h = function (z) { var $ = E.refs; $ === uC && ($ = E.refs = {}), z === null ? delete $[P] : $[P] = z }, h._stringRef = P, h) } if (typeof u != "string") throw Error(o(284)); if (!v._owner) throw Error(o(290, u)) } return u } function Im(u, h) { throw u = Object.prototype.toString.call(h), Error(o(31, u === "[object Object]" ? "object with keys {" + Object.keys(h).join(", ") + "}" : u)) } function vC(u) { var h = u._init; return h(u._payload) } function _C(u) { function h(le, ee) { if (u) { var de = le.deletions; de === null ? (le.deletions = [ee], le.flags |= 16) : de.push(ee) } } function v(le, ee) { if (!u) return null; for (; ee !== null;)h(le, ee), ee = ee.sibling; return null } function w(le, ee) { for (le = new Map; ee !== null;)ee.key !== null ? le.set(ee.key, ee) : le.set(ee.index, ee), ee = ee.sibling; return le } function E(le, ee) { return le = Wa(le, ee), le.index = 0, le.sibling = null, le } function P(le, ee, de) { return le.index = de, u ? (de = le.alternate, de !== null ? (de = de.index, de < ee ? (le.flags |= 2, ee) : de) : (le.flags |= 2, ee)) : (le.flags |= 1048576, ee) } function z(le) { return u && le.alternate === null && (le.flags |= 2), le } function $(le, ee, de, Ye) { return ee === null || ee.tag !== 6 ? (ee = hx(de, le.mode, Ye), ee.return = le, ee) : (ee = E(ee, de), ee.return = le, ee) } function me(le, ee, de, Ye) { var at = de.type; return at === f ? et(le, ee, de.props.children, Ye, de.key) : ee !== null && (ee.elementType === at || typeof at == "object" && at !== null && at.$$typeof === M && vC(at) === ee.type) ? (Ye = E(ee, de.props), Ye.ref = Uh(le, ee, de), Ye.return = le, Ye) : (Ye = lg(de.type, de.key, de.props, null, le.mode, Ye), Ye.ref = Uh(le, ee, de), Ye.return = le, Ye) } function Le(le, ee, de, Ye) { return ee === null || ee.tag !== 4 || ee.stateNode.containerInfo !== de.containerInfo || ee.stateNode.implementation !== de.implementation ? (ee = dx(de, le.mode, Ye), ee.return = le, ee) : (ee = E(ee, de.children || []), ee.return = le, ee) } function et(le, ee, de, Ye, at) { return ee === null || ee.tag !== 7 ? (ee = ic(de, le.mode, Ye, at), ee.return = le, ee) : (ee = E(ee, de), ee.return = le, ee) } function Et(le, ee, de) { if (typeof ee == "string" && ee !== "" || typeof ee == "number") return ee = hx("" + ee, le.mode, de), ee.return = le, ee; if (typeof ee == "object" && ee !== null) { switch (ee.$$typeof) { case l: return de = lg(ee.type, ee.key, ee.props, null, le.mode, de), de.ref = Uh(le, null, ee), de.return = le, de; case c: return ee = dx(ee, le.mode, de), ee.return = le, ee; case M: var Ye = ee._init; return Et(le, Ye(ee._payload), de) }if (q(ee) || T(ee)) return ee = ic(ee, le.mode, de, null), ee.return = le, ee; Im(le, ee) } return null } function mt(le, ee, de, Ye) { var at = ee !== null ? ee.key : null; if (typeof de == "string" && de !== "" || typeof de == "number") return at !== null ? null : $(le, ee, "" + de, Ye); if (typeof de == "object" && de !== null) { switch (de.$$typeof) { case l: return de.key === at ? me(le, ee, de, Ye) : null; case c: return de.key === at ? Le(le, ee, de, Ye) : null; case M: return at = de._init, mt(le, ee, at(de._payload), Ye) }if (q(de) || T(de)) return at !== null ? null : et(le, ee, de, Ye, null); Im(le, de) } return null } function cn(le, ee, de, Ye, at) { if (typeof Ye == "string" && Ye !== "" || typeof Ye == "number") return le = le.get(de) || null, $(ee, le, "" + Ye, at); if (typeof Ye == "object" && Ye !== null) { switch (Ye.$$typeof) { case l: return le = le.get(Ye.key === null ? de : Ye.key) || null, me(ee, le, Ye, at); case c: return le = le.get(Ye.key === null ? de : Ye.key) || null, Le(ee, le, Ye, at); case M: var Dt = Ye._init; return cn(le, ee, de, Dt(Ye._payload), at) }if (q(Ye) || T(Ye)) return le = le.get(de) || null, et(ee, le, Ye, at, null); Im(ee, Ye) } return null } function ct(le, ee, de, Ye) { for (var at = null, Dt = null, Ct = ee, tn = ee = 0, _i = null; Ct !== null && tn < de.length; tn++) { Ct.index > tn ? (_i = Ct, Ct = null) : _i = Ct.sibling; var nn = mt(le, Ct, de[tn], Ye); if (nn === null) { Ct === null && (Ct = _i); break } u && Ct && nn.alternate === null && h(le, Ct), ee = P(nn, ee, tn), Dt === null ? at = nn : Dt.sibling = nn, Dt = nn, Ct = _i } if (tn === de.length) return v(le, Ct), An && ql(le, tn), at; if (Ct === null) { for (; tn < de.length; tn++)Ct = Et(le, de[tn], Ye), Ct !== null && (ee = P(Ct, ee, tn), Dt === null ? at = Ct : Dt.sibling = Ct, Dt = Ct); return An && ql(le, tn), at } for (Ct = w(le, Ct); tn < de.length; tn++)_i = cn(Ct, le, tn, de[tn], Ye), _i !== null && (u && _i.alternate !== null && Ct.delete(_i.key === null ? tn : _i.key), ee = P(_i, ee, tn), Dt === null ? at = _i : Dt.sibling = _i, Dt = _i); return u && Ct.forEach(function (Xa) { return h(le, Xa) }), An && ql(le, tn), at } function Vi(le, ee, de, Ye) { var at = T(de); if (typeof at != "function") throw Error(o(150)); if (de = at.call(de), de == null) throw Error(o(151)); for (var Dt = at = null, Ct = ee, tn = ee = 0, _i = null, nn = de.next(); Ct !== null && !nn.done; tn++, nn = de.next()) { Ct.index > tn ? (_i = Ct, Ct = null) : _i = Ct.sibling; var Xa = mt(le, Ct, nn.value, Ye); if (Xa === null) { Ct === null && (Ct = _i); break } u && Ct && Xa.alternate === null && h(le, Ct), ee = P(Xa, ee, tn), Dt === null ? at = Xa : Dt.sibling = Xa, Dt = Xa, Ct = _i } if (nn.done) return v(le, Ct), An && ql(le, tn), at; if (Ct === null) { for (; !nn.done; tn++, nn = de.next())nn = Et(le, nn.value, Ye), nn !== null && (ee = P(nn, ee, tn), Dt === null ? at = nn : Dt.sibling = nn, Dt = nn); return An && ql(le, tn), at } for (Ct = w(le, Ct); !nn.done; tn++, nn = de.next())nn = cn(Ct, le, tn, nn.value, Ye), nn !== null && (u && nn.alternate !== null && Ct.delete(nn.key === null ? tn : nn.key), ee = P(nn, ee, tn), Dt === null ? at = nn : Dt.sibling = nn, Dt = nn); return u && Ct.forEach(function (HN) { return h(le, HN) }), An && ql(le, tn), at } function vs(le, ee, de, Ye) { if (typeof de == "object" && de !== null && de.type === f && de.key === null && (de = de.props.children), typeof de == "object" && de !== null) { switch (de.$$typeof) { case l: e: { for (var at = de.key, Dt = ee; Dt !== null;) { if (Dt.key === at) { if (at = de.type, at === f) { if (Dt.tag === 7) { v(le, Dt.sibling), ee = E(Dt, de.props.children), ee.return = le, le = ee; break e } } else if (Dt.elementType === at || typeof at == "object" && at !== null && at.$$typeof === M && vC(at) === Dt.type) { v(le, Dt.sibling), ee = E(Dt, de.props), ee.ref = Uh(le, Dt, de), ee.return = le, le = ee; break e } v(le, Dt); break } else h(le, Dt); Dt = Dt.sibling } de.type === f ? (ee = ic(de.props.children, le.mode, Ye, de.key), ee.return = le, le = ee) : (Ye = lg(de.type, de.key, de.props, null, le.mode, Ye), Ye.ref = Uh(le, ee, de), Ye.return = le, le = Ye) } return z(le); case c: e: { for (Dt = de.key; ee !== null;) { if (ee.key === Dt) if (ee.tag === 4 && ee.stateNode.containerInfo === de.containerInfo && ee.stateNode.implementation === de.implementation) { v(le, ee.sibling), ee = E(ee, de.children || []), ee.return = le, le = ee; break e } else { v(le, ee); break } else h(le, ee); ee = ee.sibling } ee = dx(de, le.mode, Ye), ee.return = le, le = ee } return z(le); case M: return Dt = de._init, vs(le, ee, Dt(de._payload), Ye) }if (q(de)) return ct(le, ee, de, Ye); if (T(de)) return Vi(le, ee, de, Ye); Im(le, de) } return typeof de == "string" && de !== "" || typeof de == "number" ? (de = "" + de, ee !== null && ee.tag === 6 ? (v(le, ee.sibling), ee = E(ee, de), ee.return = le, le = ee) : (v(le, ee), ee = hx(de, le.mode, Ye), ee.return = le, le = ee), z(le)) : v(le, ee) } return vs } var Eu = _C(!0), xC = _C(!1), zh = {}, ps = gt(zh), Hh = gt(zh), Cu = gt(zh); function Eo(u) { if (u === zh) throw Error(o(174)); return u } function P_(u, h) { dt(Cu, h), dt(Hh, u), dt(ps, zh), u = Q(h), jt(ps), dt(ps, u) } function Tu() { jt(ps), jt(Hh), jt(Cu) } function AC(u) { var h = Eo(Cu.current), v = Eo(ps.current); h = F(v, u.type, h), v !== h && (dt(Hh, u), dt(ps, h)) } function I_(u) { Hh.current === u && (jt(ps), jt(Hh)) } var En = gt(0); function Bm(u) { for (var h = u; h !== null;) { if (h.tag === 13) { var v = h.memoizedState; if (v !== null && (v = v.dehydrated, v === null || pt(v) || _t(v))) return h } else if (h.tag === 19 && h.memoizedProps.revealOrder !== void 0) { if (h.flags & 128) return h } else if (h.child !== null) { h.child.return = h, h = h.child; continue } if (h === u) break; for (; h.sibling === null;) { if (h.return === null || h.return === u) return null; h = h.return } h.sibling.return = h.return, h = h.sibling } return null } var B_ = []; function L_() { for (var u = 0; u < B_.length; u++) { var h = B_[u]; Bt ? h._workInProgressVersionPrimary = null : h._workInProgressVersionSecondary = null } B_.length = 0 } var Lm = a.ReactCurrentDispatcher, ms = a.ReactCurrentBatchConfig, bu = 0, kn = null, zi = null, vi = null, Dm = !1, Gh = !1, Vh = 0, hN = 0; function Hi() { throw Error(o(321)) } function D_(u, h) { if (h === null) return !1; for (var v = 0; v < h.length && v < u.length; v++)if (!Mo(u[v], h[v])) return !1; return !0 } function O_(u, h, v, w, E, P) { if (bu = P, kn = h, h.memoizedState = null, h.updateQueue = null, h.lanes = 0, Lm.current = u === null || u.memoizedState === null ? gN : yN, u = v(w, E), Gh) { P = 0; do { if (Gh = !1, Vh = 0, 25 <= P) throw Error(o(301)); P += 1, vi = zi = null, h.updateQueue = null, Lm.current = vN, u = v(w, E) } while (Gh) } if (Lm.current = Um, h = zi !== null && zi.next !== null, bu = 0, vi = zi = kn = null, Dm = !1, h) throw Error(o(300)); return u } function F_() { var u = Vh !== 0; return Vh = 0, u } function ta() { var u = { memoizedState: null, baseState: null, baseQueue: null, queue: null, next: null }; return vi === null ? kn.memoizedState = vi = u : vi = vi.next = u, vi } function Co() { if (zi === null) { var u = kn.alternate; u = u !== null ? u.memoizedState : null } else u = zi.next; var h = vi === null ? kn.memoizedState : vi.next; if (h !== null) vi = h, zi = u; else { if (u === null) throw Error(o(310)); zi = u, u = { memoizedState: zi.memoizedState, baseState: zi.baseState, baseQueue: zi.baseQueue, queue: zi.queue, next: null }, vi === null ? kn.memoizedState = vi = u : vi = vi.next = u } return vi } function Ql(u, h) { return typeof h == "function" ? h(u) : h } function Om(u) { var h = Co(), v = h.queue; if (v === null) throw Error(o(311)); v.lastRenderedReducer = u; var w = zi, E = w.baseQueue, P = v.pending; if (P !== null) { if (E !== null) { var z = E.next; E.next = P.next, P.next = z } w.baseQueue = E = P, v.pending = null } if (E !== null) { P = E.next, w = w.baseState; var $ = z = null, me = null, Le = P; do { var et = Le.lane; if ((bu & et) === et) me !== null && (me = me.next = { lane: 0, action: Le.action, hasEagerState: Le.hasEagerState, eagerState: Le.eagerState, next: null }), w = Le.hasEagerState ? Le.eagerState : u(w, Le.action); else { var Et = { lane: et, action: Le.action, hasEagerState: Le.hasEagerState, eagerState: Le.eagerState, next: null }; me === null ? ($ = me = Et, z = w) : me = me.next = Et, kn.lanes |= et, Pu |= et } Le = Le.next } while (Le !== null && Le !== P); me === null ? z = w : me.next = $, Mo(w, h.memoizedState) || (Gr = !0), h.memoizedState = w, h.baseState = z, h.baseQueue = me, v.lastRenderedState = w } if (u = v.interleaved, u !== null) { E = u; do P = E.lane, kn.lanes |= P, Pu |= P, E = E.next; while (E !== u) } else E === null && (v.lanes = 0); return [h.memoizedState, v.dispatch] } function Fm(u) { var h = Co(), v = h.queue; if (v === null) throw Error(o(311)); v.lastRenderedReducer = u; var w = v.dispatch, E = v.pending, P = h.memoizedState; if (E !== null) { v.pending = null; var z = E = E.next; do P = u(P, z.action), z = z.next; while (z !== E); Mo(P, h.memoizedState) || (Gr = !0), h.memoizedState = P, h.baseQueue === null && (h.baseState = P), v.lastRenderedState = P } return [P, w] } function MC() { } function wC(u, h) { var v = kn, w = Co(), E = h(), P = !Mo(w.memoizedState, E); if (P && (w.memoizedState = E, Gr = !0), w = w.queue, Xh(CC.bind(null, v, w, u), [u]), w.getSnapshot !== h || P || vi !== null && vi.memoizedState.tag & 1) { if (v.flags |= 2048, Wh(9, EC.bind(null, v, w, E, h), void 0, null), $n === null) throw Error(o(349)); bu & 30 || SC(v, h, E) } return E } function SC(u, h, v) { u.flags |= 16384, u = { getSnapshot: h, value: v }, h = kn.updateQueue, h === null ? (h = { lastEffect: null, stores: null }, kn.updateQueue = h, h.stores = [u]) : (v = h.stores, v === null ? h.stores = [u] : v.push(u)) } function EC(u, h, v, w) { h.value = v, h.getSnapshot = w, TC(h) && gs(u, 1, -1) } function CC(u, h, v) { return v(function () { TC(h) && gs(u, 1, -1) }) } function TC(u) { var h = u.getSnapshot; u = u.value; try { var v = h(); return !Mo(u, v) } catch { return !0 } } function k_(u) { var h = ta(); return typeof u == "function" && (u = u()), h.memoizedState = h.baseState = u, u = { pending: null, interleaved: null, lanes: 0, dispatch: null, lastRenderedReducer: Ql, lastRenderedState: u }, h.queue = u, u = u.dispatch = mN.bind(null, kn, u), [h.memoizedState, u] } function Wh(u, h, v, w) { return u = { tag: u, create: h, destroy: v, deps: w, next: null }, h = kn.updateQueue, h === null ? (h = { lastEffect: null, stores: null }, kn.updateQueue = h, h.lastEffect = u.next = u) : (v = h.lastEffect, v === null ? h.lastEffect = u.next = u : (w = v.next, v.next = u, u.next = w, h.lastEffect = u)), u } function bC() { return Co().memoizedState } function km(u, h, v, w) { var E = ta(); kn.flags |= u, E.memoizedState = Wh(1 | h, v, void 0, w === void 0 ? null : w) } function Nm(u, h, v, w) { var E = Co(); w = w === void 0 ? null : w; var P = void 0; if (zi !== null) { var z = zi.memoizedState; if (P = z.destroy, w !== null && D_(w, z.deps)) { E.memoizedState = Wh(h, v, P, w); return } } kn.flags |= u, E.memoizedState = Wh(1 | h, v, P, w) } function N_(u, h) { return km(8390656, 8, u, h) } function Xh(u, h) { return Nm(2048, 8, u, h) } function RC(u, h) { return Nm(4, 2, u, h) } function PC(u, h) { return Nm(4, 4, u, h) } function IC(u, h) { if (typeof h == "function") return u = u(), h(u), function () { h(null) }; if (h != null) return u = u(), h.current = u, function () { h.current = null } } function BC(u, h, v) { return v = v != null ? v.concat([u]) : null, Nm(4, 4, IC.bind(null, h, u), v) } function U_() { } function LC(u, h) { var v = Co(); h = h === void 0 ? null : h; var w = v.memoizedState; return w !== null && h !== null && D_(h, w[1]) ? w[0] : (v.memoizedState = [u, h], u) } function DC(u, h) { var v = Co(); h = h === void 0 ? null : h; var w = v.memoizedState; return w !== null && h !== null && D_(h, w[1]) ? w[0] : (u = u(), v.memoizedState = [u, h], u) } function dN(u, h) { var v = en; en = v !== 0 && 4 > v ? v : 4, u(!0); var w = ms.transition; ms.transition = {}; try { u(!1), h() } finally { en = v, ms.transition = w } } function OC() { return Co().memoizedState } function pN(u, h, v) { var w = Ga(u); v = { lane: w, action: v, hasEagerState: !1, eagerState: null, next: null }, FC(u) ? kC(h, v) : (NC(u, h, v), v = or(), u = gs(u, w, v), u !== null && UC(u, h, w)) } function mN(u, h, v) { var w = Ga(u), E = { lane: w, action: v, hasEagerState: !1, eagerState: null, next: null }; if (FC(u)) kC(h, E); else { NC(u, h, E); var P = u.alternate; if (u.lanes === 0 && (P === null || P.lanes === 0) && (P = h.lastRenderedReducer, P !== null)) try { var z = h.lastRenderedState, $ = P(z, v); if (E.hasEagerState = !0, E.eagerState = $, Mo($, z)) return } catch { } finally { } v = or(), u = gs(u, w, v), u !== null && UC(u, h, w) } } function FC(u) { var h = u.alternate; return u === kn || h !== null && h === kn } function kC(u, h) { Gh = Dm = !0; var v = u.pending; v === null ? h.next = h : (h.next = v.next, v.next = h), u.pending = h } function NC(u, h, v) { $n !== null && u.mode & 1 && !(kt & 2) ? (u = h.interleaved, u === null ? (v.next = v, So === null ? So = [h] : So.push(h)) : (v.next = u.next, u.next = v), h.interleaved = v) : (u = h.pending, u === null ? v.next = v : (v.next = u.next, u.next = v), h.pending = v) } function UC(u, h, v) { if (v & 4194240) { var w = h.lanes; w &= u.pendingLanes, v |= w, h.lanes = v, d_(u, v) } } var Um = { readContext: fs, useCallback: Hi, useContext: Hi, useEffect: Hi, useImperativeHandle: Hi, useInsertionEffect: Hi, useLayoutEffect: Hi, useMemo: Hi, useReducer: Hi, useRef: Hi, useState: Hi, useDebugValue: Hi, useDeferredValue: Hi, useTransition: Hi, useMutableSource: Hi, useSyncExternalStore: Hi, useId: Hi, unstable_isNewReconciler: !1 }, gN = { readContext: fs, useCallback: function (u, h) { return ta().memoizedState = [u, h === void 0 ? null : h], u }, useContext: fs, useEffect: N_, useImperativeHandle: function (u, h, v) { return v = v != null ? v.concat([u]) : null, km(4194308, 4, IC.bind(null, h, u), v) }, useLayoutEffect: function (u, h) { return km(4194308, 4, u, h) }, useInsertionEffect: function (u, h) { return km(4, 2, u, h) }, useMemo: function (u, h) { var v = ta(); return h = h === void 0 ? null : h, u = u(), v.memoizedState = [u, h], u }, useReducer: function (u, h, v) { var w = ta(); return h = v !== void 0 ? v(h) : h, w.memoizedState = w.baseState = h, u = { pending: null, interleaved: null, lanes: 0, dispatch: null, lastRenderedReducer: u, lastRenderedState: h }, w.queue = u, u = u.dispatch = pN.bind(null, kn, u), [w.memoizedState, u] }, useRef: function (u) { var h = ta(); return u = { current: u }, h.memoizedState = u }, useState: k_, useDebugValue: U_, useDeferredValue: function (u) { var h = k_(u), v = h[0], w = h[1]; return N_(function () { var E = ms.transition; ms.transition = {}; try { w(u) } finally { ms.transition = E } }, [u]), v }, useTransition: function () { var u = k_(!1), h = u[0]; return u = dN.bind(null, u[1]), ta().memoizedState = u, [h, u] }, useMutableSource: function () { }, useSyncExternalStore: function (u, h, v) { var w = kn, E = ta(); if (An) { if (v === void 0) throw Error(o(407)); v = v() } else { if (v = h(), $n === null) throw Error(o(349)); bu & 30 || SC(w, h, v) } E.memoizedState = v; var P = { value: v, getSnapshot: h }; return E.queue = P, N_(CC.bind(null, w, P, u), [u]), w.flags |= 2048, Wh(9, EC.bind(null, w, P, v, h), void 0, null), v }, useId: function () { var u = ta(), h = $n.identifierPrefix; if (An) { var v = ea, w = $o; v = (w & ~(1 << 32 - Ws(w) - 1)).toString(32) + v, h = ":" + h + "R" + v, v = Vh++, 0 < v && (h += "H" + v.toString(32)), h += ":" } else v = hN++, h = ":" + h + "r" + v.toString(32) + ":"; return u.memoizedState = h }, unstable_isNewReconciler: !1 }, yN = { readContext: fs, useCallback: LC, useContext: fs, useEffect: Xh, useImperativeHandle: BC, useInsertionEffect: RC, useLayoutEffect: PC, useMemo: DC, useReducer: Om, useRef: bC, useState: function () { return Om(Ql) }, useDebugValue: U_, useDeferredValue: function (u) { var h = Om(Ql), v = h[0], w = h[1]; return Xh(function () { var E = ms.transition; ms.transition = {}; try { w(u) } finally { ms.transition = E } }, [u]), v }, useTransition: function () { var u = Om(Ql)[0], h = Co().memoizedState; return [u, h] }, useMutableSource: MC, useSyncExternalStore: wC, useId: OC, unstable_isNewReconciler: !1 }, vN = { readContext: fs, useCallback: LC, useContext: fs, useEffect: Xh, useImperativeHandle: BC, useInsertionEffect: RC, useLayoutEffect: PC, useMemo: DC, useReducer: Fm, useRef: bC, useState: function () { return Fm(Ql) }, useDebugValue: U_, useDeferredValue: function (u) { var h = Fm(Ql), v = h[0], w = h[1]; return Xh(function () { var E = ms.transition; ms.transition = {}; try { w(u) } finally { ms.transition = E } }, [u]), v }, useTransition: function () { var u = Fm(Ql)[0], h = Co().memoizedState; return [u, h] }, useMutableSource: MC, useSyncExternalStore: wC, useId: OC, unstable_isNewReconciler: !1 }; function z_(u, h) {
		try { var v = "", w = h; do v += fN(w), w = w.return; while (w); var E = v } catch (P) {
			E = `
Error generating stack: `+ P.message + `
`+ P.stack
		} return { value: u, source: h, stack: E }
	} function H_(u, h) { try { console.error(h.value) } catch (v) { setTimeout(function () { throw v }) } } var _N = typeof WeakMap == "function" ? WeakMap : Map; function zC(u, h, v) { v = Zo(-1, v), v.tag = 3, v.payload = { element: null }; var w = h.value; return v.callback = function () { tg || (tg = !0, sx = w), H_(u, h) }, v } function HC(u, h, v) { v = Zo(-1, v), v.tag = 3; var w = u.type.getDerivedStateFromError; if (typeof w == "function") { var E = h.value; v.payload = function () { return w(E) }, v.callback = function () { H_(u, h) } } var P = u.stateNode; return P !== null && typeof P.componentDidCatch == "function" && (v.callback = function () { H_(u, h), typeof w != "function" && (za === null ? za = new Set([this]) : za.add(this)); var z = h.stack; this.componentDidCatch(h.value, { componentStack: z !== null ? z : "" }) }), v } function GC(u, h, v) { var w = u.pingCache; if (w === null) { w = u.pingCache = new _N; var E = new Set; w.set(h, E) } else E = w.get(h), E === void 0 && (E = new Set, w.set(h, E)); E.has(v) || (E.add(v), u = LN.bind(null, u, h, v), h.then(u, u)) } function VC(u) { do { var h; if ((h = u.tag === 13) && (h = u.memoizedState, h = h !== null ? h.dehydrated !== null : !0), h) return u; u = u.return } while (u !== null); return null } function WC(u, h, v, w, E) { return u.mode & 1 ? (u.flags |= 65536, u.lanes = E, u) : (u === h ? u.flags |= 65536 : (u.flags |= 128, v.flags |= 131072, v.flags &= -52805, v.tag === 1 && (v.alternate === null ? v.tag = 17 : (h = Zo(-1, 1), h.tag = 2, Ua(v, h))), v.lanes |= 1), u) } function To(u) { u.flags |= 4 } function XC(u, h) { if (u !== null && u.child === h.child) return !0; if (h.flags & 16) return !1; for (u = h.child; u !== null;) { if (u.flags & 12854 || u.subtreeFlags & 12854) return !1; u = u.sibling } return !0 } var Jh, Yh, zm, Hm; if (Ge) Jh = function (u, h) { for (var v = h.child; v !== null;) { if (v.tag === 5 || v.tag === 6) K(u, v.stateNode); else if (v.tag !== 4 && v.child !== null) { v.child.return = v, v = v.child; continue } if (v === h) break; for (; v.sibling === null;) { if (v.return === null || v.return === h) return; v = v.return } v.sibling.return = v.return, v = v.sibling } }, Yh = function () { }, zm = function (u, h, v, w, E) { if (u = u.memoizedProps, u !== w) { var P = h.stateNode, z = Eo(ps.current); v = ge(P, v, u, w, E, z), (h.updateQueue = v) && To(h) } }, Hm = function (u, h, v, w) { v !== w && To(h) }; else if (H) { Jh = function (u, h, v, w) { for (var E = h.child; E !== null;) { if (E.tag === 5) { var P = E.stateNode; v && w && (P = Ne(P, E.type, E.memoizedProps, E)), K(u, P) } else if (E.tag === 6) P = E.stateNode, v && w && (P = At(P, E.memoizedProps, E)), K(u, P); else if (E.tag !== 4) { if (E.tag === 22 && E.memoizedState !== null) P = E.child, P !== null && (P.return = E), Jh(u, E, !0, !0); else if (E.child !== null) { E.child.return = E, E = E.child; continue } } if (E === h) break; for (; E.sibling === null;) { if (E.return === null || E.return === h) return; E = E.return } E.sibling.return = E.return, E = E.sibling } }; var JC = function (u, h, v, w) { for (var E = h.child; E !== null;) { if (E.tag === 5) { var P = E.stateNode; v && w && (P = Ne(P, E.type, E.memoizedProps, E)), Qt(u, P) } else if (E.tag === 6) P = E.stateNode, v && w && (P = At(P, E.memoizedProps, E)), Qt(u, P); else if (E.tag !== 4) { if (E.tag === 22 && E.memoizedState !== null) P = E.child, P !== null && (P.return = E), JC(u, E, !0, !0); else if (E.child !== null) { E.child.return = E, E = E.child; continue } } if (E === h) break; for (; E.sibling === null;) { if (E.return === null || E.return === h) return; E = E.return } E.sibling.return = E.return, E = E.sibling } }; Yh = function (u, h) { var v = h.stateNode; if (!XC(u, h)) { u = v.containerInfo; var w = St(u); JC(w, h, !1, !1), v.pendingChildren = w, To(h), $t(u, w) } }, zm = function (u, h, v, w, E) { var P = u.stateNode, z = u.memoizedProps; if ((u = XC(u, h)) && z === w) h.stateNode = P; else { var $ = h.stateNode, me = Eo(ps.current), Le = null; z !== w && (Le = ge($, v, z, w, E, me)), u && Le === null ? h.stateNode = P : (P = ke(P, Le, v, z, w, h, u, $), ye(P, v, w, E, me) && To(h), h.stateNode = P, u ? To(h) : Jh(P, h, !1, !1)) } }, Hm = function (u, h, v, w) { v !== w ? (u = Eo(Cu.current), v = Eo(ps.current), h.stateNode = Be(w, u, v, h), To(h)) : h.stateNode = u.stateNode } } else Yh = function () { }, zm = function () { }, Hm = function () { }; function jh(u, h) { if (!An) switch (u.tailMode) { case "hidden": h = u.tail; for (var v = null; h !== null;)h.alternate !== null && (v = h), h = h.sibling; v === null ? u.tail = null : v.sibling = null; break; case "collapsed": v = u.tail; for (var w = null; v !== null;)v.alternate !== null && (w = v), v = v.sibling; w === null ? h || u.tail === null ? u.tail = null : u.tail.sibling = null : w.sibling = null } } function Gi(u) { var h = u.alternate !== null && u.alternate.child === u.child, v = 0, w = 0; if (h) for (var E = u.child; E !== null;)v |= E.lanes | E.childLanes, w |= E.subtreeFlags & 14680064, w |= E.flags & 14680064, E.return = u, E = E.sibling; else for (E = u.child; E !== null;)v |= E.lanes | E.childLanes, w |= E.subtreeFlags, w |= E.flags, E.return = u, E = E.sibling; return u.subtreeFlags |= w, u.childLanes = v, h } function xN(u, h, v) { var w = h.pendingProps; switch (C_(h), h.tag) { case 2: case 16: case 15: case 0: case 11: case 7: case 8: case 12: case 9: case 14: return Gi(h), null; case 1: return Fn(h.type) && ka(), Gi(h), null; case 3: return w = h.stateNode, Tu(), jt(Zn), jt(ci), L_(), w.pendingContext && (w.context = w.pendingContext, w.pendingContext = null), (u === null || u.child === null) && (Nh(h) ? To(h) : u === null || u.memoizedState.isDehydrated && !(h.flags & 256) || (h.flags |= 1024, Js !== null && (lx(Js), Js = null))), Yh(u, h), Gi(h), null; case 5: I_(h), v = Eo(Cu.current); var E = h.type; if (u !== null && h.stateNode != null) zm(u, h, E, w, v), u.ref !== h.ref && (h.flags |= 512, h.flags |= 2097152); else { if (!w) { if (h.stateNode === null) throw Error(o(166)); return Gi(h), null } if (u = Eo(ps.current), Nh(h)) { if (!pe) throw Error(o(175)); u = ln(h.stateNode, h.type, h.memoizedProps, v, u, h, !kh), h.updateQueue = u, u !== null && To(h) } else { var P = G(E, w, v, u, h); Jh(P, h, !1, !1), h.stateNode = P, ye(P, E, w, v, u) && To(h) } h.ref !== null && (h.flags |= 512, h.flags |= 2097152) } return Gi(h), null; case 6: if (u && h.stateNode != null) Hm(u, h, u.memoizedProps, w); else { if (typeof w != "string" && h.stateNode === null) throw Error(o(166)); if (u = Eo(Cu.current), v = Eo(ps.current), Nh(h)) { if (!pe) throw Error(o(176)); if (u = h.stateNode, w = h.memoizedProps, (v = O(u, w, h, !kh)) && (E = zr, E !== null)) switch (P = (E.mode & 1) !== 0, E.tag) { case 3: ft(E.stateNode.containerInfo, u, w, P); break; case 5: wt(E.type, E.memoizedProps, E.stateNode, u, w, P) }v && To(h) } else h.stateNode = Be(w, u, v, h) } return Gi(h), null; case 13: if (jt(En), w = h.memoizedState, An && Hr !== null && h.mode & 1 && !(h.flags & 128)) { for (u = Hr; u;)u = Mt(u); return Su(), h.flags |= 98560, h } if (w !== null && w.dehydrated !== null) { if (w = Nh(h), u === null) { if (!w) throw Error(o(318)); if (!pe) throw Error(o(344)); if (u = h.memoizedState, u = u !== null ? u.dehydrated : null, !u) throw Error(o(317)); ie(u, h) } else Su(), !(h.flags & 128) && (h.memoizedState = null), h.flags |= 4; return Gi(h), null } return Js !== null && (lx(Js), Js = null), h.flags & 128 ? (h.lanes = v, h) : (w = w !== null, v = !1, u === null ? Nh(h) : v = u.memoizedState !== null, w && !v && (h.child.flags |= 8192, h.mode & 1 && (u === null || En.current & 1 ? ui === 0 && (ui = 3) : ux())), h.updateQueue !== null && (h.flags |= 4), Gi(h), null); case 4: return Tu(), Yh(u, h), u === null && Ee(h.stateNode.containerInfo), Gi(h), null; case 10: return x_(h.type._context), Gi(h), null; case 17: return Fn(h.type) && ka(), Gi(h), null; case 19: if (jt(En), E = h.memoizedState, E === null) return Gi(h), null; if (w = (h.flags & 128) !== 0, P = E.rendering, P === null) if (w) jh(E, !1); else { if (ui !== 0 || u !== null && u.flags & 128) for (u = h.child; u !== null;) { if (P = Bm(u), P !== null) { for (h.flags |= 128, jh(E, !1), u = P.updateQueue, u !== null && (h.updateQueue = u, h.flags |= 4), h.subtreeFlags = 0, u = v, w = h.child; w !== null;)v = w, E = u, v.flags &= 14680066, P = v.alternate, P === null ? (v.childLanes = 0, v.lanes = E, v.child = null, v.subtreeFlags = 0, v.memoizedProps = null, v.memoizedState = null, v.updateQueue = null, v.dependencies = null, v.stateNode = null) : (v.childLanes = P.childLanes, v.lanes = P.lanes, v.child = P.child, v.subtreeFlags = 0, v.deletions = null, v.memoizedProps = P.memoizedProps, v.memoizedState = P.memoizedState, v.updateQueue = P.updateQueue, v.type = P.type, E = P.dependencies, v.dependencies = E === null ? null : { lanes: E.lanes, firstContext: E.firstContext }), w = w.sibling; return dt(En, En.current & 1 | 2), h.child } u = u.sibling } E.tail !== null && yi() > rx && (h.flags |= 128, w = !0, jh(E, !1), h.lanes = 4194304) } else { if (!w) if (u = Bm(P), u !== null) { if (h.flags |= 128, w = !0, u = u.updateQueue, u !== null && (h.updateQueue = u, h.flags |= 4), jh(E, !0), E.tail === null && E.tailMode === "hidden" && !P.alternate && !An) return Gi(h), null } else 2 * yi() - E.renderingStartTime > rx && v !== 1073741824 && (h.flags |= 128, w = !0, jh(E, !1), h.lanes = 4194304); E.isBackwards ? (P.sibling = h.child, h.child = P) : (u = E.last, u !== null ? u.sibling = P : h.child = P, E.last = P) } return E.tail !== null ? (h = E.tail, E.rendering = h, E.tail = h.sibling, E.renderingStartTime = yi(), h.sibling = null, u = En.current, dt(En, w ? u & 1 | 2 : u & 1), h) : (Gi(h), null); case 22: case 23: return cx(), w = h.memoizedState !== null, u !== null && u.memoizedState !== null !== w && (h.flags |= 8192), w && h.mode & 1 ? Vr & 1073741824 && (Gi(h), Ge && h.subtreeFlags & 6 && (h.flags |= 8192)) : Gi(h), null; case 24: return null; case 25: return null }throw Error(o(156, h.tag)) } var AN = a.ReactCurrentOwner, Gr = !1; function sr(u, h, v, w) { h.child = u === null ? xC(h, null, v, w) : Eu(h, u.child, v, w) } function YC(u, h, v, w, E) { v = v.render; var P = h.ref; return Au(h, E), w = O_(u, h, v, w, P, E), v = F_(), u !== null && !Gr ? (h.updateQueue = u.updateQueue, h.flags &= -2053, u.lanes &= ~E, na(u, h, E)) : (An && v && E_(h), h.flags |= 1, sr(u, h, w, E), h.child) } function jC(u, h, v, w, E) { if (u === null) { var P = v.type; return typeof P == "function" && !fx(P) && P.defaultProps === void 0 && v.compare === null && v.defaultProps === void 0 ? (h.tag = 15, h.type = P, KC(u, h, P, w, E)) : (u = lg(v.type, null, w, h, h.mode, E), u.ref = h.ref, u.return = h, h.child = u) } if (P = u.child, !(u.lanes & E)) { var z = P.memoizedProps; if (v = v.compare, v = v !== null ? v : wm, v(z, w) && u.ref === h.ref) return na(u, h, E) } return h.flags |= 1, u = Wa(P, w), u.ref = h.ref, u.return = h, h.child = u } function KC(u, h, v, w, E) { if (u !== null && wm(u.memoizedProps, w) && u.ref === h.ref) if (Gr = !1, (u.lanes & E) !== 0) u.flags & 131072 && (Gr = !0); else return h.lanes = u.lanes, na(u, h, E); return G_(u, h, v, w, E) } function qC(u, h, v) { var w = h.pendingProps, E = w.children, P = u !== null ? u.memoizedState : null; if (w.mode === "hidden") if (!(h.mode & 1)) h.memoizedState = { baseLanes: 0, cachePool: null }, dt(Ru, Vr), Vr |= v; else if (v & 1073741824) h.memoizedState = { baseLanes: 0, cachePool: null }, w = P !== null ? P.baseLanes : v, dt(Ru, Vr), Vr |= w; else return u = P !== null ? P.baseLanes | v : v, h.lanes = h.childLanes = 1073741824, h.memoizedState = { baseLanes: u, cachePool: null }, h.updateQueue = null, dt(Ru, Vr), Vr |= u, null; else P !== null ? (w = P.baseLanes | v, h.memoizedState = null) : w = v, dt(Ru, Vr), Vr |= w; return sr(u, h, E, v), h.child } function QC(u, h) { var v = h.ref; (u === null && v !== null || u !== null && u.ref !== v) && (h.flags |= 512, h.flags |= 2097152) } function G_(u, h, v, w, E) { var P = Fn(v) ? Vs : ci.current; return P = On(h, P), Au(h, E), v = O_(u, h, v, w, P, E), w = F_(), u !== null && !Gr ? (h.updateQueue = u.updateQueue, h.flags &= -2053, u.lanes &= ~E, na(u, h, E)) : (An && w && E_(h), h.flags |= 1, sr(u, h, v, E), h.child) } function ZC(u, h, v, w, E) { if (Fn(v)) { var P = !0; _u(h) } else P = !1; if (Au(h, E), h.stateNode === null) u !== null && (u.alternate = null, h.alternate = null, h.flags |= 2), hC(h, v, w), S_(h, v, w, E), w = !0; else if (u === null) { var z = h.stateNode, $ = h.memoizedProps; z.props = $; var me = z.context, Le = v.contextType; typeof Le == "object" && Le !== null ? Le = fs(Le) : (Le = Fn(v) ? Vs : ci.current, Le = On(h, Le)); var et = v.getDerivedStateFromProps, Et = typeof et == "function" || typeof z.getSnapshotBeforeUpdate == "function"; Et || typeof z.UNSAFE_componentWillReceiveProps != "function" && typeof z.componentWillReceiveProps != "function" || ($ !== w || me !== Le) && dC(h, z, w, Le), Na = !1; var mt = h.memoizedState; z.state = mt, Tm(h, w, z, E), me = h.memoizedState, $ !== w || mt !== me || Zn.current || Na ? (typeof et == "function" && (w_(h, v, et, w), me = h.memoizedState), ($ = Na || fC(h, v, $, w, mt, me, Le)) ? (Et || typeof z.UNSAFE_componentWillMount != "function" && typeof z.componentWillMount != "function" || (typeof z.componentWillMount == "function" && z.componentWillMount(), typeof z.UNSAFE_componentWillMount == "function" && z.UNSAFE_componentWillMount()), typeof z.componentDidMount == "function" && (h.flags |= 4194308)) : (typeof z.componentDidMount == "function" && (h.flags |= 4194308), h.memoizedProps = w, h.memoizedState = me), z.props = w, z.state = me, z.context = Le, w = $) : (typeof z.componentDidMount == "function" && (h.flags |= 4194308), w = !1) } else { z = h.stateNode, aC(u, h), $ = h.memoizedProps, Le = h.type === h.elementType ? $ : Xs(h.type, $), z.props = Le, Et = h.pendingProps, mt = z.context, me = v.contextType, typeof me == "object" && me !== null ? me = fs(me) : (me = Fn(v) ? Vs : ci.current, me = On(h, me)); var cn = v.getDerivedStateFromProps; (et = typeof cn == "function" || typeof z.getSnapshotBeforeUpdate == "function") || typeof z.UNSAFE_componentWillReceiveProps != "function" && typeof z.componentWillReceiveProps != "function" || ($ !== Et || mt !== me) && dC(h, z, w, me), Na = !1, mt = h.memoizedState, z.state = mt, Tm(h, w, z, E); var ct = h.memoizedState; $ !== Et || mt !== ct || Zn.current || Na ? (typeof cn == "function" && (w_(h, v, cn, w), ct = h.memoizedState), (Le = Na || fC(h, v, Le, w, mt, ct, me) || !1) ? (et || typeof z.UNSAFE_componentWillUpdate != "function" && typeof z.componentWillUpdate != "function" || (typeof z.componentWillUpdate == "function" && z.componentWillUpdate(w, ct, me), typeof z.UNSAFE_componentWillUpdate == "function" && z.UNSAFE_componentWillUpdate(w, ct, me)), typeof z.componentDidUpdate == "function" && (h.flags |= 4), typeof z.getSnapshotBeforeUpdate == "function" && (h.flags |= 1024)) : (typeof z.componentDidUpdate != "function" || $ === u.memoizedProps && mt === u.memoizedState || (h.flags |= 4), typeof z.getSnapshotBeforeUpdate != "function" || $ === u.memoizedProps && mt === u.memoizedState || (h.flags |= 1024), h.memoizedProps = w, h.memoizedState = ct), z.props = w, z.state = ct, z.context = me, w = Le) : (typeof z.componentDidUpdate != "function" || $ === u.memoizedProps && mt === u.memoizedState || (h.flags |= 4), typeof z.getSnapshotBeforeUpdate != "function" || $ === u.memoizedProps && mt === u.memoizedState || (h.flags |= 1024), w = !1) } return V_(u, h, v, w, P, E) } function V_(u, h, v, w, E, P) { QC(u, h); var z = (h.flags & 128) !== 0; if (!w && !z) return E && Dh(h, v, !1), na(u, h, P); w = h.stateNode, AN.current = h; var $ = z && typeof v.getDerivedStateFromError != "function" ? null : w.render(); return h.flags |= 1, u !== null && z ? (h.child = Eu(h, u.child, null, P), h.child = Eu(h, null, $, P)) : sr(u, h, $, P), h.memoizedState = w.state, E && Dh(h, v, !0), h.child } function $C(u) { var h = u.stateNode; h.pendingContext ? Ui(u, h.pendingContext, h.pendingContext !== h.context) : h.context && Ui(u, h.context, !1), P_(u, h.containerInfo) } function eT(u, h, v, w, E) { return Su(), R_(E), h.flags |= 256, sr(u, h, v, w), h.child } var Gm = { dehydrated: null, treeContext: null, retryLane: 0 }; function Vm(u) { return { baseLanes: u, cachePool: null } } function tT(u, h, v) { var w = h.pendingProps, E = En.current, P = !1, z = (h.flags & 128) !== 0, $; if (($ = z) || ($ = u !== null && u.memoizedState === null ? !1 : (E & 2) !== 0), $ ? (P = !0, h.flags &= -129) : (u === null || u.memoizedState !== null) && (E |= 1), dt(En, E & 1), u === null) return b_(h), u = h.memoizedState, u !== null && (u = u.dehydrated, u !== null) ? (h.mode & 1 ? _t(u) ? h.lanes = 8 : h.lanes = 1073741824 : h.lanes = 1, null) : (E = w.children, u = w.fallback, P ? (w = h.mode, P = h.child, E = { mode: "hidden", children: E }, !(w & 1) && P !== null ? (P.childLanes = 0, P.pendingProps = E) : P = cg(E, w, 0, null), u = ic(u, w, v, null), P.return = h, u.return = h, P.sibling = u, h.child = P, h.child.memoizedState = Vm(v), h.memoizedState = Gm, u) : W_(h, E)); if (E = u.memoizedState, E !== null) { if ($ = E.dehydrated, $ !== null) { if (z) return h.flags & 256 ? (h.flags &= -257, Wm(u, h, v, Error(o(422)))) : h.memoizedState !== null ? (h.child = u.child, h.flags |= 128, null) : (P = w.fallback, E = h.mode, w = cg({ mode: "visible", children: w.children }, E, 0, null), P = ic(P, E, v, null), P.flags |= 2, w.return = h, P.return = h, w.sibling = P, h.child = w, h.mode & 1 && Eu(h, u.child, null, v), h.child.memoizedState = Vm(v), h.memoizedState = Gm, P); if (!(h.mode & 1)) h = Wm(u, h, v, null); else if (_t($)) h = Wm(u, h, v, Error(o(419))); else if (w = (v & u.childLanes) !== 0, Gr || w) { if (w = $n, w !== null) { switch (v & -v) { case 4: P = 2; break; case 16: P = 8; break; case 64: case 128: case 256: case 512: case 1024: case 2048: case 4096: case 8192: case 16384: case 32768: case 65536: case 131072: case 262144: case 524288: case 1048576: case 2097152: case 4194304: case 8388608: case 16777216: case 33554432: case 67108864: P = 32; break; case 536870912: P = 268435456; break; default: P = 0 }w = P & (w.suspendedLanes | v) ? 0 : P, w !== 0 && w !== E.retryLane && (E.retryLane = w, gs(u, w, -1)) } ux(), h = Wm(u, h, v, Error(o(421))) } else pt($) ? (h.flags |= 128, h.child = u.child, h = DN.bind(null, u), Sn($, h), h = null) : (v = E.treeContext, pe && (Hr = Jn($), zr = h, An = !0, Js = null, kh = !1, v !== null && (hs[ds++] = $o, hs[ds++] = ea, hs[ds++] = Kl, $o = v.id, ea = v.overflow, Kl = h)), h = W_(h, h.pendingProps.children), h.flags |= 4096); return h } return P ? (w = iT(u, h, w.children, w.fallback, v), P = h.child, E = u.child.memoizedState, P.memoizedState = E === null ? Vm(v) : { baseLanes: E.baseLanes | v, cachePool: null }, P.childLanes = u.childLanes & ~v, h.memoizedState = Gm, w) : (v = nT(u, h, w.children, v), h.memoizedState = null, v) } return P ? (w = iT(u, h, w.children, w.fallback, v), P = h.child, E = u.child.memoizedState, P.memoizedState = E === null ? Vm(v) : { baseLanes: E.baseLanes | v, cachePool: null }, P.childLanes = u.childLanes & ~v, h.memoizedState = Gm, w) : (v = nT(u, h, w.children, v), h.memoizedState = null, v) } function W_(u, h) { return h = cg({ mode: "visible", children: h }, u.mode, 0, null), h.return = u, u.child = h } function nT(u, h, v, w) { var E = u.child; return u = E.sibling, v = Wa(E, { mode: "visible", children: v }), !(h.mode & 1) && (v.lanes = w), v.return = h, v.sibling = null, u !== null && (w = h.deletions, w === null ? (h.deletions = [u], h.flags |= 16) : w.push(u)), h.child = v } function iT(u, h, v, w, E) { var P = h.mode; u = u.child; var z = u.sibling, $ = { mode: "hidden", children: v }; return !(P & 1) && h.child !== u ? (v = h.child, v.childLanes = 0, v.pendingProps = $, h.deletions = null) : (v = Wa(u, $), v.subtreeFlags = u.subtreeFlags & 14680064), z !== null ? w = Wa(z, w) : (w = ic(w, P, E, null), w.flags |= 2), w.return = h, v.return = h, v.sibling = w, h.child = v, w } function Wm(u, h, v, w) { return w !== null && R_(w), Eu(h, u.child, null, v), u = W_(h, h.pendingProps.children), u.flags |= 2, h.memoizedState = null, u } function rT(u, h, v) { u.lanes |= h; var w = u.alternate; w !== null && (w.lanes |= h), A_(u.return, h, v) } function X_(u, h, v, w, E) { var P = u.memoizedState; P === null ? u.memoizedState = { isBackwards: h, rendering: null, renderingStartTime: 0, last: w, tail: v, tailMode: E } : (P.isBackwards = h, P.rendering = null, P.renderingStartTime = 0, P.last = w, P.tail = v, P.tailMode = E) } function sT(u, h, v) { var w = h.pendingProps, E = w.revealOrder, P = w.tail; if (sr(u, h, w.children, v), w = En.current, w & 2) w = w & 1 | 2, h.flags |= 128; else { if (u !== null && u.flags & 128) e: for (u = h.child; u !== null;) { if (u.tag === 13) u.memoizedState !== null && rT(u, v, h); else if (u.tag === 19) rT(u, v, h); else if (u.child !== null) { u.child.return = u, u = u.child; continue } if (u === h) break e; for (; u.sibling === null;) { if (u.return === null || u.return === h) break e; u = u.return } u.sibling.return = u.return, u = u.sibling } w &= 1 } if (dt(En, w), !(h.mode & 1)) h.memoizedState = null; else switch (E) { case "forwards": for (v = h.child, E = null; v !== null;)u = v.alternate, u !== null && Bm(u) === null && (E = v), v = v.sibling; v = E, v === null ? (E = h.child, h.child = null) : (E = v.sibling, v.sibling = null), X_(h, !1, E, v, P); break; case "backwards": for (v = null, E = h.child, h.child = null; E !== null;) { if (u = E.alternate, u !== null && Bm(u) === null) { h.child = E; break } u = E.sibling, E.sibling = v, v = E, E = u } X_(h, !0, v, null, P); break; case "together": X_(h, !1, null, null, void 0); break; default: h.memoizedState = null }return h.child } function na(u, h, v) { if (u !== null && (h.dependencies = u.dependencies), Pu |= h.lanes, !(v & h.childLanes)) return null; if (u !== null && h.child !== u.child) throw Error(o(153)); if (h.child !== null) { for (u = h.child, v = Wa(u, u.pendingProps), h.child = v, v.return = h; u.sibling !== null;)u = u.sibling, v = v.sibling = Wa(u, u.pendingProps), v.return = h; v.sibling = null } return h.child } function MN(u, h, v) { switch (h.tag) { case 3: $C(h), Su(); break; case 5: AC(h); break; case 1: Fn(h.type) && _u(h); break; case 4: P_(h, h.stateNode.containerInfo); break; case 10: oC(h, h.type._context, h.memoizedProps.value); break; case 13: var w = h.memoizedState; if (w !== null) return w.dehydrated !== null ? (dt(En, En.current & 1), h.flags |= 128, null) : v & h.child.childLanes ? tT(u, h, v) : (dt(En, En.current & 1), u = na(u, h, v), u !== null ? u.sibling : null); dt(En, En.current & 1); break; case 19: if (w = (v & h.childLanes) !== 0, u.flags & 128) { if (w) return sT(u, h, v); h.flags |= 128 } var E = h.memoizedState; if (E !== null && (E.rendering = null, E.tail = null, E.lastEffect = null), dt(En, En.current), w) break; return null; case 22: case 23: return h.lanes = 0, qC(u, h, v) }return na(u, h, v) } function wN(u, h) { switch (C_(h), h.tag) { case 1: return Fn(h.type) && ka(), u = h.flags, u & 65536 ? (h.flags = u & -65537 | 128, h) : null; case 3: return Tu(), jt(Zn), jt(ci), L_(), u = h.flags, u & 65536 && !(u & 128) ? (h.flags = u & -65537 | 128, h) : null; case 5: return I_(h), null; case 13: if (jt(En), u = h.memoizedState, u !== null && u.dehydrated !== null) { if (h.alternate === null) throw Error(o(340)); Su() } return u = h.flags, u & 65536 ? (h.flags = u & -65537 | 128, h) : null; case 19: return jt(En), null; case 4: return Tu(), null; case 10: return x_(h.type._context), null; case 22: case 23: return cx(), null; case 24: return null; default: return null } } var Xm = !1, Zl = !1, SN = typeof WeakSet == "function" ? WeakSet : Set, Xe = null; function Jm(u, h) { var v = u.ref; if (v !== null) if (typeof v == "function") try { v(null) } catch (w) { Sr(u, h, w) } else v.current = null } function J_(u, h, v) { try { v() } catch (w) { Sr(u, h, w) } } var oT = !1; function EN(u, h) { for (Y(u.containerInfo), Xe = h; Xe !== null;)if (u = Xe, h = u.child, (u.subtreeFlags & 1028) !== 0 && h !== null) h.return = u, Xe = h; else for (; Xe !== null;) { u = Xe; try { var v = u.alternate; if (u.flags & 1024) switch (u.tag) { case 0: case 11: case 15: break; case 1: if (v !== null) { var w = v.memoizedProps, E = v.memoizedState, P = u.stateNode, z = P.getSnapshotBeforeUpdate(u.elementType === u.type ? w : Xs(u.type, w), E); P.__reactInternalSnapshotBeforeUpdate = z } break; case 3: Ge && Se(u.stateNode.containerInfo); break; case 5: case 6: case 4: case 17: break; default: throw Error(o(163)) } } catch ($) { Sr(u, u.return, $) } if (h = u.sibling, h !== null) { h.return = u.return, Xe = h; break } Xe = u.return } return v = oT, oT = !1, v } function $l(u, h, v) { var w = h.updateQueue; if (w = w !== null ? w.lastEffect : null, w !== null) { var E = w = w.next; do { if ((E.tag & u) === u) { var P = E.destroy; E.destroy = void 0, P !== void 0 && J_(h, v, P) } E = E.next } while (E !== w) } } function Kh(u, h) { if (h = h.updateQueue, h = h !== null ? h.lastEffect : null, h !== null) { var v = h = h.next; do { if ((v.tag & u) === u) { var w = v.create; v.destroy = w() } v = v.next } while (v !== h) } } function Y_(u) { var h = u.ref; if (h !== null) { var v = u.stateNode; switch (u.tag) { case 5: u = ne(v); break; default: u = v }typeof h == "function" ? h(u) : h.current = u } } function aT(u, h, v) { if (Ao && typeof Ao.onCommitFiberUnmount == "function") try { Ao.onCommitFiberUnmount(Am, h) } catch { } switch (h.tag) { case 0: case 11: case 14: case 15: if (u = h.updateQueue, u !== null && (u = u.lastEffect, u !== null)) { var w = u = u.next; do { var E = w, P = E.destroy; E = E.tag, P !== void 0 && (E & 2 || E & 4) && J_(h, v, P), w = w.next } while (w !== u) } break; case 1: if (Jm(h, v), u = h.stateNode, typeof u.componentWillUnmount == "function") try { u.props = h.memoizedProps, u.state = h.memoizedState, u.componentWillUnmount() } catch (z) { Sr(h, v, z) } break; case 5: Jm(h, v); break; case 4: Ge ? dT(u, h, v) : H && H && (h = h.stateNode.containerInfo, v = St(h), ht(h, v)) } } function lT(u, h, v) { for (var w = h; ;)if (aT(u, w, v), w.child === null || Ge && w.tag === 4) { if (w === h) break; for (; w.sibling === null;) { if (w.return === null || w.return === h) return; w = w.return } w.sibling.return = w.return, w = w.sibling } else w.child.return = w, w = w.child } function cT(u) { var h = u.alternate; h !== null && (u.alternate = null, cT(h)), u.child = null, u.deletions = null, u.sibling = null, u.tag === 5 && (h = u.stateNode, h !== null && Z(h)), u.stateNode = null, u.return = null, u.dependencies = null, u.memoizedProps = null, u.memoizedState = null, u.pendingProps = null, u.stateNode = null, u.updateQueue = null } function uT(u) { return u.tag === 5 || u.tag === 3 || u.tag === 4 } function fT(u) { e: for (; ;) { for (; u.sibling === null;) { if (u.return === null || uT(u.return)) return null; u = u.return } for (u.sibling.return = u.return, u = u.sibling; u.tag !== 5 && u.tag !== 6 && u.tag !== 18;) { if (u.flags & 2 || u.child === null || u.tag === 4) continue e; u.child.return = u, u = u.child } if (!(u.flags & 2)) return u.stateNode } } function hT(u) { if (Ge) { e: { for (var h = u.return; h !== null;) { if (uT(h)) break e; h = h.return } throw Error(o(160)) } var v = h; switch (v.tag) { case 5: h = v.stateNode, v.flags & 32 && (lt(h), v.flags &= -33), v = fT(u), K_(u, v, h); break; case 3: case 4: h = v.stateNode.containerInfo, v = fT(u), j_(u, v, h); break; default: throw Error(o(161)) } } } function j_(u, h, v) { var w = u.tag; if (w === 5 || w === 6) u = u.stateNode, h ? we(v, u, h) : qe(v, u); else if (w !== 4 && (u = u.child, u !== null)) for (j_(u, h, v), u = u.sibling; u !== null;)j_(u, h, v), u = u.sibling } function K_(u, h, v) { var w = u.tag; if (w === 5 || w === 6) u = u.stateNode, h ? he(v, u, h) : Ce(v, u); else if (w !== 4 && (u = u.child, u !== null)) for (K_(u, h, v), u = u.sibling; u !== null;)K_(u, h, v), u = u.sibling } function dT(u, h, v) { for (var w = h, E = !1, P, z; ;) { if (!E) { E = w.return; e: for (; ;) { if (E === null) throw Error(o(160)); switch (P = E.stateNode, E.tag) { case 5: z = !1; break e; case 3: P = P.containerInfo, z = !0; break e; case 4: P = P.containerInfo, z = !0; break e }E = E.return } E = !0 } if (w.tag === 5 || w.tag === 6) lT(u, w, v), z ? De(P, w.stateNode) : be(P, w.stateNode); else if (w.tag === 18) z ? Ke(P, w.stateNode) : Ue(P, w.stateNode); else if (w.tag === 4) { if (w.child !== null) { P = w.stateNode.containerInfo, z = !0, w.child.return = w, w = w.child; continue } } else if (aT(u, w, v), w.child !== null) { w.child.return = w, w = w.child; continue } if (w === h) break; for (; w.sibling === null;) { if (w.return === null || w.return === h) return; w = w.return, w.tag === 4 && (E = !1) } w.sibling.return = w.return, w = w.sibling } } function q_(u, h) { if (Ge) { switch (h.tag) { case 0: case 11: case 14: case 15: $l(3, h, h.return), Kh(3, h), $l(5, h, h.return); return; case 1: return; case 5: var v = h.stateNode; if (v != null) { var w = h.memoizedProps; u = u !== null ? u.memoizedProps : w; var E = h.type, P = h.updateQueue; h.updateQueue = null, P !== null && X(v, P, E, u, w, h) } return; case 6: if (h.stateNode === null) throw Error(o(162)); v = h.memoizedProps, Te(h.stateNode, u !== null ? u.memoizedProps : v, v); return; case 3: pe && u !== null && u.memoizedState.isDehydrated && te(h.stateNode.containerInfo); return; case 12: return; case 13: Ym(h); return; case 19: Ym(h); return; case 17: return }throw Error(o(163)) } switch (h.tag) { case 0: case 11: case 14: case 15: $l(3, h, h.return), Kh(3, h), $l(5, h, h.return); return; case 12: return; case 13: Ym(h); return; case 19: Ym(h); return; case 3: pe && u !== null && u.memoizedState.isDehydrated && te(h.stateNode.containerInfo); break; case 22: case 23: return }e: if (H) { switch (h.tag) { case 1: case 5: case 6: break e; case 3: case 4: h = h.stateNode, ht(h.containerInfo, h.pendingChildren); break e }throw Error(o(163)) } } function Ym(u) { var h = u.updateQueue; if (h !== null) { u.updateQueue = null; var v = u.stateNode; v === null && (v = u.stateNode = new SN), h.forEach(function (w) { var E = ON.bind(null, u, w); v.has(w) || (v.add(w), w.then(E, E)) }) } } function CN(u, h) { for (Xe = h; Xe !== null;) { h = Xe; var v = h.deletions; if (v !== null) for (var w = 0; w < v.length; w++) { var E = v[w]; try { var P = u; Ge ? dT(P, E, h) : lT(P, E, h); var z = E.alternate; z !== null && (z.return = null), E.return = null } catch (at) { Sr(E, h, at) } } if (v = h.child, h.subtreeFlags & 12854 && v !== null) v.return = h, Xe = v; else for (; Xe !== null;) { h = Xe; try { var $ = h.flags; if ($ & 32 && Ge && lt(h.stateNode), $ & 512) { var me = h.alternate; if (me !== null) { var Le = me.ref; Le !== null && (typeof Le == "function" ? Le(null) : Le.current = null) } } if ($ & 8192) switch (h.tag) { case 13: if (h.memoizedState !== null) { var et = h.alternate; (et === null || et.memoizedState === null) && (ix = yi()) } break; case 22: var Et = h.memoizedState !== null, mt = h.alternate, cn = mt !== null && mt.memoizedState !== null; if (v = h, Ge) { e: if (w = v, E = Et, P = null, Ge) for (var ct = w; ;) { if (ct.tag === 5) { if (P === null) { P = ct; var Vi = ct.stateNode; E ? vt(Vi) : Oe(ct.stateNode, ct.memoizedProps) } } else if (ct.tag === 6) { if (P === null) { var vs = ct.stateNode; E ? W(vs) : se(vs, ct.memoizedProps) } } else if ((ct.tag !== 22 && ct.tag !== 23 || ct.memoizedState === null || ct === w) && ct.child !== null) { ct.child.return = ct, ct = ct.child; continue } if (ct === w) break; for (; ct.sibling === null;) { if (ct.return === null || ct.return === w) break e; P === ct && (P = null), ct = ct.return } P === ct && (P = null), ct.sibling.return = ct.return, ct = ct.sibling } } if (Et && !cn && v.mode & 1) { Xe = v; for (var le = v.child; le !== null;) { for (v = Xe = le; Xe !== null;) { w = Xe; var ee = w.child; switch (w.tag) { case 0: case 11: case 14: case 15: $l(4, w, w.return); break; case 1: Jm(w, w.return); var de = w.stateNode; if (typeof de.componentWillUnmount == "function") { var Ye = w.return; try { de.props = w.memoizedProps, de.state = w.memoizedState, de.componentWillUnmount() } catch (at) { Sr(w, Ye, at) } } break; case 5: Jm(w, w.return); break; case 22: if (w.memoizedState !== null) { gT(v); continue } }ee !== null ? (ee.return = w, Xe = ee) : gT(v) } le = le.sibling } } }switch ($ & 4102) { case 2: hT(h), h.flags &= -3; break; case 6: hT(h), h.flags &= -3, q_(h.alternate, h); break; case 4096: h.flags &= -4097; break; case 4100: h.flags &= -4097, q_(h.alternate, h); break; case 4: q_(h.alternate, h) } } catch (at) { Sr(h, h.return, at) } if (v = h.sibling, v !== null) { v.return = h.return, Xe = v; break } Xe = h.return } } } function TN(u, h, v) { Xe = u, pT(u) } function pT(u, h, v) { for (var w = (u.mode & 1) !== 0; Xe !== null;) { var E = Xe, P = E.child; if (E.tag === 22 && w) { var z = E.memoizedState !== null || Xm; if (!z) { var $ = E.alternate, me = $ !== null && $.memoizedState !== null || Zl; $ = Xm; var Le = Zl; if (Xm = z, (Zl = me) && !Le) for (Xe = E; Xe !== null;)z = Xe, me = z.child, z.tag === 22 && z.memoizedState !== null ? yT(E) : me !== null ? (me.return = z, Xe = me) : yT(E); for (; P !== null;)Xe = P, pT(P), P = P.sibling; Xe = E, Xm = $, Zl = Le } mT(u) } else E.subtreeFlags & 8772 && P !== null ? (P.return = E, Xe = P) : mT(u) } } function mT(u) { for (; Xe !== null;) { var h = Xe; if (h.flags & 8772) { var v = h.alternate; try { if (h.flags & 8772) switch (h.tag) { case 0: case 11: case 15: Zl || Kh(5, h); break; case 1: var w = h.stateNode; if (h.flags & 4 && !Zl) if (v === null) w.componentDidMount(); else { var E = h.elementType === h.type ? v.memoizedProps : Xs(h.type, v.memoizedProps); w.componentDidUpdate(E, v.memoizedState, w.__reactInternalSnapshotBeforeUpdate) } var P = h.updateQueue; P !== null && cC(h, P, w); break; case 3: var z = h.updateQueue; if (z !== null) { if (v = null, h.child !== null) switch (h.child.tag) { case 5: v = ne(h.child.stateNode); break; case 1: v = h.child.stateNode }cC(h, z, v) } break; case 5: var $ = h.stateNode; v === null && h.flags & 4 && oe($, h.type, h.memoizedProps, h); break; case 6: break; case 4: break; case 12: break; case 13: if (pe && h.memoizedState === null) { var me = h.alternate; if (me !== null) { var Le = me.memoizedState; if (Le !== null) { var et = Le.dehydrated; et !== null && ue(et) } } } break; case 19: case 17: case 21: case 22: case 23: break; default: throw Error(o(163)) }Zl || h.flags & 512 && Y_(h) } catch (Et) { Sr(h, h.return, Et) } } if (h === u) { Xe = null; break } if (v = h.sibling, v !== null) { v.return = h.return, Xe = v; break } Xe = h.return } } function gT(u) { for (; Xe !== null;) { var h = Xe; if (h === u) { Xe = null; break } var v = h.sibling; if (v !== null) { v.return = h.return, Xe = v; break } Xe = h.return } } function yT(u) { for (; Xe !== null;) { var h = Xe; try { switch (h.tag) { case 0: case 11: case 15: var v = h.return; try { Kh(4, h) } catch (me) { Sr(h, v, me) } break; case 1: var w = h.stateNode; if (typeof w.componentDidMount == "function") { var E = h.return; try { w.componentDidMount() } catch (me) { Sr(h, E, me) } } var P = h.return; try { Y_(h) } catch (me) { Sr(h, P, me) } break; case 5: var z = h.return; try { Y_(h) } catch (me) { Sr(h, z, me) } } } catch (me) { Sr(h, h.return, me) } if (h === u) { Xe = null; break } var $ = h.sibling; if ($ !== null) { $.return = h.return, Xe = $; break } Xe = h.return } } var jm = 0, Km = 1, qm = 2, Qm = 3, Zm = 4; if (typeof Symbol == "function" && Symbol.for) { var qh = Symbol.for; jm = qh("selector.component"), Km = qh("selector.has_pseudo_class"), qm = qh("selector.role"), Qm = qh("selector.test_id"), Zm = qh("selector.text") } function Q_(u) { var h = fe(u); if (h != null) { if (typeof h.memoizedProps["data-testname"] != "string") throw Error(o(364)); return h } if (u = ot(u), u === null) throw Error(o(362)); return u.stateNode.current } function Z_(u, h) { switch (h.$$typeof) { case jm: if (u.type === h.value) return !0; break; case Km: e: { h = h.value, u = [u, 0]; for (var v = 0; v < u.length;) { var w = u[v++], E = u[v++], P = h[E]; if (w.tag !== 5 || !D(w)) { for (; P != null && Z_(w, P);)E++, P = h[E]; if (E === h.length) { h = !0; break e } else for (w = w.child; w !== null;)u.push(w, E), w = w.sibling } } h = !1 } return h; case qm: if (u.tag === 5 && re(u.stateNode, h.value)) return !0; break; case Zm: if ((u.tag === 5 || u.tag === 6) && (u = U(u), u !== null && 0 <= u.indexOf(h.value))) return !0; break; case Qm: if (u.tag === 5 && (u = u.memoizedProps["data-testname"], typeof u == "string" && u.toLowerCase() === h.value.toLowerCase())) return !0; break; default: throw Error(o(365)) }return !1 } function $_(u) { switch (u.$$typeof) { case jm: return "<" + (R(u.value) || "Unknown") + ">"; case Km: return ":has(" + ($_(u) || "") + ")"; case qm: return '[role="' + u.value + '"]'; case Zm: return '"' + u.value + '"'; case Qm: return '[data-testname="' + u.value + '"]'; default: throw Error(o(365)) } } function vT(u, h) { var v = []; u = [u, 0]; for (var w = 0; w < u.length;) { var E = u[w++], P = u[w++], z = h[P]; if (E.tag !== 5 || !D(E)) { for (; z != null && Z_(E, z);)P++, z = h[P]; if (P === h.length) v.push(E); else for (E = E.child; E !== null;)u.push(E, P), E = E.sibling } } return v } function ex(u, h) { if (!st) throw Error(o(363)); u = Q_(u), u = vT(u, h), h = [], u = Array.from(u); for (var v = 0; v < u.length;) { var w = u[v++]; if (w.tag === 5) D(w) || h.push(w.stateNode); else for (w = w.child; w !== null;)u.push(w), w = w.sibling } return h } var bN = Math.ceil, $m = a.ReactCurrentDispatcher, tx = a.ReactCurrentOwner, Yn = a.ReactCurrentBatchConfig, kt = 0, $n = null, ei = null, Pi = 0, Vr = 0, Ru = gt(0), ui = 0, Qh = null, Pu = 0, eg = 0, nx = 0, Zh = null, Mr = null, ix = 0, rx = 1 / 0; function Iu() { rx = yi() + 500 } var tg = !1, sx = null, za = null, ng = !1, Ha = null, ig = 0, $h = 0, ox = null, rg = -1, sg = 0; function or() { return kt & 6 ? yi() : rg !== -1 ? rg : rg = yi() } function Ga(u) { return u.mode & 1 ? kt & 2 && Pi !== 0 ? Pi & -Pi : uN.transition !== null ? (sg === 0 && (u = vm, vm <<= 1, !(vm & 4194240) && (vm = 64), sg = u), sg) : (u = en, u !== 0 ? u : ve()) : 1 } function gs(u, h, v) { if (50 < $h) throw $h = 0, ox = null, Error(o(185)); var w = og(u, h); return w === null ? null : (Fh(w, h, v), (!(kt & 2) || w !== $n) && (w === $n && (!(kt & 2) && (eg |= h), ui === 4 && Va(w, Pi)), wr(w, v), h === 1 && kt === 0 && !(u.mode & 1) && (Iu(), Mm && wo())), w) } function og(u, h) { u.lanes |= h; var v = u.alternate; for (v !== null && (v.lanes |= h), v = u, u = u.return; u !== null;)u.childLanes |= h, v = u.alternate, v !== null && (v.childLanes |= h), v = u, u = u.return; return v.tag === 3 ? v.stateNode : null } function wr(u, h) { var v = u.callbackNode; tN(u, h); var w = xm(u, u === $n ? Pi : 0); if (w === 0) v !== null && rC(v), u.callbackNode = null, u.callbackPriority = 0; else if (h = w & -w, u.callbackPriority !== h) { if (v != null && rC(v), h === 1) u.tag === 0 ? cN(xT.bind(null, u)) : sC(xT.bind(null, u)), Fe ? Ve(function () { kt === 0 && wo() }) : p_(m_, wo), v = null; else { switch (iC(w)) { case 1: v = m_; break; case 4: v = sN; break; case 16: v = g_; break; case 536870912: v = oN; break; default: v = g_ }v = RT(v, _T.bind(null, u)) } u.callbackPriority = h, u.callbackNode = v } } function _T(u, h) { if (rg = -1, sg = 0, kt & 6) throw Error(o(327)); var v = u.callbackNode; if (nc() && u.callbackNode !== v) return null; var w = xm(u, u === $n ? Pi : 0); if (w === 0) return null; if (w & 30 || w & u.expiredLanes || h) h = ag(u, w); else { h = w; var E = kt; kt |= 2; var P = wT(); ($n !== u || Pi !== h) && (Iu(), ec(u, h)); do try { IN(); break } catch ($) { MT(u, $) } while (1); __(), $m.current = P, kt = E, ei !== null ? h = 0 : ($n = null, Pi = 0, h = ui) } if (h !== 0) { if (h === 2 && (E = f_(u), E !== 0 && (w = E, h = ax(u, E))), h === 1) throw v = Qh, ec(u, 0), Va(u, w), wr(u, yi()), v; if (h === 6) Va(u, w); else { if (E = u.current.alternate, !(w & 30) && !RN(E) && (h = ag(u, w), h === 2 && (P = f_(u), P !== 0 && (w = P, h = ax(u, P))), h === 1)) throw v = Qh, ec(u, 0), Va(u, w), wr(u, yi()), v; switch (u.finishedWork = E, u.finishedLanes = w, h) { case 0: case 1: throw Error(o(345)); case 2: tc(u, Mr); break; case 3: if (Va(u, w), (w & 130023424) === w && (h = ix + 500 - yi(), 10 < h)) { if (xm(u, 0) !== 0) break; if (E = u.suspendedLanes, (E & w) !== w) { or(), u.pingedLanes |= u.suspendedLanes & E; break } u.timeoutHandle = Ie(tc.bind(null, u, Mr), h); break } tc(u, Mr); break; case 4: if (Va(u, w), (w & 4194240) === w) break; for (h = u.eventTimes, E = -1; 0 < w;) { var z = 31 - Ws(w); P = 1 << z, z = h[z], z > E && (E = z), w &= ~P } if (w = E, w = yi() - w, w = (120 > w ? 120 : 480 > w ? 480 : 1080 > w ? 1080 : 1920 > w ? 1920 : 3e3 > w ? 3e3 : 4320 > w ? 4320 : 1960 * bN(w / 1960)) - w, 10 < w) { u.timeoutHandle = Ie(tc.bind(null, u, Mr), w); break } tc(u, Mr); break; case 5: tc(u, Mr); break; default: throw Error(o(329)) } } } return wr(u, yi()), u.callbackNode === v ? _T.bind(null, u) : null } function ax(u, h) { var v = Zh; return u.current.memoizedState.isDehydrated && (ec(u, h).flags |= 256), u = ag(u, h), u !== 2 && (h = Mr, Mr = v, h !== null && lx(h)), u } function lx(u) { Mr === null ? Mr = u : Mr.push.apply(Mr, u) } function RN(u) { for (var h = u; ;) { if (h.flags & 16384) { var v = h.updateQueue; if (v !== null && (v = v.stores, v !== null)) for (var w = 0; w < v.length; w++) { var E = v[w], P = E.getSnapshot; E = E.value; try { if (!Mo(P(), E)) return !1 } catch { return !1 } } } if (v = h.child, h.subtreeFlags & 16384 && v !== null) v.return = h, h = v; else { if (h === u) break; for (; h.sibling === null;) { if (h.return === null || h.return === u) return !0; h = h.return } h.sibling.return = h.return, h = h.sibling } } return !0 } function Va(u, h) { for (h &= ~nx, h &= ~eg, u.suspendedLanes |= h, u.pingedLanes &= ~h, u = u.expirationTimes; 0 < h;) { var v = 31 - Ws(h), w = 1 << v; u[v] = -1, h &= ~w } } function xT(u) { if (kt & 6) throw Error(o(327)); nc(); var h = xm(u, 0); if (!(h & 1)) return wr(u, yi()), null; var v = ag(u, h); if (u.tag !== 0 && v === 2) { var w = f_(u); w !== 0 && (h = w, v = ax(u, w)) } if (v === 1) throw v = Qh, ec(u, 0), Va(u, h), wr(u, yi()), v; if (v === 6) throw Error(o(345)); return u.finishedWork = u.current.alternate, u.finishedLanes = h, tc(u, Mr), wr(u, yi()), null } function AT(u) { Ha !== null && Ha.tag === 0 && !(kt & 6) && nc(); var h = kt; kt |= 1; var v = Yn.transition, w = en; try { if (Yn.transition = null, en = 1, u) return u() } finally { en = w, Yn.transition = v, kt = h, !(kt & 6) && wo() } } function cx() { Vr = Ru.current, jt(Ru) } function ec(u, h) { u.finishedWork = null, u.finishedLanes = 0; var v = u.timeoutHandle; if (v !== ut && (u.timeoutHandle = ut, Je(v)), ei !== null) for (v = ei.return; v !== null;) { var w = v; switch (C_(w), w.tag) { case 1: w = w.type.childContextTypes, w != null && ka(); break; case 3: Tu(), jt(Zn), jt(ci), L_(); break; case 5: I_(w); break; case 4: Tu(); break; case 13: jt(En); break; case 19: jt(En); break; case 10: x_(w.type._context); break; case 22: case 23: cx() }v = v.return } if ($n = u, ei = u = Wa(u.current, null), Pi = Vr = h, ui = 0, Qh = null, nx = eg = Pu = 0, Mr = Zh = null, So !== null) { for (h = 0; h < So.length; h++)if (v = So[h], w = v.interleaved, w !== null) { v.interleaved = null; var E = w.next, P = v.pending; if (P !== null) { var z = P.next; P.next = E, w.next = z } v.pending = w } So = null } return u } function MT(u, h) { do { var v = ei; try { if (__(), Lm.current = Um, Dm) { for (var w = kn.memoizedState; w !== null;) { var E = w.queue; E !== null && (E.pending = null), w = w.next } Dm = !1 } if (bu = 0, vi = zi = kn = null, Gh = !1, Vh = 0, tx.current = null, v === null || v.return === null) { ui = 1, Qh = h, ei = null; break } e: { var P = u, z = v.return, $ = v, me = h; if (h = Pi, $.flags |= 32768, me !== null && typeof me == "object" && typeof me.then == "function") { var Le = me, et = $, Et = et.tag; if (!(et.mode & 1) && (Et === 0 || Et === 11 || Et === 15)) { var mt = et.alternate; mt ? (et.updateQueue = mt.updateQueue, et.memoizedState = mt.memoizedState, et.lanes = mt.lanes) : (et.updateQueue = null, et.memoizedState = null) } var cn = VC(z); if (cn !== null) { cn.flags &= -257, WC(cn, z, $, P, h), cn.mode & 1 && GC(P, Le, h), h = cn, me = Le; var ct = h.updateQueue; if (ct === null) { var Vi = new Set; Vi.add(me), h.updateQueue = Vi } else ct.add(me); break e } else { if (!(h & 1)) { GC(P, Le, h), ux(); break e } me = Error(o(426)) } } else if (An && $.mode & 1) { var vs = VC(z); if (vs !== null) { !(vs.flags & 65536) && (vs.flags |= 256), WC(vs, z, $, P, h), R_(me); break e } } P = me, ui !== 4 && (ui = 2), Zh === null ? Zh = [P] : Zh.push(P), me = z_(me, $), $ = z; do { switch ($.tag) { case 3: $.flags |= 65536, h &= -h, $.lanes |= h; var le = zC($, me, h); lC($, le); break e; case 1: P = me; var ee = $.type, de = $.stateNode; if (!($.flags & 128) && (typeof ee.getDerivedStateFromError == "function" || de !== null && typeof de.componentDidCatch == "function" && (za === null || !za.has(de)))) { $.flags |= 65536, h &= -h, $.lanes |= h; var Ye = HC($, P, h); lC($, Ye); break e } }$ = $.return } while ($ !== null) } ET(v) } catch (at) { h = at, ei === v && v !== null && (ei = v = v.return); continue } break } while (1) } function wT() { var u = $m.current; return $m.current = Um, u === null ? Um : u } function ux() { (ui === 0 || ui === 3 || ui === 2) && (ui = 4), $n === null || !(Pu & 268435455) && !(eg & 268435455) || Va($n, Pi) } function ag(u, h) { var v = kt; kt |= 2; var w = wT(); $n === u && Pi === h || ec(u, h); do try { PN(); break } catch (E) { MT(u, E) } while (1); if (__(), kt = v, $m.current = w, ei !== null) throw Error(o(261)); return $n = null, Pi = 0, ui } function PN() { for (; ei !== null;)ST(ei) } function IN() { for (; ei !== null && !iN();)ST(ei) } function ST(u) { var h = bT(u.alternate, u, Vr); u.memoizedProps = u.pendingProps, h === null ? ET(u) : ei = h, tx.current = null } function ET(u) { var h = u; do { var v = h.alternate; if (u = h.return, h.flags & 32768) { if (v = wN(v, h), v !== null) { v.flags &= 32767, ei = v; return } if (u !== null) u.flags |= 32768, u.subtreeFlags = 0, u.deletions = null; else { ui = 6, ei = null; return } } else if (v = xN(v, h, Vr), v !== null) { ei = v; return } if (h = h.sibling, h !== null) { ei = h; return } ei = h = u } while (h !== null); ui === 0 && (ui = 5) } function tc(u, h) { var v = en, w = Yn.transition; try { Yn.transition = null, en = 1, BN(u, h, v) } finally { Yn.transition = w, en = v } return null } function BN(u, h, v) { do nc(); while (Ha !== null); if (kt & 6) throw Error(o(327)); var w = u.finishedWork, E = u.finishedLanes; if (w === null) return null; if (u.finishedWork = null, u.finishedLanes = 0, w === u.current) throw Error(o(177)); u.callbackNode = null, u.callbackPriority = 0; var P = w.lanes | w.childLanes; if (nN(u, P), u === $n && (ei = $n = null, Pi = 0), !(w.subtreeFlags & 2064) && !(w.flags & 2064) || ng || (ng = !0, RT(g_, function () { return nc(), null })), P = (w.flags & 15990) !== 0, w.subtreeFlags & 15990 || P) { P = Yn.transition, Yn.transition = null; var z = en; en = 1; var $ = kt; kt |= 4, tx.current = null, EN(u, w), CN(u, w), L(u.containerInfo), u.current = w, TN(w), rN(), kt = $, en = z, Yn.transition = P } else u.current = w; if (ng && (ng = !1, Ha = u, ig = E), P = u.pendingLanes, P === 0 && (za = null), aN(w.stateNode), wr(u, yi()), h !== null) for (v = u.onRecoverableError, w = 0; w < h.length; w++)v(h[w]); if (tg) throw tg = !1, u = sx, sx = null, u; return ig & 1 && u.tag !== 0 && nc(), P = u.pendingLanes, P & 1 ? u === ox ? $h++ : ($h = 0, ox = u) : $h = 0, wo(), null } function nc() { if (Ha !== null) { var u = iC(ig), h = Yn.transition, v = en; try { if (Yn.transition = null, en = 16 > u ? 16 : u, Ha === null) var w = !1; else { if (u = Ha, Ha = null, ig = 0, kt & 6) throw Error(o(331)); var E = kt; for (kt |= 4, Xe = u.current; Xe !== null;) { var P = Xe, z = P.child; if (Xe.flags & 16) { var $ = P.deletions; if ($ !== null) { for (var me = 0; me < $.length; me++) { var Le = $[me]; for (Xe = Le; Xe !== null;) { var et = Xe; switch (et.tag) { case 0: case 11: case 15: $l(8, et, P) }var Et = et.child; if (Et !== null) Et.return = et, Xe = Et; else for (; Xe !== null;) { et = Xe; var mt = et.sibling, cn = et.return; if (cT(et), et === Le) { Xe = null; break } if (mt !== null) { mt.return = cn, Xe = mt; break } Xe = cn } } } var ct = P.alternate; if (ct !== null) { var Vi = ct.child; if (Vi !== null) { ct.child = null; do { var vs = Vi.sibling; Vi.sibling = null, Vi = vs } while (Vi !== null) } } Xe = P } } if (P.subtreeFlags & 2064 && z !== null) z.return = P, Xe = z; else e: for (; Xe !== null;) { if (P = Xe, P.flags & 2048) switch (P.tag) { case 0: case 11: case 15: $l(9, P, P.return) }var le = P.sibling; if (le !== null) { le.return = P.return, Xe = le; break e } Xe = P.return } } var ee = u.current; for (Xe = ee; Xe !== null;) { z = Xe; var de = z.child; if (z.subtreeFlags & 2064 && de !== null) de.return = z, Xe = de; else e: for (z = ee; Xe !== null;) { if ($ = Xe, $.flags & 2048) try { switch ($.tag) { case 0: case 11: case 15: Kh(9, $) } } catch (at) { Sr($, $.return, at) } if ($ === z) { Xe = null; break e } var Ye = $.sibling; if (Ye !== null) { Ye.return = $.return, Xe = Ye; break e } Xe = $.return } } if (kt = E, wo(), Ao && typeof Ao.onPostCommitFiberRoot == "function") try { Ao.onPostCommitFiberRoot(Am, u) } catch { } w = !0 } return w } finally { en = v, Yn.transition = h } } return !1 } function CT(u, h, v) { h = z_(v, h), h = zC(u, h, 1), Ua(u, h), h = or(), u = og(u, 1), u !== null && (Fh(u, 1, h), wr(u, h)) } function Sr(u, h, v) { if (u.tag === 3) CT(u, u, v); else for (; h !== null;) { if (h.tag === 3) { CT(h, u, v); break } else if (h.tag === 1) { var w = h.stateNode; if (typeof h.type.getDerivedStateFromError == "function" || typeof w.componentDidCatch == "function" && (za === null || !za.has(w))) { u = z_(v, u), u = HC(h, u, 1), Ua(h, u), u = or(), h = og(h, 1), h !== null && (Fh(h, 1, u), wr(h, u)); break } } h = h.return } } function LN(u, h, v) { var w = u.pingCache; w !== null && w.delete(h), h = or(), u.pingedLanes |= u.suspendedLanes & v, $n === u && (Pi & v) === v && (ui === 4 || ui === 3 && (Pi & 130023424) === Pi && 500 > yi() - ix ? ec(u, 0) : nx |= v), wr(u, h) } function TT(u, h) { h === 0 && (u.mode & 1 ? (h = _m, _m <<= 1, !(_m & 130023424) && (_m = 4194304)) : h = 1); var v = or(); u = og(u, h), u !== null && (Fh(u, h, v), wr(u, v)) } function DN(u) { var h = u.memoizedState, v = 0; h !== null && (v = h.retryLane), TT(u, v) } function ON(u, h) { var v = 0; switch (u.tag) { case 13: var w = u.stateNode, E = u.memoizedState; E !== null && (v = E.retryLane); break; case 19: w = u.stateNode; break; default: throw Error(o(314)) }w !== null && w.delete(h), TT(u, v) } var bT; bT = function (u, h, v) { if (u !== null) if (u.memoizedProps !== h.pendingProps || Zn.current) Gr = !0; else { if (!(u.lanes & v) && !(h.flags & 128)) return Gr = !1, MN(u, h, v); Gr = !!(u.flags & 131072) } else Gr = !1, An && h.flags & 1048576 && pC(h, Pm, h.index); switch (h.lanes = 0, h.tag) { case 2: var w = h.type; u !== null && (u.alternate = null, h.alternate = null, h.flags |= 2), u = h.pendingProps; var E = On(h, ci.current); Au(h, v), E = O_(null, h, w, u, E, v); var P = F_(); return h.flags |= 1, typeof E == "object" && E !== null && typeof E.render == "function" && E.$$typeof === void 0 ? (h.tag = 1, h.memoizedState = null, h.updateQueue = null, Fn(w) ? (P = !0, _u(h)) : P = !1, h.memoizedState = E.state !== null && E.state !== void 0 ? E.state : null, M_(h), E.updater = bm, h.stateNode = E, E._reactInternals = h, S_(h, w, u, v), h = V_(null, h, w, !0, P, v)) : (h.tag = 0, An && P && E_(h), sr(null, h, E, v), h = h.child), h; case 16: w = h.elementType; e: { switch (u !== null && (u.alternate = null, h.alternate = null, h.flags |= 2), u = h.pendingProps, E = w._init, w = E(w._payload), h.type = w, E = h.tag = kN(w), u = Xs(w, u), E) { case 0: h = G_(null, h, w, u, v); break e; case 1: h = ZC(null, h, w, u, v); break e; case 11: h = YC(null, h, w, u, v); break e; case 14: h = jC(null, h, w, Xs(w.type, u), v); break e }throw Error(o(306, w, "")) } return h; case 0: return w = h.type, E = h.pendingProps, E = h.elementType === w ? E : Xs(w, E), G_(u, h, w, E, v); case 1: return w = h.type, E = h.pendingProps, E = h.elementType === w ? E : Xs(w, E), ZC(u, h, w, E, v); case 3: e: { if ($C(h), u === null) throw Error(o(387)); w = h.pendingProps, P = h.memoizedState, E = P.element, aC(u, h), Tm(h, w, null, v); var z = h.memoizedState; if (w = z.element, pe && P.isDehydrated) if (P = { element: w, isDehydrated: !1, cache: z.cache, transitions: z.transitions }, h.updateQueue.baseState = P, h.memoizedState = P, h.flags & 256) { E = Error(o(423)), h = eT(u, h, w, v, E); break e } else if (w !== E) { E = Error(o(424)), h = eT(u, h, w, v, E); break e } else for (pe && (Hr = ai(h.stateNode.containerInfo), zr = h, An = !0, Js = null, kh = !1), v = xC(h, null, w, v), h.child = v; v;)v.flags = v.flags & -3 | 4096, v = v.sibling; else { if (Su(), w === E) { h = na(u, h, v); break e } sr(u, h, w, v) } h = h.child } return h; case 5: return AC(h), u === null && b_(h), w = h.type, E = h.pendingProps, P = u !== null ? u.memoizedProps : null, z = E.children, xe(w, E) ? z = null : P !== null && xe(w, P) && (h.flags |= 32), QC(u, h), sr(u, h, z, v), h.child; case 6: return u === null && b_(h), null; case 13: return tT(u, h, v); case 4: return P_(h, h.stateNode.containerInfo), w = h.pendingProps, u === null ? h.child = Eu(h, null, w, v) : sr(u, h, w, v), h.child; case 11: return w = h.type, E = h.pendingProps, E = h.elementType === w ? E : Xs(w, E), YC(u, h, w, E, v); case 7: return sr(u, h, h.pendingProps, v), h.child; case 8: return sr(u, h, h.pendingProps.children, v), h.child; case 12: return sr(u, h, h.pendingProps.children, v), h.child; case 10: e: { if (w = h.type._context, E = h.pendingProps, P = h.memoizedProps, z = E.value, oC(h, w, z), P !== null) if (Mo(P.value, z)) { if (P.children === E.children && !Zn.current) { h = na(u, h, v); break e } } else for (P = h.child, P !== null && (P.return = h); P !== null;) { var $ = P.dependencies; if ($ !== null) { z = P.child; for (var me = $.firstContext; me !== null;) { if (me.context === w) { if (P.tag === 1) { me = Zo(-1, v & -v), me.tag = 2; var Le = P.updateQueue; if (Le !== null) { Le = Le.shared; var et = Le.pending; et === null ? me.next = me : (me.next = et.next, et.next = me), Le.pending = me } } P.lanes |= v, me = P.alternate, me !== null && (me.lanes |= v), A_(P.return, v, h), $.lanes |= v; break } me = me.next } } else if (P.tag === 10) z = P.type === h.type ? null : P.child; else if (P.tag === 18) { if (z = P.return, z === null) throw Error(o(341)); z.lanes |= v, $ = z.alternate, $ !== null && ($.lanes |= v), A_(z, v, h), z = P.sibling } else z = P.child; if (z !== null) z.return = P; else for (z = P; z !== null;) { if (z === h) { z = null; break } if (P = z.sibling, P !== null) { P.return = z.return, z = P; break } z = z.return } P = z } sr(u, h, E.children, v), h = h.child } return h; case 9: return E = h.type, w = h.pendingProps.children, Au(h, v), E = fs(E), w = w(E), h.flags |= 1, sr(u, h, w, v), h.child; case 14: return w = h.type, E = Xs(w, h.pendingProps), E = Xs(w.type, E), jC(u, h, w, E, v); case 15: return KC(u, h, h.type, h.pendingProps, v); case 17: return w = h.type, E = h.pendingProps, E = h.elementType === w ? E : Xs(w, E), u !== null && (u.alternate = null, h.alternate = null, h.flags |= 2), h.tag = 1, Fn(w) ? (u = !0, _u(h)) : u = !1, Au(h, v), hC(h, w, E), S_(h, w, E, v), V_(null, h, w, !0, u, v); case 19: return sT(u, h, v); case 22: return qC(u, h, v) }throw Error(o(156, h.tag)) }; function RT(u, h) { return p_(u, h) } function FN(u, h, v, w) { this.tag = u, this.key = v, this.sibling = this.child = this.return = this.stateNode = this.type = this.elementType = null, this.index = 0, this.ref = null, this.pendingProps = h, this.dependencies = this.memoizedState = this.updateQueue = this.memoizedProps = null, this.mode = w, this.subtreeFlags = this.flags = 0, this.deletions = null, this.childLanes = this.lanes = 0, this.alternate = null } function ys(u, h, v, w) { return new FN(u, h, v, w) } function fx(u) { return u = u.prototype, !(!u || !u.isReactComponent) } function kN(u) { if (typeof u == "function") return fx(u) ? 1 : 0; if (u != null) { if (u = u.$$typeof, u === _) return 11; if (u === A) return 14 } return 2 } function Wa(u, h) { var v = u.alternate; return v === null ? (v = ys(u.tag, h, u.key, u.mode), v.elementType = u.elementType, v.type = u.type, v.stateNode = u.stateNode, v.alternate = u, u.alternate = v) : (v.pendingProps = h, v.type = u.type, v.flags = 0, v.subtreeFlags = 0, v.deletions = null), v.flags = u.flags & 14680064, v.childLanes = u.childLanes, v.lanes = u.lanes, v.child = u.child, v.memoizedProps = u.memoizedProps, v.memoizedState = u.memoizedState, v.updateQueue = u.updateQueue, h = u.dependencies, v.dependencies = h === null ? null : { lanes: h.lanes, firstContext: h.firstContext }, v.sibling = u.sibling, v.index = u.index, v.ref = u.ref, v } function lg(u, h, v, w, E, P) { var z = 2; if (w = u, typeof u == "function") fx(u) && (z = 1); else if (typeof u == "string") z = 5; else e: switch (u) { case f: return ic(v.children, E, P, h); case d: z = 8, E |= 8; break; case p: return u = ys(12, v, h, E | 2), u.elementType = p, u.lanes = P, u; case x: return u = ys(13, v, h, E), u.elementType = x, u.lanes = P, u; case g: return u = ys(19, v, h, E), u.elementType = g, u.lanes = P, u; case S: return cg(v, E, P, h); default: if (typeof u == "object" && u !== null) switch (u.$$typeof) { case m: z = 10; break e; case y: z = 9; break e; case _: z = 11; break e; case A: z = 14; break e; case M: z = 16, w = null; break e }throw Error(o(130, u == null ? u : typeof u, "")) }return h = ys(z, v, h, E), h.elementType = u, h.type = w, h.lanes = P, h } function ic(u, h, v, w) { return u = ys(7, u, w, h), u.lanes = v, u } function cg(u, h, v, w) { return u = ys(22, u, w, h), u.elementType = S, u.lanes = v, u.stateNode = {}, u } function hx(u, h, v) { return u = ys(6, u, null, h), u.lanes = v, u } function dx(u, h, v) { return h = ys(4, u.children !== null ? u.children : [], u.key, h), h.lanes = v, h.stateNode = { containerInfo: u.containerInfo, pendingChildren: null, implementation: u.implementation }, h } function NN(u, h, v, w, E) { this.tag = h, this.containerInfo = u, this.finishedWork = this.pingCache = this.current = this.pendingChildren = null, this.timeoutHandle = ut, this.callbackNode = this.pendingContext = this.context = null, this.callbackPriority = 0, this.eventTimes = h_(0), this.expirationTimes = h_(-1), this.entangledLanes = this.finishedLanes = this.mutableReadLanes = this.expiredLanes = this.pingedLanes = this.suspendedLanes = this.pendingLanes = 0, this.entanglements = h_(0), this.identifierPrefix = w, this.onRecoverableError = E, pe && (this.mutableSourceEagerHydrationData = null) } function PT(u, h, v, w, E, P, z, $, me) { return u = new NN(u, h, v, $, me), h === 1 ? (h = 1, P === !0 && (h |= 8)) : h = 0, P = ys(3, null, null, h), u.current = P, P.stateNode = u, P.memoizedState = { element: w, isDehydrated: v, cache: null, transitions: null }, M_(P), u } function IT(u) { if (!u) return Ni; u = u._reactInternals; e: { if (b(u) !== u || u.tag !== 1) throw Error(o(170)); var h = u; do { switch (h.tag) { case 3: h = h.stateNode.context; break e; case 1: if (Fn(h.type)) { h = h.stateNode.__reactInternalMemoizedMergedChildContext; break e } }h = h.return } while (h !== null); throw Error(o(171)) } if (u.tag === 1) { var v = u.type; if (Fn(v)) return vu(u, v, h) } return h } function BT(u) { var h = u._reactInternals; if (h === void 0) throw typeof u.render == "function" ? Error(o(188)) : (u = Object.keys(u).join(","), Error(o(268, u))); return u = V(h), u === null ? null : u.stateNode } function LT(u, h) { if (u = u.memoizedState, u !== null && u.dehydrated !== null) { var v = u.retryLane; u.retryLane = v !== 0 && v < h ? v : h } } function px(u, h) { LT(u, h), (u = u.alternate) && LT(u, h) } function UN(u) { return u = V(u), u === null ? null : u.stateNode } function zN() { return null } return t.attemptContinuousHydration = function (u) { if (u.tag === 13) { var h = or(); gs(u, 134217728, h), px(u, 134217728) } }, t.attemptHydrationAtCurrentPriority = function (u) { if (u.tag === 13) { var h = or(), v = Ga(u); gs(u, v, h), px(u, v) } }, t.attemptSynchronousHydration = function (u) { switch (u.tag) { case 3: var h = u.stateNode; if (h.current.memoizedState.isDehydrated) { var v = Oh(h.pendingLanes); v !== 0 && (d_(h, v | 1), wr(h, yi()), !(kt & 6) && (Iu(), wo())) } break; case 13: var w = or(); AT(function () { return gs(u, 1, w) }), px(u, 1) } }, t.batchedUpdates = function (u, h) { var v = kt; kt |= 1; try { return u(h) } finally { kt = v, kt === 0 && (Iu(), Mm && wo()) } }, t.createComponentSelector = function (u) { return { $$typeof: jm, value: u } }, t.createContainer = function (u, h, v, w, E, P, z) { return PT(u, h, !1, null, v, w, E, P, z) }, t.createHasPseudoClassSelector = function (u) { return { $$typeof: Km, value: u } }, t.createHydrationContainer = function (u, h, v, w, E, P, z, $, me) { return u = PT(v, w, !0, u, E, P, z, $, me), u.context = IT(null), v = u.current, w = or(), E = Ga(v), P = Zo(w, E), P.callback = h ?? null, Ua(v, P), u.current.lanes = E, Fh(u, E, w), wr(u, w), u }, t.createPortal = function (u, h, v) { var w = 3 < arguments.length && arguments[3] !== void 0 ? arguments[3] : null; return { $$typeof: c, key: w == null ? null : "" + w, children: u, containerInfo: h, implementation: v } }, t.createRoleSelector = function (u) { return { $$typeof: qm, value: u } }, t.createTestNameSelector = function (u) { return { $$typeof: Qm, value: u } }, t.createTextSelector = function (u) { return { $$typeof: Zm, value: u } }, t.deferredUpdates = function (u) { var h = en, v = Yn.transition; try { return Yn.transition = null, en = 16, u() } finally { en = h, Yn.transition = v } }, t.discreteUpdates = function (u, h, v, w, E) { var P = en, z = Yn.transition; try { return Yn.transition = null, en = 1, u(h, v, w, E) } finally { en = P, Yn.transition = z, kt === 0 && Iu() } }, t.findAllNodes = ex, t.findBoundingRects = function (u, h) { if (!st) throw Error(o(363)); h = ex(u, h), u = []; for (var v = 0; v < h.length; v++)u.push(Yt(h[v])); for (h = u.length - 1; 0 < h; h--) { v = u[h]; for (var w = v.x, E = w + v.width, P = v.y, z = P + v.height, $ = h - 1; 0 <= $; $--)if (h !== $) { var me = u[$], Le = me.x, et = Le + me.width, Et = me.y, mt = Et + me.height; if (w >= Le && P >= Et && E <= et && z <= mt) { u.splice(h, 1); break } else if (w !== Le || v.width !== me.width || mt < P || Et > z) { if (!(P !== Et || v.height !== me.height || et < w || Le > E)) { Le > w && (me.width += Le - w, me.x = w), et < E && (me.width = E - Le), u.splice(h, 1); break } } else { Et > P && (me.height += Et - P, me.y = P), mt < z && (me.height = z - Et), u.splice(h, 1); break } } } return u }, t.findHostInstance = BT, t.findHostInstanceWithNoPortals = function (u) { return u = N(u), u = u !== null ? j(u) : null, u === null ? null : u.stateNode }, t.findHostInstanceWithWarning = function (u) { return BT(u) }, t.flushControlled = function (u) { var h = kt; kt |= 1; var v = Yn.transition, w = en; try { Yn.transition = null, en = 1, u() } finally { en = w, Yn.transition = v, kt = h, kt === 0 && (Iu(), wo()) } }, t.flushPassiveEffects = nc, t.flushSync = AT, t.focusWithin = function (u, h) { if (!st) throw Error(o(363)); for (u = Q_(u), h = vT(u, h), h = Array.from(h), u = 0; u < h.length;) { var v = h[u++]; if (!D(v)) { if (v.tag === 5 && Ae(v.stateNode)) return !0; for (v = v.child; v !== null;)h.push(v), v = v.sibling } } return !1 }, t.getCurrentUpdatePriority = function () { return en }, t.getFindAllNodesFailureDescription = function (u, h) {
		if (!st) throw Error(o(363)); var v = 0, w = []; u = [Q_(u), 0]; for (var E = 0; E < u.length;) { var P = u[E++], z = u[E++], $ = h[z]; if ((P.tag !== 5 || !D(P)) && (Z_(P, $) && (w.push($_($)), z++, z > v && (v = z)), z < h.length)) for (P = P.child; P !== null;)u.push(P, z), P = P.sibling } if (v < h.length) {
			for (u = []; v < h.length; v++)u.push($_(h[v])); return `findAllNodes was able to match part of the selector:
  `+ (w.join(" > ") + `

No matching component was found for:
  `) + u.join(" > ")
		} return null
	}, t.getPublicRootInstance = function (u) { if (u = u.current, !u.child) return null; switch (u.child.tag) { case 5: return ne(u.child.stateNode); default: return u.child.stateNode } }, t.injectIntoDevTools = function (u) { if (u = { bundleType: u.bundleType, version: u.version, rendererPackageName: u.rendererPackageName, rendererConfig: u.rendererConfig, overrideHookState: null, overrideHookStateDeletePath: null, overrideHookStateRenamePath: null, overrideProps: null, overridePropsDeletePath: null, overridePropsRenamePath: null, setErrorHandler: null, setSuspenseHandler: null, scheduleUpdate: null, currentDispatcherRef: a.ReactCurrentDispatcher, findHostInstanceByFiber: UN, findFiberByHostInstance: u.findFiberByHostInstance || zN, findHostInstancesForRefresh: null, scheduleRefresh: null, scheduleRoot: null, setRefreshHandler: null, getCurrentFiber: null, reconcilerVersion: "18.0.0-fc46dba67-20220329" }, typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ > "u") u = !1; else { var h = __REACT_DEVTOOLS_GLOBAL_HOOK__; if (h.isDisabled || !h.supportsFiber) u = !0; else { try { Am = h.inject(u), Ao = h } catch { } u = !!h.checkDCE } } return u }, t.isAlreadyRendering = function () { return !1 }, t.observeVisibleRects = function (u, h, v, w) { if (!st) throw Error(o(363)); u = ex(u, h); var E = Me(u, v, w).disconnect; return { disconnect: function () { E() } } }, t.registerMutableSourceForHydration = function (u, h) { var v = h._getVersion; v = v(h._source), u.mutableSourceEagerHydrationData == null ? u.mutableSourceEagerHydrationData = [h, v] : u.mutableSourceEagerHydrationData.push(h, v) }, t.runWithPriority = function (u, h) { var v = en; try { return en = u, h() } finally { en = v } }, t.shouldError = function () { return null }, t.shouldSuspend = function () { return !1 }, t.updateContainer = function (u, h, v, w) { var E = h.current, P = or(), z = Ga(E); return v = IT(v), h.context === null ? h.context = v : h.pendingContext = v, h = Zo(P, z), h.payload = { element: u }, w = w === void 0 ? null : w, w !== null && (h.callback = w), Ua(E, h), u = gs(E, z, P), u !== null && Cm(u, E, z), z }, t
}; Sk.exports = AK; var MK = Sk.exports; const wK = LS(MK), SK = i => typeof i == "object" && typeof i.then == "function", Fc = []; function Tk(i, e, t = (n, r) => n === r) { if (i === e) return !0; if (!i || !e) return !1; const n = i.length; if (e.length !== n) return !1; for (let r = 0; r < n; r++)if (!t(i[r], e[r])) return !1; return !0 } function bk(i, e = null, t = !1, n = {}) { e === null && (e = [i]); for (const s of Fc) if (Tk(e, s.keys, s.equal)) { if (t) return; if (Object.prototype.hasOwnProperty.call(s, "error")) throw s.error; if (Object.prototype.hasOwnProperty.call(s, "response")) return n.lifespan && n.lifespan > 0 && (s.timeout && clearTimeout(s.timeout), s.timeout = setTimeout(s.remove, n.lifespan)), s.response; if (!t) throw s.promise } const r = { keys: e, equal: n.equal, remove: () => { const s = Fc.indexOf(r); s !== -1 && Fc.splice(s, 1) }, promise: (SK(i) ? i : i(...e)).then(s => { r.response = s, n.lifespan && n.lifespan > 0 && (r.timeout = setTimeout(r.remove, n.lifespan)) }).catch(s => r.error = s) }; if (Fc.push(r), !t) throw r.promise } const EK = (i, e, t) => bk(i, e, !1, t), CK = (i, e, t) => void bk(i, e, !0, t), TK = i => { if (i === void 0 || i.length === 0) Fc.splice(0, Fc.length); else { const e = Fc.find(t => Tk(i, t.keys, t.equal)); e && e.remove() } }, eC = {}, bK = i => void Object.assign(eC, i); function RK(i, e) { function t(f, { args: d = [], attach: p, ...m }, y) { let _ = `${f[0].toUpperCase()}${f.slice(1)}`, x; if (f === "primitive") { if (m.object === void 0) throw new Error("R3F: Primitives without 'object' are invalid!"); const g = m.object; x = uf(g, { type: f, root: y, attach: p, primitive: !0 }) } else { const g = eC[_]; if (!g) throw new Error(`R3F: ${_} is not part of the THREE namespace! Did you forget to extend? See: https://docs.pmnd.rs/react-three-fiber/api/objects#using-3rd-party-objects-declaratively`); if (!Array.isArray(d)) throw new Error("R3F: The args prop must be an array!"); x = uf(new g(...d), { type: f, root: y, attach: p, memoizedProps: { args: d } }) } return x.__r3f.attach === void 0 && (x instanceof Rt ? x.__r3f.attach = "geometry" : x instanceof oi && (x.__r3f.attach = "material")), _ !== "inject" && oM(x, m), x } function n(f, d) { let p = !1; if (d) { var m, y; (m = d.__r3f) != null && m.attach ? sM(f, d, d.__r3f.attach) : d.isObject3D && f.isObject3D && (f.add(d), p = !0), p || (y = f.__r3f) == null || y.objects.push(d), d.__r3f || uf(d, {}), d.__r3f.parent = f, RS(d), ff(d) } } function r(f, d, p) { let m = !1; if (d) { var y, _; if ((y = d.__r3f) != null && y.attach) sM(f, d, d.__r3f.attach); else if (d.isObject3D && f.isObject3D) { d.parent = f, d.dispatchEvent({ type: "added" }); const x = f.children.filter(A => A !== d), g = x.indexOf(p); f.children = [...x.slice(0, g), d, ...x.slice(g)], m = !0 } m || (_ = f.__r3f) == null || _.objects.push(d), d.__r3f || uf(d, {}), d.__r3f.parent = f, RS(d), ff(d) } } function s(f, d, p = !1) { f && [...f].forEach(m => o(d, m, p)) } function o(f, d, p) { if (d) { var m, y, _; if (d.__r3f && (d.__r3f.parent = null), (m = f.__r3f) != null && m.objects && (f.__r3f.objects = f.__r3f.objects.filter(S => S !== d)), (y = d.__r3f) != null && y.attach) bI(f, d, d.__r3f.attach); else if (d.isObject3D && f.isObject3D) { var x; f.remove(d), (x = d.__r3f) != null && x.root && kK(d.__r3f.root, d) } const A = (_ = d.__r3f) == null ? void 0 : _.primitive, M = p === void 0 ? d.dispose !== null && !A : p; if (!A) { var g; s((g = d.__r3f) == null ? void 0 : g.objects, d, M), s(d.children, d, M) } delete d.__r3f, M && d.dispose && d.type !== "Scene" && TS.unstable_scheduleCallback(TS.unstable_IdlePriority, () => { try { d.dispose() } catch { } }), ff(f) } } function a(f, d, p, m) { var y; const _ = (y = f.__r3f) == null ? void 0 : y.parent; if (!_) return; const x = t(d, p, f.__r3f.root); if (f.children) { for (const g of f.children) g.__r3f && n(x, g); f.children = f.children.filter(g => !g.__r3f) } f.__r3f.objects.forEach(g => n(x, g)), f.__r3f.objects = [], f.__r3f.autoRemovedBeforeAppend || o(_, f), x.parent && (x.__r3f.autoRemovedBeforeAppend = !0), n(_, x), x.raycast && x.__r3f.eventCount && x.__r3f.root.getState().internal.interaction.push(x), [m, m.alternate].forEach(g => { g !== null && (g.stateNode = x, g.ref && (typeof g.ref == "function" ? g.ref(x) : g.ref.current = x)) }) } const l = () => console.warn("Text is not allowed in the R3F tree! This could be stray whitespace or characters."); return { reconciler: wK({ createInstance: t, removeChild: o, appendChild: n, appendInitialChild: n, insertBefore: r, supportsMutation: !0, isPrimaryRenderer: !1, supportsPersistence: !1, supportsHydration: !1, noTimeout: -1, appendChildToContainer: (f, d) => { if (!d) return; const p = f.getState().scene; p.__r3f && (p.__r3f.root = f, n(p, d)) }, removeChildFromContainer: (f, d) => { d && o(f.getState().scene, d) }, insertInContainerBefore: (f, d, p) => { if (!d || !p) return; const m = f.getState().scene; m.__r3f && r(m, d, p) }, getRootHostContext: () => null, getChildHostContext: f => f, finalizeInitialChildren(f) { var d; return !!((d = f == null ? void 0 : f.__r3f) != null ? d : {}).handlers }, prepareUpdate(f, d, p, m) { var y; if (((y = f == null ? void 0 : f.__r3f) != null ? y : {}).primitive && m.object && m.object !== f) return [!0]; { const { args: x = [], children: g, ...A } = m, { args: M = [], children: S, ...C } = p; if (!Array.isArray(x)) throw new Error("R3F: the args prop must be an array!"); if (x.some((R, B) => R !== M[B])) return [!0]; const T = Ok(f, A, C, !0); return T.changes.length ? [!1, T] : null } }, commitUpdate(f, [d, p], m, y, _, x) { d ? a(f, m, _, x) : oM(f, p) }, commitMount(f, d, p, m) { var y; const _ = (y = f.__r3f) != null ? y : {}; f.raycast && _.handlers && _.eventCount && f.__r3f.root.getState().internal.interaction.push(f) }, getPublicInstance: f => f, prepareForCommit: () => null, preparePortalMount: f => uf(f.getState().scene), resetAfterCommit: () => { }, shouldSetTextContent: () => !1, clearContainer: () => !1, hideInstance(f) { var d; const { attach: p, parent: m } = (d = f.__r3f) != null ? d : {}; p && m && bI(m, f, p), f.isObject3D && (f.visible = !1), ff(f) }, unhideInstance(f, d) { var p; const { attach: m, parent: y } = (p = f.__r3f) != null ? p : {}; m && y && sM(y, f, m), (f.isObject3D && d.visible == null || d.visible) && (f.visible = !0), ff(f) }, createTextInstance: l, hideTextInstance: l, unhideTextInstance: l, getCurrentEventPriority: () => e ? e() : Lf.DefaultEventPriority, beforeActiveInstanceBlur: () => { }, afterActiveInstanceBlur: () => { }, detachDeletedInstance: () => { }, now: typeof performance < "u" && yn.fun(performance.now) ? performance.now : yn.fun(Date.now) ? Date.now : () => 0, scheduleTimeout: yn.fun(setTimeout) ? setTimeout : void 0, cancelTimeout: yn.fun(clearTimeout) ? clearTimeout : void 0 }), applyProps: oM } } var SI, EI; const rM = i => "colorSpace" in i || "outputColorSpace" in i, Rk = () => { var i; return (i = eC.ColorManagement) != null ? i : null }, Pk = i => i && i.isOrthographicCamera, PK = i => i && i.hasOwnProperty("current"), gm = typeof window < "u" && ((SI = window.document) != null && SI.createElement || ((EI = window.navigator) == null ? void 0 : EI.product) === "ReactNative") ? ce.useLayoutEffect : ce.useEffect; function Ik(i) { const e = ce.useRef(i); return gm(() => void (e.current = i), [i]), e } function IK({ set: i }) { return gm(() => (i(new Promise(() => null)), () => i(!1)), [i]), null } class Bk extends ce.Component { constructor(...e) { super(...e), this.state = { error: !1 } } componentDidCatch(e) { this.props.set(e) } render() { return this.state.error ? null : this.props.children } } Bk.getDerivedStateFromError = () => ({ error: !0 }); const Lk = "__default", CI = new Map, BK = i => i && !!i.memoized && !!i.changes; function Dk(i) { var e; const t = typeof window < "u" ? (e = window.devicePixelRatio) != null ? e : 2 : 1; return Array.isArray(i) ? Math.min(Math.max(i[0], t), i[1]) : i } const Ad = i => { var e; return (e = i.__r3f) == null ? void 0 : e.root.getState() }, yn = { obj: i => i === Object(i) && !yn.arr(i) && typeof i != "function", fun: i => typeof i == "function", str: i => typeof i == "string", num: i => typeof i == "number", boo: i => typeof i == "boolean", und: i => i === void 0, arr: i => Array.isArray(i), equ(i, e, { arrays: t = "shallow", objects: n = "reference", strict: r = !0 } = {}) { if (typeof i != typeof e || !!i != !!e) return !1; if (yn.str(i) || yn.num(i)) return i === e; const s = yn.obj(i); if (s && n === "reference") return i === e; const o = yn.arr(i); if (o && t === "reference") return i === e; if ((o || s) && i === e) return !0; let a; for (a in i) if (!(a in e)) return !1; if (s && t === "shallow" && n === "shallow") { for (a in r ? e : i) if (!yn.equ(i[a], e[a], { strict: r, objects: "reference" })) return !1 } else for (a in r ? e : i) if (i[a] !== e[a]) return !1; if (yn.und(a)) { if (o && i.length === 0 && e.length === 0 || s && Object.keys(i).length === 0 && Object.keys(e).length === 0) return !0; if (i !== e) return !1 } return !0 } }; function LK(i) { const e = { nodes: {}, materials: {} }; return i && i.traverse(t => { t.name && (e.nodes[t.name] = t), t.material && !e.materials[t.material.name] && (e.materials[t.material.name] = t.material) }), e } function DK(i) { i.dispose && i.type !== "Scene" && i.dispose(); for (const e in i) e.dispose == null || e.dispose(), delete i[e] } function uf(i, e) { const t = i; return t.__r3f = { type: "", root: null, previousAttach: null, memoizedProps: {}, eventCount: 0, handlers: {}, objects: [], parent: null, ...e }, i } function bS(i, e) { let t = i; if (e.includes("-")) { const n = e.split("-"), r = n.pop(); return t = n.reduce((s, o) => s[o], i), { target: t, key: r } } else return { target: t, key: e } } const TI = /-\d+$/; function sM(i, e, t) { if (yn.str(t)) { if (TI.test(t)) { const s = t.replace(TI, ""), { target: o, key: a } = bS(i, s); Array.isArray(o[a]) || (o[a] = []) } const { target: n, key: r } = bS(i, t); e.__r3f.previousAttach = n[r], n[r] = e } else e.__r3f.previousAttach = t(i, e) } function bI(i, e, t) { var n, r; if (yn.str(t)) { const { target: s, key: o } = bS(i, t), a = e.__r3f.previousAttach; a === void 0 ? delete s[o] : s[o] = a } else (n = e.__r3f) == null || n.previousAttach == null || n.previousAttach(i, e); (r = e.__r3f) == null || delete r.previousAttach } function Ok(i, { children: e, key: t, ref: n, ...r }, { children: s, key: o, ref: a, ...l } = {}, c = !1) { var f; const d = (f = i == null ? void 0 : i.__r3f) != null ? f : {}, p = Object.entries(r), m = []; if (c) { const _ = Object.keys(l); for (let x = 0; x < _.length; x++)r.hasOwnProperty(_[x]) || p.unshift([_[x], Lk + "remove"]) } p.forEach(([_, x]) => { var g; if ((g = i.__r3f) != null && g.primitive && _ === "object" || yn.equ(x, l[_])) return; if (/^on(Pointer|Click|DoubleClick|ContextMenu|Wheel)/.test(_)) return m.push([_, x, !0, []]); let A = []; _.includes("-") && (A = _.split("-")), m.push([_, x, !1, A]); for (const M in r) { const S = r[M]; M.startsWith(`${_}-`) && m.push([M, S, !1, M.split("-")]) } }); const y = { ...r }; return d.memoizedProps && d.memoizedProps.args && (y.args = d.memoizedProps.args), d.memoizedProps && d.memoizedProps.attach && (y.attach = d.memoizedProps.attach), { memoized: y, changes: m } } function oM(i, e) { var t, n, r; const s = (t = i.__r3f) != null ? t : {}, o = s.root, a = (n = o == null || o.getState == null ? void 0 : o.getState()) != null ? n : {}, { memoized: l, changes: c } = BK(e) ? e : Ok(i, e), f = s.eventCount; i.__r3f && (i.__r3f.memoizedProps = l); for (let p = 0; p < c.length; p++) { let [m, y, _, x] = c[p]; if (rM(i)) { const S = "srgb", C = "srgb-linear"; m === "encoding" ? (m = "colorSpace", y = y === 3001 ? S : C) : m === "outputEncoding" && (m = "outputColorSpace", y = y === 3001 ? S : C) } let g = i, A = g[m]; if (x.length && (A = x.reduce((M, S) => M[S], i), !(A && A.set))) { const [M, ...S] = x.reverse(); g = S.reverse().reduce((C, T) => C[T], i), m = M } if (y === Lk + "remove") if (g.constructor) { let M = CI.get(g.constructor); M || (M = new g.constructor, CI.set(g.constructor, M)), y = M[m] } else y = 0; if (_) y ? s.handlers[m] = y : delete s.handlers[m], s.eventCount = Object.keys(s.handlers).length; else if (A && A.set && (A.copy || A instanceof jc)) { if (Array.isArray(y)) A.fromArray ? A.fromArray(y) : A.set(...y); else if (A.copy && y && y.constructor && A.constructor === y.constructor) A.copy(y); else if (y !== void 0) { const M = A instanceof We; !M && A.setScalar ? A.setScalar(y) : A instanceof jc && y instanceof jc ? A.mask = y.mask : A.set(y), !Rk() && !a.linear && M && A.convertSRGBToLinear() } } else if (g[m] = y, g[m] instanceof wn && g[m].format === Pr && g[m].type === Go) { const M = g[m]; rM(M) && rM(a.gl) ? M.colorSpace = a.gl.outputColorSpace : M.encoding = a.gl.outputEncoding } ff(i) } if (s.parent && a.internal && i.raycast && f !== s.eventCount) { const p = a.internal.interaction.indexOf(i); p > -1 && a.internal.interaction.splice(p, 1), s.eventCount && a.internal.interaction.push(i) } return !(c.length === 1 && c[0][0] === "onUpdate") && c.length && (r = i.__r3f) != null && r.parent && RS(i), i } function ff(i) { var e, t; const n = (e = i.__r3f) == null || (t = e.root) == null || t.getState == null ? void 0 : t.getState(); n && n.internal.frames === 0 && n.invalidate() } function RS(i) { i.onUpdate == null || i.onUpdate(i) } function OK(i, e) { i.manual || (Pk(i) ? (i.left = e.width / -2, i.right = e.width / 2, i.top = e.height / 2, i.bottom = e.height / -2) : i.aspect = e.width / e.height, i.updateProjectionMatrix(), i.updateMatrixWorld()) } function R0(i) { return (i.eventObject || i.object).uuid + "/" + i.index + i.instanceId } function FK() { var i; const e = typeof self < "u" && self || typeof window < "u" && window; if (!e) return Lf.DefaultEventPriority; switch ((i = e.event) == null ? void 0 : i.type) { case "click": case "contextmenu": case "dblclick": case "pointercancel": case "pointerdown": case "pointerup": return Lf.DiscreteEventPriority; case "pointermove": case "pointerout": case "pointerover": case "pointerenter": case "pointerleave": case "wheel": return Lf.ContinuousEventPriority; default: return Lf.DefaultEventPriority } } function Fk(i, e, t, n) { const r = t.get(e); r && (t.delete(e), t.size === 0 && (i.delete(n), r.target.releasePointerCapture(n))) } function kK(i, e) { const { internal: t } = i.getState(); t.interaction = t.interaction.filter(n => n !== e), t.initialHits = t.initialHits.filter(n => n !== e), t.hovered.forEach((n, r) => { (n.eventObject === e || n.object === e) && t.hovered.delete(r) }), t.capturedMap.forEach((n, r) => { Fk(t.capturedMap, e, n, r) }) } function NK(i) { function e(l) { const { internal: c } = i.getState(), f = l.offsetX - c.initialClick[0], d = l.offsetY - c.initialClick[1]; return Math.round(Math.sqrt(f * f + d * d)) } function t(l) { return l.filter(c => ["Move", "Over", "Enter", "Out", "Leave"].some(f => { var d; return (d = c.__r3f) == null ? void 0 : d.handlers["onPointer" + f] })) } function n(l, c) { const f = i.getState(), d = new Set, p = [], m = c ? c(f.internal.interaction) : f.internal.interaction; for (let g = 0; g < m.length; g++) { const A = Ad(m[g]); A && (A.raycaster.camera = void 0) } f.previousRoot || f.events.compute == null || f.events.compute(l, f); function y(g) { const A = Ad(g); if (!A || !A.events.enabled || A.raycaster.camera === null) return []; if (A.raycaster.camera === void 0) { var M; A.events.compute == null || A.events.compute(l, A, (M = A.previousRoot) == null ? void 0 : M.getState()), A.raycaster.camera === void 0 && (A.raycaster.camera = null) } return A.raycaster.camera ? A.raycaster.intersectObject(g, !0) : [] } let _ = m.flatMap(y).sort((g, A) => { const M = Ad(g.object), S = Ad(A.object); return !M || !S ? g.distance - A.distance : S.events.priority - M.events.priority || g.distance - A.distance }).filter(g => { const A = R0(g); return d.has(A) ? !1 : (d.add(A), !0) }); f.events.filter && (_ = f.events.filter(_, f)); for (const g of _) { let A = g.object; for (; A;) { var x; (x = A.__r3f) != null && x.eventCount && p.push({ ...g, eventObject: A }), A = A.parent } } if ("pointerId" in l && f.internal.capturedMap.has(l.pointerId)) for (let g of f.internal.capturedMap.get(l.pointerId).values()) d.has(R0(g.intersection)) || p.push(g.intersection); return p } function r(l, c, f, d) { const p = i.getState(); if (l.length) { const m = { stopped: !1 }; for (const y of l) { const _ = Ad(y.object) || p, { raycaster: x, pointer: g, camera: A, internal: M } = _, S = new k(g.x, g.y, 0).unproject(A), C = I => { var N, V; return (N = (V = M.capturedMap.get(I)) == null ? void 0 : V.has(y.eventObject)) != null ? N : !1 }, T = I => { const N = { intersection: y, target: c.target }; M.capturedMap.has(I) ? M.capturedMap.get(I).set(y.eventObject, N) : M.capturedMap.set(I, new Map([[y.eventObject, N]])), c.target.setPointerCapture(I) }, R = I => { const N = M.capturedMap.get(I); N && Fk(M.capturedMap, y.eventObject, N, I) }; let B = {}; for (let I in c) { let N = c[I]; typeof N != "function" && (B[I] = N) } let b = { ...y, ...B, pointer: g, intersections: l, stopped: m.stopped, delta: f, unprojectedPoint: S, ray: x.ray, camera: A, stopPropagation() { const I = "pointerId" in c && M.capturedMap.get(c.pointerId); if ((!I || I.has(y.eventObject)) && (b.stopped = m.stopped = !0, M.hovered.size && Array.from(M.hovered.values()).find(N => N.eventObject === y.eventObject))) { const N = l.slice(0, l.indexOf(y)); s([...N, y]) } }, target: { hasPointerCapture: C, setPointerCapture: T, releasePointerCapture: R }, currentTarget: { hasPointerCapture: C, setPointerCapture: T, releasePointerCapture: R }, nativeEvent: c }; if (d(b), m.stopped === !0) break } } return l } function s(l) { const { internal: c } = i.getState(); for (const f of c.hovered.values()) if (!l.length || !l.find(d => d.object === f.object && d.index === f.index && d.instanceId === f.instanceId)) { const p = f.eventObject.__r3f, m = p == null ? void 0 : p.handlers; if (c.hovered.delete(R0(f)), p != null && p.eventCount) { const y = { ...f, intersections: l }; m.onPointerOut == null || m.onPointerOut(y), m.onPointerLeave == null || m.onPointerLeave(y) } } } function o(l, c) { for (let f = 0; f < c.length; f++) { const d = c[f].__r3f; d == null || d.handlers.onPointerMissed == null || d.handlers.onPointerMissed(l) } } function a(l) { switch (l) { case "onPointerLeave": case "onPointerCancel": return () => s([]); case "onLostPointerCapture": return c => { const { internal: f } = i.getState(); "pointerId" in c && f.capturedMap.has(c.pointerId) && requestAnimationFrame(() => { f.capturedMap.has(c.pointerId) && (f.capturedMap.delete(c.pointerId), s([])) }) } }return function (f) { const { onPointerMissed: d, internal: p } = i.getState(); p.lastEvent.current = f; const m = l === "onPointerMove", y = l === "onClick" || l === "onContextMenu" || l === "onDoubleClick", x = n(f, m ? t : void 0), g = y ? e(f) : 0; l === "onPointerDown" && (p.initialClick = [f.offsetX, f.offsetY], p.initialHits = x.map(M => M.eventObject)), y && !x.length && g <= 2 && (o(f, p.interaction), d && d(f)), m && s(x); function A(M) { const S = M.eventObject, C = S.__r3f, T = C == null ? void 0 : C.handlers; if (C != null && C.eventCount) if (m) { if (T.onPointerOver || T.onPointerEnter || T.onPointerOut || T.onPointerLeave) { const R = R0(M), B = p.hovered.get(R); B ? B.stopped && M.stopPropagation() : (p.hovered.set(R, M), T.onPointerOver == null || T.onPointerOver(M), T.onPointerEnter == null || T.onPointerEnter(M)) } T.onPointerMove == null || T.onPointerMove(M) } else { const R = T[l]; R ? (!y || p.initialHits.includes(S)) && (o(f, p.interaction.filter(B => !p.initialHits.includes(B))), R(M)) : y && p.initialHits.includes(S) && o(f, p.interaction.filter(B => !p.initialHits.includes(B))) } } r(x, f, g, A) } } return { handlePointer: a } } const kk = i => !!(i != null && i.render), Nk = ce.createContext(null), UK = (i, e) => { const t = xK((a, l) => { const c = new k, f = new k, d = new k; function p(g = l().camera, A = f, M = l().size) { const { width: S, height: C, top: T, left: R } = M, B = S / C; A instanceof k ? d.copy(A) : d.set(...A); const b = g.getWorldPosition(c).distanceTo(d); if (Pk(g)) return { width: S / g.zoom, height: C / g.zoom, top: T, left: R, factor: 1, distance: b, aspect: B }; { const I = g.fov * Math.PI / 180, N = 2 * Math.tan(I / 2) * b, V = N * (S / C); return { width: V, height: N, top: T, left: R, factor: S / V, distance: b, aspect: B } } } let m; const y = g => a(A => ({ performance: { ...A.performance, current: g } })), _ = new _e; return { set: a, get: l, gl: null, camera: null, raycaster: null, events: { priority: 1, enabled: !0, connected: !1 }, xr: null, scene: null, invalidate: (g = 1) => i(l(), g), advance: (g, A) => e(g, A, l()), legacy: !1, linear: !1, flat: !1, controls: null, clock: new qE, pointer: _, mouse: _, frameloop: "always", onPointerMissed: void 0, performance: { current: 1, min: .5, max: 1, debounce: 200, regress: () => { const g = l(); m && clearTimeout(m), g.performance.current !== g.performance.min && y(g.performance.min), m = setTimeout(() => y(l().performance.max), g.performance.debounce) } }, size: { width: 0, height: 0, top: 0, left: 0, updateStyle: !1 }, viewport: { initialDpr: 0, dpr: 0, width: 0, height: 0, top: 0, left: 0, aspect: 0, distance: 0, factor: 0, getCurrentViewport: p }, setEvents: g => a(A => ({ ...A, events: { ...A.events, ...g } })), setSize: (g, A, M, S, C) => { const T = l().camera, R = { width: g, height: A, top: S || 0, left: C || 0, updateStyle: M }; a(B => ({ size: R, viewport: { ...B.viewport, ...p(T, f, R) } })) }, setDpr: g => a(A => { const M = Dk(g); return { viewport: { ...A.viewport, dpr: M, initialDpr: A.viewport.initialDpr || M } } }), setFrameloop: (g = "always") => { const A = l().clock; A.stop(), A.elapsedTime = 0, g !== "never" && (A.start(), A.elapsedTime = 0), a(() => ({ frameloop: g })) }, previousRoot: void 0, internal: { active: !1, priority: 0, frames: 0, lastEvent: ce.createRef(), interaction: [], hovered: new Map, subscribers: [], initialClick: [0, 0], initialHits: [], capturedMap: new Map, subscribe: (g, A, M) => { const S = l().internal; return S.priority = S.priority + (A > 0 ? 1 : 0), S.subscribers.push({ ref: g, priority: A, store: M }), S.subscribers = S.subscribers.sort((C, T) => C.priority - T.priority), () => { const C = l().internal; C != null && C.subscribers && (C.priority = C.priority - (A > 0 ? 1 : 0), C.subscribers = C.subscribers.filter(T => T.ref !== g)) } } } } }), n = t.getState(); let r = n.size, s = n.viewport.dpr, o = n.camera; return t.subscribe(() => { const { camera: a, size: l, viewport: c, gl: f, set: d } = t.getState(); if (l !== r || c.dpr !== s) { var p; r = l, s = c.dpr, OK(a, l), f.setPixelRatio(c.dpr); const m = (p = l.updateStyle) != null ? p : typeof HTMLCanvasElement < "u" && f.domElement instanceof HTMLCanvasElement; f.setSize(l.width, l.height, m) } a !== o && (o = a, d(m => ({ viewport: { ...m.viewport, ...m.viewport.getCurrentViewport(a) } }))) }), t.subscribe(a => i(a)), t }; let P0, zK = new Set, HK = new Set, GK = new Set; function aM(i, e) { if (i.size) for (const { callback: t } of i.values()) t(e) } function Md(i, e) { switch (i) { case "before": return aM(zK, e); case "after": return aM(HK, e); case "tail": return aM(GK, e) } } let lM, cM; function uM(i, e, t) { let n = e.clock.getDelta(); for (e.frameloop === "never" && typeof i == "number" && (n = i - e.clock.elapsedTime, e.clock.oldTime = e.clock.elapsedTime, e.clock.elapsedTime = i), lM = e.internal.subscribers, P0 = 0; P0 < lM.length; P0++)cM = lM[P0], cM.ref.current(cM.store.getState(), n, t); return !e.internal.priority && e.gl.render && e.gl.render(e.scene, e.camera), e.internal.frames = Math.max(0, e.internal.frames - 1), e.frameloop === "always" ? 1 : e.internal.frames } function VK(i) { let e = !1, t, n, r; function s(l) { n = requestAnimationFrame(s), e = !0, t = 0, Md("before", l); for (const f of i.values()) { var c; r = f.store.getState(), r.internal.active && (r.frameloop === "always" || r.internal.frames > 0) && !((c = r.gl.xr) != null && c.isPresenting) && (t += uM(l, r)) } if (Md("after", l), t === 0) return Md("tail", l), e = !1, cancelAnimationFrame(n) } function o(l, c = 1) { var f; if (!l) return i.forEach(d => o(d.store.getState()), c); (f = l.gl.xr) != null && f.isPresenting || !l.internal.active || l.frameloop === "never" || (l.internal.frames = Math.min(60, l.internal.frames + c), e || (e = !0, requestAnimationFrame(s))) } function a(l, c = !0, f, d) { if (c && Md("before", l), f) uM(l, f, d); else for (const p of i.values()) uM(l, p.store.getState()); c && Md("after", l) } return { loop: s, invalidate: o, advance: a } } function Uk() { const i = ce.useContext(Nk); if (!i) throw new Error("R3F: Hooks can only be used within the Canvas component!"); return i } function Za(i = t => t, e) { return Uk()(i, e) } function WK(i, e = 0) { const t = Uk(), n = t.getState().internal.subscribe, r = Ik(i); return gm(() => n(r, e, t), [e, n, t]), null } function zk(i, e) { return function (t, ...n) { const r = new t; return i && i(r), Promise.all(n.map(s => new Promise((o, a) => r.load(s, l => { l.scene && Object.assign(l, LK(l.scene)), o(l) }, e, l => a(new Error(`Could not load ${s}: ${l.message}`)))))) } } function ym(i, e, t, n) { const r = Array.isArray(e) ? e : [e], s = EK(zk(t, n), [i, ...r], { equal: yn.equ }); return Array.isArray(e) ? s : s[0] } ym.preload = function (i, e, t) { const n = Array.isArray(e) ? e : [e]; return CK(zk(t), [i, ...n]) }; ym.clear = function (i, e) { const t = Array.isArray(e) ? e : [e]; return TK([i, ...t]) }; const Sh = new Map, { invalidate: RI, advance: PI } = VK(Sh), { reconciler: av, applyProps: of } = RK(Sh, FK), af = { objects: "shallow", strict: !1 }, XK = (i, e) => { const t = typeof i == "function" ? i(e) : i; return kk(t) ? t : new bE({ powerPreference: "high-performance", canvas: e, antialias: !0, alpha: !0, ...i }) }; function JK(i, e) { if (e) return e; if (typeof HTMLCanvasElement < "u" && i instanceof HTMLCanvasElement && i.parentElement) { const { width: t, height: n, top: r, left: s } = i.parentElement.getBoundingClientRect(); return { width: t, height: n, top: r, left: s } } else if (typeof OffscreenCanvas < "u" && i instanceof OffscreenCanvas) return { width: i.width, height: i.height, top: 0, left: 0 }; return { width: 0, height: 0, top: 0, left: 0 } } function YK(i) { const e = Sh.get(i), t = e == null ? void 0 : e.fiber, n = e == null ? void 0 : e.store; e && console.warn("R3F.createRoot should only be called once!"); const r = typeof reportError == "function" ? reportError : console.error, s = n || UK(RI, PI), o = t || av.createContainer(s, Lf.ConcurrentRoot, null, !1, null, "", r, null); e || Sh.set(i, { fiber: o, store: s }); let a, l = !1, c; return { configure(f = {}) { let { gl: d, size: p, scene: m, events: y, onCreated: _, shadows: x = !1, linear: g = !1, flat: A = !1, legacy: M = !1, orthographic: S = !1, frameloop: C = "always", dpr: T = [1, 2], performance: R, raycaster: B, camera: b, onPointerMissed: I } = f, N = s.getState(), V = N.gl; N.gl || N.set({ gl: V = XK(d, i) }); let J = N.raycaster; J || N.set({ raycaster: J = new Ak }); const { params: j, ...q } = B || {}; if (yn.equ(q, J, af) || of(J, { ...q }), yn.equ(j, J.params, af) || of(J, { params: { ...J.params, ...j } }), !N.camera || N.camera === c && !yn.equ(c, b, af)) { c = b; const K = b instanceof am, ye = K ? b : S ? new Ca(0, 0, 0, 0, .1, 1e3) : new Vn(75, 0, .1, 1e3); K || (ye.position.z = 5, b && of(ye, b), !N.camera && !(b != null && b.rotation) && ye.lookAt(0, 0, 0)), N.set({ camera: ye }) } if (!N.scene) { let K; m instanceof ov ? K = m : (K = new ov, m && of(K, m)), N.set({ scene: uf(K) }) } if (!N.xr) { var ne; const K = (xe, Be) => { const Ie = s.getState(); Ie.frameloop !== "never" && PI(xe, !0, Ie, Be) }, ye = () => { const xe = s.getState(); xe.gl.xr.enabled = xe.gl.xr.isPresenting, xe.gl.xr.setAnimationLoop(xe.gl.xr.isPresenting ? K : null), xe.gl.xr.isPresenting || RI(xe) }, ge = { connect() { const xe = s.getState().gl; xe.xr.addEventListener("sessionstart", ye), xe.xr.addEventListener("sessionend", ye) }, disconnect() { const xe = s.getState().gl; xe.xr.removeEventListener("sessionstart", ye), xe.xr.removeEventListener("sessionend", ye) } }; typeof ((ne = V.xr) == null ? void 0 : ne.addEventListener) == "function" && ge.connect(), N.set({ xr: ge }) } if (V.shadowMap) { const K = V.shadowMap.enabled, ye = V.shadowMap.type; if (V.shadowMap.enabled = !!x, yn.boo(x)) V.shadowMap.type = rp; else if (yn.str(x)) { var Q; const ge = { basic: wO, percentage: Dv, soft: rp, variance: $s }; V.shadowMap.type = (Q = ge[x]) != null ? Q : rp } else yn.obj(x) && Object.assign(V.shadowMap, x); (K !== V.shadowMap.enabled || ye !== V.shadowMap.type) && (V.shadowMap.needsUpdate = !0) } const F = Rk(); F && ("enabled" in F ? F.enabled = !M : "legacyMode" in F && (F.legacyMode = M)), of(V, { outputEncoding: g ? 3e3 : 3001, toneMapping: A ? Ho : cE }), N.legacy !== M && N.set(() => ({ legacy: M })), N.linear !== g && N.set(() => ({ linear: g })), N.flat !== A && N.set(() => ({ flat: A })), d && !yn.fun(d) && !kk(d) && !yn.equ(d, V, af) && of(V, d), y && !N.events.handlers && N.set({ events: y(s) }); const G = JK(i, p); return yn.equ(G, N.size, af) || N.setSize(G.width, G.height, G.updateStyle, G.top, G.left), T && N.viewport.dpr !== Dk(T) && N.setDpr(T), N.frameloop !== C && N.setFrameloop(C), N.onPointerMissed || N.set({ onPointerMissed: I }), R && !yn.equ(R, N.performance, af) && N.set(K => ({ performance: { ...K.performance, ...R } })), a = _, l = !0, this }, render(f) { return l || this.configure(), av.updateContainer(ce.createElement(jK, { store: s, children: f, onCreated: a, rootElement: i }), o, null, () => { }), s }, unmount() { Hk(i) } } } function jK({ store: i, children: e, onCreated: t, rootElement: n }) { return gm(() => { const r = i.getState(); r.set(s => ({ internal: { ...s.internal, active: !0 } })), t && t(r), i.getState().events.connected || r.events.connect == null || r.events.connect(n) }, []), ce.createElement(Nk.Provider, { value: i }, e) } function Hk(i, e) { const t = Sh.get(i), n = t == null ? void 0 : t.fiber; if (n) { const r = t == null ? void 0 : t.store.getState(); r && (r.internal.active = !1), av.updateContainer(null, n, null, () => { r && setTimeout(() => { try { var s, o, a, l; r.events.disconnect == null || r.events.disconnect(), (s = r.gl) == null || (o = s.renderLists) == null || o.dispose == null || o.dispose(), (a = r.gl) == null || a.forceContextLoss == null || a.forceContextLoss(), (l = r.gl) != null && l.xr && r.xr.disconnect(), DK(r), Sh.delete(i), e && e(i) } catch { } }, 500) }) } } av.injectIntoDevTools({ bundleType: 0, rendererPackageName: "@react-three/fiber", version: ce.version }); function PS(i, e, t) { var n, r, s, o, a; e == null && (e = 100); function l() { var f = Date.now() - o; f < e && f >= 0 ? n = setTimeout(l, e - f) : (n = null, t || (a = i.apply(s, r), s = r = null)) } var c = function () { s = this, r = arguments, o = Date.now(); var f = t && !n; return n || (n = setTimeout(l, e)), f && (a = i.apply(s, r), s = r = null), a }; return c.clear = function () { n && (clearTimeout(n), n = null) }, c.flush = function () { n && (a = i.apply(s, r), s = r = null, clearTimeout(n), n = null) }, c } PS.debounce = PS; var KK = PS; const II = LS(KK); function qK(i) { let { debounce: e, scroll: t, polyfill: n, offsetSize: r } = i === void 0 ? { debounce: 0, scroll: !1, offsetSize: !1 } : i; const s = n || (typeof window > "u" ? class { } : window.ResizeObserver); if (!s) throw new Error("This browser does not support ResizeObserver out of the box. See: https://github.com/react-spring/react-use-measure/#resize-observer-polyfills"); const [o, a] = ce.useState({ left: 0, top: 0, width: 0, height: 0, bottom: 0, right: 0, x: 0, y: 0 }), l = ce.useRef({ element: null, scrollContainers: null, resizeObserver: null, lastBounds: o }), c = e ? typeof e == "number" ? e : e.scroll : null, f = e ? typeof e == "number" ? e : e.resize : null, d = ce.useRef(!1); ce.useEffect(() => (d.current = !0, () => void (d.current = !1))); const [p, m, y] = ce.useMemo(() => { const A = () => { if (!l.current.element) return; const { left: M, top: S, width: C, height: T, bottom: R, right: B, x: b, y: I } = l.current.element.getBoundingClientRect(), N = { left: M, top: S, width: C, height: T, bottom: R, right: B, x: b, y: I }; l.current.element instanceof HTMLElement && r && (N.height = l.current.element.offsetHeight, N.width = l.current.element.offsetWidth), Object.freeze(N), d.current && !eq(l.current.lastBounds, N) && a(l.current.lastBounds = N) }; return [A, f ? II(A, f) : A, c ? II(A, c) : A] }, [a, r, c, f]); function _() { l.current.scrollContainers && (l.current.scrollContainers.forEach(A => A.removeEventListener("scroll", y, !0)), l.current.scrollContainers = null), l.current.resizeObserver && (l.current.resizeObserver.disconnect(), l.current.resizeObserver = null) } function x() { l.current.element && (l.current.resizeObserver = new s(y), l.current.resizeObserver.observe(l.current.element), t && l.current.scrollContainers && l.current.scrollContainers.forEach(A => A.addEventListener("scroll", y, { capture: !0, passive: !0 }))) } const g = A => { !A || A === l.current.element || (_(), l.current.element = A, l.current.scrollContainers = Gk(A), x()) }; return ZK(y, !!t), QK(m), ce.useEffect(() => { _(), x() }, [t, y, m]), ce.useEffect(() => _, []), [g, o, p] } function QK(i) { ce.useEffect(() => { const e = i; return window.addEventListener("resize", e), () => void window.removeEventListener("resize", e) }, [i]) } function ZK(i, e) { ce.useEffect(() => { if (e) { const t = i; return window.addEventListener("scroll", t, { capture: !0, passive: !0 }), () => void window.removeEventListener("scroll", t, !0) } }, [i, e]) } function Gk(i) { const e = []; if (!i || i === document.body) return e; const { overflow: t, overflowX: n, overflowY: r } = window.getComputedStyle(i); return [t, n, r].some(s => s === "auto" || s === "scroll") && e.push(i), [...e, ...Gk(i.parentElement)] } const $K = ["x", "y", "top", "bottom", "left", "right", "width", "height"], eq = (i, e) => $K.every(t => i[t] === e[t]); var tq = Object.defineProperty, nq = Object.defineProperties, iq = Object.getOwnPropertyDescriptors, BI = Object.getOwnPropertySymbols, rq = Object.prototype.hasOwnProperty, sq = Object.prototype.propertyIsEnumerable, LI = (i, e, t) => e in i ? tq(i, e, { enumerable: !0, configurable: !0, writable: !0, value: t }) : i[e] = t, DI = (i, e) => { for (var t in e || (e = {})) rq.call(e, t) && LI(i, t, e[t]); if (BI) for (var t of BI(e)) sq.call(e, t) && LI(i, t, e[t]); return i }, oq = (i, e) => nq(i, iq(e)); function Vk(i, e, t) { if (!i) return; if (t(i) === !0) return i; let n = e ? i.return : i.child; for (; n;) { const r = Vk(n, e, t); if (r) return r; n = e ? null : n.sibling } } function Wk(i) { try { return Object.defineProperties(i, { _currentRenderer: { get() { return null }, set() { } }, _currentRenderer2: { get() { return null }, set() { } } }) } catch { return i } } const tC = Wk(ce.createContext(null)); class Xk extends ce.Component { render() { return ce.createElement(tC.Provider, { value: this._reactInternals }, this.props.children) } } const { ReactCurrentOwner: OI, ReactCurrentDispatcher: FI } = ce.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED; function aq() { const i = ce.useContext(tC); if (i === null) throw new Error("its-fine: useFiber must be called within a <FiberProvider />!"); const e = ce.useId(); return ce.useMemo(() => { for (const n of [OI == null ? void 0 : OI.current, i, i == null ? void 0 : i.alternate]) { if (!n) continue; const r = Vk(n, !1, s => { let o = s.memoizedState; for (; o;) { if (o.memoizedState === e) return !0; o = o.next } }); if (r) return r } }, [i, e]) } function lq() { var i, e; const t = aq(), [n] = ce.useState(() => new Map); n.clear(); let r = t; for (; r;) { const s = (i = r.type) == null ? void 0 : i._context; s && s !== tC && !n.has(s) && n.set(s, (e = FI == null ? void 0 : FI.current) == null ? void 0 : e.readContext(Wk(s))), r = r.return } return n } function cq() { const i = lq(); return ce.useMemo(() => Array.from(i.keys()).reduce((e, t) => n => ce.createElement(e, null, ce.createElement(t.Provider, oq(DI({}, n), { value: i.get(t) }))), e => ce.createElement(Xk, DI({}, e))), [i]) } const fM = { onClick: ["click", !1], onContextMenu: ["contextmenu", !1], onDoubleClick: ["dblclick", !1], onWheel: ["wheel", !0], onPointerDown: ["pointerdown", !0], onPointerUp: ["pointerup", !0], onPointerLeave: ["pointerleave", !0], onPointerMove: ["pointermove", !0], onPointerCancel: ["pointercancel", !0], onLostPointerCapture: ["lostpointercapture", !0] }; function uq(i) { const { handlePointer: e } = NK(i); return { priority: 1, enabled: !0, compute(t, n, r) { n.pointer.set(t.offsetX / n.size.width * 2 - 1, -(t.offsetY / n.size.height) * 2 + 1), n.raycaster.setFromCamera(n.pointer, n.camera) }, connected: void 0, handlers: Object.keys(fM).reduce((t, n) => ({ ...t, [n]: e(n) }), {}), update: () => { var t; const { events: n, internal: r } = i.getState(); (t = r.lastEvent) != null && t.current && n.handlers && n.handlers.onPointerMove(r.lastEvent.current) }, connect: t => { var n; const { set: r, events: s } = i.getState(); s.disconnect == null || s.disconnect(), r(o => ({ events: { ...o.events, connected: t } })), Object.entries((n = s.handlers) != null ? n : []).forEach(([o, a]) => { const [l, c] = fM[o]; t.addEventListener(l, a, { passive: c }) }) }, disconnect: () => { const { set: t, events: n } = i.getState(); if (n.connected) { var r; Object.entries((r = n.handlers) != null ? r : []).forEach(([s, o]) => { if (n && n.connected instanceof HTMLElement) { const [a] = fM[s]; n.connected.removeEventListener(a, o) } }), t(s => ({ events: { ...s.events, connected: void 0 } })) } } } } const fq = ce.forwardRef(function ({ children: e, fallback: t, resize: n, style: r, gl: s, events: o = uq, eventSource: a, eventPrefix: l, shadows: c, linear: f, flat: d, legacy: p, orthographic: m, frameloop: y, dpr: _, performance: x, raycaster: g, camera: A, scene: M, onPointerMissed: S, onCreated: C, ...T }, R) { ce.useMemo(() => bK(yK), []); const B = cq(), [b, I] = qK({ scroll: !0, debounce: { scroll: 50, resize: 0 }, ...n }), N = ce.useRef(null), V = ce.useRef(null); ce.useImperativeHandle(R, () => N.current); const J = Ik(S), [j, q] = ce.useState(!1), [ne, Q] = ce.useState(!1); if (j) throw j; if (ne) throw ne; const F = ce.useRef(null); gm(() => { const L = N.current; I.width > 0 && I.height > 0 && L && (F.current || (F.current = YK(L)), F.current.configure({ gl: s, events: o, shadows: c, linear: f, flat: d, legacy: p, orthographic: m, frameloop: y, dpr: _, performance: x, raycaster: g, camera: A, scene: M, size: I, onPointerMissed: (...G) => J.current == null ? void 0 : J.current(...G), onCreated: G => { G.events.connect == null || G.events.connect(a ? PK(a) ? a.current : a : V.current), l && G.setEvents({ compute: (K, ye) => { const ge = K[l + "X"], xe = K[l + "Y"]; ye.pointer.set(ge / ye.size.width * 2 - 1, -(xe / ye.size.height) * 2 + 1), ye.raycaster.setFromCamera(ye.pointer, ye.camera) } }), C == null || C(G) } }), F.current.render(ce.createElement(B, null, ce.createElement(Bk, { set: Q }, ce.createElement(ce.Suspense, { fallback: ce.createElement(IK, { set: q }) }, e))))) }), ce.useEffect(() => { const L = N.current; if (L) return () => Hk(L) }, []); const Y = a ? "none" : "auto"; return ce.createElement("div", Op({ ref: V, style: { position: "relative", width: "100%", height: "100%", overflow: "hidden", pointerEvents: Y, ...r } }, T), ce.createElement("div", { ref: b, style: { width: "100%", height: "100%" } }, ce.createElement("canvas", { ref: N, style: { display: "block" } }, t))) }), hq = ce.forwardRef(function (e, t) { return ce.createElement(Xk, null, ce.createElement(fq, Op({}, e, { ref: t }))) }); function kI(i, e) { if (e === aF) return console.warn("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Geometry already defined as triangles."), i; if (e === iv || e === yE) { let t = i.getIndex(); if (t === null) { const o = [], a = i.getAttribute("position"); if (a !== void 0) { for (let l = 0; l < a.count; l++)o.push(l); i.setIndex(o), t = i.getIndex() } else return console.error("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Undefined position attribute. Processing not possible."), i } const n = t.count - 2, r = []; if (t) if (e === iv) for (let o = 1; o <= n; o++)r.push(t.getX(0)), r.push(t.getX(o)), r.push(t.getX(o + 1)); else for (let o = 0; o < n; o++)o % 2 === 0 ? (r.push(t.getX(o)), r.push(t.getX(o + 1)), r.push(t.getX(o + 2))) : (r.push(t.getX(o + 2)), r.push(t.getX(o + 1)), r.push(t.getX(o))); r.length / 3 !== n && console.error("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Unable to generate correct amount of triangles."); const s = i.clone(); return s.setIndex(r), s.clearGroups(), s } else return console.error("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Unknown draw mode:", e), i } var dq = Object.defineProperty, pq = (i, e, t) => e in i ? dq(i, e, { enumerable: !0, configurable: !0, writable: !0, value: t }) : i[e] = t, xt = (i, e, t) => (pq(i, typeof e != "symbol" ? e + "" : e, t), t); const NI = (i, e) => (i % e + e) % e; let mq = class extends Ko { constructor(e, t) { super(), xt(this, "object"), xt(this, "domElement"), xt(this, "enabled", !0), xt(this, "target", new k), xt(this, "minDistance", 0), xt(this, "maxDistance", 1 / 0), xt(this, "minZoom", 0), xt(this, "maxZoom", 1 / 0), xt(this, "minPolarAngle", 0), xt(this, "maxPolarAngle", Math.PI), xt(this, "minAzimuthAngle", -1 / 0), xt(this, "maxAzimuthAngle", 1 / 0), xt(this, "enableDamping", !1), xt(this, "dampingFactor", .05), xt(this, "enableZoom", !0), xt(this, "zoomSpeed", 1), xt(this, "enableRotate", !0), xt(this, "rotateSpeed", 1), xt(this, "enablePan", !0), xt(this, "panSpeed", 1), xt(this, "screenSpacePanning", !0), xt(this, "keyPanSpeed", 7), xt(this, "autoRotate", !1), xt(this, "autoRotateSpeed", 2), xt(this, "reverseOrbit", !1), xt(this, "reverseHorizontalOrbit", !1), xt(this, "reverseVerticalOrbit", !1), xt(this, "keys", { LEFT: "ArrowLeft", UP: "ArrowUp", RIGHT: "ArrowRight", BOTTOM: "ArrowDown" }), xt(this, "mouseButtons", { LEFT: Ac.ROTATE, MIDDLE: Ac.DOLLY, RIGHT: Ac.PAN }), xt(this, "touches", { ONE: Mc.ROTATE, TWO: Mc.DOLLY_PAN }), xt(this, "target0"), xt(this, "position0"), xt(this, "zoom0"), xt(this, "_domElementKeyEvents", null), xt(this, "getPolarAngle"), xt(this, "getAzimuthalAngle"), xt(this, "setPolarAngle"), xt(this, "setAzimuthalAngle"), xt(this, "getDistance"), xt(this, "listenToKeyEvents"), xt(this, "stopListenToKeyEvents"), xt(this, "saveState"), xt(this, "reset"), xt(this, "update"), xt(this, "connect"), xt(this, "dispose"), this.object = e, this.domElement = t, this.target0 = this.target.clone(), this.position0 = this.object.position.clone(), this.zoom0 = this.object.zoom, this.getPolarAngle = () => f.phi, this.getAzimuthalAngle = () => f.theta, this.setPolarAngle = X => { let he = NI(X, 2 * Math.PI), we = f.phi; we < 0 && (we += 2 * Math.PI), he < 0 && (he += 2 * Math.PI); let be = Math.abs(he - we); 2 * Math.PI - be < be && (he < we ? he += 2 * Math.PI : we += 2 * Math.PI), d.phi = he - we, n.update() }, this.setAzimuthalAngle = X => { let he = NI(X, 2 * Math.PI), we = f.theta; we < 0 && (we += 2 * Math.PI), he < 0 && (he += 2 * Math.PI); let be = Math.abs(he - we); 2 * Math.PI - be < be && (he < we ? he += 2 * Math.PI : we += 2 * Math.PI), d.theta = he - we, n.update() }, this.getDistance = () => n.object.position.distanceTo(n.target), this.listenToKeyEvents = X => { X.addEventListener("keydown", D), this._domElementKeyEvents = X }, this.stopListenToKeyEvents = () => { this._domElementKeyEvents.removeEventListener("keydown", D), this._domElementKeyEvents = null }, this.saveState = () => { n.target0.copy(n.target), n.position0.copy(n.object.position), n.zoom0 = n.object.zoom }, this.reset = () => { n.target.copy(n.target0), n.object.position.copy(n.position0), n.object.zoom = n.zoom0, n.object.updateProjectionMatrix(), n.dispatchEvent(r), n.update(), l = a.NONE }, this.update = (() => { const X = new k, he = new k(0, 1, 0), we = new Ti().setFromUnitVectors(e.up, he), be = we.clone().invert(), De = new k, lt = new Ti, vt = 2 * Math.PI; return function () { const Oe = n.object.position; we.setFromUnitVectors(e.up, he), be.copy(we).invert(), X.copy(Oe).sub(n.target), X.applyQuaternion(we), f.setFromVector3(X), n.autoRotate && l === a.NONE && V(I()), n.enableDamping ? (f.theta += d.theta * n.dampingFactor, f.phi += d.phi * n.dampingFactor) : (f.theta += d.theta, f.phi += d.phi); let se = n.minAzimuthAngle, Se = n.maxAzimuthAngle; return isFinite(se) && isFinite(Se) && (se < -Math.PI ? se += vt : se > Math.PI && (se -= vt), Se < -Math.PI ? Se += vt : Se > Math.PI && (Se -= vt), se <= Se ? f.theta = Math.max(se, Math.min(Se, f.theta)) : f.theta = f.theta > (se + Se) / 2 ? Math.max(se, f.theta) : Math.min(Se, f.theta)), f.phi = Math.max(n.minPolarAngle, Math.min(n.maxPolarAngle, f.phi)), f.makeSafe(), f.radius *= p, f.radius = Math.max(n.minDistance, Math.min(n.maxDistance, f.radius)), n.enableDamping === !0 ? n.target.addScaledVector(m, n.dampingFactor) : n.target.add(m), X.setFromSpherical(f), X.applyQuaternion(be), Oe.copy(n.target).add(X), n.object.lookAt(n.target), n.enableDamping === !0 ? (d.theta *= 1 - n.dampingFactor, d.phi *= 1 - n.dampingFactor, m.multiplyScalar(1 - n.dampingFactor)) : (d.set(0, 0, 0), m.set(0, 0, 0)), p = 1, y || De.distanceToSquared(n.object.position) > c || 8 * (1 - lt.dot(n.object.quaternion)) > c ? (n.dispatchEvent(r), De.copy(n.object.position), lt.copy(n.object.quaternion), y = !1, !0) : !1 } })(), this.connect = X => { X === document && console.error('THREE.OrbitControls: "document" should not be used as the target "domElement". Please use "renderer.domElement" instead.'), n.domElement = X, n.domElement.style.touchAction = "none", n.domElement.addEventListener("contextmenu", Me), n.domElement.addEventListener("pointerdown", Z), n.domElement.addEventListener("pointercancel", st), n.domElement.addEventListener("wheel", U) }, this.dispose = () => { var X, he, we, be, De, lt; (X = n.domElement) == null || X.removeEventListener("contextmenu", Me), (he = n.domElement) == null || he.removeEventListener("pointerdown", Z), (we = n.domElement) == null || we.removeEventListener("pointercancel", st), (be = n.domElement) == null || be.removeEventListener("wheel", U), (De = n.domElement) == null || De.ownerDocument.removeEventListener("pointermove", Fe), (lt = n.domElement) == null || lt.ownerDocument.removeEventListener("pointerup", Ve), n._domElementKeyEvents !== null && n._domElementKeyEvents.removeEventListener("keydown", D) }; const n = this, r = { type: "change" }, s = { type: "start" }, o = { type: "end" }, a = { NONE: -1, ROTATE: 0, DOLLY: 1, PAN: 2, TOUCH_ROTATE: 3, TOUCH_PAN: 4, TOUCH_DOLLY_PAN: 5, TOUCH_DOLLY_ROTATE: 6 }; let l = a.NONE; const c = 1e-6, f = new CS, d = new CS; let p = 1; const m = new k; let y = !1; const _ = new _e, x = new _e, g = new _e, A = new _e, M = new _e, S = new _e, C = new _e, T = new _e, R = new _e, B = [], b = {}; function I() { return 2 * Math.PI / 60 / 60 * n.autoRotateSpeed } function N() { return Math.pow(.95, n.zoomSpeed) } function V(X) { n.reverseOrbit || n.reverseHorizontalOrbit ? d.theta += X : d.theta -= X } function J(X) { n.reverseOrbit || n.reverseVerticalOrbit ? d.phi += X : d.phi -= X } const j = (() => { const X = new k; return function (we, be) { X.setFromMatrixColumn(be, 0), X.multiplyScalar(-we), m.add(X) } })(), q = (() => { const X = new k; return function (we, be) { n.screenSpacePanning === !0 ? X.setFromMatrixColumn(be, 1) : (X.setFromMatrixColumn(be, 0), X.crossVectors(n.object.up, X)), X.multiplyScalar(we), m.add(X) } })(), ne = (() => { const X = new k; return function (we, be) { const De = n.domElement; if (De && n.object instanceof Vn && n.object.isPerspectiveCamera) { const lt = n.object.position; X.copy(lt).sub(n.target); let vt = X.length(); vt *= Math.tan(n.object.fov / 2 * Math.PI / 180), j(2 * we * vt / De.clientHeight, n.object.matrix), q(2 * be * vt / De.clientHeight, n.object.matrix) } else De && n.object instanceof Ca && n.object.isOrthographicCamera ? (j(we * (n.object.right - n.object.left) / n.object.zoom / De.clientWidth, n.object.matrix), q(be * (n.object.top - n.object.bottom) / n.object.zoom / De.clientHeight, n.object.matrix)) : (console.warn("WARNING: OrbitControls.js encountered an unknown camera type - pan disabled."), n.enablePan = !1) } })(); function Q(X) { n.object instanceof Vn && n.object.isPerspectiveCamera ? p /= X : n.object instanceof Ca && n.object.isOrthographicCamera ? (n.object.zoom = Math.max(n.minZoom, Math.min(n.maxZoom, n.object.zoom * X)), n.object.updateProjectionMatrix(), y = !0) : (console.warn("WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled."), n.enableZoom = !1) } function F(X) { n.object instanceof Vn && n.object.isPerspectiveCamera ? p *= X : n.object instanceof Ca && n.object.isOrthographicCamera ? (n.object.zoom = Math.max(n.minZoom, Math.min(n.maxZoom, n.object.zoom / X)), n.object.updateProjectionMatrix(), y = !0) : (console.warn("WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled."), n.enableZoom = !1) } function Y(X) { _.set(X.clientX, X.clientY) } function L(X) { C.set(X.clientX, X.clientY) } function G(X) { A.set(X.clientX, X.clientY) } function K(X) { x.set(X.clientX, X.clientY), g.subVectors(x, _).multiplyScalar(n.rotateSpeed); const he = n.domElement; he && (V(2 * Math.PI * g.x / he.clientHeight), J(2 * Math.PI * g.y / he.clientHeight)), _.copy(x), n.update() } function ye(X) { T.set(X.clientX, X.clientY), R.subVectors(T, C), R.y > 0 ? Q(N()) : R.y < 0 && F(N()), C.copy(T), n.update() } function ge(X) { M.set(X.clientX, X.clientY), S.subVectors(M, A).multiplyScalar(n.panSpeed), ne(S.x, S.y), A.copy(M), n.update() } function xe(X) { X.deltaY < 0 ? F(N()) : X.deltaY > 0 && Q(N()), n.update() } function Be(X) { let he = !1; switch (X.code) { case n.keys.UP: ne(0, n.keyPanSpeed), he = !0; break; case n.keys.BOTTOM: ne(0, -n.keyPanSpeed), he = !0; break; case n.keys.LEFT: ne(n.keyPanSpeed, 0), he = !0; break; case n.keys.RIGHT: ne(-n.keyPanSpeed, 0), he = !0; break }he && (X.preventDefault(), n.update()) } function Ie() { if (B.length == 1) _.set(B[0].pageX, B[0].pageY); else { const X = .5 * (B[0].pageX + B[1].pageX), he = .5 * (B[0].pageY + B[1].pageY); _.set(X, he) } } function Je() { if (B.length == 1) A.set(B[0].pageX, B[0].pageY); else { const X = .5 * (B[0].pageX + B[1].pageX), he = .5 * (B[0].pageY + B[1].pageY); A.set(X, he) } } function ut() { const X = B[0].pageX - B[1].pageX, he = B[0].pageY - B[1].pageY, we = Math.sqrt(X * X + he * he); C.set(0, we) } function Bt() { n.enableZoom && ut(), n.enablePan && Je() } function Ge() { n.enableZoom && ut(), n.enableRotate && Ie() } function H(X) { if (B.length == 1) x.set(X.pageX, X.pageY); else { const we = oe(X), be = .5 * (X.pageX + we.x), De = .5 * (X.pageY + we.y); x.set(be, De) } g.subVectors(x, _).multiplyScalar(n.rotateSpeed); const he = n.domElement; he && (V(2 * Math.PI * g.x / he.clientHeight), J(2 * Math.PI * g.y / he.clientHeight)), _.copy(x) } function pe(X) { if (B.length == 1) M.set(X.pageX, X.pageY); else { const he = oe(X), we = .5 * (X.pageX + he.x), be = .5 * (X.pageY + he.y); M.set(we, be) } S.subVectors(M, A).multiplyScalar(n.panSpeed), ne(S.x, S.y), A.copy(M) } function fe(X) { const he = oe(X), we = X.pageX - he.x, be = X.pageY - he.y, De = Math.sqrt(we * we + be * be); T.set(0, De), R.set(0, Math.pow(T.y / C.y, n.zoomSpeed)), Q(R.y), C.copy(T) } function Ee(X) { n.enableZoom && fe(X), n.enablePan && pe(X) } function ve(X) { n.enableZoom && fe(X), n.enableRotate && H(X) } function Z(X) { var he, we; n.enabled !== !1 && (B.length === 0 && ((he = n.domElement) == null || he.ownerDocument.addEventListener("pointermove", Fe), (we = n.domElement) == null || we.ownerDocument.addEventListener("pointerup", Ve)), Ce(X), X.pointerType === "touch" ? re(X) : ot(X)) } function Fe(X) { n.enabled !== !1 && (X.pointerType === "touch" ? Ae(X) : Yt(X)) } function Ve(X) { var he, we, be; qe(X), B.length === 0 && ((he = n.domElement) == null || he.releasePointerCapture(X.pointerId), (we = n.domElement) == null || we.ownerDocument.removeEventListener("pointermove", Fe), (be = n.domElement) == null || be.ownerDocument.removeEventListener("pointerup", Ve)), n.dispatchEvent(o), l = a.NONE } function st(X) { qe(X) } function ot(X) { let he; switch (X.button) { case 0: he = n.mouseButtons.LEFT; break; case 1: he = n.mouseButtons.MIDDLE; break; case 2: he = n.mouseButtons.RIGHT; break; default: he = -1 }switch (he) { case Ac.DOLLY: if (n.enableZoom === !1) return; L(X), l = a.DOLLY; break; case Ac.ROTATE: if (X.ctrlKey || X.metaKey || X.shiftKey) { if (n.enablePan === !1) return; G(X), l = a.PAN } else { if (n.enableRotate === !1) return; Y(X), l = a.ROTATE } break; case Ac.PAN: if (X.ctrlKey || X.metaKey || X.shiftKey) { if (n.enableRotate === !1) return; Y(X), l = a.ROTATE } else { if (n.enablePan === !1) return; G(X), l = a.PAN } break; default: l = a.NONE }l !== a.NONE && n.dispatchEvent(s) } function Yt(X) { if (n.enabled !== !1) switch (l) { case a.ROTATE: if (n.enableRotate === !1) return; K(X); break; case a.DOLLY: if (n.enableZoom === !1) return; ye(X); break; case a.PAN: if (n.enablePan === !1) return; ge(X); break } } function U(X) { n.enabled === !1 || n.enableZoom === !1 || l !== a.NONE && l !== a.ROTATE || (X.preventDefault(), n.dispatchEvent(s), xe(X), n.dispatchEvent(o)) } function D(X) { n.enabled === !1 || n.enablePan === !1 || Be(X) } function re(X) { switch (Te(X), B.length) { case 1: switch (n.touches.ONE) { case Mc.ROTATE: if (n.enableRotate === !1) return; Ie(), l = a.TOUCH_ROTATE; break; case Mc.PAN: if (n.enablePan === !1) return; Je(), l = a.TOUCH_PAN; break; default: l = a.NONE }break; case 2: switch (n.touches.TWO) { case Mc.DOLLY_PAN: if (n.enableZoom === !1 && n.enablePan === !1) return; Bt(), l = a.TOUCH_DOLLY_PAN; break; case Mc.DOLLY_ROTATE: if (n.enableZoom === !1 && n.enableRotate === !1) return; Ge(), l = a.TOUCH_DOLLY_ROTATE; break; default: l = a.NONE }break; default: l = a.NONE }l !== a.NONE && n.dispatchEvent(s) } function Ae(X) { switch (Te(X), l) { case a.TOUCH_ROTATE: if (n.enableRotate === !1) return; H(X), n.update(); break; case a.TOUCH_PAN: if (n.enablePan === !1) return; pe(X), n.update(); break; case a.TOUCH_DOLLY_PAN: if (n.enableZoom === !1 && n.enablePan === !1) return; Ee(X), n.update(); break; case a.TOUCH_DOLLY_ROTATE: if (n.enableZoom === !1 && n.enableRotate === !1) return; ve(X), n.update(); break; default: l = a.NONE } } function Me(X) { n.enabled !== !1 && X.preventDefault() } function Ce(X) { B.push(X) } function qe(X) { delete b[X.pointerId]; for (let he = 0; he < B.length; he++)if (B[he].pointerId == X.pointerId) { B.splice(he, 1); return } } function Te(X) { let he = b[X.pointerId]; he === void 0 && (he = new _e, b[X.pointerId] = he), he.set(X.pageX, X.pageY) } function oe(X) { const he = X.pointerId === B[0].pointerId ? B[1] : B[0]; return b[he.pointerId] } t !== void 0 && this.connect(t), this.update() } }; class nC extends rr { constructor(e) { super(e), this.dracoLoader = null, this.ktx2Loader = null, this.meshoptDecoder = null, this.pluginCallbacks = [], this.register(function (t) { return new xq(t) }), this.register(function (t) { return new bq(t) }), this.register(function (t) { return new Rq(t) }), this.register(function (t) { return new Pq(t) }), this.register(function (t) { return new Mq(t) }), this.register(function (t) { return new wq(t) }), this.register(function (t) { return new Sq(t) }), this.register(function (t) { return new Eq(t) }), this.register(function (t) { return new _q(t) }), this.register(function (t) { return new Cq(t) }), this.register(function (t) { return new Aq(t) }), this.register(function (t) { return new Tq(t) }), this.register(function (t) { return new yq(t) }), this.register(function (t) { return new Iq(t) }), this.register(function (t) { return new Bq(t) }) } load(e, t, n, r) { const s = this; let o; this.resourcePath !== "" ? o = this.resourcePath : this.path !== "" ? o = this.path : o = Wo.extractUrlBase(e), this.manager.itemStart(e); const a = function (c) { r ? r(c) : console.error(c), s.manager.itemError(e), s.manager.itemEnd(e) }, l = new ls(this.manager); l.setPath(this.path), l.setResponseType("arraybuffer"), l.setRequestHeader(this.requestHeader), l.setWithCredentials(this.withCredentials), l.load(e, function (c) { try { s.parse(c, o, function (f) { t(f), s.manager.itemEnd(e) }, a) } catch (f) { a(f) } }, n, a) } setDRACOLoader(e) { return this.dracoLoader = e, this } setDDSLoader() { throw new Error('THREE.GLTFLoader: "MSFT_texture_dds" no longer supported. Please update to "KHR_texture_basisu".') } setKTX2Loader(e) { return this.ktx2Loader = e, this } setMeshoptDecoder(e) { return this.meshoptDecoder = e, this } register(e) { return this.pluginCallbacks.indexOf(e) === -1 && this.pluginCallbacks.push(e), this } unregister(e) { return this.pluginCallbacks.indexOf(e) !== -1 && this.pluginCallbacks.splice(this.pluginCallbacks.indexOf(e), 1), this } parse(e, t, n, r) { let s; const o = {}, a = {}; if (typeof e == "string") s = JSON.parse(e); else if (e instanceof ArrayBuffer) if (Wo.decodeText(new Uint8Array(e.slice(0, 4))) === Jk) { try { o[Xt.KHR_BINARY_GLTF] = new Lq(e) } catch (f) { r && r(f); return } s = JSON.parse(o[Xt.KHR_BINARY_GLTF].content) } else s = JSON.parse(Wo.decodeText(new Uint8Array(e))); else s = e; if (s.asset === void 0 || s.asset.version[0] < 2) { r && r(new Error("THREE.GLTFLoader: Unsupported asset. glTF versions >=2.0 are supported.")); return } const l = new Jq(s, { path: t || this.resourcePath || "", crossOrigin: this.crossOrigin, requestHeader: this.requestHeader, manager: this.manager, ktx2Loader: this.ktx2Loader, meshoptDecoder: this.meshoptDecoder }); l.fileLoader.setRequestHeader(this.requestHeader); for (let c = 0; c < this.pluginCallbacks.length; c++) { const f = this.pluginCallbacks[c](l); a[f.name] = f, o[f.name] = !0 } if (s.extensionsUsed) for (let c = 0; c < s.extensionsUsed.length; ++c) { const f = s.extensionsUsed[c], d = s.extensionsRequired || []; switch (f) { case Xt.KHR_MATERIALS_UNLIT: o[f] = new vq; break; case Xt.KHR_DRACO_MESH_COMPRESSION: o[f] = new Dq(s, this.dracoLoader); break; case Xt.KHR_TEXTURE_TRANSFORM: o[f] = new Oq; break; case Xt.KHR_MESH_QUANTIZATION: o[f] = new Fq; break; default: d.indexOf(f) >= 0 && a[f] === void 0 && console.warn('THREE.GLTFLoader: Unknown extension "' + f + '".') } } l.setExtensions(o), l.setPlugins(a), l.parse(n, r) } parseAsync(e, t) { const n = this; return new Promise(function (r, s) { n.parse(e, t, r, s) }) } } function gq() { let i = {}; return { get: function (e) { return i[e] }, add: function (e, t) { i[e] = t }, remove: function (e) { delete i[e] }, removeAll: function () { i = {} } } } const Xt = { KHR_BINARY_GLTF: "KHR_binary_glTF", KHR_DRACO_MESH_COMPRESSION: "KHR_draco_mesh_compression", KHR_LIGHTS_PUNCTUAL: "KHR_lights_punctual", KHR_MATERIALS_CLEARCOAT: "KHR_materials_clearcoat", KHR_MATERIALS_IOR: "KHR_materials_ior", KHR_MATERIALS_SHEEN: "KHR_materials_sheen", KHR_MATERIALS_SPECULAR: "KHR_materials_specular", KHR_MATERIALS_TRANSMISSION: "KHR_materials_transmission", KHR_MATERIALS_IRIDESCENCE: "KHR_materials_iridescence", KHR_MATERIALS_ANISOTROPY: "KHR_materials_anisotropy", KHR_MATERIALS_UNLIT: "KHR_materials_unlit", KHR_MATERIALS_VOLUME: "KHR_materials_volume", KHR_TEXTURE_BASISU: "KHR_texture_basisu", KHR_TEXTURE_TRANSFORM: "KHR_texture_transform", KHR_MESH_QUANTIZATION: "KHR_mesh_quantization", KHR_MATERIALS_EMISSIVE_STRENGTH: "KHR_materials_emissive_strength", EXT_TEXTURE_WEBP: "EXT_texture_webp", EXT_TEXTURE_AVIF: "EXT_texture_avif", EXT_MESHOPT_COMPRESSION: "EXT_meshopt_compression", EXT_MESH_GPU_INSTANCING: "EXT_mesh_gpu_instancing" }; class yq { constructor(e) { this.parser = e, this.name = Xt.KHR_LIGHTS_PUNCTUAL, this.cache = { refs: {}, uses: {} } } _markDefs() { const e = this.parser, t = this.parser.json.nodes || []; for (let n = 0, r = t.length; n < r; n++) { const s = t[n]; s.extensions && s.extensions[this.name] && s.extensions[this.name].light !== void 0 && e._addNodeRef(this.cache, s.extensions[this.name].light) } } _loadLight(e) { const t = this.parser, n = "light:" + e; let r = t.cache.get(n); if (r) return r; const s = t.json, l = ((s.extensions && s.extensions[this.name] || {}).lights || [])[e]; let c; const f = new We(16777215); l.color !== void 0 && f.fromArray(l.color); const d = l.range !== void 0 ? l.range : 0; switch (l.type) { case "directional": c = new jE(f), c.target.position.set(0, 0, -1), c.add(c.target); break; case "point": c = new YE(f), c.distance = d; break; case "spot": c = new JE(f), c.distance = d, l.spot = l.spot || {}, l.spot.innerConeAngle = l.spot.innerConeAngle !== void 0 ? l.spot.innerConeAngle : 0, l.spot.outerConeAngle = l.spot.outerConeAngle !== void 0 ? l.spot.outerConeAngle : Math.PI / 4, c.angle = l.spot.outerConeAngle, c.penumbra = 1 - l.spot.innerConeAngle / l.spot.outerConeAngle, c.target.position.set(0, 0, -1), c.add(c.target); break; default: throw new Error("THREE.GLTFLoader: Unexpected light type: " + l.type) }return c.position.set(0, 0, 0), c.decay = 2, rl(c, l), l.intensity !== void 0 && (c.intensity = l.intensity), c.name = t.createUniqueName(l.name || "light_" + e), r = Promise.resolve(c), t.cache.add(n, r), r } getDependency(e, t) { if (e === "light") return this._loadLight(t) } createNodeAttachment(e) { const t = this, n = this.parser, s = n.json.nodes[e], a = (s.extensions && s.extensions[this.name] || {}).light; return a === void 0 ? null : this._loadLight(a).then(function (l) { return n._getNodeRef(t.cache, a, l) }) } } class vq { constructor() { this.name = Xt.KHR_MATERIALS_UNLIT } getMaterialType() { return ts } extendParams(e, t, n) { const r = []; e.color = new We(1, 1, 1), e.opacity = 1; const s = t.pbrMetallicRoughness; if (s) { if (Array.isArray(s.baseColorFactor)) { const o = s.baseColorFactor; e.color.fromArray(o), e.opacity = o[3] } s.baseColorTexture !== void 0 && r.push(n.assignTexture(e, "map", s.baseColorTexture, 3001)) } return Promise.all(r) } } class _q { constructor(e) { this.parser = e, this.name = Xt.KHR_MATERIALS_EMISSIVE_STRENGTH } extendMaterialParams(e, t) { const r = this.parser.json.materials[e]; if (!r.extensions || !r.extensions[this.name]) return Promise.resolve(); const s = r.extensions[this.name].emissiveStrength; return s !== void 0 && (t.emissiveIntensity = s), Promise.resolve() } } class xq { constructor(e) { this.parser = e, this.name = Xt.KHR_MATERIALS_CLEARCOAT } getMaterialType(e) { const n = this.parser.json.materials[e]; return !n.extensions || !n.extensions[this.name] ? null : qo } extendMaterialParams(e, t) { const n = this.parser, r = n.json.materials[e]; if (!r.extensions || !r.extensions[this.name]) return Promise.resolve(); const s = [], o = r.extensions[this.name]; if (o.clearcoatFactor !== void 0 && (t.clearcoat = o.clearcoatFactor), o.clearcoatTexture !== void 0 && s.push(n.assignTexture(t, "clearcoatMap", o.clearcoatTexture)), o.clearcoatRoughnessFactor !== void 0 && (t.clearcoatRoughness = o.clearcoatRoughnessFactor), o.clearcoatRoughnessTexture !== void 0 && s.push(n.assignTexture(t, "clearcoatRoughnessMap", o.clearcoatRoughnessTexture)), o.clearcoatNormalTexture !== void 0 && (s.push(n.assignTexture(t, "clearcoatNormalMap", o.clearcoatNormalTexture)), o.clearcoatNormalTexture.scale !== void 0)) { const a = o.clearcoatNormalTexture.scale; t.clearcoatNormalScale = new _e(a, a) } return Promise.all(s) } } class Aq { constructor(e) { this.parser = e, this.name = Xt.KHR_MATERIALS_IRIDESCENCE } getMaterialType(e) { const n = this.parser.json.materials[e]; return !n.extensions || !n.extensions[this.name] ? null : qo } extendMaterialParams(e, t) { const n = this.parser, r = n.json.materials[e]; if (!r.extensions || !r.extensions[this.name]) return Promise.resolve(); const s = [], o = r.extensions[this.name]; return o.iridescenceFactor !== void 0 && (t.iridescence = o.iridescenceFactor), o.iridescenceTexture !== void 0 && s.push(n.assignTexture(t, "iridescenceMap", o.iridescenceTexture)), o.iridescenceIor !== void 0 && (t.iridescenceIOR = o.iridescenceIor), t.iridescenceThicknessRange === void 0 && (t.iridescenceThicknessRange = [100, 400]), o.iridescenceThicknessMinimum !== void 0 && (t.iridescenceThicknessRange[0] = o.iridescenceThicknessMinimum), o.iridescenceThicknessMaximum !== void 0 && (t.iridescenceThicknessRange[1] = o.iridescenceThicknessMaximum), o.iridescenceThicknessTexture !== void 0 && s.push(n.assignTexture(t, "iridescenceThicknessMap", o.iridescenceThicknessTexture)), Promise.all(s) } } class Mq { constructor(e) { this.parser = e, this.name = Xt.KHR_MATERIALS_SHEEN } getMaterialType(e) { const n = this.parser.json.materials[e]; return !n.extensions || !n.extensions[this.name] ? null : qo } extendMaterialParams(e, t) { const n = this.parser, r = n.json.materials[e]; if (!r.extensions || !r.extensions[this.name]) return Promise.resolve(); const s = []; t.sheenColor = new We(0, 0, 0), t.sheenRoughness = 0, t.sheen = 1; const o = r.extensions[this.name]; return o.sheenColorFactor !== void 0 && t.sheenColor.fromArray(o.sheenColorFactor), o.sheenRoughnessFactor !== void 0 && (t.sheenRoughness = o.sheenRoughnessFactor), o.sheenColorTexture !== void 0 && s.push(n.assignTexture(t, "sheenColorMap", o.sheenColorTexture, 3001)), o.sheenRoughnessTexture !== void 0 && s.push(n.assignTexture(t, "sheenRoughnessMap", o.sheenRoughnessTexture)), Promise.all(s) } } class wq { constructor(e) { this.parser = e, this.name = Xt.KHR_MATERIALS_TRANSMISSION } getMaterialType(e) { const n = this.parser.json.materials[e]; return !n.extensions || !n.extensions[this.name] ? null : qo } extendMaterialParams(e, t) { const n = this.parser, r = n.json.materials[e]; if (!r.extensions || !r.extensions[this.name]) return Promise.resolve(); const s = [], o = r.extensions[this.name]; return o.transmissionFactor !== void 0 && (t.transmission = o.transmissionFactor), o.transmissionTexture !== void 0 && s.push(n.assignTexture(t, "transmissionMap", o.transmissionTexture)), Promise.all(s) } } class Sq { constructor(e) { this.parser = e, this.name = Xt.KHR_MATERIALS_VOLUME } getMaterialType(e) { const n = this.parser.json.materials[e]; return !n.extensions || !n.extensions[this.name] ? null : qo } extendMaterialParams(e, t) { const n = this.parser, r = n.json.materials[e]; if (!r.extensions || !r.extensions[this.name]) return Promise.resolve(); const s = [], o = r.extensions[this.name]; t.thickness = o.thicknessFactor !== void 0 ? o.thicknessFactor : 0, o.thicknessTexture !== void 0 && s.push(n.assignTexture(t, "thicknessMap", o.thicknessTexture)), t.attenuationDistance = o.attenuationDistance || 1 / 0; const a = o.attenuationColor || [1, 1, 1]; return t.attenuationColor = new We(a[0], a[1], a[2]), Promise.all(s) } } class Eq { constructor(e) { this.parser = e, this.name = Xt.KHR_MATERIALS_IOR } getMaterialType(e) { const n = this.parser.json.materials[e]; return !n.extensions || !n.extensions[this.name] ? null : qo } extendMaterialParams(e, t) { const r = this.parser.json.materials[e]; if (!r.extensions || !r.extensions[this.name]) return Promise.resolve(); const s = r.extensions[this.name]; return t.ior = s.ior !== void 0 ? s.ior : 1.5, Promise.resolve() } } class Cq { constructor(e) { this.parser = e, this.name = Xt.KHR_MATERIALS_SPECULAR } getMaterialType(e) { const n = this.parser.json.materials[e]; return !n.extensions || !n.extensions[this.name] ? null : qo } extendMaterialParams(e, t) { const n = this.parser, r = n.json.materials[e]; if (!r.extensions || !r.extensions[this.name]) return Promise.resolve(); const s = [], o = r.extensions[this.name]; t.specularIntensity = o.specularFactor !== void 0 ? o.specularFactor : 1, o.specularTexture !== void 0 && s.push(n.assignTexture(t, "specularIntensityMap", o.specularTexture)); const a = o.specularColorFactor || [1, 1, 1]; return t.specularColor = new We(a[0], a[1], a[2]), o.specularColorTexture !== void 0 && s.push(n.assignTexture(t, "specularColorMap", o.specularColorTexture, 3001)), Promise.all(s) } } class Tq { constructor(e) { this.parser = e, this.name = Xt.KHR_MATERIALS_ANISOTROPY } getMaterialType(e) { const n = this.parser.json.materials[e]; return !n.extensions || !n.extensions[this.name] ? null : qo } extendMaterialParams(e, t) { const n = this.parser, r = n.json.materials[e]; if (!r.extensions || !r.extensions[this.name]) return Promise.resolve(); const s = [], o = r.extensions[this.name]; return o.anisotropyStrength !== void 0 && (t.anisotropy = o.anisotropyStrength), o.anisotropyRotation !== void 0 && (t.anisotropyRotation = o.anisotropyRotation), o.anisotropyTexture !== void 0 && s.push(n.assignTexture(t, "anisotropyMap", o.anisotropyTexture)), Promise.all(s) } } class bq { constructor(e) { this.parser = e, this.name = Xt.KHR_TEXTURE_BASISU } loadTexture(e) { const t = this.parser, n = t.json, r = n.textures[e]; if (!r.extensions || !r.extensions[this.name]) return null; const s = r.extensions[this.name], o = t.options.ktx2Loader; if (!o) { if (n.extensionsRequired && n.extensionsRequired.indexOf(this.name) >= 0) throw new Error("THREE.GLTFLoader: setKTX2Loader must be called before loading KTX2 textures"); return null } return t.loadTextureImage(e, s.source, o) } } class Rq { constructor(e) { this.parser = e, this.name = Xt.EXT_TEXTURE_WEBP, this.isSupported = null } loadTexture(e) { const t = this.name, n = this.parser, r = n.json, s = r.textures[e]; if (!s.extensions || !s.extensions[t]) return null; const o = s.extensions[t], a = r.images[o.source]; let l = n.textureLoader; if (a.uri) { const c = n.options.manager.getHandler(a.uri); c !== null && (l = c) } return this.detectSupport().then(function (c) { if (c) return n.loadTextureImage(e, o.source, l); if (r.extensionsRequired && r.extensionsRequired.indexOf(t) >= 0) throw new Error("THREE.GLTFLoader: WebP required by asset but unsupported."); return n.loadTexture(e) }) } detectSupport() { return this.isSupported || (this.isSupported = new Promise(function (e) { const t = new Image; t.src = "data:image/webp;base64,UklGRiIAAABXRUJQVlA4IBYAAAAwAQCdASoBAAEADsD+JaQAA3AAAAAA", t.onload = t.onerror = function () { e(t.height === 1) } })), this.isSupported } } class Pq { constructor(e) { this.parser = e, this.name = Xt.EXT_TEXTURE_AVIF, this.isSupported = null } loadTexture(e) { const t = this.name, n = this.parser, r = n.json, s = r.textures[e]; if (!s.extensions || !s.extensions[t]) return null; const o = s.extensions[t], a = r.images[o.source]; let l = n.textureLoader; if (a.uri) { const c = n.options.manager.getHandler(a.uri); c !== null && (l = c) } return this.detectSupport().then(function (c) { if (c) return n.loadTextureImage(e, o.source, l); if (r.extensionsRequired && r.extensionsRequired.indexOf(t) >= 0) throw new Error("THREE.GLTFLoader: AVIF required by asset but unsupported."); return n.loadTexture(e) }) } detectSupport() { return this.isSupported || (this.isSupported = new Promise(function (e) { const t = new Image; t.src = "data:image/avif;base64,AAAAIGZ0eXBhdmlmAAAAAGF2aWZtaWYxbWlhZk1BMUIAAADybWV0YQAAAAAAAAAoaGRscgAAAAAAAAAAcGljdAAAAAAAAAAAAAAAAGxpYmF2aWYAAAAADnBpdG0AAAAAAAEAAAAeaWxvYwAAAABEAAABAAEAAAABAAABGgAAABcAAAAoaWluZgAAAAAAAQAAABppbmZlAgAAAAABAABhdjAxQ29sb3IAAAAAamlwcnAAAABLaXBjbwAAABRpc3BlAAAAAAAAAAEAAAABAAAAEHBpeGkAAAAAAwgICAAAAAxhdjFDgQAMAAAAABNjb2xybmNseAACAAIABoAAAAAXaXBtYQAAAAAAAAABAAEEAQKDBAAAAB9tZGF0EgAKCBgABogQEDQgMgkQAAAAB8dSLfI=", t.onload = t.onerror = function () { e(t.height === 1) } })), this.isSupported } } class Iq { constructor(e) { this.name = Xt.EXT_MESHOPT_COMPRESSION, this.parser = e } loadBufferView(e) { const t = this.parser.json, n = t.bufferViews[e]; if (n.extensions && n.extensions[this.name]) { const r = n.extensions[this.name], s = this.parser.getDependency("buffer", r.buffer), o = this.parser.options.meshoptDecoder; if (!o || !o.supported) { if (t.extensionsRequired && t.extensionsRequired.indexOf(this.name) >= 0) throw new Error("THREE.GLTFLoader: setMeshoptDecoder must be called before loading compressed files"); return null } return s.then(function (a) { const l = r.byteOffset || 0, c = r.byteLength || 0, f = r.count, d = r.byteStride, p = new Uint8Array(a, l, c); return o.decodeGltfBufferAsync ? o.decodeGltfBufferAsync(f, d, p, r.mode, r.filter).then(function (m) { return m.buffer }) : o.ready.then(function () { const m = new ArrayBuffer(f * d); return o.decodeGltfBuffer(new Uint8Array(m), f, d, p, r.mode, r.filter), m }) }) } else return null } } class Bq { constructor(e) { this.name = Xt.EXT_MESH_GPU_INSTANCING, this.parser = e } createNodeMesh(e) { const t = this.parser.json, n = t.nodes[e]; if (!n.extensions || !n.extensions[this.name] || n.mesh === void 0) return null; const r = t.meshes[n.mesh]; for (const c of r.primitives) if (c.mode !== Ss.TRIANGLES && c.mode !== Ss.TRIANGLE_STRIP && c.mode !== Ss.TRIANGLE_FAN && c.mode !== void 0) return null; const o = n.extensions[this.name].attributes, a = [], l = {}; for (const c in o) a.push(this.parser.getDependency("accessor", o[c]).then(f => (l[c] = f, l[c]))); return a.length < 1 ? null : (a.push(this.parser.createNodeMesh(e)), Promise.all(a).then(c => { const f = c.pop(), d = f.isGroup ? f.children : [f], p = c[0].count, m = []; for (const y of d) { const _ = new yt, x = new k, g = new Ti, A = new k(1, 1, 1), M = new IE(y.geometry, y.material, p); for (let S = 0; S < p; S++)l.TRANSLATION && x.fromBufferAttribute(l.TRANSLATION, S), l.ROTATION && g.fromBufferAttribute(l.ROTATION, S), l.SCALE && A.fromBufferAttribute(l.SCALE, S), M.setMatrixAt(S, _.compose(x, g, A)); for (const S in l) S !== "TRANSLATION" && S !== "ROTATION" && S !== "SCALE" && y.geometry.setAttribute(S, l[S]); qt.prototype.copy.call(M, y), this.parser.assignFinalMaterial(M), m.push(M) } return f.isGroup ? (f.clear(), f.add(...m), f) : m[0] })) } } const Jk = "glTF", wd = 12, UI = { JSON: 1313821514, BIN: 5130562 }; class Lq { constructor(e) { this.name = Xt.KHR_BINARY_GLTF, this.content = null, this.body = null; const t = new DataView(e, 0, wd); if (this.header = { magic: Wo.decodeText(new Uint8Array(e.slice(0, 4))), version: t.getUint32(4, !0), length: t.getUint32(8, !0) }, this.header.magic !== Jk) throw new Error("THREE.GLTFLoader: Unsupported glTF-Binary header."); if (this.header.version < 2) throw new Error("THREE.GLTFLoader: Legacy binary file detected."); const n = this.header.length - wd, r = new DataView(e, wd); let s = 0; for (; s < n;) { const o = r.getUint32(s, !0); s += 4; const a = r.getUint32(s, !0); if (s += 4, a === UI.JSON) { const l = new Uint8Array(e, wd + s, o); this.content = Wo.decodeText(l) } else if (a === UI.BIN) { const l = wd + s; this.body = e.slice(l, l + o) } s += o } if (this.content === null) throw new Error("THREE.GLTFLoader: JSON content not found.") } } class Dq { constructor(e, t) { if (!t) throw new Error("THREE.GLTFLoader: No DRACOLoader instance provided."); this.name = Xt.KHR_DRACO_MESH_COMPRESSION, this.json = e, this.dracoLoader = t, this.dracoLoader.preload() } decodePrimitive(e, t) { const n = this.json, r = this.dracoLoader, s = e.extensions[this.name].bufferView, o = e.extensions[this.name].attributes, a = {}, l = {}, c = {}; for (const f in o) { const d = IS[f] || f.toLowerCase(); a[d] = o[f] } for (const f in e.attributes) { const d = IS[f] || f.toLowerCase(); if (o[f] !== void 0) { const p = n.accessors[e.attributes[f]], m = qf[p.componentType]; c[d] = m.name, l[d] = p.normalized === !0 } } return t.getDependency("bufferView", s).then(function (f) { return new Promise(function (d) { r.decodeDracoFile(f, function (p) { for (const m in p.attributes) { const y = p.attributes[m], _ = l[m]; _ !== void 0 && (y.normalized = _) } d(p) }, a, c) }) }) } } class Oq { constructor() { this.name = Xt.KHR_TEXTURE_TRANSFORM } extendTexture(e, t) { return (t.texCoord === void 0 || t.texCoord === e.channel) && t.offset === void 0 && t.rotation === void 0 && t.scale === void 0 || (e = e.clone(), t.texCoord !== void 0 && (e.channel = t.texCoord), t.offset !== void 0 && e.offset.fromArray(t.offset), t.rotation !== void 0 && (e.rotation = t.rotation), t.scale !== void 0 && e.repeat.fromArray(t.scale), e.needsUpdate = !0), e } } class Fq { constructor() { this.name = Xt.KHR_MESH_QUANTIZATION } } class Yk extends Lh { constructor(e, t, n, r) { super(e, t, n, r) } copySampleValue_(e) { const t = this.resultBuffer, n = this.sampleValues, r = this.valueSize, s = e * r * 3 + r; for (let o = 0; o !== r; o++)t[o] = n[s + o]; return t } interpolate_(e, t, n, r) { const s = this.resultBuffer, o = this.sampleValues, a = this.valueSize, l = a * 2, c = a * 3, f = r - t, d = (n - t) / f, p = d * d, m = p * d, y = e * c, _ = y - c, x = -2 * m + 3 * p, g = m - p, A = 1 - x, M = g - p + d; for (let S = 0; S !== a; S++) { const C = o[_ + S + a], T = o[_ + S + l] * f, R = o[y + S + a], B = o[y + S] * f; s[S] = A * C + M * T + x * R + g * B } return s } } const kq = new Ti; class Nq extends Yk { interpolate_(e, t, n, r) { const s = super.interpolate_(e, t, n, r); return kq.fromArray(s).normalize().toArray(s), s } } const Ss = { FLOAT: 5126, FLOAT_MAT3: 35675, FLOAT_MAT4: 35676, FLOAT_VEC2: 35664, FLOAT_VEC3: 35665, FLOAT_VEC4: 35666, LINEAR: 9729, REPEAT: 10497, SAMPLER_2D: 35678, POINTS: 0, LINES: 1, LINE_LOOP: 2, LINE_STRIP: 3, TRIANGLES: 4, TRIANGLE_STRIP: 5, TRIANGLE_FAN: 6, UNSIGNED_BYTE: 5121, UNSIGNED_SHORT: 5123 }, qf = { 5120: Int8Array, 5121: Uint8Array, 5122: Int16Array, 5123: Uint16Array, 5125: Uint32Array, 5126: Float32Array }, zI = { 9728: zn, 9729: Pn, 9984: Np, 9985: Fv, 9986: Yf, 9987: Yo }, HI = { 33071: Di, 33648: mh, 10497: Ul }, hM = { SCALAR: 1, VEC2: 2, VEC3: 3, VEC4: 4, MAT2: 4, MAT3: 9, MAT4: 16 }, IS = { POSITION: "position", NORMAL: "normal", TANGENT: "tangent", ...rm.replace(/\D+/g, "") >= 152 ? { TEXCOORD_0: "uv", TEXCOORD_1: "uv1", TEXCOORD_2: "uv2", TEXCOORD_3: "uv3" } : { TEXCOORD_0: "uv", TEXCOORD_1: "uv2" }, COLOR_0: "color", WEIGHTS_0: "skinWeight", JOINTS_0: "skinIndex" }, $a = { scale: "scale", translation: "position", rotation: "quaternion", weights: "morphTargetInfluences" }, Uq = { CUBICSPLINE: void 0, LINEAR: lu, STEP: yh }, dM = { OPAQUE: "OPAQUE", MASK: "MASK", BLEND: "BLEND" }; function zq(i) { return i.DefaultMaterial === void 0 && (i.DefaultMaterial = new mm({ color: 16777215, emissive: 0, metalness: 1, roughness: 1, transparent: !1, depthTest: !0, side: Jo })), i.DefaultMaterial } function mc(i, e, t) { for (const n in t.extensions) i[n] === void 0 && (e.userData.gltfExtensions = e.userData.gltfExtensions || {}, e.userData.gltfExtensions[n] = t.extensions[n]) } function rl(i, e) { e.extras !== void 0 && (typeof e.extras == "object" ? Object.assign(i.userData, e.extras) : console.warn("THREE.GLTFLoader: Ignoring primitive type .extras, " + e.extras)) } function Hq(i, e, t) { let n = !1, r = !1, s = !1; for (let c = 0, f = e.length; c < f; c++) { const d = e[c]; if (d.POSITION !== void 0 && (n = !0), d.NORMAL !== void 0 && (r = !0), d.COLOR_0 !== void 0 && (s = !0), n && r && s) break } if (!n && !r && !s) return Promise.resolve(i); const o = [], a = [], l = []; for (let c = 0, f = e.length; c < f; c++) { const d = e[c]; if (n) { const p = d.POSITION !== void 0 ? t.getDependency("accessor", d.POSITION) : i.attributes.position; o.push(p) } if (r) { const p = d.NORMAL !== void 0 ? t.getDependency("accessor", d.NORMAL) : i.attributes.normal; a.push(p) } if (s) { const p = d.COLOR_0 !== void 0 ? t.getDependency("accessor", d.COLOR_0) : i.attributes.color; l.push(p) } } return Promise.all([Promise.all(o), Promise.all(a), Promise.all(l)]).then(function (c) { const f = c[0], d = c[1], p = c[2]; return n && (i.morphAttributes.position = f), r && (i.morphAttributes.normal = d), s && (i.morphAttributes.color = p), i.morphTargetsRelative = !0, i }) } function Gq(i, e) { if (i.updateMorphTargets(), e.weights !== void 0) for (let t = 0, n = e.weights.length; t < n; t++)i.morphTargetInfluences[t] = e.weights[t]; if (e.extras && Array.isArray(e.extras.targetNames)) { const t = e.extras.targetNames; if (i.morphTargetInfluences.length === t.length) { i.morphTargetDictionary = {}; for (let n = 0, r = t.length; n < r; n++)i.morphTargetDictionary[t[n]] = n } else console.warn("THREE.GLTFLoader: Invalid extras.targetNames length. Ignoring names.") } } function Vq(i) { let e; const t = i.extensions && i.extensions[Xt.KHR_DRACO_MESH_COMPRESSION]; if (t ? e = "draco:" + t.bufferView + ":" + t.indices + ":" + pM(t.attributes) : e = i.indices + ":" + pM(i.attributes) + ":" + i.mode, i.targets !== void 0) for (let n = 0, r = i.targets.length; n < r; n++)e += ":" + pM(i.targets[n]); return e } function pM(i) { let e = ""; const t = Object.keys(i).sort(); for (let n = 0, r = t.length; n < r; n++)e += t[n] + ":" + i[t[n]] + ";"; return e } function BS(i) { switch (i) { case Int8Array: return 1 / 127; case Uint8Array: return 1 / 255; case Int16Array: return 1 / 32767; case Uint16Array: return 1 / 65535; default: throw new Error("THREE.GLTFLoader: Unsupported normalized accessor component type.") } } function Wq(i) { return i.search(/\.jpe?g($|\?)/i) > 0 || i.search(/^data\:image\/jpeg/) === 0 ? "image/jpeg" : i.search(/\.webp($|\?)/i) > 0 || i.search(/^data\:image\/webp/) === 0 ? "image/webp" : "image/png" } const Xq = new yt; class Jq { constructor(e = {}, t = {}) { this.json = e, this.extensions = {}, this.plugins = {}, this.options = t, this.cache = new gq, this.associations = new Map, this.primitiveCache = {}, this.nodeCache = {}, this.meshCache = { refs: {}, uses: {} }, this.cameraCache = { refs: {}, uses: {} }, this.lightCache = { refs: {}, uses: {} }, this.sourceCache = {}, this.textureCache = {}, this.nodeNamesUsed = {}; let n = !1, r = !1, s = -1; typeof navigator < "u" && typeof navigator.userAgent < "u" && (n = /^((?!chrome|android).)*safari/i.test(navigator.userAgent) === !0, r = navigator.userAgent.indexOf("Firefox") > -1, s = r ? navigator.userAgent.match(/Firefox\/([0-9]+)\./)[1] : -1), typeof createImageBitmap > "u" || n || r && s < 98 ? this.textureLoader = new uk(this.options.manager) : this.textureLoader = new yk(this.options.manager), this.textureLoader.setCrossOrigin(this.options.crossOrigin), this.textureLoader.setRequestHeader(this.options.requestHeader), this.fileLoader = new ls(this.options.manager), this.fileLoader.setResponseType("arraybuffer"), this.options.crossOrigin === "use-credentials" && this.fileLoader.setWithCredentials(!0) } setExtensions(e) { this.extensions = e } setPlugins(e) { this.plugins = e } parse(e, t) { const n = this, r = this.json, s = this.extensions; this.cache.removeAll(), this.nodeCache = {}, this._invokeAll(function (o) { return o._markDefs && o._markDefs() }), Promise.all(this._invokeAll(function (o) { return o.beforeRoot && o.beforeRoot() })).then(function () { return Promise.all([n.getDependencies("scene"), n.getDependencies("animation"), n.getDependencies("camera")]) }).then(function (o) { const a = { scene: o[0][r.scene || 0], scenes: o[0], animations: o[1], cameras: o[2], asset: r.asset, parser: n, userData: {} }; mc(s, a, r), rl(a, r), Promise.all(n._invokeAll(function (l) { return l.afterRoot && l.afterRoot(a) })).then(function () { e(a) }) }).catch(t) } _markDefs() { const e = this.json.nodes || [], t = this.json.skins || [], n = this.json.meshes || []; for (let r = 0, s = t.length; r < s; r++) { const o = t[r].joints; for (let a = 0, l = o.length; a < l; a++)e[o[a]].isBone = !0 } for (let r = 0, s = e.length; r < s; r++) { const o = e[r]; o.mesh !== void 0 && (this._addNodeRef(this.meshCache, o.mesh), o.skin !== void 0 && (n[o.mesh].isSkinnedMesh = !0)), o.camera !== void 0 && this._addNodeRef(this.cameraCache, o.camera) } } _addNodeRef(e, t) { t !== void 0 && (e.refs[t] === void 0 && (e.refs[t] = e.uses[t] = 0), e.refs[t]++) } _getNodeRef(e, t, n) { if (e.refs[t] <= 1) return n; const r = n.clone(), s = (o, a) => { const l = this.associations.get(o); l != null && this.associations.set(a, l); for (const [c, f] of o.children.entries()) s(f, a.children[c]) }; return s(n, r), r.name += "_instance_" + e.uses[t]++, r } _invokeOne(e) { const t = Object.values(this.plugins); t.push(this); for (let n = 0; n < t.length; n++) { const r = e(t[n]); if (r) return r } return null } _invokeAll(e) { const t = Object.values(this.plugins); t.unshift(this); const n = []; for (let r = 0; r < t.length; r++) { const s = e(t[r]); s && n.push(s) } return n } getDependency(e, t) { const n = e + ":" + t; let r = this.cache.get(n); if (!r) { switch (e) { case "scene": r = this.loadScene(t); break; case "node": r = this._invokeOne(function (s) { return s.loadNode && s.loadNode(t) }); break; case "mesh": r = this._invokeOne(function (s) { return s.loadMesh && s.loadMesh(t) }); break; case "accessor": r = this.loadAccessor(t); break; case "bufferView": r = this._invokeOne(function (s) { return s.loadBufferView && s.loadBufferView(t) }); break; case "buffer": r = this.loadBuffer(t); break; case "material": r = this._invokeOne(function (s) { return s.loadMaterial && s.loadMaterial(t) }); break; case "texture": r = this._invokeOne(function (s) { return s.loadTexture && s.loadTexture(t) }); break; case "skin": r = this.loadSkin(t); break; case "animation": r = this._invokeOne(function (s) { return s.loadAnimation && s.loadAnimation(t) }); break; case "camera": r = this.loadCamera(t); break; default: if (r = this._invokeOne(function (s) { return s != this && s.getDependency && s.getDependency(e, t) }), !r) throw new Error("Unknown type: " + e); break }this.cache.add(n, r) } return r } getDependencies(e) { let t = this.cache.get(e); if (!t) { const n = this, r = this.json[e + (e === "mesh" ? "es" : "s")] || []; t = Promise.all(r.map(function (s, o) { return n.getDependency(e, o) })), this.cache.add(e, t) } return t } loadBuffer(e) { const t = this.json.buffers[e], n = this.fileLoader; if (t.type && t.type !== "arraybuffer") throw new Error("THREE.GLTFLoader: " + t.type + " buffer type is not supported."); if (t.uri === void 0 && e === 0) return Promise.resolve(this.extensions[Xt.KHR_BINARY_GLTF].body); const r = this.options; return new Promise(function (s, o) { n.load(Wo.resolveURL(t.uri, r.path), s, void 0, function () { o(new Error('THREE.GLTFLoader: Failed to load buffer "' + t.uri + '".')) }) }) } loadBufferView(e) { const t = this.json.bufferViews[e]; return this.getDependency("buffer", t.buffer).then(function (n) { const r = t.byteLength || 0, s = t.byteOffset || 0; return n.slice(s, s + r) }) } loadAccessor(e) { const t = this, n = this.json, r = this.json.accessors[e]; if (r.bufferView === void 0 && r.sparse === void 0) { const o = hM[r.type], a = qf[r.componentType], l = r.normalized === !0, c = new a(r.count * o); return Promise.resolve(new rn(c, o, l)) } const s = []; return r.bufferView !== void 0 ? s.push(this.getDependency("bufferView", r.bufferView)) : s.push(null), r.sparse !== void 0 && (s.push(this.getDependency("bufferView", r.sparse.indices.bufferView)), s.push(this.getDependency("bufferView", r.sparse.values.bufferView))), Promise.all(s).then(function (o) { const a = o[0], l = hM[r.type], c = qf[r.componentType], f = c.BYTES_PER_ELEMENT, d = f * l, p = r.byteOffset || 0, m = r.bufferView !== void 0 ? n.bufferViews[r.bufferView].byteStride : void 0, y = r.normalized === !0; let _, x; if (m && m !== d) { const g = Math.floor(p / m), A = "InterleavedBuffer:" + r.bufferView + ":" + r.componentType + ":" + g + ":" + r.count; let M = t.cache.get(A); M || (_ = new c(a, g * m, r.count * m / f), M = new um(_, m / f), t.cache.add(A, M)), x = new zl(M, l, p % m / f, y) } else a === null ? _ = new c(r.count * l) : _ = new c(a, p, r.count * l), x = new rn(_, l, y); if (r.sparse !== void 0) { const g = hM.SCALAR, A = qf[r.sparse.indices.componentType], M = r.sparse.indices.byteOffset || 0, S = r.sparse.values.byteOffset || 0, C = new A(o[1], M, r.sparse.count * g), T = new c(o[2], S, r.sparse.count * l); a !== null && (x = new rn(x.array.slice(), x.itemSize, x.normalized)); for (let R = 0, B = C.length; R < B; R++) { const b = C[R]; if (x.setX(b, T[R * l]), l >= 2 && x.setY(b, T[R * l + 1]), l >= 3 && x.setZ(b, T[R * l + 2]), l >= 4 && x.setW(b, T[R * l + 3]), l >= 5) throw new Error("THREE.GLTFLoader: Unsupported itemSize in sparse BufferAttribute.") } } return x }) } loadTexture(e) { const t = this.json, n = this.options, s = t.textures[e].source, o = t.images[s]; let a = this.textureLoader; if (o.uri) { const l = n.manager.getHandler(o.uri); l !== null && (a = l) } return this.loadTextureImage(e, s, a) } loadTextureImage(e, t, n) { const r = this, s = this.json, o = s.textures[e], a = s.images[t], l = (a.uri || a.bufferView) + ":" + o.sampler; if (this.textureCache[l]) return this.textureCache[l]; const c = this.loadImageSource(t, n).then(function (f) { f.flipY = !1, f.name = o.name || a.name || "", f.name === "" && typeof a.uri == "string" && a.uri.startsWith("data:image/") === !1 && (f.name = a.uri); const p = (s.samplers || {})[o.sampler] || {}; return f.magFilter = zI[p.magFilter] || Pn, f.minFilter = zI[p.minFilter] || Yo, f.wrapS = HI[p.wrapS] || Ul, f.wrapT = HI[p.wrapT] || Ul, r.associations.set(f, { textures: e }), f }).catch(function () { return null }); return this.textureCache[l] = c, c } loadImageSource(e, t) { const n = this, r = this.json, s = this.options; if (this.sourceCache[e] !== void 0) return this.sourceCache[e].then(d => d.clone()); const o = r.images[e], a = self.URL || self.webkitURL; let l = o.uri || "", c = !1; if (o.bufferView !== void 0) l = n.getDependency("bufferView", o.bufferView).then(function (d) { c = !0; const p = new Blob([d], { type: o.mimeType }); return l = a.createObjectURL(p), l }); else if (o.uri === void 0) throw new Error("THREE.GLTFLoader: Image " + e + " is missing URI and bufferView"); const f = Promise.resolve(l).then(function (d) { return new Promise(function (p, m) { let y = p; t.isImageBitmapLoader === !0 && (y = function (_) { const x = new wn(_); x.needsUpdate = !0, p(x) }), t.load(Wo.resolveURL(d, s.path), y, void 0, m) }) }).then(function (d) { return c === !0 && a.revokeObjectURL(l), d.userData.mimeType = o.mimeType || Wq(o.uri), d }).catch(function (d) { throw console.error("THREE.GLTFLoader: Couldn't load texture", l), d }); return this.sourceCache[e] = f, f } assignTexture(e, t, n, r) { const s = this; return this.getDependency("texture", n.index).then(function (o) { if (!o) return null; if (n.texCoord !== void 0 && n.texCoord > 0 && (o = o.clone(), o.channel = n.texCoord), s.extensions[Xt.KHR_TEXTURE_TRANSFORM]) { const a = n.extensions !== void 0 ? n.extensions[Xt.KHR_TEXTURE_TRANSFORM] : void 0; if (a) { const l = s.associations.get(o); o = s.extensions[Xt.KHR_TEXTURE_TRANSFORM].extendTexture(o, a), s.associations.set(o, l) } } return r !== void 0 && ("colorSpace" in o ? o.colorSpace = r === 3001 ? "srgb" : "srgb-linear" : o.encoding = r), e[t] = o, o }) } assignFinalMaterial(e) { const t = e.geometry; let n = e.material; const r = t.attributes.tangent === void 0, s = t.attributes.color !== void 0, o = t.attributes.normal === void 0; if (e.isPoints) { const a = "PointsMaterial:" + n.uuid; let l = this.cache.get(a); l || (l = new Xv, oi.prototype.copy.call(l, n), l.color.copy(n.color), l.map = n.map, l.sizeAttenuation = !1, this.cache.add(a, l)), n = l } else if (e.isLine) { const a = "LineBasicMaterial:" + n.uuid; let l = this.cache.get(a); l || (l = new ir, oi.prototype.copy.call(l, n), l.color.copy(n.color), l.map = n.map, this.cache.add(a, l)), n = l } if (r || s || o) { let a = "ClonedMaterial:" + n.uuid + ":"; r && (a += "derivative-tangents:"), s && (a += "vertex-colors:"), o && (a += "flat-shading:"); let l = this.cache.get(a); l || (l = n.clone(), s && (l.vertexColors = !0), o && (l.flatShading = !0), r && (l.normalScale && (l.normalScale.y *= -1), l.clearcoatNormalScale && (l.clearcoatNormalScale.y *= -1)), this.cache.add(a, l), this.associations.set(l, this.associations.get(n))), n = l } e.material = n } getMaterialType() { return mm } loadMaterial(e) { const t = this, n = this.json, r = this.extensions, s = n.materials[e]; let o; const a = {}, l = s.extensions || {}, c = []; if (l[Xt.KHR_MATERIALS_UNLIT]) { const d = r[Xt.KHR_MATERIALS_UNLIT]; o = d.getMaterialType(), c.push(d.extendParams(a, s, t)) } else { const d = s.pbrMetallicRoughness || {}; if (a.color = new We(1, 1, 1), a.opacity = 1, Array.isArray(d.baseColorFactor)) { const p = d.baseColorFactor; a.color.fromArray(p), a.opacity = p[3] } d.baseColorTexture !== void 0 && c.push(t.assignTexture(a, "map", d.baseColorTexture, 3001)), a.metalness = d.metallicFactor !== void 0 ? d.metallicFactor : 1, a.roughness = d.roughnessFactor !== void 0 ? d.roughnessFactor : 1, d.metallicRoughnessTexture !== void 0 && (c.push(t.assignTexture(a, "metalnessMap", d.metallicRoughnessTexture)), c.push(t.assignTexture(a, "roughnessMap", d.metallicRoughnessTexture))), o = this._invokeOne(function (p) { return p.getMaterialType && p.getMaterialType(e) }), c.push(Promise.all(this._invokeAll(function (p) { return p.extendMaterialParams && p.extendMaterialParams(e, a) }))) } s.doubleSided === !0 && (a.side = ro); const f = s.alphaMode || dM.OPAQUE; if (f === dM.BLEND ? (a.transparent = !0, a.depthWrite = !1) : (a.transparent = !1, f === dM.MASK && (a.alphaTest = s.alphaCutoff !== void 0 ? s.alphaCutoff : .5)), s.normalTexture !== void 0 && o !== ts && (c.push(t.assignTexture(a, "normalMap", s.normalTexture)), a.normalScale = new _e(1, 1), s.normalTexture.scale !== void 0)) { const d = s.normalTexture.scale; a.normalScale.set(d, d) } return s.occlusionTexture !== void 0 && o !== ts && (c.push(t.assignTexture(a, "aoMap", s.occlusionTexture)), s.occlusionTexture.strength !== void 0 && (a.aoMapIntensity = s.occlusionTexture.strength)), s.emissiveFactor !== void 0 && o !== ts && (a.emissive = new We().fromArray(s.emissiveFactor)), s.emissiveTexture !== void 0 && o !== ts && c.push(t.assignTexture(a, "emissiveMap", s.emissiveTexture, 3001)), Promise.all(c).then(function () { const d = new o(a); return s.name && (d.name = s.name), rl(d, s), t.associations.set(d, { materials: e }), s.extensions && mc(r, d, s), d }) } createUniqueName(e) { const t = Kt.sanitizeNodeName(e || ""); return t in this.nodeNamesUsed ? t + "_" + ++this.nodeNamesUsed[t] : (this.nodeNamesUsed[t] = 0, t) } loadGeometries(e) { const t = this, n = this.extensions, r = this.primitiveCache; function s(a) { return n[Xt.KHR_DRACO_MESH_COMPRESSION].decodePrimitive(a, t).then(function (l) { return GI(l, a, t) }) } const o = []; for (let a = 0, l = e.length; a < l; a++) { const c = e[a], f = Vq(c), d = r[f]; if (d) o.push(d.promise); else { let p; c.extensions && c.extensions[Xt.KHR_DRACO_MESH_COMPRESSION] ? p = s(c) : p = GI(new Rt, c, t), r[f] = { primitive: c, promise: p }, o.push(p) } } return Promise.all(o) } loadMesh(e) { const t = this, n = this.json, r = this.extensions, s = n.meshes[e], o = s.primitives, a = []; for (let l = 0, c = o.length; l < c; l++) { const f = o[l].material === void 0 ? zq(this.cache) : this.getDependency("material", o[l].material); a.push(f) } return a.push(t.loadGeometries(o)), Promise.all(a).then(function (l) { const c = l.slice(0, l.length - 1), f = l[l.length - 1], d = []; for (let m = 0, y = f.length; m < y; m++) { const _ = f[m], x = o[m]; let g; const A = c[m]; if (x.mode === Ss.TRIANGLES || x.mode === Ss.TRIANGLE_STRIP || x.mode === Ss.TRIANGLE_FAN || x.mode === void 0) g = s.isSkinnedMesh === !0 ? new PE(_, A) : new Ei(_, A), g.isSkinnedMesh === !0 && g.normalizeSkinWeights(), x.mode === Ss.TRIANGLE_STRIP ? g.geometry = kI(g.geometry, yE) : x.mode === Ss.TRIANGLE_FAN && (g.geometry = kI(g.geometry, iv)); else if (x.mode === Ss.LINES) g = new vo(_, A); else if (x.mode === Ss.LINE_STRIP) g = new Oa(_, A); else if (x.mode === Ss.LINE_LOOP) g = new BE(_, A); else if (x.mode === Ss.POINTS) g = new LE(_, A); else throw new Error("THREE.GLTFLoader: Primitive mode unsupported: " + x.mode); Object.keys(g.geometry.morphAttributes).length > 0 && Gq(g, s), g.name = t.createUniqueName(s.name || "mesh_" + e), rl(g, s), x.extensions && mc(r, g, x), t.assignFinalMaterial(g), d.push(g) } for (let m = 0, y = d.length; m < y; m++)t.associations.set(d[m], { meshes: e, primitives: m }); if (d.length === 1) return s.extensions && mc(r, d[0], s), d[0]; const p = new Ma; s.extensions && mc(r, p, s), t.associations.set(p, { meshes: e }); for (let m = 0, y = d.length; m < y; m++)p.add(d[m]); return p }) } loadCamera(e) { let t; const n = this.json.cameras[e], r = n[n.type]; if (!r) { console.warn("THREE.GLTFLoader: Missing camera parameters."); return } return n.type === "perspective" ? t = new Vn(AF.radToDeg(r.yfov), r.aspectRatio || 1, r.znear || 1, r.zfar || 2e6) : n.type === "orthographic" && (t = new Ca(-r.xmag, r.xmag, r.ymag, -r.ymag, r.znear, r.zfar)), n.name && (t.name = this.createUniqueName(n.name)), rl(t, n), Promise.resolve(t) } loadSkin(e) { const t = this.json.skins[e], n = []; for (let r = 0, s = t.joints.length; r < s; r++)n.push(this._loadNodeShallow(t.joints[r])); return t.inverseBindMatrices !== void 0 ? n.push(this.getDependency("accessor", t.inverseBindMatrices)) : n.push(null), Promise.all(n).then(function (r) { const s = r.pop(), o = r, a = [], l = []; for (let c = 0, f = o.length; c < f; c++) { const d = o[c]; if (d) { a.push(d); const p = new yt; s !== null && p.fromArray(s.array, c * 16), l.push(p) } else console.warn('THREE.GLTFLoader: Joint "%s" could not be found.', t.joints[c]) } return new fm(a, l) }) } loadAnimation(e) { const n = this.json.animations[e], r = n.name ? n.name : "animation_" + e, s = [], o = [], a = [], l = [], c = []; for (let f = 0, d = n.channels.length; f < d; f++) { const p = n.channels[f], m = n.samplers[p.sampler], y = p.target, _ = y.node, x = n.parameters !== void 0 ? n.parameters[m.input] : m.input, g = n.parameters !== void 0 ? n.parameters[m.output] : m.output; y.node !== void 0 && (s.push(this.getDependency("node", _)), o.push(this.getDependency("accessor", x)), a.push(this.getDependency("accessor", g)), l.push(m), c.push(y)) } return Promise.all([Promise.all(s), Promise.all(o), Promise.all(a), Promise.all(l), Promise.all(c)]).then(function (f) { const d = f[0], p = f[1], m = f[2], y = f[3], _ = f[4], x = []; for (let g = 0, A = d.length; g < A; g++) { const M = d[g], S = p[g], C = m[g], T = y[g], R = _[g]; if (M === void 0) continue; M.updateMatrix(); let B; switch ($a[R.path]) { case $a.weights: B = Ah; break; case $a.rotation: B = Hl; break; case $a.position: case $a.scale: default: B = Mh; break }const b = M.name ? M.name : M.uuid, I = T.interpolation !== void 0 ? Uq[T.interpolation] : lu, N = []; $a[R.path] === $a.weights ? M.traverse(function (J) { J.morphTargetInfluences && N.push(J.name ? J.name : J.uuid) }) : N.push(b); let V = C.array; if (C.normalized) { const J = BS(V.constructor), j = new Float32Array(V.length); for (let q = 0, ne = V.length; q < ne; q++)j[q] = V[q] * J; V = j } for (let J = 0, j = N.length; J < j; J++) { const q = new B(N[J] + "." + $a[R.path], S.array, V, I); T.interpolation === "CUBICSPLINE" && (q.createInterpolant = function (Q) { const F = this instanceof Hl ? Nq : Yk; return new F(this.times, this.values, this.getValueSize() / 3, Q) }, q.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline = !0), x.push(q) } } return new wh(r, void 0, x) }) } createNodeMesh(e) { const t = this.json, n = this, r = t.nodes[e]; return r.mesh === void 0 ? null : n.getDependency("mesh", r.mesh).then(function (s) { const o = n._getNodeRef(n.meshCache, r.mesh, s); return r.weights !== void 0 && o.traverse(function (a) { if (a.isMesh) for (let l = 0, c = r.weights.length; l < c; l++)a.morphTargetInfluences[l] = r.weights[l] }), o }) } loadNode(e) { const t = this.json, n = this, r = t.nodes[e], s = n._loadNodeShallow(e), o = [], a = r.children || []; for (let c = 0, f = a.length; c < f; c++)o.push(n.getDependency("node", a[c])); const l = r.skin === void 0 ? Promise.resolve(null) : n.getDependency("skin", r.skin); return Promise.all([s, Promise.all(o), l]).then(function (c) { const f = c[0], d = c[1], p = c[2]; p !== null && f.traverse(function (m) { m.isSkinnedMesh && m.bind(p, Xq) }); for (let m = 0, y = d.length; m < y; m++)f.add(d[m]); return f }) } _loadNodeShallow(e) { const t = this.json, n = this.extensions, r = this; if (this.nodeCache[e] !== void 0) return this.nodeCache[e]; const s = t.nodes[e], o = s.name ? r.createUniqueName(s.name) : "", a = [], l = r._invokeOne(function (c) { return c.createNodeMesh && c.createNodeMesh(e) }); return l && a.push(l), s.camera !== void 0 && a.push(r.getDependency("camera", s.camera).then(function (c) { return r._getNodeRef(r.cameraCache, s.camera, c) })), r._invokeAll(function (c) { return c.createNodeAttachment && c.createNodeAttachment(e) }).forEach(function (c) { a.push(c) }), this.nodeCache[e] = Promise.all(a).then(function (c) { let f; if (s.isBone === !0 ? f = new Wv : c.length > 1 ? f = new Ma : c.length === 1 ? f = c[0] : f = new qt, f !== c[0]) for (let d = 0, p = c.length; d < p; d++)f.add(c[d]); if (s.name && (f.userData.name = s.name, f.name = o), rl(f, s), s.extensions && mc(n, f, s), s.matrix !== void 0) { const d = new yt; d.fromArray(s.matrix), f.applyMatrix4(d) } else s.translation !== void 0 && f.position.fromArray(s.translation), s.rotation !== void 0 && f.quaternion.fromArray(s.rotation), s.scale !== void 0 && f.scale.fromArray(s.scale); return r.associations.has(f) || r.associations.set(f, {}), r.associations.get(f).nodes = e, f }), this.nodeCache[e] } loadScene(e) { const t = this.extensions, n = this.json.scenes[e], r = this, s = new Ma; n.name && (s.name = r.createUniqueName(n.name)), rl(s, n), n.extensions && mc(t, s, n); const o = n.nodes || [], a = []; for (let l = 0, c = o.length; l < c; l++)a.push(r.getDependency("node", o[l])); return Promise.all(a).then(function (l) { for (let f = 0, d = l.length; f < d; f++)s.add(l[f]); const c = f => { const d = new Map; for (const [p, m] of r.associations) (p instanceof oi || p instanceof wn) && d.set(p, m); return f.traverse(p => { const m = r.associations.get(p); m != null && d.set(p, m) }), d }; return r.associations = c(s), s }) } } function Yq(i, e, t) { const n = e.attributes, r = new yo; if (n.POSITION !== void 0) { const a = t.json.accessors[n.POSITION], l = a.min, c = a.max; if (l !== void 0 && c !== void 0) { if (r.set(new k(l[0], l[1], l[2]), new k(c[0], c[1], c[2])), a.normalized) { const f = BS(qf[a.componentType]); r.min.multiplyScalar(f), r.max.multiplyScalar(f) } } else { console.warn("THREE.GLTFLoader: Missing min/max properties for accessor POSITION."); return } } else return; const s = e.targets; if (s !== void 0) { const a = new k, l = new k; for (let c = 0, f = s.length; c < f; c++) { const d = s[c]; if (d.POSITION !== void 0) { const p = t.json.accessors[d.POSITION], m = p.min, y = p.max; if (m !== void 0 && y !== void 0) { if (l.setX(Math.max(Math.abs(m[0]), Math.abs(y[0]))), l.setY(Math.max(Math.abs(m[1]), Math.abs(y[1]))), l.setZ(Math.max(Math.abs(m[2]), Math.abs(y[2]))), p.normalized) { const _ = BS(qf[p.componentType]); l.multiplyScalar(_) } a.max(l) } else console.warn("THREE.GLTFLoader: Missing min/max properties for accessor POSITION.") } } r.expandByVector(a) } i.boundingBox = r; const o = new Gs; r.getCenter(o.center), o.radius = r.min.distanceTo(r.max) / 2, i.boundingSphere = o } function GI(i, e, t) { const n = e.attributes, r = []; function s(o, a) { return t.getDependency("accessor", o).then(function (l) { i.setAttribute(a, l) }) } for (const o in n) { const a = IS[o] || o.toLowerCase(); a in i.attributes || r.push(s(n[o], a)) } if (e.indices !== void 0 && !i.index) { const o = t.getDependency("accessor", e.indices).then(function (a) { i.setIndex(a) }); r.push(o) } return rl(i, e), Yq(i, e, t), Promise.all(r).then(function () { return e.targets !== void 0 ? Hq(i, e.targets, t) : i }) } const mM = new WeakMap; class jq extends rr {
	constructor(e) { super(e), this.decoderPath = "", this.decoderConfig = {}, this.decoderBinary = null, this.decoderPending = null, this.workerLimit = 4, this.workerPool = [], this.workerNextTaskID = 1, this.workerSourceURL = "", this.defaultAttributeIDs = { position: "POSITION", normal: "NORMAL", color: "COLOR", uv: "TEX_COORD" }, this.defaultAttributeTypes = { position: "Float32Array", normal: "Float32Array", color: "Float32Array", uv: "Float32Array" } } setDecoderPath(e) { return this.decoderPath = e, this } setDecoderConfig(e) { return this.decoderConfig = e, this } setWorkerLimit(e) { return this.workerLimit = e, this } load(e, t, n, r) { const s = new ls(this.manager); s.setPath(this.path), s.setResponseType("arraybuffer"), s.setRequestHeader(this.requestHeader), s.setWithCredentials(this.withCredentials), s.load(e, o => { const a = { attributeIDs: this.defaultAttributeIDs, attributeTypes: this.defaultAttributeTypes, useUniqueIDs: !1 }; this.decodeGeometry(o, a).then(t).catch(r) }, n, r) } decodeDracoFile(e, t, n, r) { const s = { attributeIDs: n || this.defaultAttributeIDs, attributeTypes: r || this.defaultAttributeTypes, useUniqueIDs: !!n }; this.decodeGeometry(e, s).then(t) } decodeGeometry(e, t) { for (const l in t.attributeTypes) { const c = t.attributeTypes[l]; c.BYTES_PER_ELEMENT !== void 0 && (t.attributeTypes[l] = c.name) } const n = JSON.stringify(t); if (mM.has(e)) { const l = mM.get(e); if (l.key === n) return l.promise; if (e.byteLength === 0) throw new Error("THREE.DRACOLoader: Unable to re-decode a buffer with different settings. Buffer has already been transferred.") } let r; const s = this.workerNextTaskID++, o = e.byteLength, a = this._getWorker(s, o).then(l => (r = l, new Promise((c, f) => { r._callbacks[s] = { resolve: c, reject: f }, r.postMessage({ type: "decode", id: s, taskConfig: t, buffer: e }, [e]) }))).then(l => this._createGeometry(l.geometry)); return a.catch(() => !0).then(() => { r && s && this._releaseTask(r, s) }), mM.set(e, { key: n, promise: a }), a } _createGeometry(e) { const t = new Rt; e.index && t.setIndex(new rn(e.index.array, 1)); for (let n = 0; n < e.attributes.length; n++) { const r = e.attributes[n], s = r.name, o = r.array, a = r.itemSize; t.setAttribute(s, new rn(o, a)) } return t } _loadLibrary(e, t) { const n = new ls(this.manager); return n.setPath(this.decoderPath), n.setResponseType(t), n.setWithCredentials(this.withCredentials), new Promise((r, s) => { n.load(e, r, void 0, s) }) } preload() { return this._initDecoder(), this } _initDecoder() {
		if (this.decoderPending) return this.decoderPending; const e = typeof WebAssembly != "object" || this.decoderConfig.type === "js", t = []; return e ? t.push(this._loadLibrary("draco_decoder.js", "text")) : (t.push(this._loadLibrary("draco_wasm_wrapper.js", "text")), t.push(this._loadLibrary("draco_decoder.wasm", "arraybuffer"))), this.decoderPending = Promise.all(t).then(n => {
			const r = n[0]; e || (this.decoderConfig.wasmBinary = n[1]); const s = Kq.toString(), o = ["/* draco decoder */", r, "", "/* worker */", s.substring(s.indexOf("{") + 1, s.lastIndexOf("}"))].join(`
`); this.workerSourceURL = URL.createObjectURL(new Blob([o]))
		}), this.decoderPending
	} _getWorker(e, t) { return this._initDecoder().then(() => { if (this.workerPool.length < this.workerLimit) { const r = new Worker(this.workerSourceURL); r._callbacks = {}, r._taskCosts = {}, r._taskLoad = 0, r.postMessage({ type: "init", decoderConfig: this.decoderConfig }), r.onmessage = function (s) { const o = s.data; switch (o.type) { case "decode": r._callbacks[o.id].resolve(o); break; case "error": r._callbacks[o.id].reject(o); break; default: console.error('THREE.DRACOLoader: Unexpected message, "' + o.type + '"') } }, this.workerPool.push(r) } else this.workerPool.sort(function (r, s) { return r._taskLoad > s._taskLoad ? -1 : 1 }); const n = this.workerPool[this.workerPool.length - 1]; return n._taskCosts[e] = t, n._taskLoad += t, n }) } _releaseTask(e, t) { e._taskLoad -= e._taskCosts[t], delete e._callbacks[t], delete e._taskCosts[t] } debug() { console.log("Task load: ", this.workerPool.map(e => e._taskLoad)) } dispose() { for (let e = 0; e < this.workerPool.length; ++e)this.workerPool[e].terminate(); return this.workerPool.length = 0, this }
} function Kq() { let i, e; onmessage = function (o) { const a = o.data; switch (a.type) { case "init": i = a.decoderConfig, e = new Promise(function (f) { i.onModuleLoaded = function (d) { f({ draco: d }) }, DracoDecoderModule(i) }); break; case "decode": const l = a.buffer, c = a.taskConfig; e.then(f => { const d = f.draco, p = new d.Decoder, m = new d.DecoderBuffer; m.Init(new Int8Array(l), l.byteLength); try { const y = t(d, p, m, c), _ = y.attributes.map(x => x.array.buffer); y.index && _.push(y.index.array.buffer), self.postMessage({ type: "decode", id: a.id, geometry: y }, _) } catch (y) { console.error(y), self.postMessage({ type: "error", id: a.id, error: y.message }) } finally { d.destroy(m), d.destroy(p) } }); break } }; function t(o, a, l, c) { const f = c.attributeIDs, d = c.attributeTypes; let p, m; const y = a.GetEncodedGeometryType(l); if (y === o.TRIANGULAR_MESH) p = new o.Mesh, m = a.DecodeBufferToMesh(l, p); else if (y === o.POINT_CLOUD) p = new o.PointCloud, m = a.DecodeBufferToPointCloud(l, p); else throw new Error("THREE.DRACOLoader: Unexpected geometry type."); if (!m.ok() || p.ptr === 0) throw new Error("THREE.DRACOLoader: Decoding failed: " + m.error_msg()); const _ = { index: null, attributes: [] }; for (const x in f) { const g = self[d[x]]; let A, M; if (c.useUniqueIDs) M = f[x], A = a.GetAttributeByUniqueId(p, M); else { if (M = a.GetAttributeId(p, o[f[x]]), M === -1) continue; A = a.GetAttribute(p, M) } _.attributes.push(r(o, a, p, x, g, A)) } return y === o.TRIANGULAR_MESH && (_.index = n(o, a, p)), o.destroy(p), _ } function n(o, a, l) { const f = l.num_faces() * 3, d = f * 4, p = o._malloc(d); a.GetTrianglesUInt32Array(l, d, p); const m = new Uint32Array(o.HEAPF32.buffer, p, f).slice(); return o._free(p), { array: m, itemSize: 1 } } function r(o, a, l, c, f, d) { const p = d.num_components(), y = l.num_points() * p, _ = y * f.BYTES_PER_ELEMENT, x = s(o, f), g = o._malloc(_); a.GetAttributeDataArrayForAllPoints(l, d, x, _, g); const A = new f(o.HEAPF32.buffer, g, y).slice(); return o._free(g), { name: c, array: A, itemSize: p } } function s(o, a) { switch (a) { case Float32Array: return o.DT_FLOAT32; case Int8Array: return o.DT_INT8; case Int16Array: return o.DT_INT16; case Int32Array: return o.DT_INT32; case Uint8Array: return o.DT_UINT8; case Uint16Array: return o.DT_UINT16; case Uint32Array: return o.DT_UINT32 } } } let I0; const gM = () => { if (I0) return I0; const i = "B9h9z9tFBBBF8fL9gBB9gLaaaaaFa9gEaaaB9gFaFa9gEaaaFaEMcBFFFGGGEIIILF9wFFFLEFBFKNFaFCx/IFMO/LFVK9tv9t9vq95GBt9f9f939h9z9t9f9j9h9s9s9f9jW9vq9zBBp9tv9z9o9v9wW9f9kv9j9v9kv9WvqWv94h919m9mvqBF8Z9tv9z9o9v9wW9f9kv9j9v9kv9J9u9kv94h919m9mvqBGy9tv9z9o9v9wW9f9kv9j9v9kv9J9u9kv949TvZ91v9u9jvBEn9tv9z9o9v9wW9f9kv9j9v9kv69p9sWvq9P9jWBIi9tv9z9o9v9wW9f9kv9j9v9kv69p9sWvq9R919hWBLn9tv9z9o9v9wW9f9kv9j9v9kv69p9sWvq9F949wBKI9z9iqlBOc+x8ycGBM/qQFTa8jUUUUBCU/EBlHL8kUUUUBC9+RKGXAGCFJAI9LQBCaRKAE2BBC+gF9HQBALAEAIJHOAGlAGTkUUUBRNCUoBAG9uC/wgBZHKCUGAKCUG9JyRVAECFJRICBRcGXEXAcAF9PQFAVAFAclAcAVJAF9JyRMGXGXAG9FQBAMCbJHKC9wZRSAKCIrCEJCGrRQANCUGJRfCBRbAIRTEXGXAOATlAQ9PQBCBRISEMATAQJRIGXAS9FQBCBRtCBREEXGXAOAIlCi9PQBCBRISLMANCU/CBJAEJRKGXGXGXGXGXATAECKrJ2BBAtCKZrCEZfIBFGEBMAKhB83EBAKCNJhB83EBSEMAKAI2BIAI2BBHmCKrHYAYCE6HYy86BBAKCFJAICIJAYJHY2BBAmCIrCEZHPAPCE6HPy86BBAKCGJAYAPJHY2BBAmCGrCEZHPAPCE6HPy86BBAKCEJAYAPJHY2BBAmCEZHmAmCE6Hmy86BBAKCIJAYAmJHY2BBAI2BFHmCKrHPAPCE6HPy86BBAKCLJAYAPJHY2BBAmCIrCEZHPAPCE6HPy86BBAKCKJAYAPJHY2BBAmCGrCEZHPAPCE6HPy86BBAKCOJAYAPJHY2BBAmCEZHmAmCE6Hmy86BBAKCNJAYAmJHY2BBAI2BGHmCKrHPAPCE6HPy86BBAKCVJAYAPJHY2BBAmCIrCEZHPAPCE6HPy86BBAKCcJAYAPJHY2BBAmCGrCEZHPAPCE6HPy86BBAKCMJAYAPJHY2BBAmCEZHmAmCE6Hmy86BBAKCSJAYAmJHm2BBAI2BEHICKrHYAYCE6HYy86BBAKCQJAmAYJHm2BBAICIrCEZHYAYCE6HYy86BBAKCfJAmAYJHm2BBAICGrCEZHYAYCE6HYy86BBAKCbJAmAYJHK2BBAICEZHIAICE6HIy86BBAKAIJRISGMAKAI2BNAI2BBHmCIrHYAYCb6HYy86BBAKCFJAICNJAYJHY2BBAmCbZHmAmCb6Hmy86BBAKCGJAYAmJHm2BBAI2BFHYCIrHPAPCb6HPy86BBAKCEJAmAPJHm2BBAYCbZHYAYCb6HYy86BBAKCIJAmAYJHm2BBAI2BGHYCIrHPAPCb6HPy86BBAKCLJAmAPJHm2BBAYCbZHYAYCb6HYy86BBAKCKJAmAYJHm2BBAI2BEHYCIrHPAPCb6HPy86BBAKCOJAmAPJHm2BBAYCbZHYAYCb6HYy86BBAKCNJAmAYJHm2BBAI2BIHYCIrHPAPCb6HPy86BBAKCVJAmAPJHm2BBAYCbZHYAYCb6HYy86BBAKCcJAmAYJHm2BBAI2BLHYCIrHPAPCb6HPy86BBAKCMJAmAPJHm2BBAYCbZHYAYCb6HYy86BBAKCSJAmAYJHm2BBAI2BKHYCIrHPAPCb6HPy86BBAKCQJAmAPJHm2BBAYCbZHYAYCb6HYy86BBAKCfJAmAYJHm2BBAI2BOHICIrHYAYCb6HYy86BBAKCbJAmAYJHK2BBAICbZHIAICb6HIy86BBAKAIJRISFMAKAI8pBB83BBAKCNJAICNJ8pBB83BBAICTJRIMAtCGJRtAECTJHEAS9JQBMMGXAIQBCBRISEMGXAM9FQBANAbJ2BBRtCBRKAfREEXAEANCU/CBJAKJ2BBHTCFrCBATCFZl9zAtJHt86BBAEAGJREAKCFJHKAM9HQBMMAfCFJRfAIRTAbCFJHbAG9HQBMMABAcAG9sJANCUGJAMAG9sTkUUUBpANANCUGJAMCaJAG9sJAGTkUUUBpMAMCBAIyAcJRcAIQBMC9+RKSFMCBC99AOAIlAGCAAGCA9Ly6yRKMALCU/EBJ8kUUUUBAKM+OmFTa8jUUUUBCoFlHL8kUUUUBC9+RKGXAFCE9uHOCtJAI9LQBCaRKAE2BBHNC/wFZC/gF9HQBANCbZHVCF9LQBALCoBJCgFCUFT+JUUUBpALC84Jha83EBALC8wJha83EBALC8oJha83EBALCAJha83EBALCiJha83EBALCTJha83EBALha83ENALha83EBAEAIJC9wJRcAECFJHNAOJRMGXAF9FQBCQCbAVCF6yRSABRECBRVCBRQCBRfCBRICBRKEXGXAMAcuQBC9+RKSEMGXGXAN2BBHOC/vF9LQBALCoBJAOCIrCa9zAKJCbZCEWJHb8oGIRTAb8oGBRtGXAOCbZHbAS9PQBALAOCa9zAIJCbZCGWJ8oGBAVAbyROAb9FRbGXGXAGCG9HQBABAt87FBABCIJAO87FBABCGJAT87FBSFMAEAtjGBAECNJAOjGBAECIJATjGBMAVAbJRVALCoBJAKCEWJHmAOjGBAmATjGIALAICGWJAOjGBALCoBJAKCFJCbZHKCEWJHTAtjGBATAOjGIAIAbJRIAKCFJRKSGMGXGXAbCb6QBAQAbJAbC989zJCFJRQSFMAM1BBHbCgFZROGXGXAbCa9MQBAMCFJRMSFMAM1BFHbCgBZCOWAOCgBZqROGXAbCa9MQBAMCGJRMSFMAM1BGHbCgBZCfWAOqROGXAbCa9MQBAMCEJRMSFMAM1BEHbCgBZCdWAOqROGXAbCa9MQBAMCIJRMSFMAM2BIC8cWAOqROAMCLJRMMAOCFrCBAOCFZl9zAQJRQMGXGXAGCG9HQBABAt87FBABCIJAQ87FBABCGJAT87FBSFMAEAtjGBAECNJAQjGBAECIJATjGBMALCoBJAKCEWJHOAQjGBAOATjGIALAICGWJAQjGBALCoBJAKCFJCbZHKCEWJHOAtjGBAOAQjGIAICFJRIAKCFJRKSFMGXAOCDF9LQBALAIAcAOCbZJ2BBHbCIrHTlCbZCGWJ8oGBAVCFJHtATyROALAIAblCbZCGWJ8oGBAtAT9FHmJHtAbCbZHTyRbAT9FRTGXGXAGCG9HQBABAV87FBABCIJAb87FBABCGJAO87FBSFMAEAVjGBAECNJAbjGBAECIJAOjGBMALAICGWJAVjGBALCoBJAKCEWJHYAOjGBAYAVjGIALAICFJHICbZCGWJAOjGBALCoBJAKCFJCbZCEWJHYAbjGBAYAOjGIALAIAmJCbZHICGWJAbjGBALCoBJAKCGJCbZHKCEWJHOAVjGBAOAbjGIAKCFJRKAIATJRIAtATJRVSFMAVCBAM2BBHYyHTAOC/+F6HPJROAYCbZRtGXGXAYCIrHmQBAOCFJRbSFMAORbALAIAmlCbZCGWJ8oGBROMGXGXAtQBAbCFJRVSFMAbRVALAIAYlCbZCGWJ8oGBRbMGXGXAP9FQBAMCFJRYSFMAM1BFHYCgFZRTGXGXAYCa9MQBAMCGJRYSFMAM1BGHYCgBZCOWATCgBZqRTGXAYCa9MQBAMCEJRYSFMAM1BEHYCgBZCfWATqRTGXAYCa9MQBAMCIJRYSFMAM1BIHYCgBZCdWATqRTGXAYCa9MQBAMCLJRYSFMAMCKJRYAM2BLC8cWATqRTMATCFrCBATCFZl9zAQJHQRTMGXGXAmCb6QBAYRPSFMAY1BBHMCgFZROGXGXAMCa9MQBAYCFJRPSFMAY1BFHMCgBZCOWAOCgBZqROGXAMCa9MQBAYCGJRPSFMAY1BGHMCgBZCfWAOqROGXAMCa9MQBAYCEJRPSFMAY1BEHMCgBZCdWAOqROGXAMCa9MQBAYCIJRPSFMAYCLJRPAY2BIC8cWAOqROMAOCFrCBAOCFZl9zAQJHQROMGXGXAtCb6QBAPRMSFMAP1BBHMCgFZRbGXGXAMCa9MQBAPCFJRMSFMAP1BFHMCgBZCOWAbCgBZqRbGXAMCa9MQBAPCGJRMSFMAP1BGHMCgBZCfWAbqRbGXAMCa9MQBAPCEJRMSFMAP1BEHMCgBZCdWAbqRbGXAMCa9MQBAPCIJRMSFMAPCLJRMAP2BIC8cWAbqRbMAbCFrCBAbCFZl9zAQJHQRbMGXGXAGCG9HQBABAT87FBABCIJAb87FBABCGJAO87FBSFMAEATjGBAECNJAbjGBAECIJAOjGBMALCoBJAKCEWJHYAOjGBAYATjGIALAICGWJATjGBALCoBJAKCFJCbZCEWJHYAbjGBAYAOjGIALAICFJHICbZCGWJAOjGBALCoBJAKCGJCbZCEWJHOATjGBAOAbjGIALAIAm9FAmCb6qJHICbZCGWJAbjGBAIAt9FAtCb6qJRIAKCEJRKMANCFJRNABCKJRBAECSJREAKCbZRKAICbZRIAfCEJHfAF9JQBMMCBC99AMAc6yRKMALCoFJ8kUUUUBAKM/tIFGa8jUUUUBCTlRLC9+RKGXAFCLJAI9LQBCaRKAE2BBC/+FZC/QF9HQBALhB83ENAECFJRKAEAIJC98JREGXAF9FQBGXAGCG6QBEXGXAKAE9JQBC9+bMAK1BBHGCgFZRIGXGXAGCa9MQBAKCFJRKSFMAK1BFHGCgBZCOWAICgBZqRIGXAGCa9MQBAKCGJRKSFMAK1BGHGCgBZCfWAIqRIGXAGCa9MQBAKCEJRKSFMAK1BEHGCgBZCdWAIqRIGXAGCa9MQBAKCIJRKSFMAK2BIC8cWAIqRIAKCLJRKMALCNJAICFZCGWqHGAICGrCBAICFrCFZl9zAG8oGBJHIjGBABAIjGBABCIJRBAFCaJHFQBSGMMEXGXAKAE9JQBC9+bMAK1BBHGCgFZRIGXGXAGCa9MQBAKCFJRKSFMAK1BFHGCgBZCOWAICgBZqRIGXAGCa9MQBAKCGJRKSFMAK1BGHGCgBZCfWAIqRIGXAGCa9MQBAKCEJRKSFMAK1BEHGCgBZCdWAIqRIGXAGCa9MQBAKCIJRKSFMAK2BIC8cWAIqRIAKCLJRKMABAICGrCBAICFrCFZl9zALCNJAICFZCGWqHI8oGBJHG87FBAIAGjGBABCGJRBAFCaJHFQBMMCBC99AKAE6yRKMAKM+lLKFaF99GaG99FaG99GXGXAGCI9HQBAF9FQFEXGXGX9DBBB8/9DBBB+/ABCGJHG1BB+yAB1BBHE+yHI+L+TABCFJHL1BBHK+yHO+L+THN9DBBBB9gHVyAN9DBB/+hANAN+U9DBBBBANAVyHcAc+MHMAECa3yAI+SHIAI+UAcAMAKCa3yAO+SHcAc+U+S+S+R+VHO+U+SHN+L9DBBB9P9d9FQBAN+oRESFMCUUUU94REMAGAE86BBGXGX9DBBB8/9DBBB+/Ac9DBBBB9gyAcAO+U+SHN+L9DBBB9P9d9FQBAN+oRGSFMCUUUU94RGMALAG86BBGXGX9DBBB8/9DBBB+/AI9DBBBB9gyAIAO+U+SHN+L9DBBB9P9d9FQBAN+oRGSFMCUUUU94RGMABAG86BBABCIJRBAFCaJHFQBSGMMAF9FQBEXGXGX9DBBB8/9DBBB+/ABCIJHG8uFB+yAB8uFBHE+yHI+L+TABCGJHL8uFBHK+yHO+L+THN9DBBBB9gHVyAN9DB/+g6ANAN+U9DBBBBANAVyHcAc+MHMAECa3yAI+SHIAI+UAcAMAKCa3yAO+SHcAc+U+S+S+R+VHO+U+SHN+L9DBBB9P9d9FQBAN+oRESFMCUUUU94REMAGAE87FBGXGX9DBBB8/9DBBB+/Ac9DBBBB9gyAcAO+U+SHN+L9DBBB9P9d9FQBAN+oRGSFMCUUUU94RGMALAG87FBGXGX9DBBB8/9DBBB+/AI9DBBBB9gyAIAO+U+SHN+L9DBBB9P9d9FQBAN+oRGSFMCUUUU94RGMABAG87FBABCNJRBAFCaJHFQBMMM/SEIEaE99EaF99GXAF9FQBCBREABRIEXGXGX9D/zI818/AICKJ8uFBHLCEq+y+VHKAI8uFB+y+UHO9DB/+g6+U9DBBB8/9DBBB+/AO9DBBBB9gy+SHN+L9DBBB9P9d9FQBAN+oRVSFMCUUUU94RVMAICIJ8uFBRcAICGJ8uFBRMABALCFJCEZAEqCFWJAV87FBGXGXAKAM+y+UHN9DB/+g6+U9DBBB8/9DBBB+/AN9DBBBB9gy+SHS+L9DBBB9P9d9FQBAS+oRMSFMCUUUU94RMMABALCGJCEZAEqCFWJAM87FBGXGXAKAc+y+UHK9DB/+g6+U9DBBB8/9DBBB+/AK9DBBBB9gy+SHS+L9DBBB9P9d9FQBAS+oRcSFMCUUUU94RcMABALCaJCEZAEqCFWJAc87FBGXGX9DBBU8/AOAO+U+TANAN+U+TAKAK+U+THO9DBBBBAO9DBBBB9gy+R9DB/+g6+U9DBBB8/+SHO+L9DBBB9P9d9FQBAO+oRcSFMCUUUU94RcMABALCEZAEqCFWJAc87FBAICNJRIAECIJREAFCaJHFQBMMM9JBGXAGCGrAF9sHF9FQBEXABAB8oGBHGCNWCN91+yAGCi91CnWCUUU/8EJ+++U84GBABCIJRBAFCaJHFQBMMM9TFEaCBCB8oGUkUUBHFABCEJC98ZJHBjGUkUUBGXGXAB8/BCTWHGuQBCaREABAGlCggEJCTrXBCa6QFMAFREMAEM/lFFFaGXGXAFABqCEZ9FQBABRESFMGXGXAGCT9PQBABRESFMABREEXAEAF8oGBjGBAECIJAFCIJ8oGBjGBAECNJAFCNJ8oGBjGBAECSJAFCSJ8oGBjGBAECTJREAFCTJRFAGC9wJHGCb9LQBMMAGCI9JQBEXAEAF8oGBjGBAFCIJRFAECIJREAGC98JHGCE9LQBMMGXAG9FQBEXAEAF2BB86BBAECFJREAFCFJRFAGCaJHGQBMMABMoFFGaGXGXABCEZ9FQBABRESFMAFCgFZC+BwsN9sRIGXGXAGCT9PQBABRESFMABREEXAEAIjGBAECSJAIjGBAECNJAIjGBAECIJAIjGBAECTJREAGC9wJHGCb9LQBMMAGCI9JQBEXAEAIjGBAECIJREAGC98JHGCE9LQBMMGXAG9FQBEXAEAF86BBAECFJREAGCaJHGQBMMABMMMFBCUNMIT9kBB", e = "B9h9z9tFBBBFiI9gBB9gLaaaaaFa9gEaaaB9gFaFaEMcBBFBFFGGGEILF9wFFFLEFBFKNFaFCx/aFMO/LFVK9tv9t9vq95GBt9f9f939h9z9t9f9j9h9s9s9f9jW9vq9zBBp9tv9z9o9v9wW9f9kv9j9v9kv9WvqWv94h919m9mvqBG8Z9tv9z9o9v9wW9f9kv9j9v9kv9J9u9kv94h919m9mvqBIy9tv9z9o9v9wW9f9kv9j9v9kv9J9u9kv949TvZ91v9u9jvBLn9tv9z9o9v9wW9f9kv9j9v9kv69p9sWvq9P9jWBKi9tv9z9o9v9wW9f9kv9j9v9kv69p9sWvq9R919hWBOn9tv9z9o9v9wW9f9kv9j9v9kv69p9sWvq9F949wBNI9z9iqlBVc+N9IcIBTEM9+FLa8jUUUUBCTlRBCBRFEXCBRGCBREEXABCNJAGJAECUaAFAGrCFZHIy86BBAEAIJREAGCFJHGCN9HQBMAFCx+YUUBJAE86BBAFCEWCxkUUBJAB8pEN83EBAFCFJHFCUG9HQBMMk8lLbaE97F9+FaL978jUUUUBCU/KBlHL8kUUUUBC9+RKGXAGCFJAI9LQBCaRKAE2BBC+gF9HQBALAEAIJHOAGlAG/8cBBCUoBAG9uC/wgBZHKCUGAKCUG9JyRNAECFJRKCBRVGXEXAVAF9PQFANAFAVlAVANJAF9JyRcGXGXAG9FQBAcCbJHIC9wZHMCE9sRSAMCFWRQAICIrCEJCGrRfCBRbEXAKRTCBRtGXEXGXAOATlAf9PQBCBRKSLMALCU/CBJAtAM9sJRmATAfJRKCBREGXAMCoB9JQBAOAKlC/gB9JQBCBRIEXAmAIJREGXGXGXGXGXATAICKrJ2BBHYCEZfIBFGEBMAECBDtDMIBSEMAEAKDBBIAKDBBBHPCID+MFAPDQBTFtGmEYIPLdKeOnHPCGD+MFAPDQBTFtGmEYIPLdKeOnC0+G+MiDtD9OHdCEDbD8jHPAPDQBFGENVcMILKOSQfbHeD8dBh+BsxoxoUwN0AeD8dFhxoUwkwk+gUa0sHnhTkAnsHnhNkAnsHn7CgFZHiCEWCxkUUBJDBEBAiCx+YUUBJDBBBHeAeDQBBBBBBBBBBBBBBBBAnhAk7CgFZHiCEWCxkUUBJDBEBD9uDQBFGEILKOTtmYPdenDfAdAPD9SDMIBAKCIJAeDeBJAiCx+YUUBJ2BBJRKSGMAEAKDBBNAKDBBBHPCID+MFAPDQBTFtGmEYIPLdKeOnC+P+e+8/4BDtD9OHdCbDbD8jHPAPDQBFGENVcMILKOSQfbHeD8dBh+BsxoxoUwN0AeD8dFhxoUwkwk+gUa0sHnhTkAnsHnhNkAnsHn7CgFZHiCEWCxkUUBJDBEBAiCx+YUUBJDBBBHeAeDQBBBBBBBBBBBBBBBBAnhAk7CgFZHiCEWCxkUUBJDBEBD9uDQBFGEILKOTtmYPdenDfAdAPD9SDMIBAKCNJAeDeBJAiCx+YUUBJ2BBJRKSFMAEAKDBBBDMIBAKCTJRKMGXGXGXGXGXAYCGrCEZfIBFGEBMAECBDtDMITSEMAEAKDBBIAKDBBBHPCID+MFAPDQBTFtGmEYIPLdKeOnHPCGD+MFAPDQBTFtGmEYIPLdKeOnC0+G+MiDtD9OHdCEDbD8jHPAPDQBFGENVcMILKOSQfbHeD8dBh+BsxoxoUwN0AeD8dFhxoUwkwk+gUa0sHnhTkAnsHnhNkAnsHn7CgFZHiCEWCxkUUBJDBEBAiCx+YUUBJDBBBHeAeDQBBBBBBBBBBBBBBBBAnhAk7CgFZHiCEWCxkUUBJDBEBD9uDQBFGEILKOTtmYPdenDfAdAPD9SDMITAKCIJAeDeBJAiCx+YUUBJ2BBJRKSGMAEAKDBBNAKDBBBHPCID+MFAPDQBTFtGmEYIPLdKeOnC+P+e+8/4BDtD9OHdCbDbD8jHPAPDQBFGENVcMILKOSQfbHeD8dBh+BsxoxoUwN0AeD8dFhxoUwkwk+gUa0sHnhTkAnsHnhNkAnsHn7CgFZHiCEWCxkUUBJDBEBAiCx+YUUBJDBBBHeAeDQBBBBBBBBBBBBBBBBAnhAk7CgFZHiCEWCxkUUBJDBEBD9uDQBFGEILKOTtmYPdenDfAdAPD9SDMITAKCNJAeDeBJAiCx+YUUBJ2BBJRKSFMAEAKDBBBDMITAKCTJRKMGXGXGXGXGXAYCIrCEZfIBFGEBMAECBDtDMIASEMAEAKDBBIAKDBBBHPCID+MFAPDQBTFtGmEYIPLdKeOnHPCGD+MFAPDQBTFtGmEYIPLdKeOnC0+G+MiDtD9OHdCEDbD8jHPAPDQBFGENVcMILKOSQfbHeD8dBh+BsxoxoUwN0AeD8dFhxoUwkwk+gUa0sHnhTkAnsHnhNkAnsHn7CgFZHiCEWCxkUUBJDBEBAiCx+YUUBJDBBBHeAeDQBBBBBBBBBBBBBBBBAnhAk7CgFZHiCEWCxkUUBJDBEBD9uDQBFGEILKOTtmYPdenDfAdAPD9SDMIAAKCIJAeDeBJAiCx+YUUBJ2BBJRKSGMAEAKDBBNAKDBBBHPCID+MFAPDQBTFtGmEYIPLdKeOnC+P+e+8/4BDtD9OHdCbDbD8jHPAPDQBFGENVcMILKOSQfbHeD8dBh+BsxoxoUwN0AeD8dFhxoUwkwk+gUa0sHnhTkAnsHnhNkAnsHn7CgFZHiCEWCxkUUBJDBEBAiCx+YUUBJDBBBHeAeDQBBBBBBBBBBBBBBBBAnhAk7CgFZHiCEWCxkUUBJDBEBD9uDQBFGEILKOTtmYPdenDfAdAPD9SDMIAAKCNJAeDeBJAiCx+YUUBJ2BBJRKSFMAEAKDBBBDMIAAKCTJRKMGXGXGXGXGXAYCKrfIBFGEBMAECBDtDMI8wSEMAEAKDBBIAKDBBBHPCID+MFAPDQBTFtGmEYIPLdKeOnHPCGD+MFAPDQBTFtGmEYIPLdKeOnC0+G+MiDtD9OHdCEDbD8jHPAPDQBFGENVcMILKOSQfbHeD8dBh+BsxoxoUwN0AeD8dFhxoUwkwk+gUa0sHnhTkAnsHnhNkAnsHn7CgFZHYCEWCxkUUBJDBEBAYCx+YUUBJDBBBHeAeDQBBBBBBBBBBBBBBBBAnhAk7CgFZHYCEWCxkUUBJDBEBD9uDQBFGEILKOTtmYPdenDfAdAPD9SDMI8wAKCIJAeDeBJAYCx+YUUBJ2BBJRKSGMAEAKDBBNAKDBBBHPCID+MFAPDQBTFtGmEYIPLdKeOnC+P+e+8/4BDtD9OHdCbDbD8jHPAPDQBFGENVcMILKOSQfbHeD8dBh+BsxoxoUwN0AeD8dFhxoUwkwk+gUa0sHnhTkAnsHnhNkAnsHn7CgFZHYCEWCxkUUBJDBEBAYCx+YUUBJDBBBHeAeDQBBBBBBBBBBBBBBBBAnhAk7CgFZHYCEWCxkUUBJDBEBD9uDQBFGEILKOTtmYPdenDfAdAPD9SDMI8wAKCNJAeDeBJAYCx+YUUBJ2BBJRKSFMAEAKDBBBDMI8wAKCTJRKMAICoBJREAICUFJAM9LQFAERIAOAKlC/fB9LQBMMGXAEAM9PQBAECErRIEXGXAOAKlCi9PQBCBRKSOMAmAEJRYGXGXGXGXGXATAECKrJ2BBAICKZrCEZfIBFGEBMAYCBDtDMIBSEMAYAKDBBIAKDBBBHPCID+MFAPDQBTFtGmEYIPLdKeOnHPCGD+MFAPDQBTFtGmEYIPLdKeOnC0+G+MiDtD9OHdCEDbD8jHPAPDQBFGENVcMILKOSQfbHeD8dBh+BsxoxoUwN0AeD8dFhxoUwkwk+gUa0sHnhTkAnsHnhNkAnsHn7CgFZHiCEWCxkUUBJDBEBAiCx+YUUBJDBBBHeAeDQBBBBBBBBBBBBBBBBAnhAk7CgFZHiCEWCxkUUBJDBEBD9uDQBFGEILKOTtmYPdenDfAdAPD9SDMIBAKCIJAeDeBJAiCx+YUUBJ2BBJRKSGMAYAKDBBNAKDBBBHPCID+MFAPDQBTFtGmEYIPLdKeOnC+P+e+8/4BDtD9OHdCbDbD8jHPAPDQBFGENVcMILKOSQfbHeD8dBh+BsxoxoUwN0AeD8dFhxoUwkwk+gUa0sHnhTkAnsHnhNkAnsHn7CgFZHiCEWCxkUUBJDBEBAiCx+YUUBJDBBBHeAeDQBBBBBBBBBBBBBBBBAnhAk7CgFZHiCEWCxkUUBJDBEBD9uDQBFGEILKOTtmYPdenDfAdAPD9SDMIBAKCNJAeDeBJAiCx+YUUBJ2BBJRKSFMAYAKDBBBDMIBAKCTJRKMAICGJRIAECTJHEAM9JQBMMGXAK9FQBAKRTAtCFJHtCI6QGSFMMCBRKSEMGXAM9FQBALCUGJAbJREALAbJDBGBReCBRYEXAEALCU/CBJAYJHIDBIBHdCFD9tAdCFDbHPD9OD9hD9RHdAIAMJDBIBH8ZCFD9tA8ZAPD9OD9hD9RH8ZDQBTFtGmEYIPLdKeOnHpAIAQJDBIBHyCFD9tAyAPD9OD9hD9RHyAIASJDBIBH8cCFD9tA8cAPD9OD9hD9RH8cDQBTFtGmEYIPLdKeOnH8dDQBFTtGEmYILPdKOenHPAPDQBFGEBFGEBFGEBFGEAeD9uHeDyBjGBAEAGJHIAeAPAPDQILKOILKOILKOILKOD9uHeDyBjGBAIAGJHIAeAPAPDQNVcMNVcMNVcMNVcMD9uHeDyBjGBAIAGJHIAeAPAPDQSQfbSQfbSQfbSQfbD9uHeDyBjGBAIAGJHIAeApA8dDQNVi8ZcMpySQ8c8dfb8e8fHPAPDQBFGEBFGEBFGEBFGED9uHeDyBjGBAIAGJHIAeAPAPDQILKOILKOILKOILKOD9uHeDyBjGBAIAGJHIAeAPAPDQNVcMNVcMNVcMNVcMD9uHeDyBjGBAIAGJHIAeAPAPDQSQfbSQfbSQfbSQfbD9uHeDyBjGBAIAGJHIAeAdA8ZDQNiV8ZcpMyS8cQ8df8eb8fHdAyA8cDQNiV8ZcpMyS8cQ8df8eb8fH8ZDQBFTtGEmYILPdKOenHPAPDQBFGEBFGEBFGEBFGED9uHeDyBjGBAIAGJHIAeAPAPDQILKOILKOILKOILKOD9uHeDyBjGBAIAGJHIAeAPAPDQNVcMNVcMNVcMNVcMD9uHeDyBjGBAIAGJHIAeAPAPDQSQfbSQfbSQfbSQfbD9uHeDyBjGBAIAGJHIAeAdA8ZDQNVi8ZcMpySQ8c8dfb8e8fHPAPDQBFGEBFGEBFGEBFGED9uHeDyBjGBAIAGJHIAeAPAPDQILKOILKOILKOILKOD9uHeDyBjGBAIAGJHIAeAPAPDQNVcMNVcMNVcMNVcMD9uHeDyBjGBAIAGJHIAeAPAPDQSQfbSQfbSQfbSQfbD9uHeDyBjGBAIAGJREAYCTJHYAM9JQBMMAbCIJHbAG9JQBMMABAVAG9sJALCUGJAcAG9s/8cBBALALCUGJAcCaJAG9sJAG/8cBBMAcCBAKyAVJRVAKQBMC9+RKSFMCBC99AOAKlAGCAAGCA9Ly6yRKMALCU/KBJ8kUUUUBAKMNBT+BUUUBM+KmFTa8jUUUUBCoFlHL8kUUUUBC9+RKGXAFCE9uHOCtJAI9LQBCaRKAE2BBHNC/wFZC/gF9HQBANCbZHVCF9LQBALCoBJCgFCUF/8MBALC84Jha83EBALC8wJha83EBALC8oJha83EBALCAJha83EBALCiJha83EBALCTJha83EBALha83ENALha83EBAEAIJC9wJRcAECFJHNAOJRMGXAF9FQBCQCbAVCF6yRSABRECBRVCBRQCBRfCBRICBRKEXGXAMAcuQBC9+RKSEMGXGXAN2BBHOC/vF9LQBALCoBJAOCIrCa9zAKJCbZCEWJHb8oGIRTAb8oGBRtGXAOCbZHbAS9PQBALAOCa9zAIJCbZCGWJ8oGBAVAbyROAb9FRbGXGXAGCG9HQBABAt87FBABCIJAO87FBABCGJAT87FBSFMAEAtjGBAECNJAOjGBAECIJATjGBMAVAbJRVALCoBJAKCEWJHmAOjGBAmATjGIALAICGWJAOjGBALCoBJAKCFJCbZHKCEWJHTAtjGBATAOjGIAIAbJRIAKCFJRKSGMGXGXAbCb6QBAQAbJAbC989zJCFJRQSFMAM1BBHbCgFZROGXGXAbCa9MQBAMCFJRMSFMAM1BFHbCgBZCOWAOCgBZqROGXAbCa9MQBAMCGJRMSFMAM1BGHbCgBZCfWAOqROGXAbCa9MQBAMCEJRMSFMAM1BEHbCgBZCdWAOqROGXAbCa9MQBAMCIJRMSFMAM2BIC8cWAOqROAMCLJRMMAOCFrCBAOCFZl9zAQJRQMGXGXAGCG9HQBABAt87FBABCIJAQ87FBABCGJAT87FBSFMAEAtjGBAECNJAQjGBAECIJATjGBMALCoBJAKCEWJHOAQjGBAOATjGIALAICGWJAQjGBALCoBJAKCFJCbZHKCEWJHOAtjGBAOAQjGIAICFJRIAKCFJRKSFMGXAOCDF9LQBALAIAcAOCbZJ2BBHbCIrHTlCbZCGWJ8oGBAVCFJHtATyROALAIAblCbZCGWJ8oGBAtAT9FHmJHtAbCbZHTyRbAT9FRTGXGXAGCG9HQBABAV87FBABCIJAb87FBABCGJAO87FBSFMAEAVjGBAECNJAbjGBAECIJAOjGBMALAICGWJAVjGBALCoBJAKCEWJHYAOjGBAYAVjGIALAICFJHICbZCGWJAOjGBALCoBJAKCFJCbZCEWJHYAbjGBAYAOjGIALAIAmJCbZHICGWJAbjGBALCoBJAKCGJCbZHKCEWJHOAVjGBAOAbjGIAKCFJRKAIATJRIAtATJRVSFMAVCBAM2BBHYyHTAOC/+F6HPJROAYCbZRtGXGXAYCIrHmQBAOCFJRbSFMAORbALAIAmlCbZCGWJ8oGBROMGXGXAtQBAbCFJRVSFMAbRVALAIAYlCbZCGWJ8oGBRbMGXGXAP9FQBAMCFJRYSFMAM1BFHYCgFZRTGXGXAYCa9MQBAMCGJRYSFMAM1BGHYCgBZCOWATCgBZqRTGXAYCa9MQBAMCEJRYSFMAM1BEHYCgBZCfWATqRTGXAYCa9MQBAMCIJRYSFMAM1BIHYCgBZCdWATqRTGXAYCa9MQBAMCLJRYSFMAMCKJRYAM2BLC8cWATqRTMATCFrCBATCFZl9zAQJHQRTMGXGXAmCb6QBAYRPSFMAY1BBHMCgFZROGXGXAMCa9MQBAYCFJRPSFMAY1BFHMCgBZCOWAOCgBZqROGXAMCa9MQBAYCGJRPSFMAY1BGHMCgBZCfWAOqROGXAMCa9MQBAYCEJRPSFMAY1BEHMCgBZCdWAOqROGXAMCa9MQBAYCIJRPSFMAYCLJRPAY2BIC8cWAOqROMAOCFrCBAOCFZl9zAQJHQROMGXGXAtCb6QBAPRMSFMAP1BBHMCgFZRbGXGXAMCa9MQBAPCFJRMSFMAP1BFHMCgBZCOWAbCgBZqRbGXAMCa9MQBAPCGJRMSFMAP1BGHMCgBZCfWAbqRbGXAMCa9MQBAPCEJRMSFMAP1BEHMCgBZCdWAbqRbGXAMCa9MQBAPCIJRMSFMAPCLJRMAP2BIC8cWAbqRbMAbCFrCBAbCFZl9zAQJHQRbMGXGXAGCG9HQBABAT87FBABCIJAb87FBABCGJAO87FBSFMAEATjGBAECNJAbjGBAECIJAOjGBMALCoBJAKCEWJHYAOjGBAYATjGIALAICGWJATjGBALCoBJAKCFJCbZCEWJHYAbjGBAYAOjGIALAICFJHICbZCGWJAOjGBALCoBJAKCGJCbZCEWJHOATjGBAOAbjGIALAIAm9FAmCb6qJHICbZCGWJAbjGBAIAt9FAtCb6qJRIAKCEJRKMANCFJRNABCKJRBAECSJREAKCbZRKAICbZRIAfCEJHfAF9JQBMMCBC99AMAc6yRKMALCoFJ8kUUUUBAKM/tIFGa8jUUUUBCTlRLC9+RKGXAFCLJAI9LQBCaRKAE2BBC/+FZC/QF9HQBALhB83ENAECFJRKAEAIJC98JREGXAF9FQBGXAGCG6QBEXGXAKAE9JQBC9+bMAK1BBHGCgFZRIGXGXAGCa9MQBAKCFJRKSFMAK1BFHGCgBZCOWAICgBZqRIGXAGCa9MQBAKCGJRKSFMAK1BGHGCgBZCfWAIqRIGXAGCa9MQBAKCEJRKSFMAK1BEHGCgBZCdWAIqRIGXAGCa9MQBAKCIJRKSFMAK2BIC8cWAIqRIAKCLJRKMALCNJAICFZCGWqHGAICGrCBAICFrCFZl9zAG8oGBJHIjGBABAIjGBABCIJRBAFCaJHFQBSGMMEXGXAKAE9JQBC9+bMAK1BBHGCgFZRIGXGXAGCa9MQBAKCFJRKSFMAK1BFHGCgBZCOWAICgBZqRIGXAGCa9MQBAKCGJRKSFMAK1BGHGCgBZCfWAIqRIGXAGCa9MQBAKCEJRKSFMAK1BEHGCgBZCdWAIqRIGXAGCa9MQBAKCIJRKSFMAK2BIC8cWAIqRIAKCLJRKMABAICGrCBAICFrCFZl9zALCNJAICFZCGWqHI8oGBJHG87FBAIAGjGBABCGJRBAFCaJHFQBMMCBC99AKAE6yRKMAKM/dLEK97FaF97GXGXAGCI9HQBAF9FQFCBRGEXABABDBBBHECiD+rFCiD+sFD/6FHIAECND+rFCiD+sFD/6FAID/gFAECTD+rFCiD+sFD/6FHLD/gFD/kFD/lFHKCBDtD+2FHOAICUUUU94DtHND9OD9RD/kFHI9DBB/+hDYAIAID/mFAKAKD/mFALAOALAND9OD9RD/kFHIAID/mFD/kFD/kFD/jFD/nFHLD/mF9DBBX9LDYHOD/kFCgFDtD9OAECUUU94DtD9OD9QAIALD/mFAOD/kFCND+rFCU/+EDtD9OD9QAKALD/mFAOD/kFCTD+rFCUU/8ODtD9OD9QDMBBABCTJRBAGCIJHGAF9JQBSGMMAF9FQBCBRGEXABCTJHVAVDBBBHECBDtHOCUU98D8cFCUU98D8cEHND9OABDBBBHKAEDQILKOSQfbPden8c8d8e8fCggFDtD9OD/6FAKAEDQBFGENVcMTtmYi8ZpyHECTD+sFD/6FHID/gFAECTD+rFCTD+sFD/6FHLD/gFD/kFD/lFHE9DB/+g6DYALAEAOD+2FHOALCUUUU94DtHcD9OD9RD/kFHLALD/mFAEAED/mFAIAOAIAcD9OD9RD/kFHEAED/mFD/kFD/kFD/jFD/nFHID/mF9DBBX9LDYHOD/kFCTD+rFALAID/mFAOD/kFCggEDtD9OD9QHLAEAID/mFAOD/kFCaDbCBDnGCBDnECBDnKCBDnOCBDncCBDnMCBDnfCBDnbD9OHEDQNVi8ZcMpySQ8c8dfb8e8fD9QDMBBABAKAND9OALAEDQBFTtGEmYILPdKOenD9QDMBBABCAJRBAGCIJHGAF9JQBMMM/hEIGaF97FaL978jUUUUBCTlREGXAF9FQBCBRIEXAEABDBBBHLABCTJHKDBBBHODQILKOSQfbPden8c8d8e8fHNCTD+sFHVCID+rFDMIBAB9DBBU8/DY9D/zI818/DYAVCEDtD9QD/6FD/nFHVALAODQBFGENVcMTtmYi8ZpyHLCTD+rFCTD+sFD/6FD/mFHOAOD/mFAVALCTD+sFD/6FD/mFHcAcD/mFAVANCTD+rFCTD+sFD/6FD/mFHNAND/mFD/kFD/kFD/lFCBDtD+4FD/jF9DB/+g6DYHVD/mF9DBBX9LDYHLD/kFCggEDtHMD9OAcAVD/mFALD/kFCTD+rFD9QHcANAVD/mFALD/kFCTD+rFAOAVD/mFALD/kFAMD9OD9QHVDQBFTtGEmYILPdKOenHLD8dBAEDBIBDyB+t+J83EBABCNJALD8dFAEDBIBDyF+t+J83EBAKAcAVDQNVi8ZcMpySQ8c8dfb8e8fHVD8dBAEDBIBDyG+t+J83EBABCiJAVD8dFAEDBIBDyE+t+J83EBABCAJRBAICIJHIAF9JQBMMM9jFF97GXAGCGrAF9sHG9FQBCBRFEXABABDBBBHECND+rFCND+sFD/6FAECiD+sFCnD+rFCUUU/8EDtD+uFD/mFDMBBABCTJRBAFCIJHFAG9JQBMMM9TFEaCBCB8oGUkUUBHFABCEJC98ZJHBjGUkUUBGXGXAB8/BCTWHGuQBCaREABAGlCggEJCTrXBCa6QFMAFREMAEMMMFBCUNMIT9tBB", t = new Uint8Array([0, 97, 115, 109, 1, 0, 0, 0, 1, 4, 1, 96, 0, 0, 3, 3, 2, 0, 0, 5, 3, 1, 0, 1, 12, 1, 0, 10, 22, 2, 12, 0, 65, 0, 65, 0, 65, 0, 252, 10, 0, 0, 11, 7, 0, 65, 0, 253, 15, 26, 11]), n = new Uint8Array([32, 0, 65, 253, 3, 1, 2, 34, 4, 106, 6, 5, 11, 8, 7, 20, 13, 33, 12, 16, 128, 9, 116, 64, 19, 113, 127, 15, 10, 21, 22, 14, 255, 66, 24, 54, 136, 107, 18, 23, 192, 26, 114, 118, 132, 17, 77, 101, 130, 144, 27, 87, 131, 44, 45, 74, 156, 154, 70, 167]); if (typeof WebAssembly != "object") return { supported: !1 }; let r = i; WebAssembly.validate(t) && (r = e); let s; const o = WebAssembly.instantiate(a(r), {}).then(d => { s = d.instance, s.exports.__wasm_call_ctors() }); function a(d) { const p = new Uint8Array(d.length); for (let y = 0; y < d.length; ++y) { const _ = d.charCodeAt(y); p[y] = _ > 96 ? _ - 71 : _ > 64 ? _ - 65 : _ > 47 ? _ + 4 : _ > 46 ? 63 : 62 } let m = 0; for (let y = 0; y < d.length; ++y)p[m++] = p[y] < 60 ? n[p[y]] : (p[y] - 60) * 64 + p[++y]; return p.buffer.slice(0, m) } function l(d, p, m, y, _, x) { const g = s.exports.sbrk, A = m + 3 & -4, M = g(A * y), S = g(_.length), C = new Uint8Array(s.exports.memory.buffer); C.set(_, S); const T = d(M, m, y, S, _.length); if (T === 0 && x && x(M, A, y), p.set(C.subarray(M, M + m * y)), g(M - g(0)), T !== 0) throw new Error(`Malformed buffer data: ${T}`) } const c = { 0: "", 1: "meshopt_decodeFilterOct", 2: "meshopt_decodeFilterQuat", 3: "meshopt_decodeFilterExp", NONE: "", OCTAHEDRAL: "meshopt_decodeFilterOct", QUATERNION: "meshopt_decodeFilterQuat", EXPONENTIAL: "meshopt_decodeFilterExp" }, f = { 0: "meshopt_decodeVertexBuffer", 1: "meshopt_decodeIndexBuffer", 2: "meshopt_decodeIndexSequence", ATTRIBUTES: "meshopt_decodeVertexBuffer", TRIANGLES: "meshopt_decodeIndexBuffer", INDICES: "meshopt_decodeIndexSequence" }; return I0 = { ready: o, supported: !0, decodeVertexBuffer(d, p, m, y, _) { l(s.exports.meshopt_decodeVertexBuffer, d, p, m, y, s.exports[c[_]]) }, decodeIndexBuffer(d, p, m, y) { l(s.exports.meshopt_decodeIndexBuffer, d, p, m, y) }, decodeIndexSequence(d, p, m, y) { l(s.exports.meshopt_decodeIndexSequence, d, p, m, y) }, decodeGltfBuffer(d, p, m, y, _, x) { l(s.exports[f[_]], d, p, m, y, s.exports[c[x]]) } }, I0 }; let B0 = null; function jk(i, e, t) { return n => { t && t(n), i && (B0 || (B0 = new jq), B0.setDecoderPath(typeof i == "string" ? i : "https://www.gstatic.com/draco/versioned/decoders/1.5.5/"), n.setDRACOLoader(B0)), e && n.setMeshoptDecoder(typeof gM == "function" ? gM() : gM) } } function u_(i, e = !0, t = !0, n) { return ym(nC, i, jk(e, t, n)) } u_.preload = (i, e = !0, t = !0, n) => ym.preload(nC, i, jk(e, t, n)); u_.clear = i => ym.clear(nC, i); const qq = ce.forwardRef(({ makeDefault: i, camera: e, regress: t, domElement: n, enableDamping: r = !0, keyEvents: s = !1, onChange: o, onStart: a, onEnd: l, ...c }, f) => { const d = Za(T => T.invalidate), p = Za(T => T.camera), m = Za(T => T.gl), y = Za(T => T.events), _ = Za(T => T.setEvents), x = Za(T => T.set), g = Za(T => T.get), A = Za(T => T.performance), M = e || p, S = n || y.connected || m.domElement, C = ce.useMemo(() => new mq(M), [M]); return WK(() => { C.enabled && C.update() }, -1), ce.useEffect(() => (s && C.connect(s === !0 ? S : s), C.connect(S), () => void C.dispose()), [s, S, t, C, d]), ce.useEffect(() => { const T = b => { d(), t && A.regress(), o && o(b) }, R = b => { a && a(b) }, B = b => { l && l(b) }; return C.addEventListener("change", T), C.addEventListener("start", R), C.addEventListener("end", B), () => { C.removeEventListener("start", R), C.removeEventListener("end", B), C.removeEventListener("change", T) } }, [o, a, l, C, d, _]), ce.useEffect(() => { if (i) { const T = g().controls; return x({ controls: C }), () => x({ controls: T }) } }, [i, C]), ce.createElement("primitive", Op({ ref: f, object: C, enableDamping: r }, c)) }); function Qq(i) { const { nodes: e, materials: t } = u_("computer-transformed.glb"); return Re.jsx("group", { ...i, dispose: null, children: Re.jsx("mesh", { geometry: e.defaultMaterial.geometry, material: t["01___Default"], scale: 2.5 }) }) } u_.preload("computer-transformed.glb"); const jp = { _origin: "https://api.emailjs.com" }, Zq = (i, e = "https://api.emailjs.com") => { jp._userID = i, jp._origin = e }, Kk = (i, e, t) => { if (!i) throw "The public key is required. Visit https://dashboard.emailjs.com/admin/account"; if (!e) throw "The service ID is required. Visit https://dashboard.emailjs.com/admin"; if (!t) throw "The template ID is required. Visit https://dashboard.emailjs.com/admin/templates"; return !0 }; class VI { constructor(e) { this.status = e ? e.status : 0, this.text = e ? e.responseText : "Network Error" } } const qk = (i, e, t = {}) => new Promise((n, r) => { const s = new XMLHttpRequest; s.addEventListener("load", ({ target: o }) => { const a = new VI(o); a.status === 200 || a.text === "OK" ? n(a) : r(a) }), s.addEventListener("error", ({ target: o }) => { r(new VI(o)) }), s.open("POST", jp._origin + i, !0), Object.keys(t).forEach(o => { s.setRequestHeader(o, t[o]) }), s.send(e) }), $q = (i, e, t, n) => { const r = n || jp._userID; return Kk(r, i, e), qk("/api/v1.0/email/send", JSON.stringify({ lib_version: "3.11.0", user_id: r, service_id: i, template_id: e, template_params: t }), { "Content-type": "application/json" }) }, eQ = i => { let e; if (typeof i == "string" ? e = document.querySelector(i) : e = i, !e || e.nodeName !== "FORM") throw "The 3rd parameter is expected to be the HTML form element or the style selector of form"; return e }, tQ = (i, e, t, n) => { const r = n || jp._userID, s = eQ(t); Kk(r, i, e); const o = new FormData(s); return o.append("lib_version", "3.11.0"), o.append("service_id", i), o.append("template_id", e), o.append("user_id", r), qk("/api/v1.0/email/send-form", o) }, nQ = { init: Zq, send: $q, sendForm: tQ }; va.registerPlugin(Gt); const iQ = () => { const i = ce.useRef(null), [e, t] = ce.useState(null); ce.useEffect(() => { const s = i.current; va.timeline({ scrollTrigger: { trigger: s, start: "10% center", end: "50% center", scrub: !0, markers: !1 } }).to(s, { opacity: 1, x: -500, duration: .5, display: "flex" }) }); const n = ce.useRef(), r = s => { s.preventDefault(), nQ.sendForm("service_mbj4tvw", "template_tiyn2ll", n.current, "mESv9YDwlra-9nIN8").then(o => { console.log(o.text), t(!0) }, o => { console.log(o.text), t(!1) }) }; return Re.jsxs("div", { className: "contact", id: "contact", children: [Re.jsx("div", { className: "polygon6" }), Re.jsx("div", { className: "conLeft", children: Re.jsx("div", { className: "conModel", children: Re.jsxs(hq, { children: [Re.jsx(Qq, {}), Re.jsx(qq, { enableZoom: !1, autoRotate: !0 }), Re.jsx("directionalLight", { intensity: 5, position: [3, 3, -5] })] }) }) }), Re.jsxs("div", { className: "conRight", ref: i, children: [Re.jsx("div", { className: "conTitle", children: "Get in Touch" }), Re.jsxs("form", { action: "POST", onSubmit: r, ref: n, children: [Re.jsx("input", { className: "conInput", type: "text", placeholder: "Name", name: "name" }), Re.jsx("input", { className: "conInput", type: "text", placeholder: "Email", name: "email" }), Re.jsx("textarea", { className: "conInput", placeholder: "Write your message", name: "message", rows: 4 }), Re.jsx("button", { className: "conButton", type: "submit", children: "Send" }), Re.jsx("p", { children: e && "Your message has been sent :)" })] })] })] }) }; function rQ() { return Re.jsx(kz, { children: Re.jsxs("div", { className: "Container", children: [Re.jsx(I8, {}), Re.jsx(Vz, {}), Re.jsx(Wz, {}), Re.jsx(B8, {}), Re.jsx(D8, {}), Re.jsx(iQ, {})] }) }) } yM.createRoot(document.getElementById("root")).render(Re.jsx(Qf.StrictMode, { children: Re.jsx(rQ, {}) }));
